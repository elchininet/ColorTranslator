(()=>{var __webpack_modules__={643:(module,exports)=>{eval('var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!function(){var r=null;\n(function(){function X(e){function j(){try{J.doScroll("left")}catch(e){P(j,50);return}w("poll")}function w(j){if(!(j.type=="readystatechange"&&x.readyState!="complete")&&((j.type=="load"?n:x)[z](i+j.type,w,!1),!m&&(m=!0)))e.call(n,j.type||j)}var Y=x.addEventListener,m=!1,C=!0,t=Y?"addEventListener":"attachEvent",z=Y?"removeEventListener":"detachEvent",i=Y?"":"on";if(x.readyState=="complete")e.call(n,"lazy");else{if(x.createEventObject&&J.doScroll){try{C=!n.frameElement}catch(A){}C&&j()}x[t](i+"DOMContentLoaded",\nw,!1);x[t](i+"readystatechange",w,!1);n[t](i+"load",w,!1)}}function Q(){S&&X(function(){var e=K.length;$(e?function(){for(var j=0;j<e;++j)(function(e){P(function(){n.exports[K[e]].apply(n,arguments)},0)})(j)}:void 0)})}for(var n=window,P=n.setTimeout,x=document,J=x.documentElement,L=x.head||x.getElementsByTagName("head")[0]||J,z="",A=x.scripts,m=A.length;--m>=0;){var M=A[m],T=M.src.match(/^[^#?]*\\/run_prettify\\.js(\\?[^#]*)?(?:#.*)?$/);if(T){z=T[1]||"";M.parentNode.removeChild(M);break}}var S=!0,D=\n[],N=[],K=[];z.replace(/[&?]([^&=]+)=([^&]+)/g,function(e,j,w){w=decodeURIComponent(w);j=decodeURIComponent(j);j=="autorun"?S=!/^[0fn]/i.test(w):j=="lang"?D.push(w):j=="skin"?N.push(w):j=="callback"&&K.push(w)});m=0;for(z=D.length;m<z;++m)(function(){var e=x.createElement("script");e.onload=e.onerror=e.onreadystatechange=function(){if(e&&(!e.readyState||/loaded|complete/.test(e.readyState)))e.onerror=e.onload=e.onreadystatechange=r,--R,R||P(Q,0),e.parentNode&&e.parentNode.removeChild(e),e=r};e.type=\n"text/javascript";e.src="https://google-code-prettify.googlecode.com/svn/loader/lang-"+encodeURIComponent(D[m])+".js";L.insertBefore(e,L.firstChild)})(D[m]);for(var R=D.length,A=[],m=0,z=N.length;m<z;++m)A.push("https://google-code-prettify.googlecode.com/svn/loader/skins/"+encodeURIComponent(N[m])+".css");A.push("https://google-code-prettify.googlecode.com/svn/loader/prettify.css");(function(e){function j(m){if(m!==w){var n=x.createElement("link");n.rel="stylesheet";n.type="text/css";if(m+1<w)n.error=\nn.onerror=function(){j(m+1)};n.href=e[m];L.appendChild(n)}}var w=e.length;j(0)})(A);var $=function(){window.PR_SHOULD_USE_CONTINUATION=!0;var e;(function(){function j(a){function d(f){var b=f.charCodeAt(0);if(b!==92)return b;var a=f.charAt(1);return(b=i[a])?b:"0"<=a&&a<="7"?parseInt(f.substring(1),8):a==="u"||a==="x"?parseInt(f.substring(2),16):f.charCodeAt(1)}function h(f){if(f<32)return(f<16?"\\\\x0":"\\\\x")+f.toString(16);f=String.fromCharCode(f);return f==="\\\\"||f==="-"||f==="]"||f==="^"?"\\\\"+f:\nf}function b(f){var b=f.substring(1,f.length-1).match(/\\\\u[\\dA-Fa-f]{4}|\\\\x[\\dA-Fa-f]{2}|\\\\[0-3][0-7]{0,2}|\\\\[0-7]{1,2}|\\\\[\\S\\s]|[^\\\\]/g),f=[],a=b[0]==="^",c=["["];a&&c.push("^");for(var a=a?1:0,g=b.length;a<g;++a){var k=b[a];if(/\\\\[bdsw]/i.test(k))c.push(k);else{var k=d(k),o;a+2<g&&"-"===b[a+1]?(o=d(b[a+2]),a+=2):o=k;f.push([k,o]);o<65||k>122||(o<65||k>90||f.push([Math.max(65,k)|32,Math.min(o,90)|32]),o<97||k>122||f.push([Math.max(97,k)&-33,Math.min(o,122)&-33]))}}f.sort(function(f,a){return f[0]-\na[0]||a[1]-f[1]});b=[];g=[];for(a=0;a<f.length;++a)k=f[a],k[0]<=g[1]+1?g[1]=Math.max(g[1],k[1]):b.push(g=k);for(a=0;a<b.length;++a)k=b[a],c.push(h(k[0])),k[1]>k[0]&&(k[1]+1>k[0]&&c.push("-"),c.push(h(k[1])));c.push("]");return c.join("")}function e(f){for(var a=f.source.match(/\\[(?:[^\\\\\\]]|\\\\[\\S\\s])*]|\\\\u[\\dA-Fa-f]{4}|\\\\x[\\dA-Fa-f]{2}|\\\\\\d+|\\\\[^\\dux]|\\(\\?[!:=]|[()^]|[^()[\\\\^]+/g),c=a.length,d=[],g=0,k=0;g<c;++g){var o=a[g];o==="("?++k:"\\\\"===o.charAt(0)&&(o=+o.substring(1))&&(o<=k?d[o]=-1:a[g]=h(o))}for(g=\n1;g<d.length;++g)-1===d[g]&&(d[g]=++j);for(k=g=0;g<c;++g)o=a[g],o==="("?(++k,d[k]||(a[g]="(?:")):"\\\\"===o.charAt(0)&&(o=+o.substring(1))&&o<=k&&(a[g]="\\\\"+d[o]);for(g=0;g<c;++g)"^"===a[g]&&"^"!==a[g+1]&&(a[g]="");if(f.ignoreCase&&F)for(g=0;g<c;++g)o=a[g],f=o.charAt(0),o.length>=2&&f==="["?a[g]=b(o):f!=="\\\\"&&(a[g]=o.replace(/[A-Za-z]/g,function(a){a=a.charCodeAt(0);return"["+String.fromCharCode(a&-33,a|32)+"]"}));return a.join("")}for(var j=0,F=!1,l=!1,I=0,c=a.length;I<c;++I){var p=a[I];if(p.ignoreCase)l=\n!0;else if(/[a-z]/i.test(p.source.replace(/\\\\u[\\da-f]{4}|\\\\x[\\da-f]{2}|\\\\[^UXux]/gi,""))){F=!0;l=!1;break}}for(var i={b:8,t:9,n:10,v:11,f:12,r:13},q=[],I=0,c=a.length;I<c;++I){p=a[I];if(p.global||p.multiline)throw Error(""+p);q.push("(?:"+e(p)+")")}return RegExp(q.join("|"),l?"gi":"g")}function m(a,d){function h(a){var c=a.nodeType;if(c==1){if(!b.test(a.className)){for(c=a.firstChild;c;c=c.nextSibling)h(c);c=a.nodeName.toLowerCase();if("br"===c||"li"===c)e[l]="\\n",F[l<<1]=j++,F[l++<<1|1]=a}}else if(c==\n3||c==4)c=a.nodeValue,c.length&&(c=d?c.replace(/\\r\\n?/g,"\\n"):c.replace(/[\\t\\n\\r ]+/g," "),e[l]=c,F[l<<1]=j,j+=c.length,F[l++<<1|1]=a)}var b=/(?:^|\\s)nocode(?:\\s|$)/,e=[],j=0,F=[],l=0;h(a);return{a:e.join("").replace(/\\n$/,""),d:F}}function n(a,d,h,b){d&&(a={a:d,e:a},h(a),b.push.apply(b,a.g))}function x(a){for(var d=void 0,h=a.firstChild;h;h=h.nextSibling)var b=h.nodeType,d=b===1?d?a:h:b===3?S.test(h.nodeValue)?a:d:d;return d===a?void 0:d}function C(a,d){function h(a){for(var l=a.e,j=[l,"pln"],c=\n0,p=a.a.match(e)||[],m={},q=0,f=p.length;q<f;++q){var B=p[q],y=m[B],u=void 0,g;if(typeof y==="string")g=!1;else{var k=b[B.charAt(0)];if(k)u=B.match(k[1]),y=k[0];else{for(g=0;g<i;++g)if(k=d[g],u=B.match(k[1])){y=k[0];break}u||(y="pln")}if((g=y.length>=5&&"lang-"===y.substring(0,5))&&!(u&&typeof u[1]==="string"))g=!1,y="src";g||(m[B]=y)}k=c;c+=B.length;if(g){g=u[1];var o=B.indexOf(g),H=o+g.length;u[2]&&(H=B.length-u[2].length,o=H-g.length);y=y.substring(5);n(l+k,B.substring(0,o),h,j);n(l+k+o,g,A(y,\ng),j);n(l+k+H,B.substring(H),h,j)}else j.push(l+k,y)}a.g=j}var b={},e;(function(){for(var h=a.concat(d),l=[],i={},c=0,p=h.length;c<p;++c){var m=h[c],q=m[3];if(q)for(var f=q.length;--f>=0;)b[q.charAt(f)]=m;m=m[1];q=""+m;i.hasOwnProperty(q)||(l.push(m),i[q]=r)}l.push(/[\\S\\s]/);e=j(l)})();var i=d.length;return h}function t(a){var d=[],h=[];a.tripleQuotedStrings?d.push(["str",/^(?:\'\'\'(?:[^\'\\\\]|\\\\[\\S\\s]|\'\'?(?=[^\']))*(?:\'\'\'|$)|"""(?:[^"\\\\]|\\\\[\\S\\s]|""?(?=[^"]))*(?:"""|$)|\'(?:[^\'\\\\]|\\\\[\\S\\s])*(?:\'|$)|"(?:[^"\\\\]|\\\\[\\S\\s])*(?:"|$))/,\nr,"\'\\""]):a.multiLineStrings?d.push(["str",/^(?:\'(?:[^\'\\\\]|\\\\[\\S\\s])*(?:\'|$)|"(?:[^"\\\\]|\\\\[\\S\\s])*(?:"|$)|`(?:[^\\\\`]|\\\\[\\S\\s])*(?:`|$))/,r,"\'\\"`"]):d.push(["str",/^(?:\'(?:[^\\n\\r\'\\\\]|\\\\.)*(?:\'|$)|"(?:[^\\n\\r"\\\\]|\\\\.)*(?:"|$))/,r,"\\"\'"]);a.verbatimStrings&&h.push(["str",/^@"(?:[^"]|"")*(?:"|$)/,r]);var b=a.hashComments;b&&(a.cStyleComments?(b>1?d.push(["com",/^#(?:##(?:[^#]|#(?!##))*(?:###|$)|.*)/,r,"#"]):d.push(["com",/^#(?:(?:define|e(?:l|nd)if|else|error|ifn?def|include|line|pragma|undef|warning)\\b|[^\\n\\r]*)/,\nr,"#"]),h.push(["str",/^<(?:(?:(?:\\.\\.\\/)*|\\/?)(?:[\\w-]+(?:\\/[\\w-]+)+)?[\\w-]+\\.h(?:h|pp|\\+\\+)?|[a-z]\\w*)>/,r])):d.push(["com",/^#[^\\n\\r]*/,r,"#"]));a.cStyleComments&&(h.push(["com",/^\\/\\/[^\\n\\r]*/,r]),h.push(["com",/^\\/\\*[\\S\\s]*?(?:\\*\\/|$)/,r]));if(b=a.regexLiterals){var e=(b=b>1?"":"\\n\\r")?".":"[\\\\S\\\\s]";h.push(["lang-regex",RegExp("^(?:^^\\\\.?|[+-]|[!=]=?=?|\\\\#|%=?|&&?=?|\\\\(|\\\\*=?|[+\\\\-]=|->|\\\\/=?|::?|<<?=?|>>?>?=?|,|;|\\\\?|@|\\\\[|~|{|\\\\^\\\\^?=?|\\\\|\\\\|?=?|break|case|continue|delete|do|else|finally|instanceof|return|throw|try|typeof)\\\\s*("+\n("/(?=[^/*"+b+"])(?:[^/\\\\x5B\\\\x5C"+b+"]|\\\\x5C"+e+"|\\\\x5B(?:[^\\\\x5C\\\\x5D"+b+"]|\\\\x5C"+e+")*(?:\\\\x5D|$))+/")+")")])}(b=a.types)&&h.push(["typ",b]);b=(""+a.keywords).replace(/^ | $/g,"");b.length&&h.push(["kwd",RegExp("^(?:"+b.replace(/[\\s,]+/g,"|")+")\\\\b"),r]);d.push(["pln",/^\\s+/,r," \\r\\n\\t\\u00a0"]);b="^.[^\\\\s\\\\w.$@\'\\"`/\\\\\\\\]*";a.regexLiterals&&(b+="(?!s*/)");h.push(["lit",/^@[$_a-z][\\w$@]*/i,r],["typ",/^(?:[@_]?[A-Z]+[a-z][\\w$@]*|\\w+_t\\b)/,r],["pln",/^[$_a-z][\\w$@]*/i,r],["lit",/^(?:0x[\\da-f]+|(?:\\d(?:_\\d+)*\\d*(?:\\.\\d*)?|\\.\\d\\+)(?:e[+-]?\\d+)?)[a-z]*/i,\nr,"0123456789"],["pln",/^\\\\[\\S\\s]?/,r],["pun",RegExp(b),r]);return C(d,h)}function z(a,d,h){function b(a){var c=a.nodeType;if(c==1&&!j.test(a.className))if("br"===a.nodeName)e(a),a.parentNode&&a.parentNode.removeChild(a);else for(a=a.firstChild;a;a=a.nextSibling)b(a);else if((c==3||c==4)&&h){var d=a.nodeValue,i=d.match(m);if(i)c=d.substring(0,i.index),a.nodeValue=c,(d=d.substring(i.index+i[0].length))&&a.parentNode.insertBefore(l.createTextNode(d),a.nextSibling),e(a),c||a.parentNode.removeChild(a)}}\nfunction e(a){function b(a,c){var d=c?a.cloneNode(!1):a,f=a.parentNode;if(f){var f=b(f,1),h=a.nextSibling;f.appendChild(d);for(var e=h;e;e=h)h=e.nextSibling,f.appendChild(e)}return d}for(;!a.nextSibling;)if(a=a.parentNode,!a)return;for(var a=b(a.nextSibling,0),d;(d=a.parentNode)&&d.nodeType===1;)a=d;c.push(a)}for(var j=/(?:^|\\s)nocode(?:\\s|$)/,m=/\\r\\n?|\\n/,l=a.ownerDocument,i=l.createElement("li");a.firstChild;)i.appendChild(a.firstChild);for(var c=[i],p=0;p<c.length;++p)b(c[p]);d===(d|0)&&c[0].setAttribute("value",\nd);var n=l.createElement("ol");n.className="linenums";for(var d=Math.max(0,d-1|0)||0,p=0,q=c.length;p<q;++p)i=c[p],i.className="L"+(p+d)%10,i.firstChild||i.appendChild(l.createTextNode("\\u00a0")),n.appendChild(i);a.appendChild(n)}function i(a,d){for(var h=d.length;--h>=0;){var b=d[h];U.hasOwnProperty(b)?V.console&&console.warn("cannot override language handler %s",b):U[b]=a}}function A(a,d){if(!a||!U.hasOwnProperty(a))a=/^\\s*</.test(d)?"default-markup":"default-code";return U[a]}function D(a){var d=\na.h;try{var h=m(a.c,a.i),b=h.a;a.a=b;a.d=h.d;a.e=0;A(d,b)(a);var e=/\\bMSIE\\s(\\d+)/.exec(navigator.userAgent),e=e&&+e[1]<=8,d=/\\n/g,i=a.a,j=i.length,h=0,l=a.d,n=l.length,b=0,c=a.g,p=c.length,t=0;c[p]=j;var q,f;for(f=q=0;f<p;)c[f]!==c[f+2]?(c[q++]=c[f++],c[q++]=c[f++]):f+=2;p=q;for(f=q=0;f<p;){for(var x=c[f],y=c[f+1],u=f+2;u+2<=p&&c[u+1]===y;)u+=2;c[q++]=x;c[q++]=y;f=u}c.length=q;var g=a.c,k;if(g)k=g.style.display,g.style.display="none";try{for(;b<n;){var o=l[b+2]||j,H=c[t+2]||j,u=Math.min(o,H),E=l[b+\n1],W;if(E.nodeType!==1&&(W=i.substring(h,u))){e&&(W=W.replace(d,"\\r"));E.nodeValue=W;var Z=E.ownerDocument,s=Z.createElement("span");s.className=c[t+1];var z=E.parentNode;z.replaceChild(s,E);s.appendChild(E);h<o&&(l[b+1]=E=Z.createTextNode(i.substring(u,o)),z.insertBefore(E,s.nextSibling))}h=u;h>=o&&(b+=2);h>=H&&(t+=2)}}finally{if(g)g.style.display=k}}catch(v){V.console&&console.log(v&&v.stack||v)}}var V=window,G=["break,continue,do,else,for,if,return,while"],O=[[G,"auto,case,char,const,default,double,enum,extern,float,goto,inline,int,long,register,short,signed,sizeof,static,struct,switch,typedef,union,unsigned,void,volatile"],\n"catch,class,delete,false,import,new,operator,private,protected,public,this,throw,true,try,typeof"],J=[O,"alignof,align_union,asm,axiom,bool,concept,concept_map,const_cast,constexpr,decltype,delegate,dynamic_cast,explicit,export,friend,generic,late_check,mutable,namespace,nullptr,property,reinterpret_cast,static_assert,static_cast,template,typeid,typename,using,virtual,where"],K=[O,"abstract,assert,boolean,byte,extends,final,finally,implements,import,instanceof,interface,null,native,package,strictfp,super,synchronized,throws,transient"],\nL=[K,"as,base,by,checked,decimal,delegate,descending,dynamic,event,fixed,foreach,from,group,implicit,in,internal,into,is,let,lock,object,out,override,orderby,params,partial,readonly,ref,sbyte,sealed,stackalloc,string,select,uint,ulong,unchecked,unsafe,ushort,var,virtual,where"],O=[O,"debugger,eval,export,function,get,null,set,undefined,var,with,Infinity,NaN"],M=[G,"and,as,assert,class,def,del,elif,except,exec,finally,from,global,import,in,is,lambda,nonlocal,not,or,pass,print,raise,try,with,yield,False,True,None"],\nN=[G,"alias,and,begin,case,class,def,defined,elsif,end,ensure,false,in,module,next,nil,not,or,redo,rescue,retry,self,super,then,true,undef,unless,until,when,yield,BEGIN,END"],R=[G,"as,assert,const,copy,drop,enum,extern,fail,false,fn,impl,let,log,loop,match,mod,move,mut,priv,pub,pure,ref,self,static,struct,true,trait,type,unsafe,use"],G=[G,"case,done,elif,esac,eval,fi,function,in,local,set,then,until"],Q=/^(DIR|FILE|vector|(de|priority_)?queue|list|stack|(const_)?iterator|(multi)?(set|map)|bitset|u?(int|float)\\d*)\\b/,\nS=/\\S/,T=t({keywords:[J,L,O,"caller,delete,die,do,dump,elsif,eval,exit,foreach,for,goto,if,import,last,local,my,next,no,our,print,package,redo,require,sub,undef,unless,until,use,wantarray,while,BEGIN,END",M,N,G],hashComments:!0,cStyleComments:!0,multiLineStrings:!0,regexLiterals:!0}),U={};i(T,["default-code"]);i(C([],[["pln",/^[^<?]+/],["dec",/^<!\\w[^>]*(?:>|$)/],["com",/^<\\!--[\\S\\s]*?(?:--\\>|$)/],["lang-",/^<\\?([\\S\\s]+?)(?:\\?>|$)/],["lang-",/^<%([\\S\\s]+?)(?:%>|$)/],["pun",/^(?:<[%?]|[%?]>)/],["lang-",\n/^<xmp\\b[^>]*>([\\S\\s]+?)<\\/xmp\\b[^>]*>/i],["lang-js",/^<script\\b[^>]*>([\\S\\s]*?)(<\\/script\\b[^>]*>)/i],["lang-css",/^<style\\b[^>]*>([\\S\\s]*?)(<\\/style\\b[^>]*>)/i],["lang-in.tag",/^(<\\/?[a-z][^<>]*>)/i]]),["default-markup","htm","html","mxml","xhtml","xml","xsl"]);i(C([["pln",/^\\s+/,r," \\t\\r\\n"],["atv",/^(?:"[^"]*"?|\'[^\']*\'?)/,r,"\\"\'"]],[["tag",/^^<\\/?[a-z](?:[\\w-.:]*\\w)?|\\/?>$/i],["atn",/^(?!style[\\s=]|on)[a-z](?:[\\w:-]*\\w)?/i],["lang-uq.val",/^=\\s*([^\\s"\'>]*(?:[^\\s"\'/>]|\\/(?=\\s)))/],["pun",/^[/<->]+/],\n["lang-js",/^on\\w+\\s*=\\s*"([^"]+)"/i],["lang-js",/^on\\w+\\s*=\\s*\'([^\']+)\'/i],["lang-js",/^on\\w+\\s*=\\s*([^\\s"\'>]+)/i],["lang-css",/^style\\s*=\\s*"([^"]+)"/i],["lang-css",/^style\\s*=\\s*\'([^\']+)\'/i],["lang-css",/^style\\s*=\\s*([^\\s"\'>]+)/i]]),["in.tag"]);i(C([],[["atv",/^[\\S\\s]+/]]),["uq.val"]);i(t({keywords:J,hashComments:!0,cStyleComments:!0,types:Q}),["c","cc","cpp","cxx","cyc","m"]);i(t({keywords:"null,true,false"}),["json"]);i(t({keywords:L,hashComments:!0,cStyleComments:!0,verbatimStrings:!0,types:Q}),\n["cs"]);i(t({keywords:K,cStyleComments:!0}),["java"]);i(t({keywords:G,hashComments:!0,multiLineStrings:!0}),["bash","bsh","csh","sh"]);i(t({keywords:M,hashComments:!0,multiLineStrings:!0,tripleQuotedStrings:!0}),["cv","py","python"]);i(t({keywords:"caller,delete,die,do,dump,elsif,eval,exit,foreach,for,goto,if,import,last,local,my,next,no,our,print,package,redo,require,sub,undef,unless,until,use,wantarray,while,BEGIN,END",hashComments:!0,multiLineStrings:!0,regexLiterals:2}),["perl","pl","pm"]);i(t({keywords:N,\nhashComments:!0,multiLineStrings:!0,regexLiterals:!0}),["rb","ruby"]);i(t({keywords:O,cStyleComments:!0,regexLiterals:!0}),["javascript","js"]);i(t({keywords:"all,and,by,catch,class,else,extends,false,finally,for,if,in,is,isnt,loop,new,no,not,null,of,off,on,or,return,super,then,throw,true,try,unless,until,when,while,yes",hashComments:3,cStyleComments:!0,multilineStrings:!0,tripleQuotedStrings:!0,regexLiterals:!0}),["coffee"]);i(t({keywords:R,cStyleComments:!0,multilineStrings:!0}),["rc","rs","rust"]);\ni(C([],[["str",/^[\\S\\s]+/]]),["regex"]);var X=V.PR={createSimpleLexer:C,registerLangHandler:i,sourceDecorator:t,PR_ATTRIB_NAME:"atn",PR_ATTRIB_VALUE:"atv",PR_COMMENT:"com",PR_DECLARATION:"dec",PR_KEYWORD:"kwd",PR_LITERAL:"lit",PR_NOCODE:"nocode",PR_PLAIN:"pln",PR_PUNCTUATION:"pun",PR_SOURCE:"src",PR_STRING:"str",PR_TAG:"tag",PR_TYPE:"typ",prettyPrintOne:function(a,d,e){var b=document.createElement("div");b.innerHTML="<pre>"+a+"</pre>";b=b.firstChild;e&&z(b,e,!0);D({h:d,j:e,c:b,i:1});return b.innerHTML},\nprettyPrint:e=e=function(a,d){function e(){for(var b=V.PR_SHOULD_USE_CONTINUATION?c.now()+250:Infinity;p<j.length&&c.now()<b;p++){for(var d=j[p],m=k,l=d;l=l.previousSibling;){var n=l.nodeType,s=(n===7||n===8)&&l.nodeValue;if(s?!/^\\??prettify\\b/.test(s):n!==3||/\\S/.test(l.nodeValue))break;if(s){m={};s.replace(/\\b(\\w+)=([\\w%+\\-.:]+)/g,function(a,b,c){m[b]=c});break}}l=d.className;if((m!==k||f.test(l))&&!w.test(l)){n=!1;for(s=d.parentNode;s;s=s.parentNode)if(g.test(s.tagName)&&s.className&&f.test(s.className)){n=\n!0;break}if(!n){d.className+=" prettyprinted";n=m.lang;if(!n){var n=l.match(q),A;if(!n&&(A=x(d))&&u.test(A.tagName))n=A.className.match(q);n&&(n=n[1])}if(y.test(d.tagName))s=1;else var s=d.currentStyle,v=i.defaultView,s=(s=s?s.whiteSpace:v&&v.getComputedStyle?v.getComputedStyle(d,r).getPropertyValue("white-space"):0)&&"pre"===s.substring(0,3);v=m.linenums;if(!(v=v==="true"||+v))v=(v=l.match(/\\blinenums\\b(?::(\\d+))?/))?v[1]&&v[1].length?+v[1]:!0:!1;v&&z(d,v,s);t={h:n,c:d,j:v,i:s};D(t)}}}p<j.length?\nP(e,250):"function"===typeof a&&a()}for(var b=d||document.body,i=b.ownerDocument||document,b=[b.getElementsByTagName("pre"),b.getElementsByTagName("code"),b.getElementsByTagName("xmp")],j=[],m=0;m<b.length;++m)for(var l=0,n=b[m].length;l<n;++l)j.push(b[m][l]);var b=r,c=Date;c.now||(c={now:function(){return+new Date}});var p=0,t,q=/\\blang(?:uage)?-([\\w.]+)(?!\\S)/,f=/\\bprettyprint\\b/,w=/\\bprettyprinted\\b/,y=/pre|xmp/i,u=/^code$/i,g=/^(?:pre|code|xmp)$/i,k={};e()}}; true&&\n!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = (function(){return X}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))})();return e}();R||P(Q,0)})();}()\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNjQzLmpzIiwibWFwcGluZ3MiOiJBQUFBLDRFQUFZO0FBQ1osWUFBWSxjQUFjLGFBQWEsSUFBSSxtQkFBbUIsU0FBUyxRQUFRLE9BQU8sVUFBVSxjQUFjLG9JQUFvSSw0SEFBNEgsNkNBQTZDLEtBQUssb0NBQW9DLElBQUksa0JBQWtCLFVBQVUsT0FBTztBQUMzZSxNQUFNLGdDQUFnQyxxQkFBcUIsYUFBYSxnQkFBZ0IsZUFBZSxlQUFlLFlBQVksSUFBSSxpQkFBaUIsYUFBYSxtQ0FBbUMsSUFBSSxLQUFLLFNBQVMsRUFBRSwwSUFBMEksT0FBTyxFQUFFLHlFQUF5RSxNQUFNLFdBQVcsNEJBQTRCLE9BQU87QUFDM2UsYUFBYSxrREFBa0Qsd0JBQXdCLHdCQUF3QixtR0FBbUcsRUFBRSxJQUFJLGVBQWUsSUFBSSxnQkFBZ0IsZ0NBQWdDLG1EQUFtRCxtS0FBbUs7QUFDamYsa0JBQWtCLG9HQUFvRywrQkFBK0IsUUFBUSx1Q0FBdUMsSUFBSSw0R0FBNEcsOEVBQThFLGFBQWEsY0FBYyxVQUFVLDhCQUE4QixtQkFBbUIsa0JBQWtCO0FBQzFlLHFCQUFxQixRQUFRLFlBQVksa0JBQWtCLGVBQWUsS0FBSyxLQUFLLGlCQUFpQixxQ0FBcUMsTUFBTSxZQUFZLGNBQWMsY0FBYyxzQkFBc0IsbUJBQW1CLGtCQUFrQix3SEFBd0gsY0FBYyxpREFBaUQseUJBQXlCO0FBQ25jLEVBQUUsY0FBYyxxREFBcUQsRUFBRSxlQUFlLEVBQUUsY0FBYyxJQUFJLFNBQVMsSUFBSSw2Q0FBNkMsZUFBZSwyQkFBMkIsSUFBSSxLQUFLLFdBQVcsaUNBQWlDLEtBQUssYUFBYSwyQ0FBMkMsY0FBYyx3SUFBd0kscUJBQXFCO0FBQzNlLGdCQUFnQixFQUFFLEtBQUssS0FBSyxRQUFRLFdBQVcsNkRBQTZELFFBQVEsV0FBVyxpRkFBaUYsWUFBWSxrQkFBa0IsY0FBYyxpRUFBaUUsRUFBRSxlQUFlLEVBQUUsdUVBQXVFLElBQUksS0FBSyxXQUFXLDhFQUE4RTtBQUN6ZixFQUFFLFdBQVcsMEJBQTBCLFVBQVUsSUFBSSw0R0FBNEcsUUFBUSxJQUFJLHdDQUF3QywyQkFBMkIsSUFBSSwwR0FBMEcsa0JBQWtCLDhDQUE4QyxHQUFHLGtCQUFrQixxQ0FBcUMsSUFBSSxLQUFLLFdBQVc7QUFDNWUsR0FBRyxtREFBbUQsRUFBRSxZQUFZLEVBQUUsb0JBQW9CLEtBQUssS0FBSyxPQUFPLFdBQVcsNEJBQTRCLHFCQUFxQixJQUFJLEtBQUssT0FBTywyQ0FBMkMsdUJBQXVCLHNDQUFzQyxnQkFBZ0IsY0FBYyxpQkFBaUIsU0FBUyx5QkFBeUIsbUJBQW1CLEVBQUUscUJBQXFCLDJCQUEyQiwyREFBMkQ7QUFDaGYsdUlBQXVJLGlEQUFpRCxLQUFLLE9BQU8sb0NBQW9DLG9CQUFvQixPQUFPLFFBQVEsMkJBQTJCLGNBQWMsZ0NBQWdDLEVBQUUsK0VBQStFLHNCQUFzQixnQkFBZ0IsY0FBYztBQUN6ZCx5QkFBeUIsZ0JBQWdCLElBQUksS0FBSyw2QkFBNkIsNEJBQTRCLEtBQUsscUJBQXFCLDRCQUE0QixLQUFLLFFBQVEsSUFBSSwrQkFBK0IsT0FBTyxNQUFNLGFBQWEsMEZBQTBGLFlBQVksSUFBSSxZQUFZLE1BQU0sT0FBTyxnQ0FBZ0MsNENBQTRDLGlCQUFpQiw0QkFBNEI7QUFDdmUsTUFBTSw0QkFBNEIsbUJBQW1CLE1BQU0sUUFBUSxHQUFHLFlBQVksK0JBQStCLGdCQUFnQixJQUFJLEtBQUssa0JBQWtCLHdCQUF3QixPQUFPLGtCQUFrQixPQUFPLE9BQU8sd0NBQXdDLGlCQUFpQixPQUFPLElBQUksZUFBZSxTQUFTLGNBQWMsY0FBYztBQUNuViwyT0FBMk8sOERBQThELHFCQUFxQjtBQUM5VCxvSkFBb0osa0dBQWtHLHNCQUFzQix1Q0FBdUMsb0hBQW9ILGNBQWM7QUFDcmIsa0hBQWtILCtCQUErQix1Q0FBdUMsMkVBQTJFLHlDQUF5Qyw2QkFBNkIsZ0NBQWdDO0FBQ3pXLDREQUE0RCxjQUFjLGtCQUFrQixjQUFjLGlCQUFpQixrR0FBa0csd0JBQXdCLEVBQUUscUJBQXFCLHlCQUF5QiwrQkFBK0I7QUFDcFUsY0FBYyxnQkFBZ0IseUNBQXlDLE1BQU0sNkJBQTZCLGlCQUFpQixZQUFZLEVBQUUscUNBQXFDLFNBQVMsS0FBSyxlQUFlLDZCQUE2QiwrQkFBK0IsaUNBQWlDLEtBQUssVUFBVSwwRkFBMEYsYUFBYSw2QkFBNkIsa0JBQWtCLFdBQVcsWUFBWTtBQUNwZSxHQUFHLDRCQUE0Qix1QkFBdUIsOENBQThDLElBQUksNkdBQTZHLGlCQUFpQixnQkFBZ0IsbUJBQW1CLE9BQU8sRUFBRSxXQUFXLDZGQUE2RixnQkFBZ0IsOEVBQThFLFlBQVksY0FBYztBQUNsZixJQUFJLElBQUksdUJBQXVCLE1BQU0sUUFBUSxNQUFNLFVBQVUscUlBQXFJLE9BQU8sUUFBUSxVQUFVLElBQUksa0RBQWtELElBQUksVUFBVSxJQUFJLEVBQUUsOEJBQThCLG1CQUFtQixNQUFNLFNBQVMsU0FBUyxJQUFJLFdBQVcsWUFBWSw4Q0FBOEMsSUFBSSxLQUFLLElBQUksRUFBRTtBQUN0YyxLQUFLLHlDQUF5Qyx5QkFBeUIsY0FBYyxnREFBZ0QsbUJBQW1CLG1CQUFtQixvQkFBb0IsaUJBQWlCLG1GQUFtRixJQUFJLGFBQWEsY0FBYyxRQUFRLHdCQUF3QixTQUFTLHVDQUF1QztBQUNsWjtBQUNBO0FBQ0E7QUFDQSxZQUFZLCtRQUErUSxPQUFPLHNCQUFzQjtBQUN4VCx3UUFBd1E7QUFDeFEseVBBQXlQLHlDQUF5QyxLQUFLLHFEQUFxRCxvQ0FBb0MsS0FBSywyQkFBMkIsWUFBWSxLQUFLLHdFQUF3RTtBQUN6ZixRQUFRLEtBQUssNkJBQTZCLFlBQVksS0FBSywrQ0FBK0MsNkJBQTZCLEtBQUssc0VBQXNFLHdCQUF3QixLQUFLLDhPQUE4TyxzQkFBc0IsS0FBSztBQUN4ZixxREFBcUQsaUJBQWlCLEtBQUssOENBQThDLHVCQUF1QixLQUFLLDJRQUEyUSxjQUFjLEtBQUssaURBQWlEO0FBQ3BlLHdDQUF3QyxZQUFZLGdVQUFnVSxvQ0FBb0MsK0JBQStCLGVBQWUsYUFBYSxHQUFHLGdCQUFnQixFQUFFLG1CQUFtQjtBQUMzZiw4QkFBOEIsYUFBYSw0REFBNEQsc0JBQXNCLEtBQUssdUJBQXVCLG9CQUFvQixFQUFFLCtDQUErQyxtRUFBbUUsTUFBTSxLQUFLLG1EQUFtRCxPQUFPLEVBQUUsT0FBTyxjQUFjLG1DQUFtQyxLQUFLLG1CQUFtQixFQUFFLHVFQUF1RTtBQUNqZ0IsR0FBRyxNQUFNLE9BQU8sOEJBQThCLFNBQVMsT0FBTyxtQkFBbUIsMERBQTBELFlBQVkseUJBQXlCLHlLQUF5SyxhQUFhLDhGQUE4RixZQUFZLEdBQUcsaUJBQWlCLE9BQU87QUFDM2Usb0NBQW9DLCtKQUErSixXQUFXLDhCQUE4QixJQUFJLG9CQUFvQixlQUFlLFdBQVcsZUFBZSxpQkFBaUIsRUFBRSw2SUFBNkksTUFBTSxLQUFzQztBQUN6ZixpQ0FBOEIsRUFBRSxtQ0FBQyxXQUFXLFNBQVM7QUFBQSxrR0FBQyxDQUFDLElBQUksU0FBUyxHQUFHLFVBQVUsS0FBSyIsInNvdXJjZXMiOlsid2VicGFjazovL2NvbG9ydHJhbnNsYXRvci8uL25vZGVfbW9kdWxlcy9nb29nbGUtY29kZS1wcmV0dGlmeS9iaW4vcnVuX3ByZXR0aWZ5Lm1pbi5qcz8xM2NjIl0sInNvdXJjZXNDb250ZW50IjpbIiFmdW5jdGlvbigpe3ZhciByPW51bGw7XG4oZnVuY3Rpb24oKXtmdW5jdGlvbiBYKGUpe2Z1bmN0aW9uIGooKXt0cnl7Si5kb1Njcm9sbChcImxlZnRcIil9Y2F0Y2goZSl7UChqLDUwKTtyZXR1cm59dyhcInBvbGxcIil9ZnVuY3Rpb24gdyhqKXtpZighKGoudHlwZT09XCJyZWFkeXN0YXRlY2hhbmdlXCImJngucmVhZHlTdGF0ZSE9XCJjb21wbGV0ZVwiKSYmKChqLnR5cGU9PVwibG9hZFwiP246eClbel0oaStqLnR5cGUsdywhMSksIW0mJihtPSEwKSkpZS5jYWxsKG4sai50eXBlfHxqKX12YXIgWT14LmFkZEV2ZW50TGlzdGVuZXIsbT0hMSxDPSEwLHQ9WT9cImFkZEV2ZW50TGlzdGVuZXJcIjpcImF0dGFjaEV2ZW50XCIsej1ZP1wicmVtb3ZlRXZlbnRMaXN0ZW5lclwiOlwiZGV0YWNoRXZlbnRcIixpPVk/XCJcIjpcIm9uXCI7aWYoeC5yZWFkeVN0YXRlPT1cImNvbXBsZXRlXCIpZS5jYWxsKG4sXCJsYXp5XCIpO2Vsc2V7aWYoeC5jcmVhdGVFdmVudE9iamVjdCYmSi5kb1Njcm9sbCl7dHJ5e0M9IW4uZnJhbWVFbGVtZW50fWNhdGNoKEEpe31DJiZqKCl9eFt0XShpK1wiRE9NQ29udGVudExvYWRlZFwiLFxudywhMSk7eFt0XShpK1wicmVhZHlzdGF0ZWNoYW5nZVwiLHcsITEpO25bdF0oaStcImxvYWRcIix3LCExKX19ZnVuY3Rpb24gUSgpe1MmJlgoZnVuY3Rpb24oKXt2YXIgZT1LLmxlbmd0aDskKGU/ZnVuY3Rpb24oKXtmb3IodmFyIGo9MDtqPGU7KytqKShmdW5jdGlvbihlKXtQKGZ1bmN0aW9uKCl7bi5leHBvcnRzW0tbZV1dLmFwcGx5KG4sYXJndW1lbnRzKX0sMCl9KShqKX06dm9pZCAwKX0pfWZvcih2YXIgbj13aW5kb3csUD1uLnNldFRpbWVvdXQseD1kb2N1bWVudCxKPXguZG9jdW1lbnRFbGVtZW50LEw9eC5oZWFkfHx4LmdldEVsZW1lbnRzQnlUYWdOYW1lKFwiaGVhZFwiKVswXXx8Six6PVwiXCIsQT14LnNjcmlwdHMsbT1BLmxlbmd0aDstLW0+PTA7KXt2YXIgTT1BW21dLFQ9TS5zcmMubWF0Y2goL15bXiM/XSpcXC9ydW5fcHJldHRpZnlcXC5qcyhcXD9bXiNdKik/KD86Iy4qKT8kLyk7aWYoVCl7ej1UWzFdfHxcIlwiO00ucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChNKTticmVha319dmFyIFM9ITAsRD1cbltdLE49W10sSz1bXTt6LnJlcGxhY2UoL1smP10oW14mPV0rKT0oW14mXSspL2csZnVuY3Rpb24oZSxqLHcpe3c9ZGVjb2RlVVJJQ29tcG9uZW50KHcpO2o9ZGVjb2RlVVJJQ29tcG9uZW50KGopO2o9PVwiYXV0b3J1blwiP1M9IS9eWzBmbl0vaS50ZXN0KHcpOmo9PVwibGFuZ1wiP0QucHVzaCh3KTpqPT1cInNraW5cIj9OLnB1c2godyk6aj09XCJjYWxsYmFja1wiJiZLLnB1c2godyl9KTttPTA7Zm9yKHo9RC5sZW5ndGg7bTx6OysrbSkoZnVuY3Rpb24oKXt2YXIgZT14LmNyZWF0ZUVsZW1lbnQoXCJzY3JpcHRcIik7ZS5vbmxvYWQ9ZS5vbmVycm9yPWUub25yZWFkeXN0YXRlY2hhbmdlPWZ1bmN0aW9uKCl7aWYoZSYmKCFlLnJlYWR5U3RhdGV8fC9sb2FkZWR8Y29tcGxldGUvLnRlc3QoZS5yZWFkeVN0YXRlKSkpZS5vbmVycm9yPWUub25sb2FkPWUub25yZWFkeXN0YXRlY2hhbmdlPXIsLS1SLFJ8fFAoUSwwKSxlLnBhcmVudE5vZGUmJmUucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChlKSxlPXJ9O2UudHlwZT1cblwidGV4dC9qYXZhc2NyaXB0XCI7ZS5zcmM9XCJodHRwczovL2dvb2dsZS1jb2RlLXByZXR0aWZ5Lmdvb2dsZWNvZGUuY29tL3N2bi9sb2FkZXIvbGFuZy1cIitlbmNvZGVVUklDb21wb25lbnQoRFttXSkrXCIuanNcIjtMLmluc2VydEJlZm9yZShlLEwuZmlyc3RDaGlsZCl9KShEW21dKTtmb3IodmFyIFI9RC5sZW5ndGgsQT1bXSxtPTAsej1OLmxlbmd0aDttPHo7KyttKUEucHVzaChcImh0dHBzOi8vZ29vZ2xlLWNvZGUtcHJldHRpZnkuZ29vZ2xlY29kZS5jb20vc3ZuL2xvYWRlci9za2lucy9cIitlbmNvZGVVUklDb21wb25lbnQoTlttXSkrXCIuY3NzXCIpO0EucHVzaChcImh0dHBzOi8vZ29vZ2xlLWNvZGUtcHJldHRpZnkuZ29vZ2xlY29kZS5jb20vc3ZuL2xvYWRlci9wcmV0dGlmeS5jc3NcIik7KGZ1bmN0aW9uKGUpe2Z1bmN0aW9uIGoobSl7aWYobSE9PXcpe3ZhciBuPXguY3JlYXRlRWxlbWVudChcImxpbmtcIik7bi5yZWw9XCJzdHlsZXNoZWV0XCI7bi50eXBlPVwidGV4dC9jc3NcIjtpZihtKzE8dyluLmVycm9yPVxubi5vbmVycm9yPWZ1bmN0aW9uKCl7aihtKzEpfTtuLmhyZWY9ZVttXTtMLmFwcGVuZENoaWxkKG4pfX12YXIgdz1lLmxlbmd0aDtqKDApfSkoQSk7dmFyICQ9ZnVuY3Rpb24oKXt3aW5kb3cuUFJfU0hPVUxEX1VTRV9DT05USU5VQVRJT049ITA7dmFyIGU7KGZ1bmN0aW9uKCl7ZnVuY3Rpb24gaihhKXtmdW5jdGlvbiBkKGYpe3ZhciBiPWYuY2hhckNvZGVBdCgwKTtpZihiIT09OTIpcmV0dXJuIGI7dmFyIGE9Zi5jaGFyQXQoMSk7cmV0dXJuKGI9aVthXSk/YjpcIjBcIjw9YSYmYTw9XCI3XCI/cGFyc2VJbnQoZi5zdWJzdHJpbmcoMSksOCk6YT09PVwidVwifHxhPT09XCJ4XCI/cGFyc2VJbnQoZi5zdWJzdHJpbmcoMiksMTYpOmYuY2hhckNvZGVBdCgxKX1mdW5jdGlvbiBoKGYpe2lmKGY8MzIpcmV0dXJuKGY8MTY/XCJcXFxceDBcIjpcIlxcXFx4XCIpK2YudG9TdHJpbmcoMTYpO2Y9U3RyaW5nLmZyb21DaGFyQ29kZShmKTtyZXR1cm4gZj09PVwiXFxcXFwifHxmPT09XCItXCJ8fGY9PT1cIl1cInx8Zj09PVwiXlwiP1wiXFxcXFwiK2Y6XG5mfWZ1bmN0aW9uIGIoZil7dmFyIGI9Zi5zdWJzdHJpbmcoMSxmLmxlbmd0aC0xKS5tYXRjaCgvXFxcXHVbXFxkQS1GYS1mXXs0fXxcXFxceFtcXGRBLUZhLWZdezJ9fFxcXFxbMC0zXVswLTddezAsMn18XFxcXFswLTddezEsMn18XFxcXFtcXFNcXHNdfFteXFxcXF0vZyksZj1bXSxhPWJbMF09PT1cIl5cIixjPVtcIltcIl07YSYmYy5wdXNoKFwiXlwiKTtmb3IodmFyIGE9YT8xOjAsZz1iLmxlbmd0aDthPGc7KythKXt2YXIgaz1iW2FdO2lmKC9cXFxcW2Jkc3ddL2kudGVzdChrKSljLnB1c2goayk7ZWxzZXt2YXIgaz1kKGspLG87YSsyPGcmJlwiLVwiPT09YlthKzFdPyhvPWQoYlthKzJdKSxhKz0yKTpvPWs7Zi5wdXNoKFtrLG9dKTtvPDY1fHxrPjEyMnx8KG88NjV8fGs+OTB8fGYucHVzaChbTWF0aC5tYXgoNjUsayl8MzIsTWF0aC5taW4obyw5MCl8MzJdKSxvPDk3fHxrPjEyMnx8Zi5wdXNoKFtNYXRoLm1heCg5NyxrKSYtMzMsTWF0aC5taW4obywxMjIpJi0zM10pKX19Zi5zb3J0KGZ1bmN0aW9uKGYsYSl7cmV0dXJuIGZbMF0tXG5hWzBdfHxhWzFdLWZbMV19KTtiPVtdO2c9W107Zm9yKGE9MDthPGYubGVuZ3RoOysrYSlrPWZbYV0sa1swXTw9Z1sxXSsxP2dbMV09TWF0aC5tYXgoZ1sxXSxrWzFdKTpiLnB1c2goZz1rKTtmb3IoYT0wO2E8Yi5sZW5ndGg7KythKWs9YlthXSxjLnB1c2goaChrWzBdKSksa1sxXT5rWzBdJiYoa1sxXSsxPmtbMF0mJmMucHVzaChcIi1cIiksYy5wdXNoKGgoa1sxXSkpKTtjLnB1c2goXCJdXCIpO3JldHVybiBjLmpvaW4oXCJcIil9ZnVuY3Rpb24gZShmKXtmb3IodmFyIGE9Zi5zb3VyY2UubWF0Y2goL1xcWyg/OlteXFxcXFxcXV18XFxcXFtcXFNcXHNdKSpdfFxcXFx1W1xcZEEtRmEtZl17NH18XFxcXHhbXFxkQS1GYS1mXXsyfXxcXFxcXFxkK3xcXFxcW15cXGR1eF18XFwoXFw/WyE6PV18WygpXl18W14oKVtcXFxcXl0rL2cpLGM9YS5sZW5ndGgsZD1bXSxnPTAsaz0wO2c8YzsrK2cpe3ZhciBvPWFbZ107bz09PVwiKFwiPysrazpcIlxcXFxcIj09PW8uY2hhckF0KDApJiYobz0rby5zdWJzdHJpbmcoMSkpJiYobzw9az9kW29dPS0xOmFbZ109aChvKSl9Zm9yKGc9XG4xO2c8ZC5sZW5ndGg7KytnKS0xPT09ZFtnXSYmKGRbZ109KytqKTtmb3Ioaz1nPTA7ZzxjOysrZylvPWFbZ10sbz09PVwiKFwiPygrK2ssZFtrXXx8KGFbZ109XCIoPzpcIikpOlwiXFxcXFwiPT09by5jaGFyQXQoMCkmJihvPStvLnN1YnN0cmluZygxKSkmJm88PWsmJihhW2ddPVwiXFxcXFwiK2Rbb10pO2ZvcihnPTA7ZzxjOysrZylcIl5cIj09PWFbZ10mJlwiXlwiIT09YVtnKzFdJiYoYVtnXT1cIlwiKTtpZihmLmlnbm9yZUNhc2UmJkYpZm9yKGc9MDtnPGM7KytnKW89YVtnXSxmPW8uY2hhckF0KDApLG8ubGVuZ3RoPj0yJiZmPT09XCJbXCI/YVtnXT1iKG8pOmYhPT1cIlxcXFxcIiYmKGFbZ109by5yZXBsYWNlKC9bQS1aYS16XS9nLGZ1bmN0aW9uKGEpe2E9YS5jaGFyQ29kZUF0KDApO3JldHVyblwiW1wiK1N0cmluZy5mcm9tQ2hhckNvZGUoYSYtMzMsYXwzMikrXCJdXCJ9KSk7cmV0dXJuIGEuam9pbihcIlwiKX1mb3IodmFyIGo9MCxGPSExLGw9ITEsST0wLGM9YS5sZW5ndGg7STxjOysrSSl7dmFyIHA9YVtJXTtpZihwLmlnbm9yZUNhc2UpbD1cbiEwO2Vsc2UgaWYoL1thLXpdL2kudGVzdChwLnNvdXJjZS5yZXBsYWNlKC9cXFxcdVtcXGRhLWZdezR9fFxcXFx4W1xcZGEtZl17Mn18XFxcXFteVVh1eF0vZ2ksXCJcIikpKXtGPSEwO2w9ITE7YnJlYWt9fWZvcih2YXIgaT17Yjo4LHQ6OSxuOjEwLHY6MTEsZjoxMixyOjEzfSxxPVtdLEk9MCxjPWEubGVuZ3RoO0k8YzsrK0kpe3A9YVtJXTtpZihwLmdsb2JhbHx8cC5tdWx0aWxpbmUpdGhyb3cgRXJyb3IoXCJcIitwKTtxLnB1c2goXCIoPzpcIitlKHApK1wiKVwiKX1yZXR1cm4gUmVnRXhwKHEuam9pbihcInxcIiksbD9cImdpXCI6XCJnXCIpfWZ1bmN0aW9uIG0oYSxkKXtmdW5jdGlvbiBoKGEpe3ZhciBjPWEubm9kZVR5cGU7aWYoYz09MSl7aWYoIWIudGVzdChhLmNsYXNzTmFtZSkpe2ZvcihjPWEuZmlyc3RDaGlsZDtjO2M9Yy5uZXh0U2libGluZyloKGMpO2M9YS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpO2lmKFwiYnJcIj09PWN8fFwibGlcIj09PWMpZVtsXT1cIlxcblwiLEZbbDw8MV09aisrLEZbbCsrPDwxfDFdPWF9fWVsc2UgaWYoYz09XG4zfHxjPT00KWM9YS5ub2RlVmFsdWUsYy5sZW5ndGgmJihjPWQ/Yy5yZXBsYWNlKC9cXHJcXG4/L2csXCJcXG5cIik6Yy5yZXBsYWNlKC9bXFx0XFxuXFxyIF0rL2csXCIgXCIpLGVbbF09YyxGW2w8PDFdPWosais9Yy5sZW5ndGgsRltsKys8PDF8MV09YSl9dmFyIGI9Lyg/Ol58XFxzKW5vY29kZSg/Olxcc3wkKS8sZT1bXSxqPTAsRj1bXSxsPTA7aChhKTtyZXR1cm57YTplLmpvaW4oXCJcIikucmVwbGFjZSgvXFxuJC8sXCJcIiksZDpGfX1mdW5jdGlvbiBuKGEsZCxoLGIpe2QmJihhPXthOmQsZTphfSxoKGEpLGIucHVzaC5hcHBseShiLGEuZykpfWZ1bmN0aW9uIHgoYSl7Zm9yKHZhciBkPXZvaWQgMCxoPWEuZmlyc3RDaGlsZDtoO2g9aC5uZXh0U2libGluZyl2YXIgYj1oLm5vZGVUeXBlLGQ9Yj09PTE/ZD9hOmg6Yj09PTM/Uy50ZXN0KGgubm9kZVZhbHVlKT9hOmQ6ZDtyZXR1cm4gZD09PWE/dm9pZCAwOmR9ZnVuY3Rpb24gQyhhLGQpe2Z1bmN0aW9uIGgoYSl7Zm9yKHZhciBsPWEuZSxqPVtsLFwicGxuXCJdLGM9XG4wLHA9YS5hLm1hdGNoKGUpfHxbXSxtPXt9LHE9MCxmPXAubGVuZ3RoO3E8ZjsrK3Epe3ZhciBCPXBbcV0seT1tW0JdLHU9dm9pZCAwLGc7aWYodHlwZW9mIHk9PT1cInN0cmluZ1wiKWc9ITE7ZWxzZXt2YXIgaz1iW0IuY2hhckF0KDApXTtpZihrKXU9Qi5tYXRjaChrWzFdKSx5PWtbMF07ZWxzZXtmb3IoZz0wO2c8aTsrK2cpaWYoaz1kW2ddLHU9Qi5tYXRjaChrWzFdKSl7eT1rWzBdO2JyZWFrfXV8fCh5PVwicGxuXCIpfWlmKChnPXkubGVuZ3RoPj01JiZcImxhbmctXCI9PT15LnN1YnN0cmluZygwLDUpKSYmISh1JiZ0eXBlb2YgdVsxXT09PVwic3RyaW5nXCIpKWc9ITEseT1cInNyY1wiO2d8fChtW0JdPXkpfWs9YztjKz1CLmxlbmd0aDtpZihnKXtnPXVbMV07dmFyIG89Qi5pbmRleE9mKGcpLEg9bytnLmxlbmd0aDt1WzJdJiYoSD1CLmxlbmd0aC11WzJdLmxlbmd0aCxvPUgtZy5sZW5ndGgpO3k9eS5zdWJzdHJpbmcoNSk7bihsK2ssQi5zdWJzdHJpbmcoMCxvKSxoLGopO24obCtrK28sZyxBKHksXG5nKSxqKTtuKGwraytILEIuc3Vic3RyaW5nKEgpLGgsail9ZWxzZSBqLnB1c2gobCtrLHkpfWEuZz1qfXZhciBiPXt9LGU7KGZ1bmN0aW9uKCl7Zm9yKHZhciBoPWEuY29uY2F0KGQpLGw9W10saT17fSxjPTAscD1oLmxlbmd0aDtjPHA7KytjKXt2YXIgbT1oW2NdLHE9bVszXTtpZihxKWZvcih2YXIgZj1xLmxlbmd0aDstLWY+PTA7KWJbcS5jaGFyQXQoZildPW07bT1tWzFdO3E9XCJcIittO2kuaGFzT3duUHJvcGVydHkocSl8fChsLnB1c2gobSksaVtxXT1yKX1sLnB1c2goL1tcXFNcXHNdLyk7ZT1qKGwpfSkoKTt2YXIgaT1kLmxlbmd0aDtyZXR1cm4gaH1mdW5jdGlvbiB0KGEpe3ZhciBkPVtdLGg9W107YS50cmlwbGVRdW90ZWRTdHJpbmdzP2QucHVzaChbXCJzdHJcIiwvXig/OicnJyg/OlteJ1xcXFxdfFxcXFxbXFxTXFxzXXwnJz8oPz1bXiddKSkqKD86JycnfCQpfFwiXCJcIig/OlteXCJcXFxcXXxcXFxcW1xcU1xcc118XCJcIj8oPz1bXlwiXSkpKig/OlwiXCJcInwkKXwnKD86W14nXFxcXF18XFxcXFtcXFNcXHNdKSooPzonfCQpfFwiKD86W15cIlxcXFxdfFxcXFxbXFxTXFxzXSkqKD86XCJ8JCkpLyxcbnIsXCInXFxcIlwiXSk6YS5tdWx0aUxpbmVTdHJpbmdzP2QucHVzaChbXCJzdHJcIiwvXig/OicoPzpbXidcXFxcXXxcXFxcW1xcU1xcc10pKig/Oid8JCl8XCIoPzpbXlwiXFxcXF18XFxcXFtcXFNcXHNdKSooPzpcInwkKXxgKD86W15cXFxcYF18XFxcXFtcXFNcXHNdKSooPzpgfCQpKS8scixcIidcXFwiYFwiXSk6ZC5wdXNoKFtcInN0clwiLC9eKD86Jyg/OlteXFxuXFxyJ1xcXFxdfFxcXFwuKSooPzonfCQpfFwiKD86W15cXG5cXHJcIlxcXFxdfFxcXFwuKSooPzpcInwkKSkvLHIsXCJcXFwiJ1wiXSk7YS52ZXJiYXRpbVN0cmluZ3MmJmgucHVzaChbXCJzdHJcIiwvXkBcIig/OlteXCJdfFwiXCIpKig/OlwifCQpLyxyXSk7dmFyIGI9YS5oYXNoQ29tbWVudHM7YiYmKGEuY1N0eWxlQ29tbWVudHM/KGI+MT9kLnB1c2goW1wiY29tXCIsL14jKD86IyMoPzpbXiNdfCMoPyEjIykpKig/OiMjI3wkKXwuKikvLHIsXCIjXCJdKTpkLnB1c2goW1wiY29tXCIsL14jKD86KD86ZGVmaW5lfGUoPzpsfG5kKWlmfGVsc2V8ZXJyb3J8aWZuP2RlZnxpbmNsdWRlfGxpbmV8cHJhZ21hfHVuZGVmfHdhcm5pbmcpXFxifFteXFxuXFxyXSopLyxcbnIsXCIjXCJdKSxoLnB1c2goW1wic3RyXCIsL148KD86KD86KD86XFwuXFwuXFwvKSp8XFwvPykoPzpbXFx3LV0rKD86XFwvW1xcdy1dKykrKT9bXFx3LV0rXFwuaCg/Omh8cHB8XFwrXFwrKT98W2Etel1cXHcqKT4vLHJdKSk6ZC5wdXNoKFtcImNvbVwiLC9eI1teXFxuXFxyXSovLHIsXCIjXCJdKSk7YS5jU3R5bGVDb21tZW50cyYmKGgucHVzaChbXCJjb21cIiwvXlxcL1xcL1teXFxuXFxyXSovLHJdKSxoLnB1c2goW1wiY29tXCIsL15cXC9cXCpbXFxTXFxzXSo/KD86XFwqXFwvfCQpLyxyXSkpO2lmKGI9YS5yZWdleExpdGVyYWxzKXt2YXIgZT0oYj1iPjE/XCJcIjpcIlxcblxcclwiKT9cIi5cIjpcIltcXFxcU1xcXFxzXVwiO2gucHVzaChbXCJsYW5nLXJlZ2V4XCIsUmVnRXhwKFwiXig/Ol5eXFxcXC4/fFsrLV18WyE9XT0/PT98XFxcXCN8JT0/fCYmPz0/fFxcXFwofFxcXFwqPT98WytcXFxcLV09fC0+fFxcXFwvPT98Ojo/fDw8Pz0/fD4+Pz4/PT98LHw7fFxcXFw/fEB8XFxcXFt8fnx7fFxcXFxeXFxcXF4/PT98XFxcXHxcXFxcfD89P3xicmVha3xjYXNlfGNvbnRpbnVlfGRlbGV0ZXxkb3xlbHNlfGZpbmFsbHl8aW5zdGFuY2VvZnxyZXR1cm58dGhyb3d8dHJ5fHR5cGVvZilcXFxccyooXCIrXG4oXCIvKD89W14vKlwiK2IrXCJdKSg/OlteL1xcXFx4NUJcXFxceDVDXCIrYitcIl18XFxcXHg1Q1wiK2UrXCJ8XFxcXHg1Qig/OlteXFxcXHg1Q1xcXFx4NURcIitiK1wiXXxcXFxceDVDXCIrZStcIikqKD86XFxcXHg1RHwkKSkrL1wiKStcIilcIildKX0oYj1hLnR5cGVzKSYmaC5wdXNoKFtcInR5cFwiLGJdKTtiPShcIlwiK2Eua2V5d29yZHMpLnJlcGxhY2UoL14gfCAkL2csXCJcIik7Yi5sZW5ndGgmJmgucHVzaChbXCJrd2RcIixSZWdFeHAoXCJeKD86XCIrYi5yZXBsYWNlKC9bXFxzLF0rL2csXCJ8XCIpK1wiKVxcXFxiXCIpLHJdKTtkLnB1c2goW1wicGxuXCIsL15cXHMrLyxyLFwiIFxcclxcblxcdFxcdTAwYTBcIl0pO2I9XCJeLlteXFxcXHNcXFxcdy4kQCdcXFwiYC9cXFxcXFxcXF0qXCI7YS5yZWdleExpdGVyYWxzJiYoYis9XCIoPyFzKi8pXCIpO2gucHVzaChbXCJsaXRcIiwvXkBbJF9hLXpdW1xcdyRAXSovaSxyXSxbXCJ0eXBcIiwvXig/OltAX10/W0EtWl0rW2Etel1bXFx3JEBdKnxcXHcrX3RcXGIpLyxyXSxbXCJwbG5cIiwvXlskX2Etel1bXFx3JEBdKi9pLHJdLFtcImxpdFwiLC9eKD86MHhbXFxkYS1mXSt8KD86XFxkKD86X1xcZCspKlxcZCooPzpcXC5cXGQqKT98XFwuXFxkXFwrKSg/OmVbKy1dP1xcZCspPylbYS16XSovaSxcbnIsXCIwMTIzNDU2Nzg5XCJdLFtcInBsblwiLC9eXFxcXFtcXFNcXHNdPy8scl0sW1wicHVuXCIsUmVnRXhwKGIpLHJdKTtyZXR1cm4gQyhkLGgpfWZ1bmN0aW9uIHooYSxkLGgpe2Z1bmN0aW9uIGIoYSl7dmFyIGM9YS5ub2RlVHlwZTtpZihjPT0xJiYhai50ZXN0KGEuY2xhc3NOYW1lKSlpZihcImJyXCI9PT1hLm5vZGVOYW1lKWUoYSksYS5wYXJlbnROb2RlJiZhLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoYSk7ZWxzZSBmb3IoYT1hLmZpcnN0Q2hpbGQ7YTthPWEubmV4dFNpYmxpbmcpYihhKTtlbHNlIGlmKChjPT0zfHxjPT00KSYmaCl7dmFyIGQ9YS5ub2RlVmFsdWUsaT1kLm1hdGNoKG0pO2lmKGkpYz1kLnN1YnN0cmluZygwLGkuaW5kZXgpLGEubm9kZVZhbHVlPWMsKGQ9ZC5zdWJzdHJpbmcoaS5pbmRleCtpWzBdLmxlbmd0aCkpJiZhLnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKGwuY3JlYXRlVGV4dE5vZGUoZCksYS5uZXh0U2libGluZyksZShhKSxjfHxhLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoYSl9fVxuZnVuY3Rpb24gZShhKXtmdW5jdGlvbiBiKGEsYyl7dmFyIGQ9Yz9hLmNsb25lTm9kZSghMSk6YSxmPWEucGFyZW50Tm9kZTtpZihmKXt2YXIgZj1iKGYsMSksaD1hLm5leHRTaWJsaW5nO2YuYXBwZW5kQ2hpbGQoZCk7Zm9yKHZhciBlPWg7ZTtlPWgpaD1lLm5leHRTaWJsaW5nLGYuYXBwZW5kQ2hpbGQoZSl9cmV0dXJuIGR9Zm9yKDshYS5uZXh0U2libGluZzspaWYoYT1hLnBhcmVudE5vZGUsIWEpcmV0dXJuO2Zvcih2YXIgYT1iKGEubmV4dFNpYmxpbmcsMCksZDsoZD1hLnBhcmVudE5vZGUpJiZkLm5vZGVUeXBlPT09MTspYT1kO2MucHVzaChhKX1mb3IodmFyIGo9Lyg/Ol58XFxzKW5vY29kZSg/Olxcc3wkKS8sbT0vXFxyXFxuP3xcXG4vLGw9YS5vd25lckRvY3VtZW50LGk9bC5jcmVhdGVFbGVtZW50KFwibGlcIik7YS5maXJzdENoaWxkOylpLmFwcGVuZENoaWxkKGEuZmlyc3RDaGlsZCk7Zm9yKHZhciBjPVtpXSxwPTA7cDxjLmxlbmd0aDsrK3ApYihjW3BdKTtkPT09KGR8MCkmJmNbMF0uc2V0QXR0cmlidXRlKFwidmFsdWVcIixcbmQpO3ZhciBuPWwuY3JlYXRlRWxlbWVudChcIm9sXCIpO24uY2xhc3NOYW1lPVwibGluZW51bXNcIjtmb3IodmFyIGQ9TWF0aC5tYXgoMCxkLTF8MCl8fDAscD0wLHE9Yy5sZW5ndGg7cDxxOysrcClpPWNbcF0saS5jbGFzc05hbWU9XCJMXCIrKHArZCklMTAsaS5maXJzdENoaWxkfHxpLmFwcGVuZENoaWxkKGwuY3JlYXRlVGV4dE5vZGUoXCJcXHUwMGEwXCIpKSxuLmFwcGVuZENoaWxkKGkpO2EuYXBwZW5kQ2hpbGQobil9ZnVuY3Rpb24gaShhLGQpe2Zvcih2YXIgaD1kLmxlbmd0aDstLWg+PTA7KXt2YXIgYj1kW2hdO1UuaGFzT3duUHJvcGVydHkoYik/Vi5jb25zb2xlJiZjb25zb2xlLndhcm4oXCJjYW5ub3Qgb3ZlcnJpZGUgbGFuZ3VhZ2UgaGFuZGxlciAlc1wiLGIpOlVbYl09YX19ZnVuY3Rpb24gQShhLGQpe2lmKCFhfHwhVS5oYXNPd25Qcm9wZXJ0eShhKSlhPS9eXFxzKjwvLnRlc3QoZCk/XCJkZWZhdWx0LW1hcmt1cFwiOlwiZGVmYXVsdC1jb2RlXCI7cmV0dXJuIFVbYV19ZnVuY3Rpb24gRChhKXt2YXIgZD1cbmEuaDt0cnl7dmFyIGg9bShhLmMsYS5pKSxiPWguYTthLmE9YjthLmQ9aC5kO2EuZT0wO0EoZCxiKShhKTt2YXIgZT0vXFxiTVNJRVxccyhcXGQrKS8uZXhlYyhuYXZpZ2F0b3IudXNlckFnZW50KSxlPWUmJitlWzFdPD04LGQ9L1xcbi9nLGk9YS5hLGo9aS5sZW5ndGgsaD0wLGw9YS5kLG49bC5sZW5ndGgsYj0wLGM9YS5nLHA9Yy5sZW5ndGgsdD0wO2NbcF09ajt2YXIgcSxmO2ZvcihmPXE9MDtmPHA7KWNbZl0hPT1jW2YrMl0/KGNbcSsrXT1jW2YrK10sY1txKytdPWNbZisrXSk6Zis9MjtwPXE7Zm9yKGY9cT0wO2Y8cDspe2Zvcih2YXIgeD1jW2ZdLHk9Y1tmKzFdLHU9ZisyO3UrMjw9cCYmY1t1KzFdPT09eTspdSs9MjtjW3ErK109eDtjW3ErK109eTtmPXV9Yy5sZW5ndGg9cTt2YXIgZz1hLmMsaztpZihnKWs9Zy5zdHlsZS5kaXNwbGF5LGcuc3R5bGUuZGlzcGxheT1cIm5vbmVcIjt0cnl7Zm9yKDtiPG47KXt2YXIgbz1sW2IrMl18fGosSD1jW3QrMl18fGosdT1NYXRoLm1pbihvLEgpLEU9bFtiK1xuMV0sVztpZihFLm5vZGVUeXBlIT09MSYmKFc9aS5zdWJzdHJpbmcoaCx1KSkpe2UmJihXPVcucmVwbGFjZShkLFwiXFxyXCIpKTtFLm5vZGVWYWx1ZT1XO3ZhciBaPUUub3duZXJEb2N1bWVudCxzPVouY3JlYXRlRWxlbWVudChcInNwYW5cIik7cy5jbGFzc05hbWU9Y1t0KzFdO3ZhciB6PUUucGFyZW50Tm9kZTt6LnJlcGxhY2VDaGlsZChzLEUpO3MuYXBwZW5kQ2hpbGQoRSk7aDxvJiYobFtiKzFdPUU9Wi5jcmVhdGVUZXh0Tm9kZShpLnN1YnN0cmluZyh1LG8pKSx6Lmluc2VydEJlZm9yZShFLHMubmV4dFNpYmxpbmcpKX1oPXU7aD49byYmKGIrPTIpO2g+PUgmJih0Kz0yKX19ZmluYWxseXtpZihnKWcuc3R5bGUuZGlzcGxheT1rfX1jYXRjaCh2KXtWLmNvbnNvbGUmJmNvbnNvbGUubG9nKHYmJnYuc3RhY2t8fHYpfX12YXIgVj13aW5kb3csRz1bXCJicmVhayxjb250aW51ZSxkbyxlbHNlLGZvcixpZixyZXR1cm4sd2hpbGVcIl0sTz1bW0csXCJhdXRvLGNhc2UsY2hhcixjb25zdCxkZWZhdWx0LGRvdWJsZSxlbnVtLGV4dGVybixmbG9hdCxnb3RvLGlubGluZSxpbnQsbG9uZyxyZWdpc3RlcixzaG9ydCxzaWduZWQsc2l6ZW9mLHN0YXRpYyxzdHJ1Y3Qsc3dpdGNoLHR5cGVkZWYsdW5pb24sdW5zaWduZWQsdm9pZCx2b2xhdGlsZVwiXSxcblwiY2F0Y2gsY2xhc3MsZGVsZXRlLGZhbHNlLGltcG9ydCxuZXcsb3BlcmF0b3IscHJpdmF0ZSxwcm90ZWN0ZWQscHVibGljLHRoaXMsdGhyb3csdHJ1ZSx0cnksdHlwZW9mXCJdLEo9W08sXCJhbGlnbm9mLGFsaWduX3VuaW9uLGFzbSxheGlvbSxib29sLGNvbmNlcHQsY29uY2VwdF9tYXAsY29uc3RfY2FzdCxjb25zdGV4cHIsZGVjbHR5cGUsZGVsZWdhdGUsZHluYW1pY19jYXN0LGV4cGxpY2l0LGV4cG9ydCxmcmllbmQsZ2VuZXJpYyxsYXRlX2NoZWNrLG11dGFibGUsbmFtZXNwYWNlLG51bGxwdHIscHJvcGVydHkscmVpbnRlcnByZXRfY2FzdCxzdGF0aWNfYXNzZXJ0LHN0YXRpY19jYXN0LHRlbXBsYXRlLHR5cGVpZCx0eXBlbmFtZSx1c2luZyx2aXJ0dWFsLHdoZXJlXCJdLEs9W08sXCJhYnN0cmFjdCxhc3NlcnQsYm9vbGVhbixieXRlLGV4dGVuZHMsZmluYWwsZmluYWxseSxpbXBsZW1lbnRzLGltcG9ydCxpbnN0YW5jZW9mLGludGVyZmFjZSxudWxsLG5hdGl2ZSxwYWNrYWdlLHN0cmljdGZwLHN1cGVyLHN5bmNocm9uaXplZCx0aHJvd3MsdHJhbnNpZW50XCJdLFxuTD1bSyxcImFzLGJhc2UsYnksY2hlY2tlZCxkZWNpbWFsLGRlbGVnYXRlLGRlc2NlbmRpbmcsZHluYW1pYyxldmVudCxmaXhlZCxmb3JlYWNoLGZyb20sZ3JvdXAsaW1wbGljaXQsaW4saW50ZXJuYWwsaW50byxpcyxsZXQsbG9jayxvYmplY3Qsb3V0LG92ZXJyaWRlLG9yZGVyYnkscGFyYW1zLHBhcnRpYWwscmVhZG9ubHkscmVmLHNieXRlLHNlYWxlZCxzdGFja2FsbG9jLHN0cmluZyxzZWxlY3QsdWludCx1bG9uZyx1bmNoZWNrZWQsdW5zYWZlLHVzaG9ydCx2YXIsdmlydHVhbCx3aGVyZVwiXSxPPVtPLFwiZGVidWdnZXIsZXZhbCxleHBvcnQsZnVuY3Rpb24sZ2V0LG51bGwsc2V0LHVuZGVmaW5lZCx2YXIsd2l0aCxJbmZpbml0eSxOYU5cIl0sTT1bRyxcImFuZCxhcyxhc3NlcnQsY2xhc3MsZGVmLGRlbCxlbGlmLGV4Y2VwdCxleGVjLGZpbmFsbHksZnJvbSxnbG9iYWwsaW1wb3J0LGluLGlzLGxhbWJkYSxub25sb2NhbCxub3Qsb3IscGFzcyxwcmludCxyYWlzZSx0cnksd2l0aCx5aWVsZCxGYWxzZSxUcnVlLE5vbmVcIl0sXG5OPVtHLFwiYWxpYXMsYW5kLGJlZ2luLGNhc2UsY2xhc3MsZGVmLGRlZmluZWQsZWxzaWYsZW5kLGVuc3VyZSxmYWxzZSxpbixtb2R1bGUsbmV4dCxuaWwsbm90LG9yLHJlZG8scmVzY3VlLHJldHJ5LHNlbGYsc3VwZXIsdGhlbix0cnVlLHVuZGVmLHVubGVzcyx1bnRpbCx3aGVuLHlpZWxkLEJFR0lOLEVORFwiXSxSPVtHLFwiYXMsYXNzZXJ0LGNvbnN0LGNvcHksZHJvcCxlbnVtLGV4dGVybixmYWlsLGZhbHNlLGZuLGltcGwsbGV0LGxvZyxsb29wLG1hdGNoLG1vZCxtb3ZlLG11dCxwcml2LHB1YixwdXJlLHJlZixzZWxmLHN0YXRpYyxzdHJ1Y3QsdHJ1ZSx0cmFpdCx0eXBlLHVuc2FmZSx1c2VcIl0sRz1bRyxcImNhc2UsZG9uZSxlbGlmLGVzYWMsZXZhbCxmaSxmdW5jdGlvbixpbixsb2NhbCxzZXQsdGhlbix1bnRpbFwiXSxRPS9eKERJUnxGSUxFfHZlY3RvcnwoZGV8cHJpb3JpdHlfKT9xdWV1ZXxsaXN0fHN0YWNrfChjb25zdF8pP2l0ZXJhdG9yfChtdWx0aSk/KHNldHxtYXApfGJpdHNldHx1PyhpbnR8ZmxvYXQpXFxkKilcXGIvLFxuUz0vXFxTLyxUPXQoe2tleXdvcmRzOltKLEwsTyxcImNhbGxlcixkZWxldGUsZGllLGRvLGR1bXAsZWxzaWYsZXZhbCxleGl0LGZvcmVhY2gsZm9yLGdvdG8saWYsaW1wb3J0LGxhc3QsbG9jYWwsbXksbmV4dCxubyxvdXIscHJpbnQscGFja2FnZSxyZWRvLHJlcXVpcmUsc3ViLHVuZGVmLHVubGVzcyx1bnRpbCx1c2Usd2FudGFycmF5LHdoaWxlLEJFR0lOLEVORFwiLE0sTixHXSxoYXNoQ29tbWVudHM6ITAsY1N0eWxlQ29tbWVudHM6ITAsbXVsdGlMaW5lU3RyaW5nczohMCxyZWdleExpdGVyYWxzOiEwfSksVT17fTtpKFQsW1wiZGVmYXVsdC1jb2RlXCJdKTtpKEMoW10sW1tcInBsblwiLC9eW148P10rL10sW1wiZGVjXCIsL148IVxcd1tePl0qKD86PnwkKS9dLFtcImNvbVwiLC9ePFxcIS0tW1xcU1xcc10qPyg/Oi0tXFw+fCQpL10sW1wibGFuZy1cIiwvXjxcXD8oW1xcU1xcc10rPykoPzpcXD8+fCQpL10sW1wibGFuZy1cIiwvXjwlKFtcXFNcXHNdKz8pKD86JT58JCkvXSxbXCJwdW5cIiwvXig/OjxbJT9dfFslP10+KS9dLFtcImxhbmctXCIsXG4vXjx4bXBcXGJbXj5dKj4oW1xcU1xcc10rPyk8XFwveG1wXFxiW14+XSo+L2ldLFtcImxhbmctanNcIiwvXjxzY3JpcHRcXGJbXj5dKj4oW1xcU1xcc10qPykoPFxcL3NjcmlwdFxcYltePl0qPikvaV0sW1wibGFuZy1jc3NcIiwvXjxzdHlsZVxcYltePl0qPihbXFxTXFxzXSo/KSg8XFwvc3R5bGVcXGJbXj5dKj4pL2ldLFtcImxhbmctaW4udGFnXCIsL14oPFxcLz9bYS16XVtePD5dKj4pL2ldXSksW1wiZGVmYXVsdC1tYXJrdXBcIixcImh0bVwiLFwiaHRtbFwiLFwibXhtbFwiLFwieGh0bWxcIixcInhtbFwiLFwieHNsXCJdKTtpKEMoW1tcInBsblwiLC9eXFxzKy8scixcIiBcXHRcXHJcXG5cIl0sW1wiYXR2XCIsL14oPzpcIlteXCJdKlwiP3wnW14nXSonPykvLHIsXCJcXFwiJ1wiXV0sW1tcInRhZ1wiLC9eXjxcXC8/W2Etel0oPzpbXFx3LS46XSpcXHcpP3xcXC8/PiQvaV0sW1wiYXRuXCIsL14oPyFzdHlsZVtcXHM9XXxvbilbYS16XSg/OltcXHc6LV0qXFx3KT8vaV0sW1wibGFuZy11cS52YWxcIiwvXj1cXHMqKFteXFxzXCInPl0qKD86W15cXHNcIicvPl18XFwvKD89XFxzKSkpL10sW1wicHVuXCIsL15bLzwtPl0rL10sXG5bXCJsYW5nLWpzXCIsL15vblxcdytcXHMqPVxccypcIihbXlwiXSspXCIvaV0sW1wibGFuZy1qc1wiLC9eb25cXHcrXFxzKj1cXHMqJyhbXiddKyknL2ldLFtcImxhbmctanNcIiwvXm9uXFx3K1xccyo9XFxzKihbXlxcc1wiJz5dKykvaV0sW1wibGFuZy1jc3NcIiwvXnN0eWxlXFxzKj1cXHMqXCIoW15cIl0rKVwiL2ldLFtcImxhbmctY3NzXCIsL15zdHlsZVxccyo9XFxzKicoW14nXSspJy9pXSxbXCJsYW5nLWNzc1wiLC9ec3R5bGVcXHMqPVxccyooW15cXHNcIic+XSspL2ldXSksW1wiaW4udGFnXCJdKTtpKEMoW10sW1tcImF0dlwiLC9eW1xcU1xcc10rL11dKSxbXCJ1cS52YWxcIl0pO2kodCh7a2V5d29yZHM6SixoYXNoQ29tbWVudHM6ITAsY1N0eWxlQ29tbWVudHM6ITAsdHlwZXM6UX0pLFtcImNcIixcImNjXCIsXCJjcHBcIixcImN4eFwiLFwiY3ljXCIsXCJtXCJdKTtpKHQoe2tleXdvcmRzOlwibnVsbCx0cnVlLGZhbHNlXCJ9KSxbXCJqc29uXCJdKTtpKHQoe2tleXdvcmRzOkwsaGFzaENvbW1lbnRzOiEwLGNTdHlsZUNvbW1lbnRzOiEwLHZlcmJhdGltU3RyaW5nczohMCx0eXBlczpRfSksXG5bXCJjc1wiXSk7aSh0KHtrZXl3b3JkczpLLGNTdHlsZUNvbW1lbnRzOiEwfSksW1wiamF2YVwiXSk7aSh0KHtrZXl3b3JkczpHLGhhc2hDb21tZW50czohMCxtdWx0aUxpbmVTdHJpbmdzOiEwfSksW1wiYmFzaFwiLFwiYnNoXCIsXCJjc2hcIixcInNoXCJdKTtpKHQoe2tleXdvcmRzOk0saGFzaENvbW1lbnRzOiEwLG11bHRpTGluZVN0cmluZ3M6ITAsdHJpcGxlUXVvdGVkU3RyaW5nczohMH0pLFtcImN2XCIsXCJweVwiLFwicHl0aG9uXCJdKTtpKHQoe2tleXdvcmRzOlwiY2FsbGVyLGRlbGV0ZSxkaWUsZG8sZHVtcCxlbHNpZixldmFsLGV4aXQsZm9yZWFjaCxmb3IsZ290byxpZixpbXBvcnQsbGFzdCxsb2NhbCxteSxuZXh0LG5vLG91cixwcmludCxwYWNrYWdlLHJlZG8scmVxdWlyZSxzdWIsdW5kZWYsdW5sZXNzLHVudGlsLHVzZSx3YW50YXJyYXksd2hpbGUsQkVHSU4sRU5EXCIsaGFzaENvbW1lbnRzOiEwLG11bHRpTGluZVN0cmluZ3M6ITAscmVnZXhMaXRlcmFsczoyfSksW1wicGVybFwiLFwicGxcIixcInBtXCJdKTtpKHQoe2tleXdvcmRzOk4sXG5oYXNoQ29tbWVudHM6ITAsbXVsdGlMaW5lU3RyaW5nczohMCxyZWdleExpdGVyYWxzOiEwfSksW1wicmJcIixcInJ1YnlcIl0pO2kodCh7a2V5d29yZHM6TyxjU3R5bGVDb21tZW50czohMCxyZWdleExpdGVyYWxzOiEwfSksW1wiamF2YXNjcmlwdFwiLFwianNcIl0pO2kodCh7a2V5d29yZHM6XCJhbGwsYW5kLGJ5LGNhdGNoLGNsYXNzLGVsc2UsZXh0ZW5kcyxmYWxzZSxmaW5hbGx5LGZvcixpZixpbixpcyxpc250LGxvb3AsbmV3LG5vLG5vdCxudWxsLG9mLG9mZixvbixvcixyZXR1cm4sc3VwZXIsdGhlbix0aHJvdyx0cnVlLHRyeSx1bmxlc3MsdW50aWwsd2hlbix3aGlsZSx5ZXNcIixoYXNoQ29tbWVudHM6MyxjU3R5bGVDb21tZW50czohMCxtdWx0aWxpbmVTdHJpbmdzOiEwLHRyaXBsZVF1b3RlZFN0cmluZ3M6ITAscmVnZXhMaXRlcmFsczohMH0pLFtcImNvZmZlZVwiXSk7aSh0KHtrZXl3b3JkczpSLGNTdHlsZUNvbW1lbnRzOiEwLG11bHRpbGluZVN0cmluZ3M6ITB9KSxbXCJyY1wiLFwicnNcIixcInJ1c3RcIl0pO1xuaShDKFtdLFtbXCJzdHJcIiwvXltcXFNcXHNdKy9dXSksW1wicmVnZXhcIl0pO3ZhciBYPVYuUFI9e2NyZWF0ZVNpbXBsZUxleGVyOkMscmVnaXN0ZXJMYW5nSGFuZGxlcjppLHNvdXJjZURlY29yYXRvcjp0LFBSX0FUVFJJQl9OQU1FOlwiYXRuXCIsUFJfQVRUUklCX1ZBTFVFOlwiYXR2XCIsUFJfQ09NTUVOVDpcImNvbVwiLFBSX0RFQ0xBUkFUSU9OOlwiZGVjXCIsUFJfS0VZV09SRDpcImt3ZFwiLFBSX0xJVEVSQUw6XCJsaXRcIixQUl9OT0NPREU6XCJub2NvZGVcIixQUl9QTEFJTjpcInBsblwiLFBSX1BVTkNUVUFUSU9OOlwicHVuXCIsUFJfU09VUkNFOlwic3JjXCIsUFJfU1RSSU5HOlwic3RyXCIsUFJfVEFHOlwidGFnXCIsUFJfVFlQRTpcInR5cFwiLHByZXR0eVByaW50T25lOmZ1bmN0aW9uKGEsZCxlKXt2YXIgYj1kb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO2IuaW5uZXJIVE1MPVwiPHByZT5cIithK1wiPC9wcmU+XCI7Yj1iLmZpcnN0Q2hpbGQ7ZSYmeihiLGUsITApO0Qoe2g6ZCxqOmUsYzpiLGk6MX0pO3JldHVybiBiLmlubmVySFRNTH0sXG5wcmV0dHlQcmludDplPWU9ZnVuY3Rpb24oYSxkKXtmdW5jdGlvbiBlKCl7Zm9yKHZhciBiPVYuUFJfU0hPVUxEX1VTRV9DT05USU5VQVRJT04/Yy5ub3coKSsyNTA6SW5maW5pdHk7cDxqLmxlbmd0aCYmYy5ub3coKTxiO3ArKyl7Zm9yKHZhciBkPWpbcF0sbT1rLGw9ZDtsPWwucHJldmlvdXNTaWJsaW5nOyl7dmFyIG49bC5ub2RlVHlwZSxzPShuPT09N3x8bj09PTgpJiZsLm5vZGVWYWx1ZTtpZihzPyEvXlxcPz9wcmV0dGlmeVxcYi8udGVzdChzKTpuIT09M3x8L1xcUy8udGVzdChsLm5vZGVWYWx1ZSkpYnJlYWs7aWYocyl7bT17fTtzLnJlcGxhY2UoL1xcYihcXHcrKT0oW1xcdyUrXFwtLjpdKykvZyxmdW5jdGlvbihhLGIsYyl7bVtiXT1jfSk7YnJlYWt9fWw9ZC5jbGFzc05hbWU7aWYoKG0hPT1rfHxmLnRlc3QobCkpJiYhdy50ZXN0KGwpKXtuPSExO2ZvcihzPWQucGFyZW50Tm9kZTtzO3M9cy5wYXJlbnROb2RlKWlmKGcudGVzdChzLnRhZ05hbWUpJiZzLmNsYXNzTmFtZSYmZi50ZXN0KHMuY2xhc3NOYW1lKSl7bj1cbiEwO2JyZWFrfWlmKCFuKXtkLmNsYXNzTmFtZSs9XCIgcHJldHR5cHJpbnRlZFwiO249bS5sYW5nO2lmKCFuKXt2YXIgbj1sLm1hdGNoKHEpLEE7aWYoIW4mJihBPXgoZCkpJiZ1LnRlc3QoQS50YWdOYW1lKSluPUEuY2xhc3NOYW1lLm1hdGNoKHEpO24mJihuPW5bMV0pfWlmKHkudGVzdChkLnRhZ05hbWUpKXM9MTtlbHNlIHZhciBzPWQuY3VycmVudFN0eWxlLHY9aS5kZWZhdWx0VmlldyxzPShzPXM/cy53aGl0ZVNwYWNlOnYmJnYuZ2V0Q29tcHV0ZWRTdHlsZT92LmdldENvbXB1dGVkU3R5bGUoZCxyKS5nZXRQcm9wZXJ0eVZhbHVlKFwid2hpdGUtc3BhY2VcIik6MCkmJlwicHJlXCI9PT1zLnN1YnN0cmluZygwLDMpO3Y9bS5saW5lbnVtcztpZighKHY9dj09PVwidHJ1ZVwifHwrdikpdj0odj1sLm1hdGNoKC9cXGJsaW5lbnVtc1xcYig/OjooXFxkKykpPy8pKT92WzFdJiZ2WzFdLmxlbmd0aD8rdlsxXTohMDohMTt2JiZ6KGQsdixzKTt0PXtoOm4sYzpkLGo6dixpOnN9O0QodCl9fX1wPGoubGVuZ3RoP1xuUChlLDI1MCk6XCJmdW5jdGlvblwiPT09dHlwZW9mIGEmJmEoKX1mb3IodmFyIGI9ZHx8ZG9jdW1lbnQuYm9keSxpPWIub3duZXJEb2N1bWVudHx8ZG9jdW1lbnQsYj1bYi5nZXRFbGVtZW50c0J5VGFnTmFtZShcInByZVwiKSxiLmdldEVsZW1lbnRzQnlUYWdOYW1lKFwiY29kZVwiKSxiLmdldEVsZW1lbnRzQnlUYWdOYW1lKFwieG1wXCIpXSxqPVtdLG09MDttPGIubGVuZ3RoOysrbSlmb3IodmFyIGw9MCxuPWJbbV0ubGVuZ3RoO2w8bjsrK2wpai5wdXNoKGJbbV1bbF0pO3ZhciBiPXIsYz1EYXRlO2Mubm93fHwoYz17bm93OmZ1bmN0aW9uKCl7cmV0dXJuK25ldyBEYXRlfX0pO3ZhciBwPTAsdCxxPS9cXGJsYW5nKD86dWFnZSk/LShbXFx3Ll0rKSg/IVxcUykvLGY9L1xcYnByZXR0eXByaW50XFxiLyx3PS9cXGJwcmV0dHlwcmludGVkXFxiLyx5PS9wcmV8eG1wL2ksdT0vXmNvZGUkL2ksZz0vXig/OnByZXxjb2RlfHhtcCkkL2ksaz17fTtlKCl9fTt0eXBlb2YgZGVmaW5lPT09XCJmdW5jdGlvblwiJiZkZWZpbmUuYW1kJiZcbmRlZmluZShcImdvb2dsZS1jb2RlLXByZXR0aWZ5XCIsW10sZnVuY3Rpb24oKXtyZXR1cm4gWH0pfSkoKTtyZXR1cm4gZX0oKTtSfHxQKFEsMCl9KSgpO30oKVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///643\n')},405:(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{"use strict";eval('// ESM COMPAT FLAG\n__webpack_require__.r(__webpack_exports__);\n\n// EXTERNAL MODULE: ./node_modules/google-code-prettify/bin/run_prettify.min.js\nvar run_prettify_min = __webpack_require__(643);\n;// CONCATENATED MODULE: ./node_modules/whatwg-fetch/fetch.js\n/* eslint-disable no-prototype-builtins */\nvar g =\n  (typeof globalThis !== \'undefined\' && globalThis) ||\n  (typeof self !== \'undefined\' && self) ||\n  // eslint-disable-next-line no-undef\n  (typeof __webpack_require__.g !== \'undefined\' && __webpack_require__.g) ||\n  {}\n\nvar support = {\n  searchParams: \'URLSearchParams\' in g,\n  iterable: \'Symbol\' in g && \'iterator\' in Symbol,\n  blob:\n    \'FileReader\' in g &&\n    \'Blob\' in g &&\n    (function() {\n      try {\n        new Blob()\n        return true\n      } catch (e) {\n        return false\n      }\n    })(),\n  formData: \'FormData\' in g,\n  arrayBuffer: \'ArrayBuffer\' in g\n}\n\nfunction isDataView(obj) {\n  return obj && DataView.prototype.isPrototypeOf(obj)\n}\n\nif (support.arrayBuffer) {\n  var viewClasses = [\n    \'[object Int8Array]\',\n    \'[object Uint8Array]\',\n    \'[object Uint8ClampedArray]\',\n    \'[object Int16Array]\',\n    \'[object Uint16Array]\',\n    \'[object Int32Array]\',\n    \'[object Uint32Array]\',\n    \'[object Float32Array]\',\n    \'[object Float64Array]\'\n  ]\n\n  var isArrayBufferView =\n    ArrayBuffer.isView ||\n    function(obj) {\n      return obj && viewClasses.indexOf(Object.prototype.toString.call(obj)) > -1\n    }\n}\n\nfunction normalizeName(name) {\n  if (typeof name !== \'string\') {\n    name = String(name)\n  }\n  if (/[^a-z0-9\\-#$%&\'*+.^_`|~!]/i.test(name) || name === \'\') {\n    throw new TypeError(\'Invalid character in header field name: "\' + name + \'"\')\n  }\n  return name.toLowerCase()\n}\n\nfunction normalizeValue(value) {\n  if (typeof value !== \'string\') {\n    value = String(value)\n  }\n  return value\n}\n\n// Build a destructive iterator for the value list\nfunction iteratorFor(items) {\n  var iterator = {\n    next: function() {\n      var value = items.shift()\n      return {done: value === undefined, value: value}\n    }\n  }\n\n  if (support.iterable) {\n    iterator[Symbol.iterator] = function() {\n      return iterator\n    }\n  }\n\n  return iterator\n}\n\nfunction Headers(headers) {\n  this.map = {}\n\n  if (headers instanceof Headers) {\n    headers.forEach(function(value, name) {\n      this.append(name, value)\n    }, this)\n  } else if (Array.isArray(headers)) {\n    headers.forEach(function(header) {\n      if (header.length != 2) {\n        throw new TypeError(\'Headers constructor: expected name/value pair to be length 2, found\' + header.length)\n      }\n      this.append(header[0], header[1])\n    }, this)\n  } else if (headers) {\n    Object.getOwnPropertyNames(headers).forEach(function(name) {\n      this.append(name, headers[name])\n    }, this)\n  }\n}\n\nHeaders.prototype.append = function(name, value) {\n  name = normalizeName(name)\n  value = normalizeValue(value)\n  var oldValue = this.map[name]\n  this.map[name] = oldValue ? oldValue + \', \' + value : value\n}\n\nHeaders.prototype[\'delete\'] = function(name) {\n  delete this.map[normalizeName(name)]\n}\n\nHeaders.prototype.get = function(name) {\n  name = normalizeName(name)\n  return this.has(name) ? this.map[name] : null\n}\n\nHeaders.prototype.has = function(name) {\n  return this.map.hasOwnProperty(normalizeName(name))\n}\n\nHeaders.prototype.set = function(name, value) {\n  this.map[normalizeName(name)] = normalizeValue(value)\n}\n\nHeaders.prototype.forEach = function(callback, thisArg) {\n  for (var name in this.map) {\n    if (this.map.hasOwnProperty(name)) {\n      callback.call(thisArg, this.map[name], name, this)\n    }\n  }\n}\n\nHeaders.prototype.keys = function() {\n  var items = []\n  this.forEach(function(value, name) {\n    items.push(name)\n  })\n  return iteratorFor(items)\n}\n\nHeaders.prototype.values = function() {\n  var items = []\n  this.forEach(function(value) {\n    items.push(value)\n  })\n  return iteratorFor(items)\n}\n\nHeaders.prototype.entries = function() {\n  var items = []\n  this.forEach(function(value, name) {\n    items.push([name, value])\n  })\n  return iteratorFor(items)\n}\n\nif (support.iterable) {\n  Headers.prototype[Symbol.iterator] = Headers.prototype.entries\n}\n\nfunction consumed(body) {\n  if (body._noBody) return\n  if (body.bodyUsed) {\n    return Promise.reject(new TypeError(\'Already read\'))\n  }\n  body.bodyUsed = true\n}\n\nfunction fileReaderReady(reader) {\n  return new Promise(function(resolve, reject) {\n    reader.onload = function() {\n      resolve(reader.result)\n    }\n    reader.onerror = function() {\n      reject(reader.error)\n    }\n  })\n}\n\nfunction readBlobAsArrayBuffer(blob) {\n  var reader = new FileReader()\n  var promise = fileReaderReady(reader)\n  reader.readAsArrayBuffer(blob)\n  return promise\n}\n\nfunction readBlobAsText(blob) {\n  var reader = new FileReader()\n  var promise = fileReaderReady(reader)\n  var match = /charset=([A-Za-z0-9_-]+)/.exec(blob.type)\n  var encoding = match ? match[1] : \'utf-8\'\n  reader.readAsText(blob, encoding)\n  return promise\n}\n\nfunction readArrayBufferAsText(buf) {\n  var view = new Uint8Array(buf)\n  var chars = new Array(view.length)\n\n  for (var i = 0; i < view.length; i++) {\n    chars[i] = String.fromCharCode(view[i])\n  }\n  return chars.join(\'\')\n}\n\nfunction bufferClone(buf) {\n  if (buf.slice) {\n    return buf.slice(0)\n  } else {\n    var view = new Uint8Array(buf.byteLength)\n    view.set(new Uint8Array(buf))\n    return view.buffer\n  }\n}\n\nfunction Body() {\n  this.bodyUsed = false\n\n  this._initBody = function(body) {\n    /*\n      fetch-mock wraps the Response object in an ES6 Proxy to\n      provide useful test harness features such as flush. However, on\n      ES5 browsers without fetch or Proxy support pollyfills must be used;\n      the proxy-pollyfill is unable to proxy an attribute unless it exists\n      on the object before the Proxy is created. This change ensures\n      Response.bodyUsed exists on the instance, while maintaining the\n      semantic of setting Request.bodyUsed in the constructor before\n      _initBody is called.\n    */\n    // eslint-disable-next-line no-self-assign\n    this.bodyUsed = this.bodyUsed\n    this._bodyInit = body\n    if (!body) {\n      this._noBody = true;\n      this._bodyText = \'\'\n    } else if (typeof body === \'string\') {\n      this._bodyText = body\n    } else if (support.blob && Blob.prototype.isPrototypeOf(body)) {\n      this._bodyBlob = body\n    } else if (support.formData && FormData.prototype.isPrototypeOf(body)) {\n      this._bodyFormData = body\n    } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {\n      this._bodyText = body.toString()\n    } else if (support.arrayBuffer && support.blob && isDataView(body)) {\n      this._bodyArrayBuffer = bufferClone(body.buffer)\n      // IE 10-11 can\'t handle a DataView body.\n      this._bodyInit = new Blob([this._bodyArrayBuffer])\n    } else if (support.arrayBuffer && (ArrayBuffer.prototype.isPrototypeOf(body) || isArrayBufferView(body))) {\n      this._bodyArrayBuffer = bufferClone(body)\n    } else {\n      this._bodyText = body = Object.prototype.toString.call(body)\n    }\n\n    if (!this.headers.get(\'content-type\')) {\n      if (typeof body === \'string\') {\n        this.headers.set(\'content-type\', \'text/plain;charset=UTF-8\')\n      } else if (this._bodyBlob && this._bodyBlob.type) {\n        this.headers.set(\'content-type\', this._bodyBlob.type)\n      } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {\n        this.headers.set(\'content-type\', \'application/x-www-form-urlencoded;charset=UTF-8\')\n      }\n    }\n  }\n\n  if (support.blob) {\n    this.blob = function() {\n      var rejected = consumed(this)\n      if (rejected) {\n        return rejected\n      }\n\n      if (this._bodyBlob) {\n        return Promise.resolve(this._bodyBlob)\n      } else if (this._bodyArrayBuffer) {\n        return Promise.resolve(new Blob([this._bodyArrayBuffer]))\n      } else if (this._bodyFormData) {\n        throw new Error(\'could not read FormData body as blob\')\n      } else {\n        return Promise.resolve(new Blob([this._bodyText]))\n      }\n    }\n  }\n\n  this.arrayBuffer = function() {\n    if (this._bodyArrayBuffer) {\n      var isConsumed = consumed(this)\n      if (isConsumed) {\n        return isConsumed\n      } else if (ArrayBuffer.isView(this._bodyArrayBuffer)) {\n        return Promise.resolve(\n          this._bodyArrayBuffer.buffer.slice(\n            this._bodyArrayBuffer.byteOffset,\n            this._bodyArrayBuffer.byteOffset + this._bodyArrayBuffer.byteLength\n          )\n        )\n      } else {\n        return Promise.resolve(this._bodyArrayBuffer)\n      }\n    } else if (support.blob) {\n      return this.blob().then(readBlobAsArrayBuffer)\n    } else {\n      throw new Error(\'could not read as ArrayBuffer\')\n    }\n  }\n\n  this.text = function() {\n    var rejected = consumed(this)\n    if (rejected) {\n      return rejected\n    }\n\n    if (this._bodyBlob) {\n      return readBlobAsText(this._bodyBlob)\n    } else if (this._bodyArrayBuffer) {\n      return Promise.resolve(readArrayBufferAsText(this._bodyArrayBuffer))\n    } else if (this._bodyFormData) {\n      throw new Error(\'could not read FormData body as text\')\n    } else {\n      return Promise.resolve(this._bodyText)\n    }\n  }\n\n  if (support.formData) {\n    this.formData = function() {\n      return this.text().then(decode)\n    }\n  }\n\n  this.json = function() {\n    return this.text().then(JSON.parse)\n  }\n\n  return this\n}\n\n// HTTP methods whose capitalization should be normalized\nvar methods = [\'CONNECT\', \'DELETE\', \'GET\', \'HEAD\', \'OPTIONS\', \'PATCH\', \'POST\', \'PUT\', \'TRACE\']\n\nfunction normalizeMethod(method) {\n  var upcased = method.toUpperCase()\n  return methods.indexOf(upcased) > -1 ? upcased : method\n}\n\nfunction Request(input, options) {\n  if (!(this instanceof Request)) {\n    throw new TypeError(\'Please use the "new" operator, this DOM object constructor cannot be called as a function.\')\n  }\n\n  options = options || {}\n  var body = options.body\n\n  if (input instanceof Request) {\n    if (input.bodyUsed) {\n      throw new TypeError(\'Already read\')\n    }\n    this.url = input.url\n    this.credentials = input.credentials\n    if (!options.headers) {\n      this.headers = new Headers(input.headers)\n    }\n    this.method = input.method\n    this.mode = input.mode\n    this.signal = input.signal\n    if (!body && input._bodyInit != null) {\n      body = input._bodyInit\n      input.bodyUsed = true\n    }\n  } else {\n    this.url = String(input)\n  }\n\n  this.credentials = options.credentials || this.credentials || \'same-origin\'\n  if (options.headers || !this.headers) {\n    this.headers = new Headers(options.headers)\n  }\n  this.method = normalizeMethod(options.method || this.method || \'GET\')\n  this.mode = options.mode || this.mode || null\n  this.signal = options.signal || this.signal || (function () {\n    if (\'AbortController\' in g) {\n      var ctrl = new AbortController();\n      return ctrl.signal;\n    }\n  }());\n  this.referrer = null\n\n  if ((this.method === \'GET\' || this.method === \'HEAD\') && body) {\n    throw new TypeError(\'Body not allowed for GET or HEAD requests\')\n  }\n  this._initBody(body)\n\n  if (this.method === \'GET\' || this.method === \'HEAD\') {\n    if (options.cache === \'no-store\' || options.cache === \'no-cache\') {\n      // Search for a \'_\' parameter in the query string\n      var reParamSearch = /([?&])_=[^&]*/\n      if (reParamSearch.test(this.url)) {\n        // If it already exists then set the value with the current time\n        this.url = this.url.replace(reParamSearch, \'$1_=\' + new Date().getTime())\n      } else {\n        // Otherwise add a new \'_\' parameter to the end with the current time\n        var reQueryString = /\\?/\n        this.url += (reQueryString.test(this.url) ? \'&\' : \'?\') + \'_=\' + new Date().getTime()\n      }\n    }\n  }\n}\n\nRequest.prototype.clone = function() {\n  return new Request(this, {body: this._bodyInit})\n}\n\nfunction decode(body) {\n  var form = new FormData()\n  body\n    .trim()\n    .split(\'&\')\n    .forEach(function(bytes) {\n      if (bytes) {\n        var split = bytes.split(\'=\')\n        var name = split.shift().replace(/\\+/g, \' \')\n        var value = split.join(\'=\').replace(/\\+/g, \' \')\n        form.append(decodeURIComponent(name), decodeURIComponent(value))\n      }\n    })\n  return form\n}\n\nfunction parseHeaders(rawHeaders) {\n  var headers = new Headers()\n  // Replace instances of \\r\\n and \\n followed by at least one space or horizontal tab with a space\n  // https://tools.ietf.org/html/rfc7230#section-3.2\n  var preProcessedHeaders = rawHeaders.replace(/\\r?\\n[\\t ]+/g, \' \')\n  // Avoiding split via regex to work around a common IE11 bug with the core-js 3.6.0 regex polyfill\n  // https://github.com/github/fetch/issues/748\n  // https://github.com/zloirock/core-js/issues/751\n  preProcessedHeaders\n    .split(\'\\r\')\n    .map(function(header) {\n      return header.indexOf(\'\\n\') === 0 ? header.substr(1, header.length) : header\n    })\n    .forEach(function(line) {\n      var parts = line.split(\':\')\n      var key = parts.shift().trim()\n      if (key) {\n        var value = parts.join(\':\').trim()\n        try {\n          headers.append(key, value)\n        } catch (error) {\n          console.warn(\'Response \' + error.message)\n        }\n      }\n    })\n  return headers\n}\n\nBody.call(Request.prototype)\n\nfunction Response(bodyInit, options) {\n  if (!(this instanceof Response)) {\n    throw new TypeError(\'Please use the "new" operator, this DOM object constructor cannot be called as a function.\')\n  }\n  if (!options) {\n    options = {}\n  }\n\n  this.type = \'default\'\n  this.status = options.status === undefined ? 200 : options.status\n  if (this.status < 200 || this.status > 599) {\n    throw new RangeError("Failed to construct \'Response\': The status provided (0) is outside the range [200, 599].")\n  }\n  this.ok = this.status >= 200 && this.status < 300\n  this.statusText = options.statusText === undefined ? \'\' : \'\' + options.statusText\n  this.headers = new Headers(options.headers)\n  this.url = options.url || \'\'\n  this._initBody(bodyInit)\n}\n\nBody.call(Response.prototype)\n\nResponse.prototype.clone = function() {\n  return new Response(this._bodyInit, {\n    status: this.status,\n    statusText: this.statusText,\n    headers: new Headers(this.headers),\n    url: this.url\n  })\n}\n\nResponse.error = function() {\n  var response = new Response(null, {status: 200, statusText: \'\'})\n  response.ok = false\n  response.status = 0\n  response.type = \'error\'\n  return response\n}\n\nvar redirectStatuses = [301, 302, 303, 307, 308]\n\nResponse.redirect = function(url, status) {\n  if (redirectStatuses.indexOf(status) === -1) {\n    throw new RangeError(\'Invalid status code\')\n  }\n\n  return new Response(null, {status: status, headers: {location: url}})\n}\n\nvar DOMException = g.DOMException\ntry {\n  new DOMException()\n} catch (err) {\n  DOMException = function(message, name) {\n    this.message = message\n    this.name = name\n    var error = Error(message)\n    this.stack = error.stack\n  }\n  DOMException.prototype = Object.create(Error.prototype)\n  DOMException.prototype.constructor = DOMException\n}\n\nfunction fetch_fetch(input, init) {\n  return new Promise(function(resolve, reject) {\n    var request = new Request(input, init)\n\n    if (request.signal && request.signal.aborted) {\n      return reject(new DOMException(\'Aborted\', \'AbortError\'))\n    }\n\n    var xhr = new XMLHttpRequest()\n\n    function abortXhr() {\n      xhr.abort()\n    }\n\n    xhr.onload = function() {\n      var options = {\n        statusText: xhr.statusText,\n        headers: parseHeaders(xhr.getAllResponseHeaders() || \'\')\n      }\n      // This check if specifically for when a user fetches a file locally from the file system\n      // Only if the status is out of a normal range\n      if (request.url.indexOf(\'file://\') === 0 && (xhr.status < 200 || xhr.status > 599)) {\n        options.status = 200;\n      } else {\n        options.status = xhr.status;\n      }\n      options.url = \'responseURL\' in xhr ? xhr.responseURL : options.headers.get(\'X-Request-URL\')\n      var body = \'response\' in xhr ? xhr.response : xhr.responseText\n      setTimeout(function() {\n        resolve(new Response(body, options))\n      }, 0)\n    }\n\n    xhr.onerror = function() {\n      setTimeout(function() {\n        reject(new TypeError(\'Network request failed\'))\n      }, 0)\n    }\n\n    xhr.ontimeout = function() {\n      setTimeout(function() {\n        reject(new TypeError(\'Network request timed out\'))\n      }, 0)\n    }\n\n    xhr.onabort = function() {\n      setTimeout(function() {\n        reject(new DOMException(\'Aborted\', \'AbortError\'))\n      }, 0)\n    }\n\n    function fixUrl(url) {\n      try {\n        return url === \'\' && g.location.href ? g.location.href : url\n      } catch (e) {\n        return url\n      }\n    }\n\n    xhr.open(request.method, fixUrl(request.url), true)\n\n    if (request.credentials === \'include\') {\n      xhr.withCredentials = true\n    } else if (request.credentials === \'omit\') {\n      xhr.withCredentials = false\n    }\n\n    if (\'responseType\' in xhr) {\n      if (support.blob) {\n        xhr.responseType = \'blob\'\n      } else if (\n        support.arrayBuffer\n      ) {\n        xhr.responseType = \'arraybuffer\'\n      }\n    }\n\n    if (init && typeof init.headers === \'object\' && !(init.headers instanceof Headers || (g.Headers && init.headers instanceof g.Headers))) {\n      var names = [];\n      Object.getOwnPropertyNames(init.headers).forEach(function(name) {\n        names.push(normalizeName(name))\n        xhr.setRequestHeader(name, normalizeValue(init.headers[name]))\n      })\n      request.headers.forEach(function(value, name) {\n        if (names.indexOf(name) === -1) {\n          xhr.setRequestHeader(name, value)\n        }\n      })\n    } else {\n      request.headers.forEach(function(value, name) {\n        xhr.setRequestHeader(name, value)\n      })\n    }\n\n    if (request.signal) {\n      request.signal.addEventListener(\'abort\', abortXhr)\n\n      xhr.onreadystatechange = function() {\n        // DONE (success or failure)\n        if (xhr.readyState === 4) {\n          request.signal.removeEventListener(\'abort\', abortXhr)\n        }\n      }\n    }\n\n    xhr.send(typeof request._bodyInit === \'undefined\' ? null : request._bodyInit)\n  })\n}\n\nfetch_fetch.polyfill = true\n\nif (!g.fetch) {\n  g.fetch = fetch_fetch\n  g.Headers = Headers\n  g.Request = Request\n  g.Response = Response\n}\n\n;// CONCATENATED MODULE: ./src/constants/numbers.ts\nconst MAX_DECIMALS = 6;\nconst DEFAULT_BLEND_STEPS = 5;\nconst DEFAULT_SHADES_TINTS_STEPS = 5;\n\n;// CONCATENATED MODULE: ./src/constants/enums.ts\nvar ColorModel;\n(function (ColorModel) {\n    ColorModel["HEX"] = "HEX";\n    ColorModel["RGB"] = "RGB";\n    ColorModel["HSL"] = "HSL";\n    ColorModel["CIELab"] = "CIELab";\n    ColorModel["CMYK"] = "CMYK";\n})(ColorModel || (ColorModel = {}));\nvar Harmony;\n(function (Harmony) {\n    Harmony["ANALOGOUS"] = "ANALOGOUS";\n    Harmony["COMPLEMENTARY"] = "COMPLEMENTARY";\n    Harmony["SPLIT_COMPLEMENTARY"] = "SPLIT_COMPLEMENTARY";\n    Harmony["TRIADIC"] = "TRIADIC";\n    Harmony["TETRADIC"] = "TETRADIC";\n    Harmony["SQUARE"] = "SQUARE";\n})(Harmony || (Harmony = {}));\nvar Mix;\n(function (Mix) {\n    Mix["ADDITIVE"] = "ADDITIVE";\n    Mix["SUBTRACTIVE"] = "SUBTRACTIVE";\n})(Mix || (Mix = {}));\nvar ColorKeywords;\n(function (ColorKeywords) {\n    ColorKeywords["black"] = "#000000";\n    ColorKeywords["silver"] = "#C0C0C0";\n    ColorKeywords["gray"] = "#808080";\n    ColorKeywords["white"] = "#FFFFFF";\n    ColorKeywords["maroon"] = "#800000";\n    ColorKeywords["red"] = "#FF0000";\n    ColorKeywords["purple"] = "#800080";\n    ColorKeywords["fuchsia"] = "#FF00FF";\n    ColorKeywords["green"] = "#008000";\n    ColorKeywords["lime"] = "#00FF00";\n    ColorKeywords["olive"] = "#808000";\n    ColorKeywords["yellow"] = "#FFFF00";\n    ColorKeywords["navy"] = "#000080";\n    ColorKeywords["blue"] = "#0000FF";\n    ColorKeywords["teal"] = "#008080";\n    ColorKeywords["aqua"] = "#00FFFF";\n    ColorKeywords["orange"] = "#FFA500";\n    ColorKeywords["aliceblue"] = "#F0F8FF";\n    ColorKeywords["antiquewhite"] = "#FAEBD7";\n    ColorKeywords["aquamarine"] = "#7FFFD4";\n    ColorKeywords["azure"] = "#F0FFFF";\n    ColorKeywords["beige"] = "#F5F5DC";\n    ColorKeywords["bisque"] = "#FFE4C4";\n    ColorKeywords["blanchedalmond"] = "#FFEBCD";\n    ColorKeywords["blueviolet"] = "#8A2BE2";\n    ColorKeywords["brown"] = "#A52A2A";\n    ColorKeywords["burlywood"] = "#DEB887";\n    ColorKeywords["cadetblue"] = "#5F9EA0";\n    ColorKeywords["chartreuse"] = "#7FFF00";\n    ColorKeywords["chocolate"] = "#D2691E";\n    ColorKeywords["coral"] = "#FF7F50";\n    ColorKeywords["cornflowerblue"] = "#6495ED";\n    ColorKeywords["cornsilk"] = "#FFF8DC";\n    ColorKeywords["crimson"] = "#DC143C";\n    ColorKeywords["cyan"] = "#00FFFF";\n    ColorKeywords["darkblue"] = "#00008B";\n    ColorKeywords["darkcyan"] = "#008B8B";\n    ColorKeywords["darkgoldenrod"] = "#B8860B";\n    ColorKeywords["darkgray"] = "#A9A9A9";\n    ColorKeywords["darkgreen"] = "#006400";\n    ColorKeywords["darkgrey"] = "#A9A9A9";\n    ColorKeywords["darkkhaki"] = "#BDB76B";\n    ColorKeywords["darkmagenta"] = "#8B008B";\n    ColorKeywords["darkolivegreen"] = "#556B2F";\n    ColorKeywords["darkorange"] = "#FF8C00";\n    ColorKeywords["darkorchid"] = "#9932CC";\n    ColorKeywords["darkred"] = "#8B0000";\n    ColorKeywords["darksalmon"] = "#E9967A";\n    ColorKeywords["darkseagreen"] = "#8FBC8F";\n    ColorKeywords["darkslateblue"] = "#483D8B";\n    ColorKeywords["darkslategray"] = "#2F4F4F";\n    ColorKeywords["darkslategrey"] = "#2F4F4F";\n    ColorKeywords["darkturquoise"] = "#00CED1";\n    ColorKeywords["darkviolet"] = "#9400D3";\n    ColorKeywords["deeppink"] = "#FF1493";\n    ColorKeywords["deepskyblue"] = "#00BFFF";\n    ColorKeywords["dimgray"] = "#696969";\n    ColorKeywords["dimgrey"] = "#696969";\n    ColorKeywords["dodgerblue"] = "#1E90FF";\n    ColorKeywords["firebrick"] = "#B22222";\n    ColorKeywords["floralwhite"] = "#FFFAF0";\n    ColorKeywords["forestgreen"] = "#228B22";\n    ColorKeywords["gainsboro"] = "#DCDCDC";\n    ColorKeywords["ghostwhite"] = "#F8F8FF";\n    ColorKeywords["gold"] = "#FFD700";\n    ColorKeywords["goldenrod"] = "#DAA520";\n    ColorKeywords["greenyellow"] = "#ADFF2F";\n    ColorKeywords["grey"] = "#808080";\n    ColorKeywords["honeydew"] = "#F0FFF0";\n    ColorKeywords["hotpink"] = "#FF69B4";\n    ColorKeywords["indianred"] = "#CD5C5C";\n    ColorKeywords["indigo"] = "#4B0082";\n    ColorKeywords["ivory"] = "#FFFFF0";\n    ColorKeywords["khaki"] = "#F0E68C";\n    ColorKeywords["lavender"] = "#E6E6FA";\n    ColorKeywords["lavenderblush"] = "#FFF0F5";\n    ColorKeywords["lawngreen"] = "#7CFC00";\n    ColorKeywords["lemonchiffon"] = "#FFFACD";\n    ColorKeywords["lightblue"] = "#ADD8E6";\n    ColorKeywords["lightcoral"] = "#F08080";\n    ColorKeywords["lightcyan"] = "#E0FFFF";\n    ColorKeywords["lightgoldenrodyellow"] = "#FAFAD2";\n    ColorKeywords["lightgray"] = "#D3D3D3";\n    ColorKeywords["lightgreen"] = "#90EE90";\n    ColorKeywords["lightgrey"] = "#D3D3D3";\n    ColorKeywords["lightpink"] = "#FFB6C1";\n    ColorKeywords["lightsalmon"] = "#FFA07A";\n    ColorKeywords["lightseagreen"] = "#20B2AA";\n    ColorKeywords["lightskyblue"] = "#87CEFA";\n    ColorKeywords["lightslategray"] = "#778899";\n    ColorKeywords["lightslategrey"] = "#778899";\n    ColorKeywords["lightsteelblue"] = "#B0C4DE";\n    ColorKeywords["lightyellow"] = "#FFFFE0";\n    ColorKeywords["limegreen"] = "#32CD32";\n    ColorKeywords["linen"] = "#FAF0E6";\n    ColorKeywords["magenta"] = "#FF00FF";\n    ColorKeywords["mediumaquamarine"] = "#66CDAA";\n    ColorKeywords["mediumblue"] = "#0000CD";\n    ColorKeywords["mediumorchid"] = "#BA55D3";\n    ColorKeywords["mediumpurple"] = "#9370DB";\n    ColorKeywords["mediumseagreen"] = "#3CB371";\n    ColorKeywords["mediumslateblue"] = "#7B68EE";\n    ColorKeywords["mediumspringgreen"] = "#00FA9A";\n    ColorKeywords["mediumturquoise"] = "#48D1CC";\n    ColorKeywords["mediumvioletred"] = "#C71585";\n    ColorKeywords["midnightblue"] = "#191970";\n    ColorKeywords["mintcream"] = "#F5FFFA";\n    ColorKeywords["mistyrose"] = "#FFE4E1";\n    ColorKeywords["moccasin"] = "#FFE4B5";\n    ColorKeywords["navajowhite"] = "#FFDEAD";\n    ColorKeywords["oldlace"] = "#FDF5E6";\n    ColorKeywords["olivedrab"] = "#6B8E23";\n    ColorKeywords["orangered"] = "#FF4500";\n    ColorKeywords["orchid"] = "#DA70D6";\n    ColorKeywords["palegoldenrod"] = "#EEE8AA";\n    ColorKeywords["palegreen"] = "#98FB98";\n    ColorKeywords["paleturquoise"] = "#AFEEEE";\n    ColorKeywords["palevioletred"] = "#DB7093";\n    ColorKeywords["papayawhip"] = "#FFEFD5";\n    ColorKeywords["peachpuff"] = "#FFDAB9";\n    ColorKeywords["peru"] = "#CD853F";\n    ColorKeywords["pink"] = "#FFC0CB";\n    ColorKeywords["plum"] = "#DDA0DD";\n    ColorKeywords["powderblue"] = "#B0E0E6";\n    ColorKeywords["rosybrown"] = "#BC8F8F";\n    ColorKeywords["royalblue"] = "#4169E1";\n    ColorKeywords["saddlebrown"] = "#8B4513";\n    ColorKeywords["salmon"] = "#FA8072";\n    ColorKeywords["sandybrown"] = "#F4A460";\n    ColorKeywords["seagreen"] = "#2E8B57";\n    ColorKeywords["seashell"] = "#FFF5EE";\n    ColorKeywords["sienna"] = "#A0522D";\n    ColorKeywords["skyblue"] = "#87CEEB";\n    ColorKeywords["slateblue"] = "#6A5ACD";\n    ColorKeywords["slategray"] = "#708090";\n    ColorKeywords["slategrey"] = "#708090";\n    ColorKeywords["snow"] = "#FFFAFA";\n    ColorKeywords["springgreen"] = "#00FF7F";\n    ColorKeywords["steelblue"] = "#4682B4";\n    ColorKeywords["tan"] = "#D2B48C";\n    ColorKeywords["thistle"] = "#D8BFD8";\n    ColorKeywords["tomato"] = "#FF6347";\n    ColorKeywords["turquoise"] = "#40E0D0";\n    ColorKeywords["violet"] = "#EE82EE";\n    ColorKeywords["wheat"] = "#F5DEB3";\n    ColorKeywords["whitesmoke"] = "#F5F5F5";\n    ColorKeywords["yellowgreen"] = "#9ACD32";\n    ColorKeywords["rebeccapurple"] = "#663399";\n})(ColorKeywords || (ColorKeywords = {}));\nconst COLOR_KEYS = Object.keys(ColorKeywords);\nconst COLOR_PROPS = {\n    HEX: [\'R\', \'G\', \'B\', \'A\'],\n    RGB: [\'R\', \'G\', \'B\', \'A\'],\n    HSL: [\'H\', \'S\', \'L\', \'A\'],\n    CIELab: [\'L\', \'a\', \'b\', \'A\'],\n    CMYK: [\'C\', \'M\', \'Y\', \'K\', \'A\']\n};\nconst VALID_COLOR_OBJECTS = {\n    BGR: ColorModel.RGB,\n    ABGR: ColorModel.RGB,\n    HLS: ColorModel.HSL,\n    AHLS: ColorModel.HSL,\n    LAB: ColorModel.CIELab,\n    ALAB: ColorModel.CIELab,\n    CKMY: ColorModel.CMYK,\n    ACKMY: ColorModel.CMYK\n};\nvar TypeOf;\n(function (TypeOf) {\n    TypeOf["NUMBER"] = "number";\n    TypeOf["BOOLEAN"] = "boolean";\n})(TypeOf || (TypeOf = {}));\n\n;// CONCATENATED MODULE: ./src/constants/regexps.ts\n\nconst COLORREGS = {\n    [ColorModel.HEX]: /^#(?:([a-f\\d])([a-f\\d])([a-f\\d])([a-f\\d])?|([a-f\\d]{2})([a-f\\d]{2})([a-f\\d]{2})([a-f\\d]{2})?)$/i,\n    [ColorModel.RGB]: /^rgba?\\s*\\(\\s*(?:((?:\\d*\\.)?\\d+%?)\\s*,\\s*((?:\\d*\\.)?\\d+%?)\\s*,\\s*((?:\\d*\\.)?\\d+%?)(?:\\s*,\\s*((?:\\d*\\.)?\\d+))?|((?:\\d*\\.)?\\d+%?)\\s*((?:\\d*\\.)?\\d+%?)\\s*((?:\\d*\\.)?\\d+%?)(?:\\s*\\/\\s*((?:\\d*\\.)?\\d+%?))?)\\s*\\)$/,\n    [ColorModel.HSL]: /^hsla?\\s*\\(\\s*(?:(-?(?:\\d*\\.)?\\d+(?:deg|grad|rad|turn)?)\\s*,\\s*((?:\\d*\\.)?\\d+)%\\s*,\\s*((?:\\d*\\.)?\\d+)%(?:\\s*,\\s*((?:\\d*\\.)?\\d+))?|(-?(?:\\d*\\.)?\\d+(?:deg|grad|rad|turn)?)\\s*((?:\\d*\\.)?\\d+)%\\s*((?:\\d*\\.)?\\d+)%(?:\\s*\\/\\s*((?:\\d*\\.)?\\d+%?))?)\\s*\\)$/,\n    [ColorModel.CIELab]: /^lab\\s*\\(\\s*(?:((?:\\d*\\.)?\\d+%?)\\s*(-?(?:\\d*\\.)?\\d+%?)\\s*(-?(?:\\d*\\.)?\\d+%?)(?:\\s*\\/\\s*((?:\\d*\\.)?\\d+%?))?)\\s*\\)$/,\n    [ColorModel.CMYK]: /^(?:device-cmyk|cmyk)\\s*\\(\\s*(?:((?:\\d*\\.)?\\d+%?)\\s*,\\s*((?:\\d*\\.)?\\d+%?)\\s*,\\s*((?:\\d*\\.)?\\d+%?)\\s*,\\s*((?:\\d*\\.)?\\d+%?)(?:\\s*,\\s*((?:\\d*\\.)?\\d+))?|((?:\\d*\\.)?\\d+%?)\\s*((?:\\d*\\.)?\\d+%?)\\s*((?:\\d*\\.)?\\d+%?)\\s*((?:\\d*\\.)?\\d+%?)(?:\\s*\\/\\s*((?:\\d*\\.)?\\d+%?))?)\\s*\\)$/\n};\nconst HSL_HUE = /^(-?(?:\\d*\\.)?\\d+)((?:deg|grad|rad|turn)?)$/;\nconst PCENT = /^(-?\\d+(?:\\.\\d+)?|-?\\.\\d+)%$/;\nconst HEX = /^0x([a-f\\d]{1,2})$/i;\nconst TEMPLATE_VAR = /\\{(\\d+)\\}/g;\nconst COMMAS_AND_NEXT_CHARS = /,( +|\\d+)/g;\nconst SPACES = / +/;\n\n;// CONCATENATED MODULE: ./src/constants/errors.ts\nconst ERRORS = {\n    NOT_ACCEPTED_STRING_INPUT: \'The provided string color doesn\\\'t have a correct format\',\n    NOT_ACCEPTED_OBJECT_INPUT: \'The provided color object doesn\\\'t have the proper keys or format\'\n};\n\n;// CONCATENATED MODULE: ./src/@types/index.ts\nvar AnglesUnitEnum;\n(function (AnglesUnitEnum) {\n    AnglesUnitEnum["NONE"] = "none";\n    AnglesUnitEnum["DEGREES"] = "deg";\n    AnglesUnitEnum["GRADIANS"] = "grad";\n    AnglesUnitEnum["RADIANS"] = "rad";\n    AnglesUnitEnum["TURNS"] = "turn";\n})(AnglesUnitEnum || (AnglesUnitEnum = {}));\nvar ColorUnitEnum;\n(function (ColorUnitEnum) {\n    ColorUnitEnum["NONE"] = "none";\n    ColorUnitEnum["PERCENT"] = "percent";\n})(ColorUnitEnum || (ColorUnitEnum = {}));\nvar CMYKFunctionEnum;\n(function (CMYKFunctionEnum) {\n    CMYKFunctionEnum["DEVICE_CMYK"] = "device-cmyk";\n    CMYKFunctionEnum["CMYK"] = "cmyk";\n})(CMYKFunctionEnum || (CMYKFunctionEnum = {}));\n\n;// CONCATENATED MODULE: ./src/constants/options.ts\n\n\nconst DEFAULT_OPTIONS = {\n    decimals: MAX_DECIMALS,\n    legacyCSS: false,\n    spacesAfterCommas: false,\n    anglesUnit: AnglesUnitEnum.NONE,\n    rgbUnit: ColorUnitEnum.NONE,\n    labUnit: ColorUnitEnum.NONE,\n    cmykUnit: ColorUnitEnum.PERCENT,\n    alphaUnit: ColorUnitEnum.NONE,\n    cmykFunction: CMYKFunctionEnum.DEVICE_CMYK\n};\n\n;// CONCATENATED MODULE: ./src/constants/index.ts\n\n\n\n\n\n\n\n;// CONCATENATED MODULE: ./src/helpers/index.ts\n\n\nconst hasProp = (obj, prop) => Object.prototype.hasOwnProperty.call(obj, prop);\nconst percentNumber = (percent) => {\n    return +`${percent}`.replace(PCENT, \'$1\');\n};\nconst percent = (percent) => PCENT.test(`${percent}`)\n    ? percentNumber(percent)\n    : Math.min(+percent, 100);\nconst getDEC = (hex) => {\n    if (hex.length === 1) {\n        hex += hex;\n    }\n    return parseInt(hex, 16);\n};\nconst getHEX = (number) => {\n    const hex = round(number, 0).toString(16).toUpperCase();\n    if (hex.length === 1) {\n        return `0x0${hex}`;\n    }\n    return `0x${hex}`;\n};\nconst toHEX = (h) => {\n    let hex = round(h, 0).toString(16).toUpperCase();\n    if (hex.length === 1) {\n        hex = `0${hex}`;\n    }\n    return hex;\n};\nconst from255NumberToPercent = (value, decimals) => round(value / 255 * 100, decimals);\nconst from125NumberToPercent = (value, decimals) => round(value / 125 * 100, decimals);\nconst getBase255Number = (color, alpha = false) => {\n    if (!alpha && PCENT.test(color)) {\n        return Math.min(255 * percentNumber(color) / 100, 255);\n    }\n    if (HEX.test(color)) {\n        if (color.length === 3) {\n            color += color.slice(-1);\n        }\n        return alpha\n            ? round(color) / 255\n            : round(color);\n    }\n    return Math.min(+color, alpha ? 1 : 255);\n};\nconst getBase125Number = (color) => {\n    if (PCENT.test(color)) {\n        return minmax(125 * percentNumber(color) / 100, -125, 125);\n    }\n    return minmax(+color, -125, 125);\n};\nconst getCMYKNumber = (color) => Math.min(PCENT.test(color) ? percentNumber(color) / 100 : +color, 1);\nconst getOrderedArrayString = (keys) => [...keys].sort().join(\'\').toUpperCase();\nconst round = (value, decimals = MAX_DECIMALS) => {\n    const exp = Math.pow(10, decimals);\n    return Math.round(+value * exp) / exp;\n};\nconst minmax = (n, min, max) => Math.max(min, Math.min(n, max));\nconst degrees = (radian) => radian * 180 / Math.PI;\nconst radians = (degrees) => degrees * Math.PI / 180;\nconst pi2 = 360;\nconst normalizeHue = (hue) => {\n    if (typeof hue === \'string\') {\n        const matches = hue.match(HSL_HUE);\n        const value = +matches[1];\n        const units = matches[2];\n        switch (units) {\n            case AnglesUnitEnum.RADIANS:\n                hue = round(degrees(value));\n                break;\n            case AnglesUnitEnum.TURNS:\n                hue = round(value * pi2);\n                break;\n            case AnglesUnitEnum.GRADIANS:\n                hue = round(9 / 10 * value);\n                break;\n            case AnglesUnitEnum.DEGREES:\n            default:\n                hue = value;\n        }\n    }\n    if (hue > 360 || hue < 0) {\n        hue -= Math.floor(hue / pi2) * pi2;\n    }\n    return hue;\n};\nconst translateDegrees = (degrees, units) => {\n    let hue;\n    switch (units) {\n        case AnglesUnitEnum.RADIANS:\n            hue = round(radians(degrees));\n            break;\n        case AnglesUnitEnum.TURNS:\n            hue = round(degrees / pi2);\n            break;\n        case AnglesUnitEnum.GRADIANS:\n            hue = round(10 / 9 * degrees);\n            break;\n        case AnglesUnitEnum.DEGREES:\n        case AnglesUnitEnum.NONE:\n        default:\n            hue = degrees;\n    }\n    return hue;\n};\nconst getOptionsFromColorInput = (options, ...colors) => {\n    const cssColors = [];\n    const hslColors = [];\n    const rgbColors = [];\n    const labColors = [];\n    const cmykColors = [];\n    const alphaValues = [];\n    const anglesUnitValues = Object.values(AnglesUnitEnum);\n    const colorUnitValues = Object.values(ColorUnitEnum);\n    const cmykFunctionValues = Object.values(CMYKFunctionEnum);\n    const matchOptions = {\n        legacyCSS: 0,\n        spacesAfterCommas: 0,\n        cmykFunction: 0\n    };\n    for (const color of colors) {\n        if (typeof color === \'string\') {\n            cssColors.push(color);\n            if (color.includes(\',\')) {\n                matchOptions.legacyCSS++;\n                const commasWithNextCharacter = color.match(COMMAS_AND_NEXT_CHARS);\n                if (new Set(commasWithNextCharacter).size === 1 &&\n                    SPACES.test(commasWithNextCharacter[0].slice(1))) {\n                    matchOptions.spacesAfterCommas++;\n                }\n            }\n            if (color.match(COLORREGS.HSL)) {\n                const match = color.match(COLORREGS.HSL);\n                const angle = match[1] || match[5];\n                const alpha = match[8];\n                const angleUnit = angle.match(HSL_HUE)[2];\n                hslColors.push(angleUnit === \'\'\n                    ? AnglesUnitEnum.NONE\n                    : angleUnit);\n                alphaValues.push(PCENT.test(alpha));\n                continue;\n            }\n            if (COLORREGS.RGB.test(color)) {\n                const match = color.match(COLORREGS.RGB);\n                const R = match[1] || match[5];\n                const G = match[2] || match[6];\n                const B = match[3] || match[7];\n                const A = match[8];\n                rgbColors.push(PCENT.test(R) &&\n                    PCENT.test(G) &&\n                    PCENT.test(B));\n                alphaValues.push(PCENT.test(A));\n                continue;\n            }\n            if (COLORREGS.CIELab.test(color)) {\n                const match = color.match(COLORREGS.CIELab);\n                const L = match[1];\n                const a = match[2];\n                const b = match[3];\n                const A = match[4];\n                labColors.push(PCENT.test(L) &&\n                    PCENT.test(a) &&\n                    PCENT.test(b));\n                alphaValues.push(PCENT.test(A));\n                continue;\n            }\n            if (color.match(COLORREGS.CMYK)) {\n                const match = color.match(COLORREGS.CMYK);\n                const C = match[1] || match[6];\n                const M = match[2] || match[7];\n                const Y = match[3] || match[8];\n                const K = match[4] || match[9];\n                const A = match[10];\n                cmykColors.push(PCENT.test(C) &&\n                    PCENT.test(M) &&\n                    PCENT.test(Y) &&\n                    PCENT.test(K));\n                if (color.startsWith(\'cmyk\')) {\n                    matchOptions.cmykFunction++;\n                }\n                alphaValues.push(PCENT.test(A));\n            }\n        }\n    }\n    return {\n        decimals: typeof options.decimals === TypeOf.NUMBER\n            ? options.decimals\n            : DEFAULT_OPTIONS.decimals,\n        legacyCSS: typeof options.legacyCSS === TypeOf.BOOLEAN\n            ? options.legacyCSS\n            : Boolean(cssColors.length &&\n                matchOptions.legacyCSS === cssColors.length) || DEFAULT_OPTIONS.legacyCSS,\n        spacesAfterCommas: typeof options.spacesAfterCommas === TypeOf.BOOLEAN\n            ? options.spacesAfterCommas\n            : Boolean(cssColors.length &&\n                matchOptions.spacesAfterCommas === cssColors.length) || DEFAULT_OPTIONS.spacesAfterCommas,\n        anglesUnit: options.anglesUnit && anglesUnitValues.includes(options.anglesUnit)\n            ? options.anglesUnit\n            : (new Set(hslColors).size === 1\n                ? hslColors[0]\n                : DEFAULT_OPTIONS.anglesUnit),\n        rgbUnit: options.rgbUnit && colorUnitValues.includes(options.rgbUnit)\n            ? options.rgbUnit\n            : (new Set(rgbColors).size === 1 && rgbColors[0]\n                ? ColorUnitEnum.PERCENT\n                : DEFAULT_OPTIONS.rgbUnit),\n        labUnit: options.labUnit && colorUnitValues.includes(options.labUnit)\n            ? options.labUnit\n            : (new Set(labColors).size === 1 && labColors[0]\n                ? ColorUnitEnum.PERCENT\n                : DEFAULT_OPTIONS.labUnit),\n        cmykUnit: options.cmykUnit && colorUnitValues.includes(options.cmykUnit)\n            ? options.cmykUnit\n            : (new Set(cmykColors).size === 1 && !cmykColors[0]\n                ? ColorUnitEnum.NONE\n                : DEFAULT_OPTIONS.cmykUnit),\n        alphaUnit: options.alphaUnit && colorUnitValues.includes(options.alphaUnit)\n            ? options.alphaUnit\n            : (new Set(alphaValues).size === 1 && alphaValues[0]\n                ? ColorUnitEnum.PERCENT\n                : DEFAULT_OPTIONS.alphaUnit),\n        cmykFunction: options.cmykFunction && cmykFunctionValues.includes(options.cmykFunction)\n            ? options.cmykFunction\n            : (cmykColors.length && cmykColors.length === matchOptions.cmykFunction\n                ? CMYKFunctionEnum.CMYK\n                : DEFAULT_OPTIONS.cmykFunction)\n    };\n};\nconst isHarmony = (param) => {\n    return `${param}` in Harmony;\n};\nconst isMix = (param) => {\n    return `${param}` in Mix;\n};\n\n;// CONCATENATED MODULE: ./src/color/translators.ts\n\nconst MATRIX_LRGB_XYZ_D50 = [\n    [0.4360747, 0.3850649, 0.1430804],\n    [0.2225045, 0.7168786, 0.0606169],\n    [0.0139322, 0.0971045, 0.7141733]\n];\nconst MATRIX_XYZ_D50_LRGB = [\n    [3.1338561, -1.6168667, -0.4906146],\n    [-0.9787684, 1.9161415, 0.033454],\n    [0.0719453, -0.2289914, 1.4052427]\n];\nconst TRISTIMULUS_D50 = MATRIX_LRGB_XYZ_D50.map((matrix) => {\n    return matrix.reduce((sum, value) => sum + value, 0);\n});\nconst hueToRGB = (t1, t2, hue) => {\n    if (hue < 0) {\n        hue += 6;\n    }\n    if (hue >= 6) {\n        hue -= 6;\n    }\n    if (hue < 1) {\n        return round(((t2 - t1) * hue + t1) * 255);\n    }\n    else if (hue < 3) {\n        return round(t2 * 255);\n    }\n    else if (hue < 4) {\n        return round(((t2 - t1) * (4 - hue) + t1) * 255);\n    }\n    else {\n        return round(t1 * 255);\n    }\n};\nconst rgbToLinearLightRGB = (value) => {\n    return value <= 0.04045\n        ? value / 12.92\n        : ((value + 0.055) / 1.055) ** 2.4;\n};\nconst linearLightRGBToRGB = (value) => {\n    return value <= 0.0031308\n        ? 12.92 * value\n        : 1.055 * (value ** (1 / 2.4)) - 0.055;\n};\nconst matrixVectorMultiplication = (v1, v2, v3, matrix) => {\n    const result = [0, 0, 0];\n    const linearRGB = [v1, v2, v3];\n    matrix.forEach((array, index) => {\n        array.forEach((value, mindex) => {\n            result[index] += value * linearRGB[mindex];\n        });\n    });\n    return result;\n};\nconst from_CIE_XYZ_D50_to_CIE_LAB = (x, y, z) => {\n    const f = (t) => {\n        return t > (6 / 29) ** 3\n            ? Math.cbrt(t)\n            : t / (3 * (6 / 29) ** 2) + (4 / 29);\n    };\n    const fx = f(x / TRISTIMULUS_D50[0]);\n    const fy = f(y / TRISTIMULUS_D50[1]);\n    const fz = f(z / TRISTIMULUS_D50[2]);\n    return [\n        116 * fy - 16,\n        500 * (fx - fy),\n        200 * (fy - fz)\n    ];\n};\nconst from_CIE_LAB_to_CIE_XYZ_D50 = (L, a, b) => {\n    const f = (t) => {\n        return t > 6 / 29\n            ? t ** 3\n            : 3 * (6 / 29) ** 2 * (t - 4 / 29);\n    };\n    const fl = (L + 16) / 116;\n    const fa = a / 500;\n    const fb = b / 200;\n    return [\n        TRISTIMULUS_D50[0] * f(fl + fa),\n        TRISTIMULUS_D50[1] * f(fl),\n        TRISTIMULUS_D50[2] * f(fl - fb)\n    ];\n};\nconst hslToRGB = (H, S, L) => {\n    H /= 60;\n    S /= 100;\n    L /= 100;\n    const t2 = (L <= .5)\n        ? L * (S + 1)\n        : L + S - (L * S);\n    const t1 = L * 2 - t2;\n    const R = hueToRGB(t1, t2, H + 2);\n    const G = hueToRGB(t1, t2, H);\n    const B = hueToRGB(t1, t2, H - 2);\n    return { R, G, B };\n};\nconst rgbToHSL = (R, G, B, A = 1) => {\n    R /= 255;\n    G /= 255;\n    B /= 255;\n    A = Math.min(A, 1);\n    const MAX = Math.max(R, G, B);\n    const MIN = Math.min(R, G, B);\n    const D = MAX - MIN;\n    let H = 0;\n    let S = 0;\n    const L = (MAX + MIN) / 2;\n    if (D !== 0) {\n        switch (MAX) {\n            case R:\n                H = ((G - B) / D) % 6;\n                break;\n            case G:\n                H = (B - R) / D + 2;\n                break;\n            case B:\n                H = (R - G) / D + 4;\n                break;\n        }\n        H = round(H * 60);\n        if (H < 0) {\n            H += 360;\n        }\n        S = D / (1 - Math.abs(2 * L - 1));\n    }\n    return {\n        H,\n        S: round(S * 100),\n        L: round(L * 100),\n        A\n    };\n};\nconst rgbToLab = (R, G, B) => {\n    const LINEAR_LIGHT_RGB = [\n        R / 255,\n        G / 255,\n        B / 255\n    ].map(rgbToLinearLightRGB);\n    const CIE_XYZ_D50 = matrixVectorMultiplication(LINEAR_LIGHT_RGB[0], LINEAR_LIGHT_RGB[1], LINEAR_LIGHT_RGB[2], MATRIX_LRGB_XYZ_D50);\n    const CIE_LAB = from_CIE_XYZ_D50_to_CIE_LAB(CIE_XYZ_D50[0], CIE_XYZ_D50[1], CIE_XYZ_D50[2]);\n    return {\n        L: CIE_LAB[0],\n        a: CIE_LAB[1],\n        b: CIE_LAB[2]\n    };\n};\nconst labToRgb = (L, a, b) => {\n    const CIE_XYZ_D50 = from_CIE_LAB_to_CIE_XYZ_D50(L, a, b);\n    const LINEAR_LIGHT_RGB = matrixVectorMultiplication(CIE_XYZ_D50[0], CIE_XYZ_D50[1], CIE_XYZ_D50[2], MATRIX_XYZ_D50_LRGB);\n    const RGB = LINEAR_LIGHT_RGB.map(linearLightRGBToRGB);\n    return {\n        R: minmax(RGB[0] * 255, 0, 255),\n        G: minmax(RGB[1] * 255, 0, 255),\n        B: minmax(RGB[2] * 255, 0, 255)\n    };\n};\nconst cmykToRGB = (C, M, Y, K) => {\n    K = 1 - K;\n    const R = round(255 * (1 - C) * K);\n    const G = round(255 * (1 - M) * K);\n    const B = round(255 * (1 - Y) * K);\n    return { R, G, B };\n};\nconst rgbToCMYK = (R, G, B) => {\n    R /= 255;\n    G /= 255;\n    B /= 255;\n    const K = 1 - Math.max(R, G, B);\n    const K1 = 1 - K;\n    const C = K1 && (K1 - R) / K1;\n    const M = K1 && (K1 - G) / K1;\n    const Y = K1 && (K1 - B) / K1;\n    return {\n        C: round(C * 100),\n        M: round(M * 100),\n        Y: round(Y * 100),\n        K: round(K * 100)\n    };\n};\nconst rgbToRYB = (R, G, B) => {\n    const Iw = Math.min(R, G, B);\n    const Ib = Math.min(255 - R, 255 - G, 255 - B);\n    const rRGB = R - Iw;\n    const gRGB = G - Iw;\n    const bRGB = B - Iw;\n    const minRG = Math.min(rRGB, gRGB);\n    const rRYB = rRGB - minRG;\n    const yRYB = (gRGB + minRG) / 2;\n    const bRYB = (bRGB + gRGB - minRG) / 2;\n    const n = Math.max(rRYB, yRYB, bRYB) / Math.max(rRGB, gRGB, bRGB);\n    const N = isNaN(n) || n === Infinity || n <= 0 ? 1 : n;\n    return {\n        R: rRYB / N + Ib,\n        Y: yRYB / N + Ib,\n        B: bRYB / N + Ib\n    };\n};\nconst rybToRGB = (R, Y, B) => {\n    const Iw = Math.min(R, Y, B);\n    const Ib = Math.min(255 - R, 255 - Y, 255 - B);\n    const rRYB = R - Iw;\n    const yRYB = Y - Iw;\n    const bRYB = B - Iw;\n    const minYB = Math.min(yRYB, bRYB);\n    const rRGB = rRYB + yRYB - minYB;\n    const gRGB = yRYB + minYB;\n    const bRGB = 2 * (bRYB - minYB);\n    const n = Math.max(rRGB, gRGB, bRGB) / Math.max(rRYB, yRYB, bRYB);\n    const N = isNaN(n) || n === Infinity || n <= 0 ? 1 : n;\n    return {\n        R: rRGB / N + Ib,\n        G: gRGB / N + Ib,\n        B: bRGB / N + Ib\n    };\n};\nconst hueRYB = (hue, toRYB) => {\n    if (hue < 0)\n        hue += 360;\n    if (hue > 360)\n        hue -= 360;\n    if (hue === 360 || hue === 0)\n        return hue;\n    const map1 = [\n        [0, 120],\n        [120, 180],\n        [180, 240],\n        [240, 360]\n    ];\n    const map2 = [\n        [0, 60],\n        [60, 120],\n        [120, 240],\n        [240, 360]\n    ];\n    const from = toRYB ? map1 : map2;\n    const to = toRYB ? map2 : map1;\n    let A = 0;\n    let B = 0;\n    let C = 0;\n    let D = 0;\n    from.find((arr, index) => {\n        if (hue >= arr[0] && hue < arr[1]) {\n            A = arr[0];\n            B = arr[1];\n            C = to[index][0];\n            D = to[index][1];\n            return true;\n        }\n        return false;\n    });\n    return C + (hue - A) * ((D - C) / (B - A));\n};\n\n;// CONCATENATED MODULE: ./src/color/css.ts\n\n\n\nconst getComma = (withSpace) => withSpace\n    ? \', \'\n    : \',\';\nconst prepareColorForCss = (color, transformer) => {\n    const props = getOrderedArrayString(Object.keys(color));\n    const model = VALID_COLOR_OBJECTS[props];\n    const keys = COLOR_PROPS[model];\n    return keys.reduce((result, key, index) => {\n        const value = color[key];\n        if (typeof value !== \'undefined\') {\n            result.push(transformer(value, index));\n        }\n        return result;\n    }, []);\n};\nconst getResultFromTemplate = (template, vars) => {\n    return template.replace(TEMPLATE_VAR, (__match, indexStr) => {\n        const index = +indexStr - 1;\n        return `${vars[index]}`;\n    });\n};\nconst getAlpha = (value, options, ignoreLegacy = false) => {\n    const { alphaUnit, legacyCSS, decimals } = options;\n    if (alphaUnit === ColorUnitEnum.PERCENT &&\n        (!legacyCSS ||\n            ignoreLegacy)) {\n        return `${round(value * 100, decimals)}%`;\n    }\n    return round(value, decimals);\n};\nconst CSS = {\n    [ColorModel.HEX]: (color) => {\n        const transformer = (value) => toHEX(round(value));\n        const values = prepareColorForCss(color, transformer);\n        const template = values.length === 4\n            ? \'#{1}{2}{3}{4}\'\n            : \'#{1}{2}{3}\';\n        return getResultFromTemplate(template, values);\n    },\n    [ColorModel.RGB]: (color, options) => {\n        const { decimals, legacyCSS, spacesAfterCommas, rgbUnit } = options;\n        const comma = getComma(spacesAfterCommas);\n        const transformer = (value, index) => {\n            return rgbUnit === ColorUnitEnum.PERCENT && index < 3\n                ? `${from255NumberToPercent(value, decimals)}%`\n                : (index === 3\n                    ? getAlpha(value, options)\n                    : round(value, decimals));\n        };\n        const values = prepareColorForCss(color, transformer);\n        const template = legacyCSS\n            ? (values.length === 4\n                ? `rgba({1}${comma}{2}${comma}{3}${comma}{4})`\n                : `rgb({1}${comma}{2}${comma}{3})`)\n            : (values.length === 4\n                ? `rgb({1} {2} {3} / {4})`\n                : `rgb({1} {2} {3})`);\n        return getResultFromTemplate(template, values);\n    },\n    [ColorModel.HSL]: (color, options) => {\n        const { decimals, legacyCSS, spacesAfterCommas, anglesUnit } = options;\n        const comma = getComma(spacesAfterCommas);\n        const transformer = (value, index) => {\n            if (index === 0 &&\n                anglesUnit !== AnglesUnitEnum.NONE) {\n                const translated = round(translateDegrees(value, anglesUnit), decimals);\n                return `${translated}${anglesUnit}`;\n            }\n            return index === 3\n                ? getAlpha(value, options)\n                : round(value, decimals);\n        };\n        const values = prepareColorForCss(color, transformer);\n        const template = legacyCSS\n            ? (values.length === 4\n                ? `hsla({1}${comma}{2}%${comma}{3}%${comma}{4})`\n                : `hsl({1}${comma}{2}%${comma}{3}%)`)\n            : (values.length === 4\n                ? `hsl({1} {2}% {3}% / {4})`\n                : `hsl({1} {2}% {3}%)`);\n        return getResultFromTemplate(template, values);\n    },\n    [ColorModel.CIELab]: (color, options) => {\n        const { decimals, labUnit } = options;\n        const transformer = (value, index) => {\n            if (index === 0) {\n                const L = round(percent(value), decimals);\n                return labUnit === ColorUnitEnum.PERCENT\n                    ? `${L}%`\n                    : `${L}`;\n            }\n            if (index < 3) {\n                return labUnit === ColorUnitEnum.PERCENT\n                    ? `${from125NumberToPercent(value, decimals)}%`\n                    : round(value, decimals);\n            }\n            return getAlpha(value, options, true);\n        };\n        const values = prepareColorForCss(color, transformer);\n        const template = values.length === 4\n            ? `lab({1} {2} {3} / {4})`\n            : `lab({1} {2} {3})`;\n        return getResultFromTemplate(template, values);\n    },\n    [ColorModel.CMYK]: (color, options) => {\n        const { decimals, legacyCSS, spacesAfterCommas, cmykUnit, cmykFunction } = options;\n        const comma = getComma(spacesAfterCommas);\n        const transformer = (value, index) => {\n            if (cmykUnit === ColorUnitEnum.PERCENT &&\n                index < 4) {\n                return `${round(value, decimals)}%`;\n            }\n            return index === 4\n                ? getAlpha(value, options)\n                : round(value / 100, decimals);\n        };\n        const values = prepareColorForCss(color, transformer);\n        const template = legacyCSS\n            ? (values.length === 5\n                ? `${cmykFunction}({1}${comma}{2}${comma}{3}${comma}{4}${comma}{5})`\n                : `${cmykFunction}({1}${comma}{2}${comma}{3}${comma}{4})`)\n            : (values.length === 5\n                ? `${cmykFunction}({1} {2} {3} {4} / {5})`\n                : `${cmykFunction}({1} {2} {3} {4})`);\n        return getResultFromTemplate(template, values);\n    }\n};\n\n;// CONCATENATED MODULE: ./src/color/utils.ts\n\n\n\n\nconst normalizeAlpha = (alpha) => {\n    if (typeof alpha === \'string\') {\n        if (PCENT.test(alpha)) {\n            alpha = percentNumber(alpha) / 100;\n        }\n        else {\n            alpha = +alpha;\n        }\n    }\n    return (isNaN(+alpha) || alpha > 1) ? 1 : round(alpha);\n};\nconst harmony = (color, angles, mode) => angles.reduce((arr, num) => ([\n    ...arr,\n    {\n        ...color,\n        H: mode === Mix.ADDITIVE\n            ? normalizeHue(color.H + num)\n            : normalizeHue(hueRYB(hueRYB(color.H, false) + num, true))\n    }\n]), [{ ...color }]);\nconst analogous = (color, mode) => harmony(color, [30, -30], mode);\nconst complementary = (color, mode) => harmony(color, [180], mode);\nconst splitComplementary = (color, mode) => harmony(color, [150, -150], mode);\nconst triadic = (color, mode) => harmony(color, [120, -120], mode);\nconst tetradic = (color, mode) => harmony(color, [60, -120, 180], mode);\nconst square = (color, mode) => harmony(color, [90, -90, 180], mode);\nconst getColorModelFromString = (color) => {\n    let model;\n    Object.keys(ColorModel).some((p) => {\n        const reg = COLORREGS[p];\n        if (reg.test(color)) {\n            model = p;\n            return true;\n        }\n    });\n    if (!model &&\n        !!~COLOR_KEYS.indexOf(color)) {\n        model = ColorModel.HEX;\n    }\n    if (!model) {\n        throw new Error(ERRORS.NOT_ACCEPTED_STRING_INPUT);\n    }\n    return model;\n};\nconst getColorModelFromObject = (color) => {\n    let model;\n    let invalid = false;\n    const props = getOrderedArrayString(Object.keys(color));\n    if (VALID_COLOR_OBJECTS[props]) {\n        model = VALID_COLOR_OBJECTS[props];\n    }\n    if (model && model === ColorModel.RGB) {\n        const hasInvalidHex = Object.entries(color).some((item) => {\n            return !HEX.test(`${item[1]}`);\n        });\n        const hasInvalidRegb = Object.entries(color).some((item) => {\n            return !(PCENT.test(`${item[1]}`) ||\n                (!HEX.test(`${item[1]}`) &&\n                    !isNaN(+item[1]) &&\n                    +item[1] <= 255));\n        });\n        if (hasInvalidHex && hasInvalidRegb) {\n            invalid = true;\n        }\n        if (!hasInvalidHex) {\n            model = ColorModel.HEX;\n        }\n    }\n    if (!model || invalid) {\n        throw new Error(ERRORS.NOT_ACCEPTED_OBJECT_INPUT);\n    }\n    return model;\n};\nconst getColorModel = (color) => typeof color === \'string\'\n    ? getColorModelFromString(color)\n    : getColorModelFromObject(color);\nconst getRGBObjectFromString = {\n    [ColorModel.HEX](color) {\n        const colorStr = !~COLOR_KEYS.indexOf(color)\n            ? color\n            : ColorKeywords[color];\n        const match = colorStr.match(COLORREGS.HEX);\n        const object = {\n            R: getDEC(match[1] || match[5]),\n            G: getDEC(match[2] || match[6]),\n            B: getDEC(match[3] || match[7])\n        };\n        const A = match[4] || match[8];\n        if (A !== undefined) {\n            object.A = getDEC(A) / 255;\n        }\n        return object;\n    },\n    [ColorModel.RGB](color) {\n        const match = color.match(COLORREGS.RGB);\n        const R = getBase255Number(match[1] || match[5]);\n        const G = getBase255Number(match[2] || match[6]);\n        const B = getBase255Number(match[3] || match[7]);\n        const A = match[4] || match[8];\n        const object = {\n            R: Math.min(R, 255),\n            G: Math.min(G, 255),\n            B: Math.min(B, 255)\n        };\n        if (A !== undefined) {\n            object.A = normalizeAlpha(A);\n        }\n        return object;\n    },\n    [ColorModel.HSL](color) {\n        const match = color.match(COLORREGS.HSL);\n        const H = normalizeHue(match[1] || match[5]);\n        const S = percent(match[2] || match[6]);\n        const L = percent(match[3] || match[7]);\n        const A = match[4] || match[8];\n        const RGB = hslToRGB(H, S, L);\n        if (A !== undefined) {\n            RGB.A = normalizeAlpha(A);\n        }\n        return RGB;\n    },\n    [ColorModel.CIELab](color) {\n        const match = color.match(COLORREGS.CIELab);\n        const L = percent(match[1]);\n        const a = getBase125Number(match[2]);\n        const b = getBase125Number(match[3]);\n        const A = match[4];\n        const RGB = labToRgb(L, a, b);\n        if (A !== undefined) {\n            RGB.A = normalizeAlpha(A);\n        }\n        return RGB;\n    },\n    [ColorModel.CMYK](color) {\n        const match = color.match(COLORREGS.CMYK);\n        const C = getCMYKNumber(match[1] || match[6]);\n        const M = getCMYKNumber(match[2] || match[7]);\n        const Y = getCMYKNumber(match[3] || match[8]);\n        const K = getCMYKNumber(match[4] || match[9]);\n        const A = match[5] || match[10];\n        const RGB = cmykToRGB(C, M, Y, K);\n        if (A !== undefined) {\n            RGB.A = normalizeAlpha(A);\n        }\n        return RGB;\n    }\n};\nconst getRGBObjectFromObject = {\n    [ColorModel.HEX](color) {\n        const object = {\n            R: getBase255Number(`${color.R}`),\n            G: getBase255Number(`${color.G}`),\n            B: getBase255Number(`${color.B}`)\n        };\n        if (hasProp(color, \'A\')) {\n            object.A = Math.min(getBase255Number(`${color.A}`, true), 1);\n        }\n        return object;\n    },\n    [ColorModel.RGB](color) {\n        return this.HEX(color);\n    },\n    [ColorModel.HSL](color) {\n        const S = percent(`${color.S}`);\n        const L = percent(`${color.L}`);\n        const RGB = hslToRGB(normalizeHue(color.H), S, L);\n        if (hasProp(color, \'A\')) {\n            RGB.A = normalizeAlpha(color.A);\n        }\n        return RGB;\n    },\n    [ColorModel.CIELab](color) {\n        const L = percent(`${color.L}`);\n        const a = getBase125Number(`${color.a}`);\n        const b = getBase125Number(`${color.b}`);\n        const RGB = labToRgb(L, a, b);\n        if (hasProp(color, \'A\')) {\n            RGB.A = normalizeAlpha(color.A);\n        }\n        return RGB;\n    },\n    [ColorModel.CMYK](color) {\n        const C = getCMYKNumber(`${color.C}`);\n        const M = getCMYKNumber(`${color.M}`);\n        const Y = getCMYKNumber(`${color.Y}`);\n        const K = getCMYKNumber(`${color.K}`);\n        const RGB = cmykToRGB(C, M, Y, K);\n        if (hasProp(color, \'A\')) {\n            RGB.A = normalizeAlpha(color.A);\n        }\n        return RGB;\n    }\n};\nconst getRGBObject = (color, model = getColorModel(color)) => {\n    return typeof color === \'string\'\n        ? getRGBObjectFromString[model](color)\n        : getRGBObjectFromObject[model](color);\n};\nconst translateColor = {\n    [ColorModel.HEX](color) {\n        return {\n            R: getHEX(color.R),\n            G: getHEX(color.G),\n            B: getHEX(color.B)\n        };\n    },\n    HEXA(color) {\n        const RGB = translateColor.HEX(color);\n        RGB.A = hasProp(color, \'A\')\n            ? getHEX(color.A * 255)\n            : \'0xFF\';\n        return RGB;\n    },\n    [ColorModel.RGB](color, decimals) {\n        const RGB = roundRGBObject(color, decimals);\n        if (hasProp(RGB, \'A\')) {\n            delete RGB.A;\n        }\n        return RGB;\n    },\n    RGBA(color, decimals) {\n        const RGB = translateColor.RGB(color, decimals);\n        RGB.A = hasProp(color, \'A\')\n            ? round(color.A)\n            : 1;\n        return RGB;\n    },\n    [ColorModel.HSL](color, decimals) {\n        const HSL = rgbToHSL(color.R, color.G, color.B);\n        delete HSL.A;\n        return roundHSLObject(HSL, decimals);\n    },\n    HSLA(color, decimals) {\n        const HSL = translateColor.HSL(color, decimals);\n        HSL.A = hasProp(color, \'A\')\n            ? round(color.A, decimals)\n            : 1;\n        return HSL;\n    },\n    [ColorModel.CIELab](color, decimals) {\n        const Lab = rgbToLab(color.R, color.G, color.B);\n        return roundCIELabObject(Lab, decimals);\n    },\n    CIELabA(color, decimals) {\n        const Lab = translateColor.CIELab(color, decimals);\n        Lab.A = hasProp(color, \'A\')\n            ? round(color.A, decimals)\n            : 1;\n        return Lab;\n    },\n    [ColorModel.CMYK](color, decimals) {\n        return roundCMYKObject(rgbToCMYK(color.R, color.G, color.B), decimals);\n    },\n    CMYKA(color, decimals) {\n        const CMYK = translateColor.CMYK(color, decimals);\n        CMYK.A = hasProp(color, \'A\')\n            ? round(color.A, decimals)\n            : 1;\n        return CMYK;\n    }\n};\nconst blend = (from, to, steps) => {\n    const div = steps - 1;\n    const diffR = (to.R - from.R) / div;\n    const diffG = (to.G - from.G) / div;\n    const diffB = (to.B - from.B) / div;\n    const fromA = normalizeAlpha(from.A);\n    const toA = normalizeAlpha(to.A);\n    const diffA = (toA - fromA) / div;\n    return Array(steps).fill(null).map((__n, i) => {\n        if (i === 0) {\n            return from;\n        }\n        if (i === div) {\n            return to;\n        }\n        return {\n            R: round(from.R + diffR * i),\n            G: round(from.G + diffG * i),\n            B: round(from.B + diffB * i),\n            A: round(fromA + diffA * i)\n        };\n    });\n};\nconst getColorMixture = (color, steps, shades, options) => {\n    const model = getColorModel(color);\n    const isCSS = typeof color === \'string\';\n    const RGB = getRGBObject(color, model);\n    const hasAlpha = ((typeof color === \'string\' && hasProp(RGB, \'A\')) ||\n        (typeof color !== \'string\' && hasProp(color, \'A\')));\n    const HSL = rgbToHSL(RGB.R, RGB.G, RGB.B, RGB.A);\n    if (!hasAlpha)\n        delete HSL.A;\n    const increment = shades\n        ? HSL.L / (steps + 1)\n        : (100 - HSL.L) / (steps + 1);\n    const hslMap = Array(steps).fill(null).map((__n, i) => ({\n        ...HSL,\n        L: HSL.L + increment * (i + 1) * (1 - +shades * 2)\n    }));\n    switch (model) {\n        case ColorModel.HEX:\n        default:\n            return hslMap.map((HSLColor) => {\n                const RGBColor = hslToRGB(HSLColor.H, HSLColor.S, HSLColor.L);\n                if (hasAlpha)\n                    RGBColor.A = HSLColor.A;\n                return isCSS\n                    ? hasAlpha\n                        ? CSS.HEX({\n                            ...RGBColor,\n                            A: round(RGBColor.A * 255)\n                        })\n                        : CSS.HEX(RGBColor)\n                    : hasAlpha\n                        ? translateColor.HEXA(RGBColor)\n                        : translateColor.HEX(RGBColor);\n            });\n        case ColorModel.RGB:\n            return hslMap.map((HSLColor) => {\n                const RGBColor = hslToRGB(HSLColor.H, HSLColor.S, HSLColor.L);\n                if (hasAlpha)\n                    RGBColor.A = HSLColor.A;\n                return isCSS\n                    ? CSS.RGB(RGBColor, options)\n                    : hasAlpha\n                        ? translateColor.RGBA(RGBColor, options.decimals)\n                        : translateColor.RGB(RGBColor, options.decimals);\n            });\n        case ColorModel.HSL:\n            return hslMap.map((HSLColor) => {\n                return isCSS\n                    ? CSS.HSL(HSLColor, options)\n                    : hasAlpha\n                        ? translateColor.HSLA({\n                            ...hslToRGB(HSLColor.H, HSLColor.S, HSLColor.L),\n                            A: HSLColor.A\n                        }, options.decimals)\n                        : translateColor.HSL(hslToRGB(HSLColor.H, HSLColor.S, HSLColor.L), options.decimals);\n            });\n        case ColorModel.CIELab:\n            return hslMap.map((HSLColor) => {\n                const RGBColor = hslToRGB(HSLColor.H, HSLColor.S, HSLColor.L);\n                return isCSS\n                    ? CSS.CIELab(hasAlpha\n                        ? translateColor.CIELabA(RGBColor, options.decimals)\n                        : translateColor.CIELab(RGBColor, options.decimals), options)\n                    : hasAlpha\n                        ? translateColor.CIELabA({\n                            ...RGBColor,\n                            A: HSLColor.A\n                        }, options.decimals)\n                        : translateColor.CIELab(RGBColor, options.decimals);\n            });\n    }\n};\nconst colorHarmony = {\n    buildHarmony(color, harmonyFunction, mode, options) {\n        const model = getColorModel(color);\n        const RGB = getRGBObject(color, model);\n        const HSL = rgbToHSL(RGB.R, RGB.G, RGB.B, RGB.A);\n        const hasAlpha = ((typeof color === \'string\' && hasProp(RGB, \'A\')) ||\n            (typeof color !== \'string\' && hasProp(color, \'A\')));\n        const isCSS = typeof color === \'string\';\n        switch (model) {\n            case ColorModel.HEX:\n            default:\n                return hasAlpha\n                    ? this.HEXA(roundHSLObject(HSL, 0), harmonyFunction, mode, isCSS)\n                    : this.HEX(roundHSLObject(HSL, 0), harmonyFunction, mode, isCSS);\n            case ColorModel.HSL:\n                return hasAlpha\n                    ? this.HSLA(HSL, harmonyFunction, mode, isCSS, options)\n                    : this.HSL(HSL, harmonyFunction, mode, isCSS, options);\n            case ColorModel.RGB:\n                return hasAlpha\n                    ? this.RGBA(HSL, harmonyFunction, mode, isCSS, options)\n                    : this.RGB(HSL, harmonyFunction, mode, isCSS, options);\n            case ColorModel.CIELab:\n                return hasAlpha\n                    ? this.CIELabA(HSL, harmonyFunction, mode, isCSS, options)\n                    : this.CIELab(HSL, harmonyFunction, mode, isCSS, options);\n        }\n    },\n    [ColorModel.HEX](color, harmonyFunction, mode, css) {\n        const array = harmonyFunction(color, mode);\n        return array.map((c) => (css\n            ? CSS.HEX(hslToRGB(c.H, c.S, c.L))\n            : translateColor.HEX(hslToRGB(c.H, c.S, c.L))));\n    },\n    HEXA(color, harmonyFunction, mode, css) {\n        const array = harmonyFunction(color, mode);\n        return array.map((c) => (css\n            ? CSS.HEX({\n                ...hslToRGB(c.H, c.S, c.L),\n                A: normalizeAlpha(c.A) * 255\n            })\n            : translateColor.HEXA({\n                ...hslToRGB(c.H, c.S, c.L),\n                A: normalizeAlpha(c.A)\n            })));\n    },\n    [ColorModel.RGB](color, harmonyFunction, mode, css, options) {\n        const array = harmonyFunction(color, mode);\n        return array.map((c) => (css\n            ? CSS.RGB(hslToRGB(c.H, c.S, c.L), options)\n            : translateColor.RGB(hslToRGB(c.H, c.S, c.L), options.decimals)));\n    },\n    RGBA(color, harmonyFunction, mode, css, options) {\n        const array = harmonyFunction(color, mode);\n        return array.map((c) => (css\n            ? CSS.RGB({\n                ...hslToRGB(c.H, c.S, c.L),\n                A: normalizeAlpha(c.A)\n            }, options)\n            : translateColor.RGBA({\n                ...hslToRGB(c.H, c.S, c.L),\n                A: normalizeAlpha(c.A)\n            }, options.decimals)));\n    },\n    [ColorModel.HSL](color, harmonyFunction, mode, css, options) {\n        const array = harmonyFunction(color, mode);\n        return array.map((c) => (css\n            ? CSS.HSL({\n                H: c.H,\n                S: c.S,\n                L: c.L\n            }, options)\n            : translateColor.HSL(hslToRGB(c.H, c.S, c.L), options.decimals)));\n    },\n    HSLA(color, harmonyFunction, mode, css, options) {\n        const array = harmonyFunction(color, mode);\n        return array.map((c) => (css\n            ? CSS.HSL({\n                ...c,\n                A: normalizeAlpha(c.A)\n            }, options)\n            : translateColor.HSLA({\n                ...hslToRGB(c.H, c.S, c.L),\n                A: normalizeAlpha(c.A)\n            }, options.decimals)));\n    },\n    [ColorModel.CIELab](color, harmonyFunction, mode, css, options) {\n        const array = harmonyFunction(color, mode);\n        return array.map((c) => {\n            const RGB = hslToRGB(c.H, c.S, c.L);\n            return (css\n                ? CSS.CIELab(rgbToLab(RGB.R, RGB.G, RGB.B), options)\n                : translateColor.CIELab(RGB, options.decimals));\n        });\n    },\n    CIELabA(color, harmonyFunction, mode, css, options) {\n        const array = harmonyFunction(color, mode);\n        return array.map((c) => {\n            const RGB = hslToRGB(c.H, c.S, c.L);\n            return (css\n                ? CSS.CIELab({\n                    ...rgbToLab(RGB.R, RGB.G, RGB.B),\n                    A: normalizeAlpha(c.A)\n                }, options)\n                : translateColor.CIELabA({\n                    ...RGB,\n                    A: normalizeAlpha(c.A)\n                }, options.decimals));\n        });\n    }\n};\nconst colorMixer = {\n    mix(colors, mode) {\n        const rgbMap = colors.map((color) => {\n            const model = getColorModel(color);\n            return getRGBObject(color, model);\n        });\n        const rybMap = mode === Mix.SUBTRACTIVE\n            ? rgbMap.map((color) => {\n                const RYB = rgbToRYB(color.R, color.G, color.B);\n                if (hasProp(color, \'A\')) {\n                    RYB.A = color.A;\n                }\n                return RYB;\n            })\n            : null;\n        function createMix(items) {\n            const initial = mode === Mix.ADDITIVE\n                ? { R: 0, G: 0, B: 0, A: 0 }\n                : { R: 0, Y: 0, B: 0, A: 0 };\n            return items.reduce((mix, color) => {\n                const colorA = hasProp(color, \'A\') ? color.A : 1;\n                const common = {\n                    R: Math.min(mix.R + color.R * colorA, 255),\n                    B: Math.min(mix.B + color.B * colorA, 255),\n                    A: 1 - (1 - colorA) * (1 - mix.A)\n                };\n                const mixGY = \'G\' in mix\n                    ? mix.G\n                    : mix.Y;\n                const colorGY = \'G\' in color\n                    ? color.G\n                    : color.Y;\n                return {\n                    ...common,\n                    ...(mode === Mix.ADDITIVE\n                        ? { G: Math.min(mixGY + colorGY * colorA, 255) }\n                        : { Y: Math.min(mixGY + colorGY * colorA, 255) })\n                };\n            }, initial);\n        }\n        let mix;\n        if (mode === Mix.ADDITIVE) {\n            mix = createMix(rgbMap);\n        }\n        else {\n            const RYB = createMix(rybMap);\n            mix = rybToRGB(RYB.R, RYB.Y, RYB.B);\n            mix.A = RYB.A;\n        }\n        return {\n            R: round(mix.R),\n            G: round(mix.G),\n            B: round(mix.B),\n            A: minmax(mix.A, 0, 1)\n        };\n    },\n    [ColorModel.HEX](colors, mode, css) {\n        const mix = this.mix(colors, mode);\n        delete mix.A;\n        return (css\n            ? CSS.HEX(mix)\n            : translateColor.HEX(mix));\n    },\n    HEXA(colors, mode, css) {\n        const mix = this.mix(colors, mode);\n        mix.A = css\n            ? normalizeAlpha(mix.A) * 255\n            : normalizeAlpha(mix.A);\n        return (css\n            ? CSS.HEX(mix)\n            : translateColor.HEXA(mix));\n    },\n    [ColorModel.RGB](colors, mode, css, options) {\n        const mix = this.mix(colors, mode);\n        delete mix.A;\n        return (css\n            ? CSS.RGB(mix, options)\n            : translateColor.RGB(mix, options.decimals));\n    },\n    RGBA(colors, mode, css, options) {\n        const mix = this.mix(colors, mode);\n        return (css\n            ? CSS.RGB(mix, options)\n            : translateColor.RGBA(mix, options.decimals));\n    },\n    [ColorModel.HSL](colors, mode, css, options) {\n        const mix = this.mix(colors, mode);\n        const HSL = rgbToHSL(mix.R, mix.G, mix.B);\n        delete mix.A;\n        delete HSL.A;\n        return (css\n            ? CSS.HSL(HSL, options)\n            : translateColor.HSL(mix, options.decimals));\n    },\n    HSLA(colors, mode, css, options) {\n        const mix = this.mix(colors, mode);\n        const HSL = rgbToHSL(mix.R, mix.G, mix.B, mix.A);\n        return (css\n            ? CSS.HSL(HSL, options)\n            : translateColor.HSLA(mix, options.decimals));\n    },\n    [ColorModel.CIELab](colors, mode, css, options) {\n        const mix = this.mix(colors, mode);\n        const Lab = rgbToLab(mix.R, mix.G, mix.B);\n        delete mix.A;\n        return (css\n            ? CSS.CIELab(Lab, options)\n            : translateColor.CIELabA(mix, options.decimals));\n    },\n    CIELabA(colors, mode, css, options) {\n        const mix = this.mix(colors, mode);\n        const Lab = rgbToLab(mix.R, mix.G, mix.B);\n        if (hasProp(mix, \'A\')) {\n            Lab.A = mix.A;\n        }\n        return (css\n            ? CSS.CIELab(Lab, options)\n            : translateColor.CIELabA(mix, options.decimals));\n    }\n};\nconst roundRGBObject = (color, decimals) => {\n    const R = round(color.R, decimals);\n    const G = round(color.G, decimals);\n    const B = round(color.B, decimals);\n    return {\n        R,\n        G,\n        B,\n        ...(hasProp(color, \'A\')\n            ? {\n                A: round(color.A, decimals)\n            }\n            : {})\n    };\n};\nconst roundHSLObject = (color, decimals) => {\n    return {\n        H: round(color.H, decimals),\n        S: round(color.S, decimals),\n        L: round(color.L, decimals),\n        ...(hasProp(color, \'A\')\n            ? {\n                A: round(color.A, decimals)\n            }\n            : {})\n    };\n};\nconst roundCIELabObject = (color, decimals) => {\n    return {\n        L: round(color.L, decimals),\n        a: round(color.a, decimals),\n        b: round(color.b, decimals)\n    };\n};\nconst roundCMYKObject = (color, decimals) => {\n    return {\n        C: round(color.C, decimals),\n        M: round(color.M, decimals),\n        Y: round(color.Y, decimals),\n        K: round(color.K, decimals)\n    };\n};\n\n;// CONCATENATED MODULE: ./src/index.ts\n\n\n\n\n\nconst getColorReturn = (color, model, decimals, translateFunction) => {\n    const rgbObject = getRGBObject(color, model);\n    return translateFunction(rgbObject, decimals);\n};\nconst getBlendReturn = (from, to, steps, decimals, translateFunction) => {\n    if (steps < 1)\n        steps = DEFAULT_BLEND_STEPS;\n    const fromRGBObject = getRGBObject(from);\n    const toRGBObject = getRGBObject(to);\n    const blendArray = blend(fromRGBObject, toRGBObject, steps);\n    return blendArray.map((color) => {\n        return translateFunction(color, decimals);\n    });\n};\nconst getHarmonyReturn = (harmony, color, mode, options) => {\n    return ({\n        [Harmony.ANALOGOUS]: colorHarmony.buildHarmony(color, analogous, mode, options),\n        [Harmony.COMPLEMENTARY]: colorHarmony.buildHarmony(color, complementary, mode, options),\n        [Harmony.SPLIT_COMPLEMENTARY]: colorHarmony.buildHarmony(color, splitComplementary, mode, options),\n        [Harmony.TRIADIC]: colorHarmony.buildHarmony(color, triadic, mode, options),\n        [Harmony.TETRADIC]: colorHarmony.buildHarmony(color, tetradic, mode, options),\n        [Harmony.SQUARE]: colorHarmony.buildHarmony(color, square, mode, options)\n    })[harmony];\n};\nclass ColorTranslator {\n    constructor(color, options = {}) {\n        this._options = getOptionsFromColorInput(options, color);\n        this.rgb = getRGBObject(color);\n        this.updateHSL();\n        this.updateLab();\n        this.updateCMYK();\n    }\n    updateRGB() {\n        this.rgb = {\n            ...hslToRGB(this.hsl.H, this.hsl.S, this.hsl.L),\n            A: this.hsl.A\n        };\n    }\n    updateRGBFromCMYK() {\n        this.rgb = {\n            ...cmykToRGB(this.cmyk.C, this.cmyk.M, this.cmyk.Y, this.cmyk.K),\n            A: this.rgb.A\n        };\n    }\n    updateRGBFromLab() {\n        this.rgb = {\n            ...labToRgb(this.lab.L, this.lab.a, this.lab.b),\n            A: this.rgb.A\n        };\n    }\n    updateHSL() {\n        this.hsl = rgbToHSL(this.rgb.R, this.rgb.G, this.rgb.B, this.rgb.A);\n    }\n    updateLab() {\n        this.lab = {\n            ...rgbToLab(this.rgb.R, this.rgb.G, this.rgb.B),\n            A: this.rgb.A\n        };\n    }\n    updateCMYK() {\n        this.cmyk = rgbToCMYK(this.rgb.R, this.rgb.G, this.rgb.B);\n    }\n    setOptions(options = {}) {\n        this._options = {\n            ...this._options,\n            ...options\n        };\n        return this;\n    }\n    setH(H) {\n        this.hsl.H = normalizeHue(H);\n        this.updateRGB();\n        this.updateLab();\n        this.updateCMYK();\n        return this;\n    }\n    setS(S) {\n        this.hsl.S = minmax(S, 0, 100);\n        this.updateRGB();\n        this.updateLab();\n        this.updateCMYK();\n        return this;\n    }\n    setL(L) {\n        this.hsl.L = minmax(L, 0, 100);\n        this.updateRGB();\n        this.updateLab();\n        this.updateCMYK();\n        return this;\n    }\n    setR(R) {\n        this.rgb.R = minmax(R, 0, 255);\n        this.updateHSL();\n        this.updateLab();\n        this.updateCMYK();\n        return;\n    }\n    setG(G) {\n        this.rgb.G = minmax(G, 0, 255);\n        this.updateHSL();\n        this.updateLab();\n        this.updateCMYK();\n        return this;\n    }\n    setB(B) {\n        this.rgb.B = minmax(B, 0, 255);\n        this.updateHSL();\n        this.updateLab();\n        this.updateCMYK();\n        return this;\n    }\n    setCIEL(L) {\n        this.lab.L = minmax(L, 0, 100);\n        this.updateRGBFromLab();\n        this.updateHSL();\n        this.updateCMYK();\n        return this;\n    }\n    setCIEa(a) {\n        this.lab.a = minmax(a, -125, 125);\n        this.updateRGBFromLab();\n        this.updateHSL();\n        this.updateCMYK();\n        return this;\n    }\n    setCIEb(b) {\n        this.lab.b = minmax(b, -125, 125);\n        this.updateRGBFromLab();\n        this.updateHSL();\n        this.updateCMYK();\n        return this;\n    }\n    setA(A) {\n        this.hsl.A = this.rgb.A = minmax(A, 0, 1);\n        return this;\n    }\n    setC(C) {\n        this.cmyk.C = minmax(C, 0, 100);\n        this.updateRGBFromCMYK();\n        this.updateHSL();\n        this.updateLab();\n        return this;\n    }\n    setM(M) {\n        this.cmyk.M = minmax(M, 0, 100);\n        this.updateRGBFromCMYK();\n        this.updateHSL();\n        this.updateLab();\n        return this;\n    }\n    setY(Y) {\n        this.cmyk.Y = minmax(Y, 0, 100);\n        this.updateRGBFromCMYK();\n        this.updateHSL();\n        this.updateLab();\n        return this;\n    }\n    setK(K) {\n        this.cmyk.K = minmax(K, 0, 100);\n        this.updateRGBFromCMYK();\n        this.updateHSL();\n        this.updateLab();\n        return this;\n    }\n    get options() {\n        return this._options;\n    }\n    get H() {\n        return round(this.hsl.H, this.options.decimals);\n    }\n    get S() {\n        return round(this.hsl.S, this.options.decimals);\n    }\n    get L() {\n        return round(this.hsl.L, this.options.decimals);\n    }\n    get CIEL() {\n        return round(this.lab.L, this.options.decimals);\n    }\n    get CIEa() {\n        return round(this.lab.a, this.options.decimals);\n    }\n    get CIEb() {\n        return round(this.lab.b, this.options.decimals);\n    }\n    get R() {\n        return round(this.rgb.R, this.options.decimals);\n    }\n    get G() {\n        return round(this.rgb.G, this.options.decimals);\n    }\n    get B() {\n        return round(this.rgb.B, this.options.decimals);\n    }\n    get A() {\n        return round(this.hsl.A, this.options.decimals);\n    }\n    get C() {\n        return round(this.cmyk.C, this.options.decimals);\n    }\n    get M() {\n        return round(this.cmyk.M, this.options.decimals);\n    }\n    get Y() {\n        return round(this.cmyk.Y, this.options.decimals);\n    }\n    get K() {\n        return round(this.cmyk.K, this.options.decimals);\n    }\n    get HEXObject() {\n        return translateColor.HEX(this.rgb);\n    }\n    get HEXAObject() {\n        return translateColor.HEXA(this.rgb);\n    }\n    get RGBObject() {\n        return {\n            R: this.R,\n            G: this.G,\n            B: this.B\n        };\n    }\n    get RGBAObject() {\n        return {\n            ...this.RGBObject,\n            A: this.A\n        };\n    }\n    get HSLObject() {\n        return {\n            H: this.H,\n            S: this.S,\n            L: this.L\n        };\n    }\n    get HSLAObject() {\n        return {\n            ...this.HSLObject,\n            A: this.A\n        };\n    }\n    get CIELabObject() {\n        return {\n            L: this.CIEL,\n            a: this.CIEa,\n            b: this.CIEb\n        };\n    }\n    get CIELabAObject() {\n        return {\n            ...this.CIELabObject,\n            A: this.A\n        };\n    }\n    get CMYKObject() {\n        return {\n            C: this.C,\n            M: this.M,\n            Y: this.Y,\n            K: this.K\n        };\n    }\n    get CMYKAObject() {\n        return {\n            ...this.CMYKObject,\n            A: this.A\n        };\n    }\n    get HEX() {\n        return CSS.HEX({\n            R: this.R,\n            G: this.G,\n            B: this.B\n        });\n    }\n    get HEXA() {\n        return CSS.HEX({\n            R: this.R,\n            G: this.G,\n            B: this.B,\n            A: this.A * 255\n        });\n    }\n    get RGB() {\n        return CSS.RGB({\n            R: this.R,\n            G: this.G,\n            B: this.B\n        }, this.options);\n    }\n    get RGBA() {\n        return CSS.RGB({\n            R: this.R,\n            G: this.G,\n            B: this.B,\n            A: this.A\n        }, this.options);\n    }\n    get HSL() {\n        return CSS.HSL({\n            H: this.H,\n            S: this.S,\n            L: this.L\n        }, this.options);\n    }\n    get HSLA() {\n        return CSS.HSL({\n            H: this.H,\n            S: this.S,\n            L: this.L,\n            A: this.A\n        }, this.options);\n    }\n    get CIELab() {\n        return CSS.CIELab({\n            L: this.CIEL,\n            a: this.CIEa,\n            b: this.CIEb\n        }, this.options);\n    }\n    get CIELabA() {\n        return CSS.CIELab({\n            L: this.CIEL,\n            a: this.CIEa,\n            b: this.CIEb,\n            A: this.A\n        }, this.options);\n    }\n    get CMYK() {\n        return CSS.CMYK({\n            C: this.C,\n            M: this.M,\n            Y: this.Y,\n            K: this.K\n        }, this.options);\n    }\n    get CMYKA() {\n        return CSS.CMYK({\n            C: this.C,\n            M: this.M,\n            Y: this.Y,\n            K: this.K,\n            A: this.A\n        }, this.options);\n    }\n    static toHEXObject(color) {\n        const model = getColorModel(color);\n        return getColorReturn(color, model, 0, translateColor.HEX);\n    }\n    static toHEX(color) {\n        return CSS.HEX(ColorTranslator.toHEXObject(color));\n    }\n    static toHEXAObject(color) {\n        const model = getColorModel(color);\n        return getColorReturn(color, model, 0, translateColor.HEXA);\n    }\n    static toHEXA(color) {\n        return CSS.HEX(ColorTranslator.toHEXAObject(color));\n    }\n    static toRGBObject(color, options = {}) {\n        const model = getColorModel(color);\n        return getColorReturn(color, model, options.decimals, translateColor.RGB);\n    }\n    static toRGB(color, options = {}) {\n        const model = getColorModel(color);\n        const detectedOptions = getOptionsFromColorInput(options, color);\n        const rgb = getColorReturn(color, model, options.decimals, translateColor.RGB);\n        return CSS.RGB(rgb, detectedOptions);\n    }\n    static toRGBAObject(color, options = {}) {\n        const model = getColorModel(color);\n        return getColorReturn(color, model, options.decimals, translateColor.RGBA);\n    }\n    static toRGBA(color, options = {}) {\n        const model = getColorModel(color);\n        const detectedOptions = getOptionsFromColorInput(options, color);\n        const rgba = getColorReturn(color, model, options.decimals, translateColor.RGBA);\n        return CSS.RGB(rgba, detectedOptions);\n    }\n    static toHSLObject(color, options = {}) {\n        const model = getColorModel(color);\n        return getColorReturn(color, model, options.decimals, translateColor.HSL);\n    }\n    static toHSL(color, options = {}) {\n        const model = getColorModel(color);\n        const detectedOptions = getOptionsFromColorInput(options, color);\n        const hsl = getColorReturn(color, model, options.decimals, translateColor.HSL);\n        return CSS.HSL(hsl, detectedOptions);\n    }\n    static toHSLAObject(color, options = {}) {\n        const model = getColorModel(color);\n        return getColorReturn(color, model, options.decimals, translateColor.HSLA);\n    }\n    static toHSLA(color, options = {}) {\n        const model = getColorModel(color);\n        const detectedOptions = getOptionsFromColorInput(options, color);\n        const hsla = getColorReturn(color, model, options.decimals, translateColor.HSLA);\n        return CSS.HSL(hsla, detectedOptions);\n    }\n    static toCIELabObject(color, options = {}) {\n        const model = getColorModel(color);\n        return getColorReturn(color, model, options.decimals, translateColor.CIELab);\n    }\n    static toCIELab(color, options = {}) {\n        const model = getColorModel(color);\n        const detectedOptions = getOptionsFromColorInput(options, color);\n        const lab = getColorReturn(color, model, options.decimals, translateColor.CIELab);\n        return CSS.CIELab(lab, detectedOptions);\n    }\n    static toCIELabAObject(color, options = {}) {\n        const model = getColorModel(color);\n        return getColorReturn(color, model, options.decimals, translateColor.CIELabA);\n    }\n    static toCIELabA(color, options = {}) {\n        const model = getColorModel(color);\n        const detectedOptions = getOptionsFromColorInput(options, color);\n        const lab = getColorReturn(color, model, options.decimals, translateColor.CIELabA);\n        return CSS.CIELab(lab, detectedOptions);\n    }\n    static toCMYKObject(color, options = {}) {\n        const model = getColorModel(color);\n        return getColorReturn(color, model, options.decimals, translateColor.CMYK);\n    }\n    static toCMYK(color, options = {}) {\n        const model = getColorModel(color);\n        const detectedOptions = getOptionsFromColorInput(options, color);\n        const cmyk = getColorReturn(color, model, options.decimals, translateColor.CMYK);\n        return CSS.CMYK(cmyk, detectedOptions);\n    }\n    static toCMYKAObject(color, options = {}) {\n        const model = getColorModel(color);\n        return getColorReturn(color, model, options.decimals, translateColor.CMYKA);\n    }\n    static toCMYKA(color, options = {}) {\n        const model = getColorModel(color);\n        const detectedOptions = getOptionsFromColorInput(options, color);\n        const cmyka = getColorReturn(color, model, options.decimals, translateColor.CMYKA);\n        return CSS.CMYK(cmyka, detectedOptions);\n    }\n    static getBlendHEXObject(from, to, steps = DEFAULT_BLEND_STEPS) {\n        return getBlendReturn(from, to, steps, 0, translateColor.HEX);\n    }\n    static getBlendHEX(from, to, steps = DEFAULT_BLEND_STEPS) {\n        return ColorTranslator.getBlendHEXObject(from, to, steps)\n            .map((color) => CSS.HEX(color));\n    }\n    static getBlendHEXAObject(from, to, steps = DEFAULT_BLEND_STEPS) {\n        return getBlendReturn(from, to, steps, 0, translateColor.HEXA);\n    }\n    static getBlendHEXA(from, to, steps = DEFAULT_BLEND_STEPS) {\n        return ColorTranslator.getBlendHEXAObject(from, to, steps)\n            .map((color) => CSS.HEX(color));\n    }\n    static getBlendRGBObject(from, to, thirdParameter, fourthParameter) {\n        if (typeof thirdParameter === \'number\') {\n            return getBlendReturn(from, to, thirdParameter, fourthParameter?.decimals, translateColor.RGB);\n        }\n        return getBlendReturn(from, to, DEFAULT_BLEND_STEPS, thirdParameter?.decimals, translateColor.RGB);\n    }\n    static getBlendRGB(from, to, thirdParameter, fourthParameter) {\n        if (typeof thirdParameter === \'number\') {\n            return getBlendReturn(from, to, thirdParameter, fourthParameter?.decimals, translateColor.RGB)\n                .map((color) => {\n                return CSS.RGB(color, getOptionsFromColorInput(fourthParameter || {}, from, to));\n            });\n        }\n        return getBlendReturn(from, to, DEFAULT_BLEND_STEPS, thirdParameter?.decimals, translateColor.RGB)\n            .map((color) => {\n            return CSS.RGB(color, getOptionsFromColorInput(thirdParameter || {}, from, to));\n        });\n    }\n    static getBlendRGBAObject(from, to, thirdParameter, fourthParameter) {\n        if (typeof thirdParameter === \'number\') {\n            return getBlendReturn(from, to, thirdParameter, fourthParameter?.decimals, translateColor.RGBA);\n        }\n        return getBlendReturn(from, to, DEFAULT_BLEND_STEPS, thirdParameter?.decimals, translateColor.RGBA);\n    }\n    static getBlendRGBA(from, to, thirdParameter, fourthParameter) {\n        if (typeof thirdParameter === \'number\') {\n            return getBlendReturn(from, to, thirdParameter, fourthParameter?.decimals, translateColor.RGBA)\n                .map((color) => {\n                return CSS.RGB(color, getOptionsFromColorInput(fourthParameter || {}, from, to));\n            });\n        }\n        return getBlendReturn(from, to, DEFAULT_BLEND_STEPS, thirdParameter?.decimals, translateColor.RGBA)\n            .map((color) => {\n            return CSS.RGB(color, getOptionsFromColorInput(thirdParameter || {}, from, to));\n        });\n    }\n    static getBlendHSLObject(from, to, thirdParameter, fourthParameter) {\n        if (typeof thirdParameter === \'number\') {\n            return getBlendReturn(from, to, thirdParameter, fourthParameter?.decimals, translateColor.HSL);\n        }\n        return getBlendReturn(from, to, DEFAULT_BLEND_STEPS, fourthParameter?.decimals, translateColor.HSL);\n    }\n    static getBlendHSL(from, to, thirdParameter, fourthParameter) {\n        if (typeof thirdParameter === \'number\') {\n            return getBlendReturn(from, to, thirdParameter, fourthParameter?.decimals, translateColor.HSL)\n                .map((color) => {\n                return CSS.HSL(color, getOptionsFromColorInput(fourthParameter || {}, from, to));\n            });\n        }\n        return getBlendReturn(from, to, DEFAULT_BLEND_STEPS, thirdParameter?.decimals, translateColor.HSL)\n            .map((color) => {\n            return CSS.HSL(color, getOptionsFromColorInput(thirdParameter || {}, from, to));\n        });\n    }\n    static getBlendHSLAObject(from, to, thirdParameter, fourthParameter) {\n        if (typeof thirdParameter === \'number\') {\n            return getBlendReturn(from, to, thirdParameter, fourthParameter?.decimals, translateColor.HSLA);\n        }\n        return getBlendReturn(from, to, DEFAULT_BLEND_STEPS, thirdParameter?.decimals, translateColor.HSLA);\n    }\n    static getBlendHSLA(from, to, thirdParameter, fourthParameter) {\n        if (typeof thirdParameter === \'number\') {\n            return getBlendReturn(from, to, thirdParameter, fourthParameter?.decimals, translateColor.HSLA)\n                .map((color) => {\n                return CSS.HSL(color, getOptionsFromColorInput(fourthParameter || {}, from, to));\n            });\n        }\n        return getBlendReturn(from, to, DEFAULT_BLEND_STEPS, thirdParameter?.decimals, translateColor.HSLA)\n            .map((color) => {\n            return CSS.HSL(color, getOptionsFromColorInput(thirdParameter || {}, from, to));\n        });\n    }\n    static getBlendCIELabObject(from, to, thirdParameter, fourthParameter) {\n        if (typeof thirdParameter === \'number\') {\n            return getBlendReturn(from, to, thirdParameter, fourthParameter?.decimals, translateColor.CIELab);\n        }\n        return getBlendReturn(from, to, DEFAULT_BLEND_STEPS, thirdParameter?.decimals, translateColor.CIELab);\n    }\n    static getBlendCIELab(from, to, thirdParameter, fourthParameter) {\n        if (typeof thirdParameter === \'number\') {\n            return getBlendReturn(from, to, thirdParameter, fourthParameter?.decimals, translateColor.CIELab)\n                .map((color) => {\n                return CSS.CIELab(color, getOptionsFromColorInput(fourthParameter || {}, from, to));\n            });\n        }\n        return getBlendReturn(from, to, DEFAULT_BLEND_STEPS, thirdParameter?.decimals, translateColor.CIELab)\n            .map((color) => {\n            return CSS.CIELab(color, getOptionsFromColorInput(thirdParameter || {}, from, to));\n        });\n    }\n    static getBlendCIELabAObject(from, to, thirdParameter, fourthParameter) {\n        if (typeof thirdParameter === \'number\') {\n            return getBlendReturn(from, to, thirdParameter, fourthParameter?.decimals, translateColor.CIELabA);\n        }\n        return getBlendReturn(from, to, DEFAULT_BLEND_STEPS, thirdParameter?.decimals, translateColor.CIELabA);\n    }\n    static getBlendCIELabA(from, to, thirdParameter, fourthParameter) {\n        if (typeof thirdParameter === \'number\') {\n            return getBlendReturn(from, to, thirdParameter, fourthParameter?.decimals, translateColor.CIELabA)\n                .map((color) => {\n                return CSS.CIELab(color, getOptionsFromColorInput(fourthParameter || {}, from, to));\n            });\n        }\n        return getBlendReturn(from, to, DEFAULT_BLEND_STEPS, thirdParameter?.decimals, translateColor.CIELabA)\n            .map((color) => {\n            return CSS.CIELab(color, getOptionsFromColorInput(thirdParameter || {}, from, to));\n        });\n    }\n    static getMixHEXObject(colors, mode = Mix.ADDITIVE) {\n        return colorMixer.HEX(colors, mode, false);\n    }\n    static getMixHEX(colors, mode = Mix.ADDITIVE) {\n        return colorMixer.HEX(colors, mode, true);\n    }\n    static getMixHEXAObject(colors, mode = Mix.ADDITIVE) {\n        return colorMixer.HEXA(colors, mode, false);\n    }\n    static getMixHEXA(colors, mode = Mix.ADDITIVE) {\n        return colorMixer.HEXA(colors, mode, true);\n    }\n    static getMixRGBObject(colors, secondParameter, thirdParameter) {\n        if (typeof secondParameter === \'string\') {\n            return colorMixer.RGB(colors, secondParameter, false, getOptionsFromColorInput(thirdParameter || {}, ...colors));\n        }\n        return colorMixer.RGB(colors, Mix.ADDITIVE, false, getOptionsFromColorInput(secondParameter || {}, ...colors));\n    }\n    static getMixRGB(colors, secondParameter, thirdParameter) {\n        if (typeof secondParameter === \'string\') {\n            return colorMixer.RGB(colors, secondParameter, true, getOptionsFromColorInput(thirdParameter || {}, ...colors));\n        }\n        return colorMixer.RGB(colors, Mix.ADDITIVE, true, getOptionsFromColorInput(secondParameter || {}, ...colors));\n    }\n    static getMixRGBAObject(colors, secondParameter, thirdParameter) {\n        if (typeof secondParameter === \'string\') {\n            return colorMixer.RGBA(colors, secondParameter, false, getOptionsFromColorInput(thirdParameter || {}, ...colors));\n        }\n        return colorMixer.RGBA(colors, Mix.ADDITIVE, false, getOptionsFromColorInput(secondParameter || {}, ...colors));\n    }\n    static getMixRGBA(colors, secondParameter, thirdParameter) {\n        if (typeof secondParameter === \'string\') {\n            return colorMixer.RGBA(colors, secondParameter, true, getOptionsFromColorInput(thirdParameter || {}, ...colors));\n        }\n        return colorMixer.RGBA(colors, Mix.ADDITIVE, true, getOptionsFromColorInput(secondParameter || {}, ...colors));\n    }\n    static getMixHSLObject(colors, secondParameter, thirdParameter) {\n        if (typeof secondParameter === \'string\') {\n            return colorMixer.HSL(colors, secondParameter, false, getOptionsFromColorInput(thirdParameter || {}, ...colors));\n        }\n        return colorMixer.HSL(colors, Mix.ADDITIVE, false, getOptionsFromColorInput(secondParameter || {}, ...colors));\n    }\n    static getMixHSL(colors, secondParameter, thirdParameter) {\n        if (typeof secondParameter === \'string\') {\n            return colorMixer.HSL(colors, secondParameter, true, getOptionsFromColorInput(thirdParameter || {}, ...colors));\n        }\n        return colorMixer.HSL(colors, Mix.ADDITIVE, true, getOptionsFromColorInput(secondParameter || {}, ...colors));\n    }\n    static getMixHSLAObject(colors, secondParameter, thirdParameter) {\n        if (typeof secondParameter === \'string\') {\n            return colorMixer.HSLA(colors, secondParameter, false, getOptionsFromColorInput(thirdParameter || {}, ...colors));\n        }\n        return colorMixer.HSLA(colors, Mix.ADDITIVE, false, getOptionsFromColorInput(secondParameter || {}, ...colors));\n    }\n    static getMixHSLA(colors, secondParameter, thirdParameter) {\n        if (typeof secondParameter === \'string\') {\n            return colorMixer.HSLA(colors, secondParameter, true, getOptionsFromColorInput(thirdParameter || {}, ...colors));\n        }\n        return colorMixer.HSLA(colors, Mix.ADDITIVE, true, getOptionsFromColorInput(secondParameter || {}, ...colors));\n    }\n    static getMixCIELabObject(colors, secondParameter, thirdParameter) {\n        if (typeof secondParameter === \'string\') {\n            return colorMixer.CIELab(colors, secondParameter, false, getOptionsFromColorInput(thirdParameter || {}, ...colors));\n        }\n        return colorMixer.CIELab(colors, Mix.ADDITIVE, false, getOptionsFromColorInput(secondParameter || {}, ...colors));\n    }\n    static getMixCIELab(colors, secondParameter, thirdParameter) {\n        if (typeof secondParameter === \'string\') {\n            return colorMixer.CIELab(colors, secondParameter, true, getOptionsFromColorInput(thirdParameter || {}, ...colors));\n        }\n        return colorMixer.CIELab(colors, Mix.ADDITIVE, true, getOptionsFromColorInput(secondParameter || {}, ...colors));\n    }\n    static getMixCIELabAObject(colors, secondParameter, thirdParameter) {\n        if (typeof secondParameter === \'string\') {\n            return colorMixer.CIELabA(colors, secondParameter, false, getOptionsFromColorInput(thirdParameter || {}, ...colors));\n        }\n        return colorMixer.CIELabA(colors, Mix.ADDITIVE, false, getOptionsFromColorInput(secondParameter || {}, ...colors));\n    }\n    static getMixCIELabA(colors, secondParameter, thirdParameter) {\n        if (typeof secondParameter === \'string\') {\n            return colorMixer.CIELabA(colors, secondParameter, true, getOptionsFromColorInput(thirdParameter || {}, ...colors));\n        }\n        return colorMixer.CIELabA(colors, Mix.ADDITIVE, true, getOptionsFromColorInput(secondParameter || {}, ...colors));\n    }\n    static getShades(color, secondParameter, thirdParameter) {\n        if (typeof secondParameter === \'number\') {\n            return getColorMixture(color, secondParameter, true, getOptionsFromColorInput(thirdParameter || {}, color));\n        }\n        return getColorMixture(color, DEFAULT_SHADES_TINTS_STEPS, true, getOptionsFromColorInput(secondParameter || {}, color));\n    }\n    static getTints(color, secondParameter, thirdParameter) {\n        if (typeof secondParameter === \'number\') {\n            return getColorMixture(color, secondParameter, false, getOptionsFromColorInput(thirdParameter || {}, color));\n        }\n        return getColorMixture(color, DEFAULT_SHADES_TINTS_STEPS, false, getOptionsFromColorInput(secondParameter || {}, color));\n    }\n    static getHarmony(color, secondParam, thirdParam, fourthParam) {\n        if (isHarmony(secondParam)) {\n            return getHarmonyReturn(secondParam, color, isMix(thirdParam)\n                ? thirdParam\n                : Mix.ADDITIVE, getOptionsFromColorInput(isMix(thirdParam)\n                ? (fourthParam || {})\n                : thirdParam || {}, color));\n        }\n        else if (isMix(secondParam)) {\n            return getHarmonyReturn(Harmony.COMPLEMENTARY, color, secondParam, getOptionsFromColorInput(thirdParam || {}, color));\n        }\n        return getHarmonyReturn(Harmony.COMPLEMENTARY, color, Mix.ADDITIVE, getOptionsFromColorInput(secondParam || {}, color));\n    }\n}\n\n\n;// CONCATENATED MODULE: ./src/@demo/demo1/index.js\n\n\n/* harmony default export */ const demo1 = ((ColorTranslator) => {\n\n    const container = document.createElement(\'div\');\n    const color = new ColorTranslator(\'hsl(180 100% 50%)\', { decimals: 0 });\n\n    for (let row = 0; row < 10; row++) {\n\n        for (let col = 0; col < 10; col++) {\n\n            color\n                .setS(row * 10)\n                .setL(col * 5 + 30);\n\n            const box = document.createElement(\'div\');\n\n            box.classList.add(\'box\');\n            box.style.background = color.HEX;\n\n            box.innerText =\n                `R:${color.R}\n                 G:${color.G}\n                 B:${color.B}`;\n            container.appendChild(box);\n\n        }\n    }\n\n    return container;\n\n});\n;// CONCATENATED MODULE: ./src/@demo/demo2/index.js\n\n\n/* harmony default export */ const demo2 = ((ColorTranslator) => {\n\n    const container = document.createElement(\'div\');\n    const color = new ColorTranslator({ R: 255, G: 0, B: 0 });\n    const hue = [0, 30, 60, 120, 240, 280, 320, 0];\n    let rainbow;\n\n    for (let r = 0; r < hue.length; r++) {\n\n        color.setH(hue[r]);\n\n        const bow = document.createElement(\'div\');\n\n        bow.classList.add(\'rainbow\');\n        bow.style.background = color.HEX;\n\n        if (rainbow) {\n            rainbow.appendChild(bow);\n        } else {\n            container.appendChild(bow);\n        }\n\n        rainbow = bow;\n    }\n\n    rainbow.style.background = \'#333\';\n\n    return container;\n\n});\n;// CONCATENATED MODULE: ./src/@demo/demo3/index.js\n\n\n/* harmony default export */ const demo3 = ((ColorTranslator) => {\n\n    const container = document.createElement(\'div\');\n    const hsl = { H: 0, S: \'90%\', L: \'50%\' };\n    const hue = [undefined, 55, 30, 0, 290, 220, 130];\n    const total = hue.length;\n\n    for (let row = 0; row < total; row++) {\n\n        for (let col = 0; col < total; col++) {\n\n            let index = total - row + col;\n            if (index >= total) {\n                index -= total;\n            }\n            hsl.H = hue[index];\n            const rgb = hue[index] === undefined\n                ? \'#FFF\'\n                : ColorTranslator.toHEX(hsl);\n            const box = document.createElement(\'div\');\n\n            box.classList.add(\'flag\');\n            box.style.background = rgb;\n\n            container.appendChild(box);\n\n        }\n    }\n\n    return container;\n\n});\n;// CONCATENATED MODULE: ./src/@demo/demo4/index.js\n\n\n/* harmony default export */ const demo4 = ((ColorTranslator) => {\n\n    const container = document.createElement(\'div\');\n    const hexColors = [\n        \'#FE2712\', \'#FE5409\', \'#FB9902\',\n        \'#FABD03\', \'#FFFE32\', \'#D1EA2C\',\n        \'#66B132\', \'#0392CE\', \'#0247FE\',\n        \'#3D00A5\', \'#8601B0\', \'#A7194B\'\n    ];\n\n    hexColors.forEach((color) => {\n\n        const rgb = ColorTranslator.toRGB(color);\n        const hsl = ColorTranslator.toHSL(color, { decimals: 0 });\n        const lab = ColorTranslator.toCIELab(color, { decimals: 0 });\n\n        const rgbDiv = document.createElement(\'div\');\n        const hslDiv = document.createElement(\'div\');\n        const labDiv = document.createElement(\'div\');\n\n        rgbDiv.style.backgroundColor = rgb;\n        rgbDiv.textContent = rgb;\n\n        hslDiv.style.backgroundColor = hsl;\n        hslDiv.textContent = hsl;\n\n        labDiv.style.backgroundColor = lab;\n        labDiv.textContent = lab;\n\n        container.appendChild(rgbDiv);\n        container.appendChild(hslDiv);\n        container.appendChild(labDiv);\n\n    });\n\n    return container;\n\n});\n;// CONCATENATED MODULE: ./src/@demo/demo5/index.js\n\n\n/* harmony default export */ const demo5 = ((ColorTranslator) => {\n\n    const container = document.createElement(\'div\');\n    const colors = [\n        \'red\',\n        \'lime\',\n        \'blue\',\n        \'aqua\',\n        \'yellow\',\n        \'fuchsia\'\n    ];\n    const total = colors.length;\n\n    for (let row = 0; row < total; row++) {\n\n        const hsl = ColorTranslator.toHSLObject(colors[row]);\n        const step = hsl.S / (total - 1);\n\n        for (let col = 0; col < total; col++) {\n\n            const rgb = ColorTranslator.toHEX(hsl);\n            const cmyk = ColorTranslator.toCMYKObject(hsl, { decimals: 0 });\n\n            const box = document.createElement(\'div\');\n            box.classList.add(\'box\');\n            box.style.background = rgb;\n            box.innerText = `C:${cmyk.C}\n                             M:${cmyk.M}\n                             Y:${cmyk.Y}\n                             K:${cmyk.K}`;\n\n            container.appendChild(box);\n\n            hsl.S -= step;\n\n        }\n    }\n\n    return container;\n\n});\n;// CONCATENATED MODULE: ./src/@demo/demo6/index.js\n\n\n/* harmony default export */ const demo6 = ((ColorTranslator) => {\n\n    const container = document.createElement(\'div\');\n    const rows = 11;\n    const mult = 3;\n\n    for (let i = 0; i < rows; i++) {\n\n        const blends = ColorTranslator.getBlendHEX(\'#F00\', \'#FF0\', mult + i * mult);\n\n        blends.forEach((blend, index) => {\n            const box = document.createElement(\'div\');\n            box.classList.add(\'box\', `file${i}`);\n            box.style.background = blend;\n            box.innerText = index + 1;\n            container.appendChild(box);\n        });\n\n    }\n\n    return container;\n\n});\n;// CONCATENATED MODULE: ./src/@demo/demo7/index.js\n\n\n/* harmony default export */ const demo7 = ((ColorTranslator) => {\n\n    const container = document.createElement(\'div\');\n\n    const colors = [\'#F00\', \'#FF8000\', \'#FF0\', \'#0F0\', \'#00F\', \'#A0F\', \'#F0A\'];\n\n    const createBox = (color, type) => {\n        const box = document.createElement(\'div\');\n        box.classList.add(\'box\');\n        box.style.backgroundColor = color;\n        if (type) box.dataset.type = type;\n        container.appendChild(box);\n    };\n\n    colors.forEach((color) => {\n        const shades = ColorTranslator.getShades(color, 3).reverse();\n        const tints = ColorTranslator.getTints(color, 3);\n        shades.forEach((shade) => createBox(shade, \'shade\'));\n        createBox(color);\n        tints.forEach((tint) => createBox(tint, \'tint\'));\n    });\n\n    return container;\n\n});\n;// CONCATENATED MODULE: ./src/@demo/demo8/index.js\n\n\n\n/* harmony default export */ const demo8 = ((ColorTranslator) => {\n\n    const container = document.createElement(\'div\');\n\n    const mixes = [\n        \'#F00\',\n        \'#0F0\',\n        \'#00F\',\n        [1, 3],\n        [1, 2],\n        [2, 3],\n        [1, 2, 3]\n    ];\n\n    const fillPlanes = () => {\n        const planes = container.querySelectorAll(\'#planes path\');\n        planes.forEach((plane, index) => {\n            let color = \'#CCC\';\n            if (typeof mixes[index] === \'string\') {\n                color = mixes[index];\n            } else if(mixes[index]) {\n                const colors = mixes[index].map((i) => mixes[i - 1]);\n                color = mixes[index] = ColorTranslator.getMixHEX(colors);\n            }\n            plane.setAttribute(\'fill\', color);\n        });\n    };\n\n    fetch(\'images/color-mixes.svg\')\n        .then(result => result.text())\n        .then((svgCode) => {\n            container.innerHTML = svgCode;\n            fillPlanes();\n        });\n\n    return container;\n\n});\n;// CONCATENATED MODULE: ./src/@demo/demo9/index.js\n\n\n/* harmony default export */ const demo9 = ((ColorTranslator, { Mix }) => {\n\n    const container = document.createElement(\'div\');\n\n    const mixes = [\n        \'#F00\',\n        \'#FF0\',\n        \'#00F\',\n        [1, 3],\n        [1, 2],\n        [2, 3],\n        [1, 2, 3]\n    ];\n\n    const fillPlanes = () => {\n        const planes = container.querySelectorAll(\'#planes path\');\n        planes.forEach((plane, index) => {\n            let color = \'#CCC\';\n            if (typeof mixes[index] === \'string\') {\n                color = mixes[index];\n            } else if(mixes[index]) {\n                const colors = mixes[index].map((i) => mixes[i - 1]);\n                color = mixes[index] = ColorTranslator.getMixHEX(colors, Mix.SUBTRACTIVE);\n            }\n            plane.setAttribute(\'fill\', color);\n        });\n    };\n\n    fetch(\'images/color-mixes.svg\')\n        .then(result => result.text())\n        .then((svgCode) => {\n            container.innerHTML = svgCode;\n            fillPlanes();\n        });\n\n    return container;\n\n});\n;// CONCATENATED MODULE: ./src/@demo/demo10/index.js\n\n\n/* harmony default export */ const demo10 = ((ColorTranslator, { Harmony }) => {\n\n    const container = document.createElement(\'div\');\n\n    const harmonies = [\n        { label: \'Complementary\',       value: Harmony.COMPLEMENTARY },\n        { label: \'Split Complementary\', value: Harmony.SPLIT_COMPLEMENTARY },\n        { label: \'Analogous\',           value: Harmony.ANALOGOUS },\n        { label: \'Triadic\',             value: Harmony.TRIADIC },\n        { label: \'Tetradic\',            value: Harmony.TETRADIC },\n        { label: \'Square\',              value: Harmony.SQUARE }\n    ];\n\n    const baseColor = \'#F00\';\n\n    const createElement = (className, parent) => {\n        const div = document.createElement(\'div\');\n        div.classList.add(className);\n        parent.appendChild(div);\n        return div;\n    };\n\n    const createHarmony = (item) => {\n\n        const wrapper = createElement(\'wrapper\', container);\n        const wheel = createElement(\'wheel\', wrapper);\n        const harmony = createElement(\'harmony\', wrapper);\n        createElement(\'label\', wrapper).innerText = item.label;\n\n        fetch(\'images/wheel-additive.svg\')\n            .then(result => result.text())\n            .then((svgCode) => {\n                const harmonyColors = ColorTranslator.getHarmony(baseColor, item.value);\n                const selector = \'path\' + harmonyColors.map((color) => `:not([fill="${color}"])`).join(\'\');\n                wheel.innerHTML = svgCode;\n                harmonyColors.forEach((hex) => createElement(\'box\', harmony).style.background = hex);\n                wheel.querySelectorAll(selector).forEach((path) => path.setAttribute(\'fill-opacity\', \'0.25\'));\n            });\n\n    };\n\n    harmonies.forEach((item) => createHarmony(item));\n\n    return container;\n\n});\n;// CONCATENATED MODULE: ./src/@demo/demo11/index.js\n\n\n/* harmony default export */ const demo11 = ((ColorTranslator, { Harmony, Mix }) => {\n\n    const container = document.createElement(\'div\');\n\n    const harmonies = [\n        { label: \'Complementary\',       value: Harmony.COMPLEMENTARY },\n        { label: \'Split Complementary\', value: Harmony.SPLIT_COMPLEMENTARY },\n        { label: \'Analogous\',           value: Harmony.ANALOGOUS },\n        { label: \'Triadic\',             value: Harmony.TRIADIC },\n        { label: \'Tetradic\',            value: Harmony.TETRADIC },\n        { label: \'Square\',              value: Harmony.SQUARE }\n    ];\n\n    const baseColor = \'#F00\';\n\n    const createElement = (className, parent) => {\n        const div = document.createElement(\'div\');\n        div.classList.add(className);\n        parent.appendChild(div);\n        return div;\n    };\n\n    const createHarmony = (item) => {\n\n        const wrapper = createElement(\'wrapper\', container);\n        const wheel = createElement(\'wheel\', wrapper);\n        const harmony = createElement(\'harmony\', wrapper);\n        createElement(\'label\', wrapper).innerText = item.label;\n\n        fetch(\'images/wheel-subtractive.svg\')\n            .then(result => result.text())\n            .then((svgCode) => {\n                const harmonyColors = ColorTranslator.getHarmony(baseColor, item.value, Mix.SUBTRACTIVE);\n                const selector = \'path\' + harmonyColors.map((color) => `:not([fill="${color}"])`).join(\'\');\n                wheel.innerHTML = svgCode;\n                harmonyColors.forEach((hex) => createElement(\'box\', harmony).style.background = hex);\n                wheel.querySelectorAll(selector).forEach((path) => path.setAttribute(\'fill-opacity\', \'0.25\'));\n            });\n\n    };\n\n    harmonies.forEach((item) => createHarmony(item));\n\n    return container;\n\n});\n;// CONCATENATED MODULE: ./src/@demo/demo.js\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nconst functioToString = (fn) => {\n    const article = document.createElement(\'article\');\n    const pre = document.createElement(\'pre\');\n    article.classList.add(\'function-container\');\n    pre.classList.add(\'prettyprint\');\n    article.appendChild(pre);\n    pre.innerHTML = fn.toString().replace(\'(ColorTranslator)\', \'()\');\n    return article;\n};\n\nconst demos = new Map([\n    [\'demo1\', demo1],\n    [\'demo2\', demo2],\n    [\'demo3\', demo3],\n    [\'demo4\', demo4],\n    [\'demo5\', demo5],\n    [\'demo6\', demo6],\n    [\'demo7\', demo7],\n    [\'demo8\', demo8],\n    [\'demo9\', demo9],\n    [\'demo10\', demo10],\n    [\'demo11\', demo11],\n]);\n\ndocument.addEventListener(\'DOMContentLoaded\', () => {\n    demos.forEach((module, div) => {\n        const demo = document.getElementById(div);\n        const container = document.createElement(\'div\');\n        const wrapper = document.createElement(\'div\');\n\n        container.classList.add(\'demo-container\');\n        wrapper.classList.add(\'demo-wrapper\');\n\n        wrapper.appendChild(module(ColorTranslator, { Harmony: Harmony, Mix: Mix }));\n        container.appendChild(wrapper);\n        demo.appendChild(container);\n        demo.appendChild(functioToString(module));\n    });\n});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNDA1LmpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLHFCQUFNLG9CQUFvQixxQkFBTTtBQUMxQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsSUFBSTtBQUNKO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLGtCQUFrQixpQkFBaUI7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxxREFBcUQ7QUFDckQsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSLDRFQUE0RTtBQUM1RTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFF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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxzQ0FBc0M7QUFDaEM7QUFDQTtBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQSxDQUFDLHdCQUF3Qjs7O0FDbk1ZO0FBQzlCO0FBQ1AsS0FBSyxVQUFVLDREQUE0RCxFQUFFLFVBQVUsRUFBRSxVQUFVLEVBQUUsVUFBVSxFQUFFO0FBQ2pILEtBQUssVUFBVTtB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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxLQUFLO0FBQ3BCO0FBQ0E7QUFDQSxlQUFlLEtBQUs7QUFDcEI7QUFDQTtBQUNBLGVBQWUsS0FBSztBQUNwQjtBQUNBO0FBQ0EsZUFBZSxLQUFLO0FBQ3BCO0FBQ0E7QUFDQSxlQUFlLEtBQUs7QUFDcEI7QUFDQTtBQUNBLGVBQWUsS0FBSztBQUNwQjtBQUNBO0FBQ0EsZUFBZSxLQUFLO0FBQ3BCO0FBQ0E7QUFDQSxlQUFlLEtBQUs7QUFDcEI7QUFDQTtBQUNBLGVBQWUsS0FBSztBQUNwQjtBQUNBO0FBQ0EsZUFBZSxLQUFLO0FBQ3BCO0FBQ0E7QUFDQSxlQUFlLEtBQUs7QUFDcEI7QUFDQTtBQUNBLGVBQWUsS0FBSztBQUNwQjtBQUNBO0FBQ0EsZUFBZSxLQUFLO0FBQ3BCO0FBQ0E7QUFDQSxlQUFlLEtBQUs7QUFDcEI7QUFDQTtBQUNBLGVBQWUsY0FBb0I7QUFDbkM7QUFDQTtBQUNBLGVBQWUsY0FBb0I7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLEdBQUc7QUFDbEI7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxlQUFlLEdBQUc7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLGVBQWUsR0FBRztBQUNsQjtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLGVBQWUsR0FBRztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNB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QTtBQUNBO0FBQ0Esc0ZBQXNGLE1BQU07QUFDNUY7QUFDQTtBQUNBO0FBQ0EsYUFBYTs7QUFFYjs7QUFFQTs7QUFFQTs7QUFFQSxDQUFDLEU7O0FDL0NzQjs7QUFFdkIsNkNBQWUsb0JBQW9CLGNBQWM7O0FBRWpEOztBQUVBO0FBQ0EsVUFBVSw0REFBNEQ7QUFDdEUsVUFBVSxrRUFBa0U7QUFDNUUsVUFBVSx3REFBd0Q7QUFDbEUsVUFBVSxzREFBc0Q7QUFDaEUsVUFBVSx1REFBdUQ7QUFDakUsVUFBVTtBQUNWOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNGQUFzRixNQUFNO0FBQzVGO0FBQ0E7QUFDQTtBQUNBLGFBQWE7O0FBRWI7O0FBRUE7O0FBRUE7O0FBRUEsQ0FBQyxFOztBQy9DcUU7QUFDQTtBQUNIO0FBQzdDO0FBQ0M7QUFDNkI7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0U7QUFDQTs7QUFFOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsY0FBYyxLQUFLO0FBQ25CLGNBQWMsS0FBSztBQUNuQixjQUFjLEtBQUs7QUFDbkIsY0FBYyxLQUFLO0FBQ25CLGNBQWMsS0FBSztBQUNuQixjQUFjLEtBQUs7QUFDbkIsY0FBYyxLQUFLO0FBQ25CLGNBQWMsS0FBSztBQUNuQixjQUFjLEtBQUs7QUFDbkIsZUFBZSxNQUFNO0FBQ3JCLGVBQWUsTUFBTTtBQUNyQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsbUNBQW1DLGVBQWUsSUFBSSxPQUFPLGNBQUssT0FBRTtBQUNwRTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsQ0FBQyIsInNvdXJjZXMiOlsid2VicGFjazovL2NvbG9ydHJhbnNsYXRvci8uL25vZGVfbW9kdWxlcy93aGF0d2ctZmV0Y2gvZmV0Y2guanM/NmQ5MyIsIndlYnBhY2s6Ly9jb2xvcnRyYW5zbGF0b3IvLi9zcmMvY29uc3RhbnRzL251bWJlcnMudHM/ZDU1OSIsIndlYnBhY2s6Ly9jb2xvcnRyYW5zbGF0b3IvLi9zcmMvY29uc3RhbnRzL2VudW1zLnRzP2Y1Y2EiLCJ3ZWJwYWNrOi8vY29sb3J0cmFuc2xhdG9yLy4vc3JjL2NvbnN0YW50cy9yZWdleHBzLnRzP2NmZjgiLCJ3ZWJwYWNrOi8vY29sb3J0cmFuc2xhdG9yLy4vc3JjL2NvbnN0YW50cy9lcnJvcnMudHM/N2E0ZCIsIndlYnBhY2s6Ly9jb2xvcnRyYW5zbGF0b3IvLi9zcmMvQHR5cGVzL2luZGV4LnRzPzNkY2EiLCJ3ZWJwYWNrOi8vY29sb3J0cmFuc2xhdG9yLy4vc3JjL2NvbnN0YW50cy9vcHRpb25zLnRzPzVhMzUiLCJ3ZWJwYWNrOi8vY29sb3J0cmFuc2xhdG9yLy4vc3JjL2NvbnN0YW50cy9pbmRleC50cz83MDJhIiwid2VicGFjazovL2NvbG9ydHJhbnNsYXRvci8uL3NyYy9oZWxwZXJzL2luZGV4LnRzPzc4YTEiLCJ3ZWJwYWNrOi8vY29sb3J0cmFuc2xhdG9yLy4vc3JjL2NvbG9yL3RyYW5zbGF0b3JzLnRzPzlmNzAiLCJ3ZWJwYWNrOi8vY29sb3J0cmFuc2xhdG9yLy4vc3JjL2NvbG9yL2Nzcy50cz82YjEyIiwid2VicGFjazovL2NvbG9ydHJhbnNsYXRvci8uL3NyYy9jb2xvci91dGlscy50cz82OWYzIiwid2VicGFjazovL2NvbG9ydHJhbnNsYXRvci8uL3NyYy9pbmRleC50cz9lOTRlIiwid2VicGFjazovL2NvbG9ydHJhbnNsYXRvci8uL3NyYy9AZGVtby9kZW1vMS9pbmRleC5qcz8zOTY1Iiwid2VicGFjazovL2NvbG9ydHJhbnNsYXRvci8uL3NyYy9AZGVtby9kZW1vMi9pbmRleC5qcz9kOGRjIiwid2VicGFjazovL2NvbG9ydHJhbnNsYXRvci8uL3NyYy9AZGVtby9kZW1vMy9pbmRleC5qcz9kMzg2Iiwid2VicGFjazovL2NvbG9ydHJhbnNsYXRvci8uL3NyYy9AZGVtby9kZW1vNC9pbmRleC5qcz82MTlmIiwid2VicGFjazovL2NvbG9ydHJhbnNsYXRvci8uL3NyYy9AZGVtby9kZW1vNS9pbmRleC5qcz9kOGNjIiwid2VicGFjazovL2NvbG9ydHJhbnNsYXRvci8uL3NyYy9AZGVtby9kZW1vNi9pbmRleC5qcz8zYTMyIiwid2VicGFjazovL2NvbG9ydHJhbnNsYXRvci8uL3NyYy9AZGVtby9kZW1vNy9pbmRleC5qcz84MzQzIiwid2VicGFjazovL2NvbG9ydHJhbnNsYXRvci8uL3NyYy9AZGVtby9kZW1vOC9pbmRleC5qcz83NzI1Iiwid2VicGFjazovL2NvbG9ydHJhbnNsYXRvci8uL3NyYy9AZGVtby9kZW1vOS9pbmRleC5qcz84NTMyIiwid2VicGFjazovL2NvbG9ydHJhbnNsYXRvci8uL3NyYy9AZGVtby9kZW1vMTAvaW5kZXguanM/NGY2NyIsIndlYnBhY2s6Ly9jb2xvcnRyYW5zbGF0b3IvLi9zcmMvQGRlbW8vZGVtbzExL2luZGV4LmpzP2RiZTYiLCJ3ZWJwYWNrOi8vY29sb3J0cmFuc2xhdG9yLy4vc3JjL0BkZW1vL2RlbW8uanM/OWI3ZCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiBlc2xpbnQtZGlzYWJsZSBuby1wcm90b3R5cGUtYnVpbHRpbnMgKi9cbnZhciBnID1cbiAgKHR5cGVvZiBnbG9iYWxUaGlzICE9PSAndW5kZWZpbmVkJyAmJiBnbG9iYWxUaGlzKSB8fFxuICAodHlwZW9mIHNlbGYgIT09ICd1bmRlZmluZWQnICYmIHNlbGYpIHx8XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bmRlZlxuICAodHlwZW9mIGdsb2JhbCAhPT0gJ3VuZGVmaW5lZCcgJiYgZ2xvYmFsKSB8fFxuICB7fVxuXG52YXIgc3VwcG9ydCA9IHtcbiAgc2VhcmNoUGFyYW1zOiAnVVJMU2VhcmNoUGFyYW1zJyBpbiBnLFxuICBpdGVyYWJsZTogJ1N5bWJvbCcgaW4gZyAmJiAnaXRlcmF0b3InIGluIFN5bWJvbCxcbiAgYmxvYjpcbiAgICAnRmlsZVJlYWRlcicgaW4gZyAmJlxuICAgICdCbG9iJyBpbiBnICYmXG4gICAgKGZ1bmN0aW9uKCkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgbmV3IEJsb2IoKVxuICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgIH1cbiAgICB9KSgpLFxuICBmb3JtRGF0YTogJ0Zvcm1EYXRhJyBpbiBnLFxuICBhcnJheUJ1ZmZlcjogJ0FycmF5QnVmZmVyJyBpbiBnXG59XG5cbmZ1bmN0aW9uIGlzRGF0YVZpZXcob2JqKSB7XG4gIHJldHVybiBvYmogJiYgRGF0YVZpZXcucHJvdG90eXBlLmlzUHJvdG90eXBlT2Yob2JqKVxufVxuXG5pZiAoc3VwcG9ydC5hcnJheUJ1ZmZlcikge1xuICB2YXIgdmlld0NsYXNzZXMgPSBbXG4gICAgJ1tvYmplY3QgSW50OEFycmF5XScsXG4gICAgJ1tvYmplY3QgVWludDhBcnJheV0nLFxuICAgICdbb2JqZWN0IFVpbnQ4Q2xhbXBlZEFycmF5XScsXG4gICAgJ1tvYmplY3QgSW50MTZBcnJheV0nLFxuICAgICdbb2JqZWN0IFVpbnQxNkFycmF5XScsXG4gICAgJ1tvYmplY3QgSW50MzJBcnJheV0nLFxuICAgICdbb2JqZWN0IFVpbnQzMkFycmF5XScsXG4gICAgJ1tvYmplY3QgRmxvYXQzMkFycmF5XScsXG4gICAgJ1tvYmplY3QgRmxvYXQ2NEFycmF5XSdcbiAgXVxuXG4gIHZhciBpc0FycmF5QnVmZmVyVmlldyA9XG4gICAgQXJyYXlCdWZmZXIuaXNWaWV3IHx8XG4gICAgZnVuY3Rpb24ob2JqKSB7XG4gICAgICByZXR1cm4gb2JqICYmIHZpZXdDbGFzc2VzLmluZGV4T2YoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG9iaikpID4gLTFcbiAgICB9XG59XG5cbmZ1bmN0aW9uIG5vcm1hbGl6ZU5hbWUobmFtZSkge1xuICBpZiAodHlwZW9mIG5hbWUgIT09ICdzdHJpbmcnKSB7XG4gICAgbmFtZSA9IFN0cmluZyhuYW1lKVxuICB9XG4gIGlmICgvW15hLXowLTlcXC0jJCUmJyorLl5fYHx+IV0vaS50ZXN0KG5hbWUpIHx8IG5hbWUgPT09ICcnKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignSW52YWxpZCBjaGFyYWN0ZXIgaW4gaGVhZGVyIGZpZWxkIG5hbWU6IFwiJyArIG5hbWUgKyAnXCInKVxuICB9XG4gIHJldHVybiBuYW1lLnRvTG93ZXJDYXNlKClcbn1cblxuZnVuY3Rpb24gbm9ybWFsaXplVmFsdWUodmFsdWUpIHtcbiAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ3N0cmluZycpIHtcbiAgICB2YWx1ZSA9IFN0cmluZyh2YWx1ZSlcbiAgfVxuICByZXR1cm4gdmFsdWVcbn1cblxuLy8gQnVpbGQgYSBkZXN0cnVjdGl2ZSBpdGVyYXRvciBmb3IgdGhlIHZhbHVlIGxpc3RcbmZ1bmN0aW9uIGl0ZXJhdG9yRm9yKGl0ZW1zKSB7XG4gIHZhciBpdGVyYXRvciA9IHtcbiAgICBuZXh0OiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciB2YWx1ZSA9IGl0ZW1zLnNoaWZ0KClcbiAgICAgIHJldHVybiB7ZG9uZTogdmFsdWUgPT09IHVuZGVmaW5lZCwgdmFsdWU6IHZhbHVlfVxuICAgIH1cbiAgfVxuXG4gIGlmIChzdXBwb3J0Lml0ZXJhYmxlKSB7XG4gICAgaXRlcmF0b3JbU3ltYm9sLml0ZXJhdG9yXSA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIGl0ZXJhdG9yXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGl0ZXJhdG9yXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBIZWFkZXJzKGhlYWRlcnMpIHtcbiAgdGhpcy5tYXAgPSB7fVxuXG4gIGlmIChoZWFkZXJzIGluc3RhbmNlb2YgSGVhZGVycykge1xuICAgIGhlYWRlcnMuZm9yRWFjaChmdW5jdGlvbih2YWx1ZSwgbmFtZSkge1xuICAgICAgdGhpcy5hcHBlbmQobmFtZSwgdmFsdWUpXG4gICAgfSwgdGhpcylcbiAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KGhlYWRlcnMpKSB7XG4gICAgaGVhZGVycy5mb3JFYWNoKGZ1bmN0aW9uKGhlYWRlcikge1xuICAgICAgaWYgKGhlYWRlci5sZW5ndGggIT0gMikge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdIZWFkZXJzIGNvbnN0cnVjdG9yOiBleHBlY3RlZCBuYW1lL3ZhbHVlIHBhaXIgdG8gYmUgbGVuZ3RoIDIsIGZvdW5kJyArIGhlYWRlci5sZW5ndGgpXG4gICAgICB9XG4gICAgICB0aGlzLmFwcGVuZChoZWFkZXJbMF0sIGhlYWRlclsxXSlcbiAgICB9LCB0aGlzKVxuICB9IGVsc2UgaWYgKGhlYWRlcnMpIHtcbiAgICBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhoZWFkZXJzKS5mb3JFYWNoKGZ1bmN0aW9uKG5hbWUpIHtcbiAgICAgIHRoaXMuYXBwZW5kKG5hbWUsIGhlYWRlcnNbbmFtZV0pXG4gICAgfSwgdGhpcylcbiAgfVxufVxuXG5IZWFkZXJzLnByb3RvdHlwZS5hcHBlbmQgPSBmdW5jdGlvbihuYW1lLCB2YWx1ZSkge1xuICBuYW1lID0gbm9ybWFsaXplTmFtZShuYW1lKVxuICB2YWx1ZSA9IG5vcm1hbGl6ZVZhbHVlKHZhbHVlKVxuICB2YXIgb2xkVmFsdWUgPSB0aGlzLm1hcFtuYW1lXVxuICB0aGlzLm1hcFtuYW1lXSA9IG9sZFZhbHVlID8gb2xkVmFsdWUgKyAnLCAnICsgdmFsdWUgOiB2YWx1ZVxufVxuXG5IZWFkZXJzLnByb3RvdHlwZVsnZGVsZXRlJ10gPSBmdW5jdGlvbihuYW1lKSB7XG4gIGRlbGV0ZSB0aGlzLm1hcFtub3JtYWxpemVOYW1lKG5hbWUpXVxufVxuXG5IZWFkZXJzLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbihuYW1lKSB7XG4gIG5hbWUgPSBub3JtYWxpemVOYW1lKG5hbWUpXG4gIHJldHVybiB0aGlzLmhhcyhuYW1lKSA/IHRoaXMubWFwW25hbWVdIDogbnVsbFxufVxuXG5IZWFkZXJzLnByb3RvdHlwZS5oYXMgPSBmdW5jdGlvbihuYW1lKSB7XG4gIHJldHVybiB0aGlzLm1hcC5oYXNPd25Qcm9wZXJ0eShub3JtYWxpemVOYW1lKG5hbWUpKVxufVxuXG5IZWFkZXJzLnByb3RvdHlwZS5zZXQgPSBmdW5jdGlvbihuYW1lLCB2YWx1ZSkge1xuICB0aGlzLm1hcFtub3JtYWxpemVOYW1lKG5hbWUpXSA9IG5vcm1hbGl6ZVZhbHVlKHZhbHVlKVxufVxuXG5IZWFkZXJzLnByb3RvdHlwZS5mb3JFYWNoID0gZnVuY3Rpb24oY2FsbGJhY2ssIHRoaXNBcmcpIHtcbiAgZm9yICh2YXIgbmFtZSBpbiB0aGlzLm1hcCkge1xuICAgIGlmICh0aGlzLm1hcC5oYXNPd25Qcm9wZXJ0eShuYW1lKSkge1xuICAgICAgY2FsbGJhY2suY2FsbCh0aGlzQXJnLCB0aGlzLm1hcFtuYW1lXSwgbmFtZSwgdGhpcylcbiAgICB9XG4gIH1cbn1cblxuSGVhZGVycy5wcm90b3R5cGUua2V5cyA9IGZ1bmN0aW9uKCkge1xuICB2YXIgaXRlbXMgPSBbXVxuICB0aGlzLmZvckVhY2goZnVuY3Rpb24odmFsdWUsIG5hbWUpIHtcbiAgICBpdGVtcy5wdXNoKG5hbWUpXG4gIH0pXG4gIHJldHVybiBpdGVyYXRvckZvcihpdGVtcylcbn1cblxuSGVhZGVycy5wcm90b3R5cGUudmFsdWVzID0gZnVuY3Rpb24oKSB7XG4gIHZhciBpdGVtcyA9IFtdXG4gIHRoaXMuZm9yRWFjaChmdW5jdGlvbih2YWx1ZSkge1xuICAgIGl0ZW1zLnB1c2godmFsdWUpXG4gIH0pXG4gIHJldHVybiBpdGVyYXRvckZvcihpdGVtcylcbn1cblxuSGVhZGVycy5wcm90b3R5cGUuZW50cmllcyA9IGZ1bmN0aW9uKCkge1xuICB2YXIgaXRlbXMgPSBbXVxuICB0aGlzLmZvckVhY2goZnVuY3Rpb24odmFsdWUsIG5hbWUpIHtcbiAgICBpdGVtcy5wdXNoKFtuYW1lLCB2YWx1ZV0pXG4gIH0pXG4gIHJldHVybiBpdGVyYXRvckZvcihpdGVtcylcbn1cblxuaWYgKHN1cHBvcnQuaXRlcmFibGUpIHtcbiAgSGVhZGVycy5wcm90b3R5cGVbU3ltYm9sLml0ZXJhdG9yXSA9IEhlYWRlcnMucHJvdG90eXBlLmVudHJpZXNcbn1cblxuZnVuY3Rpb24gY29uc3VtZWQoYm9keSkge1xuICBpZiAoYm9keS5fbm9Cb2R5KSByZXR1cm5cbiAgaWYgKGJvZHkuYm9keVVzZWQpIHtcbiAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IFR5cGVFcnJvcignQWxyZWFkeSByZWFkJykpXG4gIH1cbiAgYm9keS5ib2R5VXNlZCA9IHRydWVcbn1cblxuZnVuY3Rpb24gZmlsZVJlYWRlclJlYWR5KHJlYWRlcikge1xuICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgcmVhZGVyLm9ubG9hZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmVzb2x2ZShyZWFkZXIucmVzdWx0KVxuICAgIH1cbiAgICByZWFkZXIub25lcnJvciA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmVqZWN0KHJlYWRlci5lcnJvcilcbiAgICB9XG4gIH0pXG59XG5cbmZ1bmN0aW9uIHJlYWRCbG9iQXNBcnJheUJ1ZmZlcihibG9iKSB7XG4gIHZhciByZWFkZXIgPSBuZXcgRmlsZVJlYWRlcigpXG4gIHZhciBwcm9taXNlID0gZmlsZVJlYWRlclJlYWR5KHJlYWRlcilcbiAgcmVhZGVyLnJlYWRBc0FycmF5QnVmZmVyKGJsb2IpXG4gIHJldHVybiBwcm9taXNlXG59XG5cbmZ1bmN0aW9uIHJlYWRCbG9iQXNUZXh0KGJsb2IpIHtcbiAgdmFyIHJlYWRlciA9IG5ldyBGaWxlUmVhZGVyKClcbiAgdmFyIHByb21pc2UgPSBmaWxlUmVhZGVyUmVhZHkocmVhZGVyKVxuICB2YXIgbWF0Y2ggPSAvY2hhcnNldD0oW0EtWmEtejAtOV8tXSspLy5leGVjKGJsb2IudHlwZSlcbiAgdmFyIGVuY29kaW5nID0gbWF0Y2ggPyBtYXRjaFsxXSA6ICd1dGYtOCdcbiAgcmVhZGVyLnJlYWRBc1RleHQoYmxvYiwgZW5jb2RpbmcpXG4gIHJldHVybiBwcm9taXNlXG59XG5cbmZ1bmN0aW9uIHJlYWRBcnJheUJ1ZmZlckFzVGV4dChidWYpIHtcbiAgdmFyIHZpZXcgPSBuZXcgVWludDhBcnJheShidWYpXG4gIHZhciBjaGFycyA9IG5ldyBBcnJheSh2aWV3Lmxlbmd0aClcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IHZpZXcubGVuZ3RoOyBpKyspIHtcbiAgICBjaGFyc1tpXSA9IFN0cmluZy5mcm9tQ2hhckNvZGUodmlld1tpXSlcbiAgfVxuICByZXR1cm4gY2hhcnMuam9pbignJylcbn1cblxuZnVuY3Rpb24gYnVmZmVyQ2xvbmUoYnVmKSB7XG4gIGlmIChidWYuc2xpY2UpIHtcbiAgICByZXR1cm4gYnVmLnNsaWNlKDApXG4gIH0gZWxzZSB7XG4gICAgdmFyIHZpZXcgPSBuZXcgVWludDhBcnJheShidWYuYnl0ZUxlbmd0aClcbiAgICB2aWV3LnNldChuZXcgVWludDhBcnJheShidWYpKVxuICAgIHJldHVybiB2aWV3LmJ1ZmZlclxuICB9XG59XG5cbmZ1bmN0aW9uIEJvZHkoKSB7XG4gIHRoaXMuYm9keVVzZWQgPSBmYWxzZVxuXG4gIHRoaXMuX2luaXRCb2R5ID0gZnVuY3Rpb24oYm9keSkge1xuICAgIC8qXG4gICAgICBmZXRjaC1tb2NrIHdyYXBzIHRoZSBSZXNwb25zZSBvYmplY3QgaW4gYW4gRVM2IFByb3h5IHRvXG4gICAgICBwcm92aWRlIHVzZWZ1bCB0ZXN0IGhhcm5lc3MgZmVhdHVyZXMgc3VjaCBhcyBmbHVzaC4gSG93ZXZlciwgb25cbiAgICAgIEVTNSBicm93c2VycyB3aXRob3V0IGZldGNoIG9yIFByb3h5IHN1cHBvcnQgcG9sbHlmaWxscyBtdXN0IGJlIHVzZWQ7XG4gICAgICB0aGUgcHJveHktcG9sbHlmaWxsIGlzIHVuYWJsZSB0byBwcm94eSBhbiBhdHRyaWJ1dGUgdW5sZXNzIGl0IGV4aXN0c1xuICAgICAgb24gdGhlIG9iamVjdCBiZWZvcmUgdGhlIFByb3h5IGlzIGNyZWF0ZWQuIFRoaXMgY2hhbmdlIGVuc3VyZXNcbiAgICAgIFJlc3BvbnNlLmJvZHlVc2VkIGV4aXN0cyBvbiB0aGUgaW5zdGFuY2UsIHdoaWxlIG1haW50YWluaW5nIHRoZVxuICAgICAgc2VtYW50aWMgb2Ygc2V0dGluZyBSZXF1ZXN0LmJvZHlVc2VkIGluIHRoZSBjb25zdHJ1Y3RvciBiZWZvcmVcbiAgICAgIF9pbml0Qm9keSBpcyBjYWxsZWQuXG4gICAgKi9cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tc2VsZi1hc3NpZ25cbiAgICB0aGlzLmJvZHlVc2VkID0gdGhpcy5ib2R5VXNlZFxuICAgIHRoaXMuX2JvZHlJbml0ID0gYm9keVxuICAgIGlmICghYm9keSkge1xuICAgICAgdGhpcy5fbm9Cb2R5ID0gdHJ1ZTtcbiAgICAgIHRoaXMuX2JvZHlUZXh0ID0gJydcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBib2R5ID09PSAnc3RyaW5nJykge1xuICAgICAgdGhpcy5fYm9keVRleHQgPSBib2R5XG4gICAgfSBlbHNlIGlmIChzdXBwb3J0LmJsb2IgJiYgQmxvYi5wcm90b3R5cGUuaXNQcm90b3R5cGVPZihib2R5KSkge1xuICAgICAgdGhpcy5fYm9keUJsb2IgPSBib2R5XG4gICAgfSBlbHNlIGlmIChzdXBwb3J0LmZvcm1EYXRhICYmIEZvcm1EYXRhLnByb3RvdHlwZS5pc1Byb3RvdHlwZU9mKGJvZHkpKSB7XG4gICAgICB0aGlzLl9ib2R5Rm9ybURhdGEgPSBib2R5XG4gICAgfSBlbHNlIGlmIChzdXBwb3J0LnNlYXJjaFBhcmFtcyAmJiBVUkxTZWFyY2hQYXJhbXMucHJvdG90eXBlLmlzUHJvdG90eXBlT2YoYm9keSkpIHtcbiAgICAgIHRoaXMuX2JvZHlUZXh0ID0gYm9keS50b1N0cmluZygpXG4gICAgfSBlbHNlIGlmIChzdXBwb3J0LmFycmF5QnVmZmVyICYmIHN1cHBvcnQuYmxvYiAmJiBpc0RhdGFWaWV3KGJvZHkpKSB7XG4gICAgICB0aGlzLl9ib2R5QXJyYXlCdWZmZXIgPSBidWZmZXJDbG9uZShib2R5LmJ1ZmZlcilcbiAgICAgIC8vIElFIDEwLTExIGNhbid0IGhhbmRsZSBhIERhdGFWaWV3IGJvZHkuXG4gICAgICB0aGlzLl9ib2R5SW5pdCA9IG5ldyBCbG9iKFt0aGlzLl9ib2R5QXJyYXlCdWZmZXJdKVxuICAgIH0gZWxzZSBpZiAoc3VwcG9ydC5hcnJheUJ1ZmZlciAmJiAoQXJyYXlCdWZmZXIucHJvdG90eXBlLmlzUHJvdG90eXBlT2YoYm9keSkgfHwgaXNBcnJheUJ1ZmZlclZpZXcoYm9keSkpKSB7XG4gICAgICB0aGlzLl9ib2R5QXJyYXlCdWZmZXIgPSBidWZmZXJDbG9uZShib2R5KVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9ib2R5VGV4dCA9IGJvZHkgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoYm9keSlcbiAgICB9XG5cbiAgICBpZiAoIXRoaXMuaGVhZGVycy5nZXQoJ2NvbnRlbnQtdHlwZScpKSB7XG4gICAgICBpZiAodHlwZW9mIGJvZHkgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHRoaXMuaGVhZGVycy5zZXQoJ2NvbnRlbnQtdHlwZScsICd0ZXh0L3BsYWluO2NoYXJzZXQ9VVRGLTgnKVxuICAgICAgfSBlbHNlIGlmICh0aGlzLl9ib2R5QmxvYiAmJiB0aGlzLl9ib2R5QmxvYi50eXBlKSB7XG4gICAgICAgIHRoaXMuaGVhZGVycy5zZXQoJ2NvbnRlbnQtdHlwZScsIHRoaXMuX2JvZHlCbG9iLnR5cGUpXG4gICAgICB9IGVsc2UgaWYgKHN1cHBvcnQuc2VhcmNoUGFyYW1zICYmIFVSTFNlYXJjaFBhcmFtcy5wcm90b3R5cGUuaXNQcm90b3R5cGVPZihib2R5KSkge1xuICAgICAgICB0aGlzLmhlYWRlcnMuc2V0KCdjb250ZW50LXR5cGUnLCAnYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkO2NoYXJzZXQ9VVRGLTgnKVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGlmIChzdXBwb3J0LmJsb2IpIHtcbiAgICB0aGlzLmJsb2IgPSBmdW5jdGlvbigpIHtcbiAgICAgIHZhciByZWplY3RlZCA9IGNvbnN1bWVkKHRoaXMpXG4gICAgICBpZiAocmVqZWN0ZWQpIHtcbiAgICAgICAgcmV0dXJuIHJlamVjdGVkXG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLl9ib2R5QmxvYikge1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHRoaXMuX2JvZHlCbG9iKVxuICAgICAgfSBlbHNlIGlmICh0aGlzLl9ib2R5QXJyYXlCdWZmZXIpIHtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShuZXcgQmxvYihbdGhpcy5fYm9keUFycmF5QnVmZmVyXSkpXG4gICAgICB9IGVsc2UgaWYgKHRoaXMuX2JvZHlGb3JtRGF0YSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2NvdWxkIG5vdCByZWFkIEZvcm1EYXRhIGJvZHkgYXMgYmxvYicpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKG5ldyBCbG9iKFt0aGlzLl9ib2R5VGV4dF0pKVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHRoaXMuYXJyYXlCdWZmZXIgPSBmdW5jdGlvbigpIHtcbiAgICBpZiAodGhpcy5fYm9keUFycmF5QnVmZmVyKSB7XG4gICAgICB2YXIgaXNDb25zdW1lZCA9IGNvbnN1bWVkKHRoaXMpXG4gICAgICBpZiAoaXNDb25zdW1lZCkge1xuICAgICAgICByZXR1cm4gaXNDb25zdW1lZFxuICAgICAgfSBlbHNlIGlmIChBcnJheUJ1ZmZlci5pc1ZpZXcodGhpcy5fYm9keUFycmF5QnVmZmVyKSkge1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKFxuICAgICAgICAgIHRoaXMuX2JvZHlBcnJheUJ1ZmZlci5idWZmZXIuc2xpY2UoXG4gICAgICAgICAgICB0aGlzLl9ib2R5QXJyYXlCdWZmZXIuYnl0ZU9mZnNldCxcbiAgICAgICAgICAgIHRoaXMuX2JvZHlBcnJheUJ1ZmZlci5ieXRlT2Zmc2V0ICsgdGhpcy5fYm9keUFycmF5QnVmZmVyLmJ5dGVMZW5ndGhcbiAgICAgICAgICApXG4gICAgICAgIClcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUodGhpcy5fYm9keUFycmF5QnVmZmVyKVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoc3VwcG9ydC5ibG9iKSB7XG4gICAgICByZXR1cm4gdGhpcy5ibG9iKCkudGhlbihyZWFkQmxvYkFzQXJyYXlCdWZmZXIpXG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignY291bGQgbm90IHJlYWQgYXMgQXJyYXlCdWZmZXInKVxuICAgIH1cbiAgfVxuXG4gIHRoaXMudGV4dCA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciByZWplY3RlZCA9IGNvbnN1bWVkKHRoaXMpXG4gICAgaWYgKHJlamVjdGVkKSB7XG4gICAgICByZXR1cm4gcmVqZWN0ZWRcbiAgICB9XG5cbiAgICBpZiAodGhpcy5fYm9keUJsb2IpIHtcbiAgICAgIHJldHVybiByZWFkQmxvYkFzVGV4dCh0aGlzLl9ib2R5QmxvYilcbiAgICB9IGVsc2UgaWYgKHRoaXMuX2JvZHlBcnJheUJ1ZmZlcikge1xuICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShyZWFkQXJyYXlCdWZmZXJBc1RleHQodGhpcy5fYm9keUFycmF5QnVmZmVyKSlcbiAgICB9IGVsc2UgaWYgKHRoaXMuX2JvZHlGb3JtRGF0YSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdjb3VsZCBub3QgcmVhZCBGb3JtRGF0YSBib2R5IGFzIHRleHQnKVxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHRoaXMuX2JvZHlUZXh0KVxuICAgIH1cbiAgfVxuXG4gIGlmIChzdXBwb3J0LmZvcm1EYXRhKSB7XG4gICAgdGhpcy5mb3JtRGF0YSA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMudGV4dCgpLnRoZW4oZGVjb2RlKVxuICAgIH1cbiAgfVxuXG4gIHRoaXMuanNvbiA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLnRleHQoKS50aGVuKEpTT04ucGFyc2UpXG4gIH1cblxuICByZXR1cm4gdGhpc1xufVxuXG4vLyBIVFRQIG1ldGhvZHMgd2hvc2UgY2FwaXRhbGl6YXRpb24gc2hvdWxkIGJlIG5vcm1hbGl6ZWRcbnZhciBtZXRob2RzID0gWydDT05ORUNUJywgJ0RFTEVURScsICdHRVQnLCAnSEVBRCcsICdPUFRJT05TJywgJ1BBVENIJywgJ1BPU1QnLCAnUFVUJywgJ1RSQUNFJ11cblxuZnVuY3Rpb24gbm9ybWFsaXplTWV0aG9kKG1ldGhvZCkge1xuICB2YXIgdXBjYXNlZCA9IG1ldGhvZC50b1VwcGVyQ2FzZSgpXG4gIHJldHVybiBtZXRob2RzLmluZGV4T2YodXBjYXNlZCkgPiAtMSA/IHVwY2FzZWQgOiBtZXRob2Rcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIFJlcXVlc3QoaW5wdXQsIG9wdGlvbnMpIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFJlcXVlc3QpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignUGxlYXNlIHVzZSB0aGUgXCJuZXdcIiBvcGVyYXRvciwgdGhpcyBET00gb2JqZWN0IGNvbnN0cnVjdG9yIGNhbm5vdCBiZSBjYWxsZWQgYXMgYSBmdW5jdGlvbi4nKVxuICB9XG5cbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge31cbiAgdmFyIGJvZHkgPSBvcHRpb25zLmJvZHlcblxuICBpZiAoaW5wdXQgaW5zdGFuY2VvZiBSZXF1ZXN0KSB7XG4gICAgaWYgKGlucHV0LmJvZHlVc2VkKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBbHJlYWR5IHJlYWQnKVxuICAgIH1cbiAgICB0aGlzLnVybCA9IGlucHV0LnVybFxuICAgIHRoaXMuY3JlZGVudGlhbHMgPSBpbnB1dC5jcmVkZW50aWFsc1xuICAgIGlmICghb3B0aW9ucy5oZWFkZXJzKSB7XG4gICAgICB0aGlzLmhlYWRlcnMgPSBuZXcgSGVhZGVycyhpbnB1dC5oZWFkZXJzKVxuICAgIH1cbiAgICB0aGlzLm1ldGhvZCA9IGlucHV0Lm1ldGhvZFxuICAgIHRoaXMubW9kZSA9IGlucHV0Lm1vZGVcbiAgICB0aGlzLnNpZ25hbCA9IGlucHV0LnNpZ25hbFxuICAgIGlmICghYm9keSAmJiBpbnB1dC5fYm9keUluaXQgIT0gbnVsbCkge1xuICAgICAgYm9keSA9IGlucHV0Ll9ib2R5SW5pdFxuICAgICAgaW5wdXQuYm9keVVzZWQgPSB0cnVlXG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHRoaXMudXJsID0gU3RyaW5nKGlucHV0KVxuICB9XG5cbiAgdGhpcy5jcmVkZW50aWFscyA9IG9wdGlvbnMuY3JlZGVudGlhbHMgfHwgdGhpcy5jcmVkZW50aWFscyB8fCAnc2FtZS1vcmlnaW4nXG4gIGlmIChvcHRpb25zLmhlYWRlcnMgfHwgIXRoaXMuaGVhZGVycykge1xuICAgIHRoaXMuaGVhZGVycyA9IG5ldyBIZWFkZXJzKG9wdGlvbnMuaGVhZGVycylcbiAgfVxuICB0aGlzLm1ldGhvZCA9IG5vcm1hbGl6ZU1ldGhvZChvcHRpb25zLm1ldGhvZCB8fCB0aGlzLm1ldGhvZCB8fCAnR0VUJylcbiAgdGhpcy5tb2RlID0gb3B0aW9ucy5tb2RlIHx8IHRoaXMubW9kZSB8fCBudWxsXG4gIHRoaXMuc2lnbmFsID0gb3B0aW9ucy5zaWduYWwgfHwgdGhpcy5zaWduYWwgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoJ0Fib3J0Q29udHJvbGxlcicgaW4gZykge1xuICAgICAgdmFyIGN0cmwgPSBuZXcgQWJvcnRDb250cm9sbGVyKCk7XG4gICAgICByZXR1cm4gY3RybC5zaWduYWw7XG4gICAgfVxuICB9KCkpO1xuICB0aGlzLnJlZmVycmVyID0gbnVsbFxuXG4gIGlmICgodGhpcy5tZXRob2QgPT09ICdHRVQnIHx8IHRoaXMubWV0aG9kID09PSAnSEVBRCcpICYmIGJvZHkpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdCb2R5IG5vdCBhbGxvd2VkIGZvciBHRVQgb3IgSEVBRCByZXF1ZXN0cycpXG4gIH1cbiAgdGhpcy5faW5pdEJvZHkoYm9keSlcblxuICBpZiAodGhpcy5tZXRob2QgPT09ICdHRVQnIHx8IHRoaXMubWV0aG9kID09PSAnSEVBRCcpIHtcbiAgICBpZiAob3B0aW9ucy5jYWNoZSA9PT0gJ25vLXN0b3JlJyB8fCBvcHRpb25zLmNhY2hlID09PSAnbm8tY2FjaGUnKSB7XG4gICAgICAvLyBTZWFyY2ggZm9yIGEgJ18nIHBhcmFtZXRlciBpbiB0aGUgcXVlcnkgc3RyaW5nXG4gICAgICB2YXIgcmVQYXJhbVNlYXJjaCA9IC8oWz8mXSlfPVteJl0qL1xuICAgICAgaWYgKHJlUGFyYW1TZWFyY2gudGVzdCh0aGlzLnVybCkpIHtcbiAgICAgICAgLy8gSWYgaXQgYWxyZWFkeSBleGlzdHMgdGhlbiBzZXQgdGhlIHZhbHVlIHdpdGggdGhlIGN1cnJlbnQgdGltZVxuICAgICAgICB0aGlzLnVybCA9IHRoaXMudXJsLnJlcGxhY2UocmVQYXJhbVNlYXJjaCwgJyQxXz0nICsgbmV3IERhdGUoKS5nZXRUaW1lKCkpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBPdGhlcndpc2UgYWRkIGEgbmV3ICdfJyBwYXJhbWV0ZXIgdG8gdGhlIGVuZCB3aXRoIHRoZSBjdXJyZW50IHRpbWVcbiAgICAgICAgdmFyIHJlUXVlcnlTdHJpbmcgPSAvXFw/L1xuICAgICAgICB0aGlzLnVybCArPSAocmVRdWVyeVN0cmluZy50ZXN0KHRoaXMudXJsKSA/ICcmJyA6ICc/JykgKyAnXz0nICsgbmV3IERhdGUoKS5nZXRUaW1lKClcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuUmVxdWVzdC5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIG5ldyBSZXF1ZXN0KHRoaXMsIHtib2R5OiB0aGlzLl9ib2R5SW5pdH0pXG59XG5cbmZ1bmN0aW9uIGRlY29kZShib2R5KSB7XG4gIHZhciBmb3JtID0gbmV3IEZvcm1EYXRhKClcbiAgYm9keVxuICAgIC50cmltKClcbiAgICAuc3BsaXQoJyYnKVxuICAgIC5mb3JFYWNoKGZ1bmN0aW9uKGJ5dGVzKSB7XG4gICAgICBpZiAoYnl0ZXMpIHtcbiAgICAgICAgdmFyIHNwbGl0ID0gYnl0ZXMuc3BsaXQoJz0nKVxuICAgICAgICB2YXIgbmFtZSA9IHNwbGl0LnNoaWZ0KCkucmVwbGFjZSgvXFwrL2csICcgJylcbiAgICAgICAgdmFyIHZhbHVlID0gc3BsaXQuam9pbignPScpLnJlcGxhY2UoL1xcKy9nLCAnICcpXG4gICAgICAgIGZvcm0uYXBwZW5kKGRlY29kZVVSSUNvbXBvbmVudChuYW1lKSwgZGVjb2RlVVJJQ29tcG9uZW50KHZhbHVlKSlcbiAgICAgIH1cbiAgICB9KVxuICByZXR1cm4gZm9ybVxufVxuXG5mdW5jdGlvbiBwYXJzZUhlYWRlcnMocmF3SGVhZGVycykge1xuICB2YXIgaGVhZGVycyA9IG5ldyBIZWFkZXJzKClcbiAgLy8gUmVwbGFjZSBpbnN0YW5jZXMgb2YgXFxyXFxuIGFuZCBcXG4gZm9sbG93ZWQgYnkgYXQgbGVhc3Qgb25lIHNwYWNlIG9yIGhvcml6b250YWwgdGFiIHdpdGggYSBzcGFjZVxuICAvLyBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjNzIzMCNzZWN0aW9uLTMuMlxuICB2YXIgcHJlUHJvY2Vzc2VkSGVhZGVycyA9IHJhd0hlYWRlcnMucmVwbGFjZSgvXFxyP1xcbltcXHQgXSsvZywgJyAnKVxuICAvLyBBdm9pZGluZyBzcGxpdCB2aWEgcmVnZXggdG8gd29yayBhcm91bmQgYSBjb21tb24gSUUxMSBidWcgd2l0aCB0aGUgY29yZS1qcyAzLjYuMCByZWdleCBwb2x5ZmlsbFxuICAvLyBodHRwczovL2dpdGh1Yi5jb20vZ2l0aHViL2ZldGNoL2lzc3Vlcy83NDhcbiAgLy8gaHR0cHM6Ly9naXRodWIuY29tL3psb2lyb2NrL2NvcmUtanMvaXNzdWVzLzc1MVxuICBwcmVQcm9jZXNzZWRIZWFkZXJzXG4gICAgLnNwbGl0KCdcXHInKVxuICAgIC5tYXAoZnVuY3Rpb24oaGVhZGVyKSB7XG4gICAgICByZXR1cm4gaGVhZGVyLmluZGV4T2YoJ1xcbicpID09PSAwID8gaGVhZGVyLnN1YnN0cigxLCBoZWFkZXIubGVuZ3RoKSA6IGhlYWRlclxuICAgIH0pXG4gICAgLmZvckVhY2goZnVuY3Rpb24obGluZSkge1xuICAgICAgdmFyIHBhcnRzID0gbGluZS5zcGxpdCgnOicpXG4gICAgICB2YXIga2V5ID0gcGFydHMuc2hpZnQoKS50cmltKClcbiAgICAgIGlmIChrZXkpIHtcbiAgICAgICAgdmFyIHZhbHVlID0gcGFydHMuam9pbignOicpLnRyaW0oKVxuICAgICAgICB0cnkge1xuICAgICAgICAgIGhlYWRlcnMuYXBwZW5kKGtleSwgdmFsdWUpXG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgY29uc29sZS53YXJuKCdSZXNwb25zZSAnICsgZXJyb3IubWVzc2FnZSlcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pXG4gIHJldHVybiBoZWFkZXJzXG59XG5cbkJvZHkuY2FsbChSZXF1ZXN0LnByb3RvdHlwZSlcblxuZXhwb3J0IGZ1bmN0aW9uIFJlc3BvbnNlKGJvZHlJbml0LCBvcHRpb25zKSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBSZXNwb25zZSkpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdQbGVhc2UgdXNlIHRoZSBcIm5ld1wiIG9wZXJhdG9yLCB0aGlzIERPTSBvYmplY3QgY29uc3RydWN0b3IgY2Fubm90IGJlIGNhbGxlZCBhcyBhIGZ1bmN0aW9uLicpXG4gIH1cbiAgaWYgKCFvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IHt9XG4gIH1cblxuICB0aGlzLnR5cGUgPSAnZGVmYXVsdCdcbiAgdGhpcy5zdGF0dXMgPSBvcHRpb25zLnN0YXR1cyA9PT0gdW5kZWZpbmVkID8gMjAwIDogb3B0aW9ucy5zdGF0dXNcbiAgaWYgKHRoaXMuc3RhdHVzIDwgMjAwIHx8IHRoaXMuc3RhdHVzID4gNTk5KSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJGYWlsZWQgdG8gY29uc3RydWN0ICdSZXNwb25zZSc6IFRoZSBzdGF0dXMgcHJvdmlkZWQgKDApIGlzIG91dHNpZGUgdGhlIHJhbmdlIFsyMDAsIDU5OV0uXCIpXG4gIH1cbiAgdGhpcy5vayA9IHRoaXMuc3RhdHVzID49IDIwMCAmJiB0aGlzLnN0YXR1cyA8IDMwMFxuICB0aGlzLnN0YXR1c1RleHQgPSBvcHRpb25zLnN0YXR1c1RleHQgPT09IHVuZGVmaW5lZCA/ICcnIDogJycgKyBvcHRpb25zLnN0YXR1c1RleHRcbiAgdGhpcy5oZWFkZXJzID0gbmV3IEhlYWRlcnMob3B0aW9ucy5oZWFkZXJzKVxuICB0aGlzLnVybCA9IG9wdGlvbnMudXJsIHx8ICcnXG4gIHRoaXMuX2luaXRCb2R5KGJvZHlJbml0KVxufVxuXG5Cb2R5LmNhbGwoUmVzcG9uc2UucHJvdG90eXBlKVxuXG5SZXNwb25zZS5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIG5ldyBSZXNwb25zZSh0aGlzLl9ib2R5SW5pdCwge1xuICAgIHN0YXR1czogdGhpcy5zdGF0dXMsXG4gICAgc3RhdHVzVGV4dDogdGhpcy5zdGF0dXNUZXh0LFxuICAgIGhlYWRlcnM6IG5ldyBIZWFkZXJzKHRoaXMuaGVhZGVycyksXG4gICAgdXJsOiB0aGlzLnVybFxuICB9KVxufVxuXG5SZXNwb25zZS5lcnJvciA9IGZ1bmN0aW9uKCkge1xuICB2YXIgcmVzcG9uc2UgPSBuZXcgUmVzcG9uc2UobnVsbCwge3N0YXR1czogMjAwLCBzdGF0dXNUZXh0OiAnJ30pXG4gIHJlc3BvbnNlLm9rID0gZmFsc2VcbiAgcmVzcG9uc2Uuc3RhdHVzID0gMFxuICByZXNwb25zZS50eXBlID0gJ2Vycm9yJ1xuICByZXR1cm4gcmVzcG9uc2Vcbn1cblxudmFyIHJlZGlyZWN0U3RhdHVzZXMgPSBbMzAxLCAzMDIsIDMwMywgMzA3LCAzMDhdXG5cblJlc3BvbnNlLnJlZGlyZWN0ID0gZnVuY3Rpb24odXJsLCBzdGF0dXMpIHtcbiAgaWYgKHJlZGlyZWN0U3RhdHVzZXMuaW5kZXhPZihzdGF0dXMpID09PSAtMSkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdJbnZhbGlkIHN0YXR1cyBjb2RlJylcbiAgfVxuXG4gIHJldHVybiBuZXcgUmVzcG9uc2UobnVsbCwge3N0YXR1czogc3RhdHVzLCBoZWFkZXJzOiB7bG9jYXRpb246IHVybH19KVxufVxuXG5leHBvcnQgdmFyIERPTUV4Y2VwdGlvbiA9IGcuRE9NRXhjZXB0aW9uXG50cnkge1xuICBuZXcgRE9NRXhjZXB0aW9uKClcbn0gY2F0Y2ggKGVycikge1xuICBET01FeGNlcHRpb24gPSBmdW5jdGlvbihtZXNzYWdlLCBuYW1lKSB7XG4gICAgdGhpcy5tZXNzYWdlID0gbWVzc2FnZVxuICAgIHRoaXMubmFtZSA9IG5hbWVcbiAgICB2YXIgZXJyb3IgPSBFcnJvcihtZXNzYWdlKVxuICAgIHRoaXMuc3RhY2sgPSBlcnJvci5zdGFja1xuICB9XG4gIERPTUV4Y2VwdGlvbi5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEVycm9yLnByb3RvdHlwZSlcbiAgRE9NRXhjZXB0aW9uLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IERPTUV4Y2VwdGlvblxufVxuXG5leHBvcnQgZnVuY3Rpb24gZmV0Y2goaW5wdXQsIGluaXQpIHtcbiAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkge1xuICAgIHZhciByZXF1ZXN0ID0gbmV3IFJlcXVlc3QoaW5wdXQsIGluaXQpXG5cbiAgICBpZiAocmVxdWVzdC5zaWduYWwgJiYgcmVxdWVzdC5zaWduYWwuYWJvcnRlZCkge1xuICAgICAgcmV0dXJuIHJlamVjdChuZXcgRE9NRXhjZXB0aW9uKCdBYm9ydGVkJywgJ0Fib3J0RXJyb3InKSlcbiAgICB9XG5cbiAgICB2YXIgeGhyID0gbmV3IFhNTEh0dHBSZXF1ZXN0KClcblxuICAgIGZ1bmN0aW9uIGFib3J0WGhyKCkge1xuICAgICAgeGhyLmFib3J0KClcbiAgICB9XG5cbiAgICB4aHIub25sb2FkID0gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgb3B0aW9ucyA9IHtcbiAgICAgICAgc3RhdHVzVGV4dDogeGhyLnN0YXR1c1RleHQsXG4gICAgICAgIGhlYWRlcnM6IHBhcnNlSGVhZGVycyh4aHIuZ2V0QWxsUmVzcG9uc2VIZWFkZXJzKCkgfHwgJycpXG4gICAgICB9XG4gICAgICAvLyBUaGlzIGNoZWNrIGlmIHNwZWNpZmljYWxseSBmb3Igd2hlbiBhIHVzZXIgZmV0Y2hlcyBhIGZpbGUgbG9jYWxseSBmcm9tIHRoZSBmaWxlIHN5c3RlbVxuICAgICAgLy8gT25seSBpZiB0aGUgc3RhdHVzIGlzIG91dCBvZiBhIG5vcm1hbCByYW5nZVxuICAgICAgaWYgKHJlcXVlc3QudXJsLmluZGV4T2YoJ2ZpbGU6Ly8nKSA9PT0gMCAmJiAoeGhyLnN0YXR1cyA8IDIwMCB8fCB4aHIuc3RhdHVzID4gNTk5KSkge1xuICAgICAgICBvcHRpb25zLnN0YXR1cyA9IDIwMDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG9wdGlvbnMuc3RhdHVzID0geGhyLnN0YXR1cztcbiAgICAgIH1cbiAgICAgIG9wdGlvbnMudXJsID0gJ3Jlc3BvbnNlVVJMJyBpbiB4aHIgPyB4aHIucmVzcG9uc2VVUkwgOiBvcHRpb25zLmhlYWRlcnMuZ2V0KCdYLVJlcXVlc3QtVVJMJylcbiAgICAgIHZhciBib2R5ID0gJ3Jlc3BvbnNlJyBpbiB4aHIgPyB4aHIucmVzcG9uc2UgOiB4aHIucmVzcG9uc2VUZXh0XG4gICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICByZXNvbHZlKG5ldyBSZXNwb25zZShib2R5LCBvcHRpb25zKSlcbiAgICAgIH0sIDApXG4gICAgfVxuXG4gICAgeGhyLm9uZXJyb3IgPSBmdW5jdGlvbigpIHtcbiAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgIHJlamVjdChuZXcgVHlwZUVycm9yKCdOZXR3b3JrIHJlcXVlc3QgZmFpbGVkJykpXG4gICAgICB9LCAwKVxuICAgIH1cblxuICAgIHhoci5vbnRpbWVvdXQgPSBmdW5jdGlvbigpIHtcbiAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgIHJlamVjdChuZXcgVHlwZUVycm9yKCdOZXR3b3JrIHJlcXVlc3QgdGltZWQgb3V0JykpXG4gICAgICB9LCAwKVxuICAgIH1cblxuICAgIHhoci5vbmFib3J0ID0gZnVuY3Rpb24oKSB7XG4gICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICByZWplY3QobmV3IERPTUV4Y2VwdGlvbignQWJvcnRlZCcsICdBYm9ydEVycm9yJykpXG4gICAgICB9LCAwKVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGZpeFVybCh1cmwpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHJldHVybiB1cmwgPT09ICcnICYmIGcubG9jYXRpb24uaHJlZiA/IGcubG9jYXRpb24uaHJlZiA6IHVybFxuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICByZXR1cm4gdXJsXG4gICAgICB9XG4gICAgfVxuXG4gICAgeGhyLm9wZW4ocmVxdWVzdC5tZXRob2QsIGZpeFVybChyZXF1ZXN0LnVybCksIHRydWUpXG5cbiAgICBpZiAocmVxdWVzdC5jcmVkZW50aWFscyA9PT0gJ2luY2x1ZGUnKSB7XG4gICAgICB4aHIud2l0aENyZWRlbnRpYWxzID0gdHJ1ZVxuICAgIH0gZWxzZSBpZiAocmVxdWVzdC5jcmVkZW50aWFscyA9PT0gJ29taXQnKSB7XG4gICAgICB4aHIud2l0aENyZWRlbnRpYWxzID0gZmFsc2VcbiAgICB9XG5cbiAgICBpZiAoJ3Jlc3BvbnNlVHlwZScgaW4geGhyKSB7XG4gICAgICBpZiAoc3VwcG9ydC5ibG9iKSB7XG4gICAgICAgIHhoci5yZXNwb25zZVR5cGUgPSAnYmxvYidcbiAgICAgIH0gZWxzZSBpZiAoXG4gICAgICAgIHN1cHBvcnQuYXJyYXlCdWZmZXJcbiAgICAgICkge1xuICAgICAgICB4aHIucmVzcG9uc2VUeXBlID0gJ2FycmF5YnVmZmVyJ1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChpbml0ICYmIHR5cGVvZiBpbml0LmhlYWRlcnMgPT09ICdvYmplY3QnICYmICEoaW5pdC5oZWFkZXJzIGluc3RhbmNlb2YgSGVhZGVycyB8fCAoZy5IZWFkZXJzICYmIGluaXQuaGVhZGVycyBpbnN0YW5jZW9mIGcuSGVhZGVycykpKSB7XG4gICAgICB2YXIgbmFtZXMgPSBbXTtcbiAgICAgIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKGluaXQuaGVhZGVycykuZm9yRWFjaChmdW5jdGlvbihuYW1lKSB7XG4gICAgICAgIG5hbWVzLnB1c2gobm9ybWFsaXplTmFtZShuYW1lKSlcbiAgICAgICAgeGhyLnNldFJlcXVlc3RIZWFkZXIobmFtZSwgbm9ybWFsaXplVmFsdWUoaW5pdC5oZWFkZXJzW25hbWVdKSlcbiAgICAgIH0pXG4gICAgICByZXF1ZXN0LmhlYWRlcnMuZm9yRWFjaChmdW5jdGlvbih2YWx1ZSwgbmFtZSkge1xuICAgICAgICBpZiAobmFtZXMuaW5kZXhPZihuYW1lKSA9PT0gLTEpIHtcbiAgICAgICAgICB4aHIuc2V0UmVxdWVzdEhlYWRlcihuYW1lLCB2YWx1ZSlcbiAgICAgICAgfVxuICAgICAgfSlcbiAgICB9IGVsc2Uge1xuICAgICAgcmVxdWVzdC5oZWFkZXJzLmZvckVhY2goZnVuY3Rpb24odmFsdWUsIG5hbWUpIHtcbiAgICAgICAgeGhyLnNldFJlcXVlc3RIZWFkZXIobmFtZSwgdmFsdWUpXG4gICAgICB9KVxuICAgIH1cblxuICAgIGlmIChyZXF1ZXN0LnNpZ25hbCkge1xuICAgICAgcmVxdWVzdC5zaWduYWwuYWRkRXZlbnRMaXN0ZW5lcignYWJvcnQnLCBhYm9ydFhocilcblxuICAgICAgeGhyLm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAvLyBET05FIChzdWNjZXNzIG9yIGZhaWx1cmUpXG4gICAgICAgIGlmICh4aHIucmVhZHlTdGF0ZSA9PT0gNCkge1xuICAgICAgICAgIHJlcXVlc3Quc2lnbmFsLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2Fib3J0JywgYWJvcnRYaHIpXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICB4aHIuc2VuZCh0eXBlb2YgcmVxdWVzdC5fYm9keUluaXQgPT09ICd1bmRlZmluZWQnID8gbnVsbCA6IHJlcXVlc3QuX2JvZHlJbml0KVxuICB9KVxufVxuXG5mZXRjaC5wb2x5ZmlsbCA9IHRydWVcblxuaWYgKCFnLmZldGNoKSB7XG4gIGcuZmV0Y2ggPSBmZXRjaFxuICBnLkhlYWRlcnMgPSBIZWFkZXJzXG4gIGcuUmVxdWVzdCA9IFJlcXVlc3RcbiAgZy5SZXNwb25zZSA9IFJlc3BvbnNlXG59XG4iLCJleHBvcnQgY29uc3QgTUFYX0RFQ0lNQUxTID0gNjtcbmV4cG9ydCBjb25zdCBERUZBVUxUX0JMRU5EX1NURVBTID0gNTtcbmV4cG9ydCBjb25zdCBERUZBVUxUX1NIQURFU19USU5UU19TVEVQUyA9IDU7XG4iLCJleHBvcnQgdmFyIENvbG9yTW9kZWw7XG4oZnVuY3Rpb24gKENvbG9yTW9kZWwpIHtcbiAgICBDb2xvck1vZGVsW1wiSEVYXCJdID0gXCJIRVhcIjtcbiAgICBDb2xvck1vZGVsW1wiUkdCXCJdID0gXCJSR0JcIjtcbiAgICBDb2xvck1vZGVsW1wiSFNMXCJdID0gXCJIU0xcIjtcbiAgICBDb2xvck1vZGVsW1wiQ0lFTGFiXCJdID0gXCJDSUVMYWJcIjtcbiAgICBDb2xvck1vZGVsW1wiQ01ZS1wiXSA9IFwiQ01ZS1wiO1xufSkoQ29sb3JNb2RlbCB8fCAoQ29sb3JNb2RlbCA9IHt9KSk7XG5leHBvcnQgdmFyIEhhcm1vbnk7XG4oZnVuY3Rpb24gKEhhcm1vbnkpIHtcbiAgICBIYXJtb255W1wiQU5BTE9HT1VTXCJdID0gXCJBTkFMT0dPVVNcIjtcbiAgICBIYXJtb255W1wiQ09NUExFTUVOVEFSWVwiXSA9IFwiQ09NUExFTUVOVEFSWVwiO1xuICAgIEhhcm1vbnlbXCJTUExJVF9DT01QTEVNRU5UQVJZXCJdID0gXCJTUExJVF9DT01QTEVNRU5UQVJZXCI7XG4gICAgSGFybW9ueVtcIlRSSUFESUNcIl0gPSBcIlRSSUFESUNcIjtcbiAgICBIYXJtb255W1wiVEVUUkFESUNcIl0gPSBcIlRFVFJBRElDXCI7XG4gICAgSGFybW9ueVtcIlNRVUFSRVwiXSA9IFwiU1FVQVJFXCI7XG59KShIYXJtb255IHx8IChIYXJtb255ID0ge30pKTtcbmV4cG9ydCB2YXIgTWl4O1xuKGZ1bmN0aW9uIChNaXgpIHtcbiAgICBNaXhbXCJBRERJVElWRVwiXSA9IFwiQURESVRJVkVcIjtcbiAgICBNaXhbXCJTVUJUUkFDVElWRVwiXSA9IFwiU1VCVFJBQ1RJVkVcIjtcbn0pKE1peCB8fCAoTWl4ID0ge30pKTtcbmV4cG9ydCB2YXIgQ29sb3JLZXl3b3JkcztcbihmdW5jdGlvbiAoQ29sb3JLZXl3b3Jkcykge1xuICAgIENvbG9yS2V5d29yZHNbXCJibGFja1wiXSA9IFwiIzAwMDAwMFwiO1xuICAgIENvbG9yS2V5d29yZHNbXCJzaWx2ZXJcIl0gPSBcIiNDMEMwQzBcIjtcbiAgICBDb2xvcktleXdvcmRzW1wiZ3JheVwiXSA9IFwiIzgwODA4MFwiO1xuICAgIENvbG9yS2V5d29yZHNbXCJ3aGl0ZVwiXSA9IFwiI0ZGRkZGRlwiO1xuICAgIENvbG9yS2V5d29yZHNbXCJtYXJvb25cIl0gPSBcIiM4MDAwMDBcIjtcbiAgICBDb2xvcktleXdvcmRzW1wicmVkXCJdID0gXCIjRkYwMDAwXCI7XG4gICAgQ29sb3JLZXl3b3Jkc1tcInB1cnBsZVwiXSA9IFwiIzgwMDA4MFwiO1xuICAgIENvbG9yS2V5d29yZHNbXCJmdWNoc2lhXCJdID0gXCIjRkYwMEZGXCI7XG4gICAgQ29sb3JLZXl3b3Jkc1tcImdyZWVuXCJdID0gXCIjMDA4MDAwXCI7XG4gICAgQ29sb3JLZXl3b3Jkc1tcImxpbWVcIl0gPSBcIiMwMEZGMDBcIjtcbiAgICBDb2xvcktleXdvcmRzW1wib2xpdmVcIl0gPSBcIiM4MDgwMDBcIjtcbiAgICBDb2xvcktleXdvcmRzW1wieWVsbG93XCJdID0gXCIjRkZGRjAwXCI7XG4gICAgQ29sb3JLZXl3b3Jkc1tcIm5hdnlcIl0gPSBcIiMwMDAwODBcIjtcbiAgICBDb2xvcktleXdvcmRzW1wiYmx1ZVwiXSA9IFwiIzAwMDBGRlwiO1xuICAgIENvbG9yS2V5d29yZHNbXCJ0ZWFsXCJdID0gXCIjMDA4MDgwXCI7XG4gICAgQ29sb3JLZXl3b3Jkc1tcImFxdWFcIl0gPSBcIiMwMEZGRkZcIjtcbiAgICBDb2xvcktleXdvcmRzW1wib3JhbmdlXCJdID0gXCIjRkZBNTAwXCI7XG4gICAgQ29sb3JLZXl3b3Jkc1tcImFsaWNlYmx1ZVwiXSA9IFwiI0YwRjhGRlwiO1xuICAgIENvbG9yS2V5d29yZHNbXCJhbnRpcXVld2hpdGVcIl0gPSBcIiNGQUVCRDdcIjtcbiAgICBDb2xvcktleXdvcmRzW1wiYXF1YW1hcmluZVwiXSA9IFwiIzdGRkZENFwiO1xuICAgIENvbG9yS2V5d29yZHNbXCJhenVyZVwiXSA9IFwiI0YwRkZGRlwiO1xuICAgIENvbG9yS2V5d29yZHNbXCJiZWlnZVwiXSA9IFwiI0Y1RjVEQ1wiO1xuICAgIENvbG9yS2V5d29yZHNbXCJiaXNxdWVcIl0gPSBcIiNGRkU0QzRcIjtcbiAgICBDb2xvcktleXdvcmRzW1wiYmxhbmNoZWRhbG1vbmRcIl0gPSBcIiNGRkVCQ0RcIjtcbiAgICBDb2xvcktleXdvcmRzW1wiYmx1ZXZpb2xldFwiXSA9IFwiIzhBMkJFMlwiO1xuICAgIENvbG9yS2V5d29yZHNbXCJicm93blwiXSA9IFwiI0E1MkEyQVwiO1xuICAgIENvbG9yS2V5d29yZHNbXCJidXJseXdvb2RcIl0gPSBcIiNERUI4ODdcIjtcbiAgICBDb2xvcktleXdvcmRzW1wiY2FkZXRibHVlXCJdID0gXCIjNUY5RUEwXCI7XG4gICAgQ29sb3JLZXl3b3Jkc1tcImNoYXJ0cmV1c2VcIl0gPSBcIiM3RkZGMDBcIjtcbiAgICBDb2xvcktleXdvcmRzW1wiY2hvY29sYXRlXCJdID0gXCIjRDI2OTFFXCI7XG4gICAgQ29sb3JLZXl3b3Jkc1tcImNvcmFsXCJdID0gXCIjRkY3RjUwXCI7XG4gICAgQ29sb3JLZXl3b3Jkc1tcImNvcm5mbG93ZXJibHVlXCJdID0gXCIjNjQ5NUVEXCI7XG4gICAgQ29sb3JLZXl3b3Jkc1tcImNvcm5zaWxrXCJdID0gXCIjRkZGOERDXCI7XG4gICAgQ29sb3JLZXl3b3Jkc1tcImNyaW1zb25cIl0gPSBcIiNEQzE0M0NcIjtcbiAgICBDb2xvcktleXdvcmRzW1wiY3lhblwiXSA9IFwiIzAwRkZGRlwiO1xuICAgIENvbG9yS2V5d29yZHNbXCJkYXJrYmx1ZVwiXSA9IFwiIzAwMDA4QlwiO1xuICAgIENvbG9yS2V5d29yZHNbXCJkYXJrY3lhblwiXSA9IFwiIzAwOEI4QlwiO1xuICAgIENvbG9yS2V5d29yZHNbXCJkYXJrZ29sZGVucm9kXCJdID0gXCIjQjg4NjBCXCI7XG4gICAgQ29sb3JLZXl3b3Jkc1tcImRhcmtncmF5XCJdID0gXCIjQTlBOUE5XCI7XG4gICAgQ29sb3JLZXl3b3Jkc1tcImRhcmtncmVlblwiXSA9IFwiIzAwNjQwMFwiO1xuICAgIENvbG9yS2V5d29yZHNbXCJkYXJrZ3JleVwiXSA9IFwiI0E5QTlBOVwiO1xuICAgIENvbG9yS2V5d29yZHNbXCJkYXJra2hha2lcIl0gPSBcIiNCREI3NkJcIjtcbiAgICBDb2xvcktleXdvcmRzW1wiZGFya21hZ2VudGFcIl0gPSBcIiM4QjAwOEJcIjtcbiAgICBDb2xvcktleXdvcmRzW1wiZGFya29saXZlZ3JlZW5cIl0gPSBcIiM1NTZCMkZcIjtcbiAgICBDb2xvcktleXdvcmRzW1wiZGFya29yYW5nZVwiXSA9IFwiI0ZGOEMwMFwiO1xuICAgIENvbG9yS2V5d29yZHNbXCJkYXJrb3JjaGlkXCJdID0gXCIjOTkzMkNDXCI7XG4gICAgQ29sb3JLZXl3b3Jkc1tcImRhcmtyZWRcIl0gPSBcIiM4QjAwMDBcIjtcbiAgICBDb2xvcktleXdvcmRzW1wiZGFya3NhbG1vblwiXSA9IFwiI0U5OTY3QVwiO1xuICAgIENvbG9yS2V5d29yZHNbXCJkYXJrc2VhZ3JlZW5cIl0gPSBcIiM4RkJDOEZcIjtcbiAgICBDb2xvcktleXdvcmRzW1wiZGFya3NsYXRlYmx1ZVwiXSA9IFwiIzQ4M0Q4QlwiO1xuICAgIENvbG9yS2V5d29yZHNbXCJkYXJrc2xhdGVncmF5XCJdID0gXCIjMkY0RjRGXCI7XG4gICAgQ29sb3JLZXl3b3Jkc1tcImRhcmtzbGF0ZWdyZXlcIl0gPSBcIiMyRjRGNEZcIjtcbiAgICBDb2xvcktleXdvcmRzW1wiZGFya3R1cnF1b2lzZVwiXSA9IFwiIzAwQ0VEMVwiO1xuICAgIENvbG9yS2V5d29yZHNbXCJkYXJrdmlvbGV0XCJdID0gXCIjOTQwMEQzXCI7XG4gICAgQ29sb3JLZXl3b3Jkc1tcImRlZXBwaW5rXCJdID0gXCIjRkYxNDkzXCI7XG4gICAgQ29sb3JLZXl3b3Jkc1tcImRlZXBza3libHVlXCJdID0gXCIjMDBCRkZGXCI7XG4gICAgQ29sb3JLZXl3b3Jkc1tcImRpbWdyYXlcIl0gPSBcIiM2OTY5NjlcIjtcbiAgICBDb2xvcktleXdvcmRzW1wiZGltZ3JleVwiXSA9IFwiIzY5Njk2OVwiO1xuICAgIENvbG9yS2V5d29yZHNbXCJkb2RnZXJibHVlXCJdID0gXCIjMUU5MEZGXCI7XG4gICAgQ29sb3JLZXl3b3Jkc1tcImZpcmVicmlja1wiXSA9IFwiI0IyMjIyMlwiO1xuICAgIENvbG9yS2V5d29yZHNbXCJmbG9yYWx3aGl0ZVwiXSA9IFwiI0ZGRkFGMFwiO1xuICAgIENvbG9yS2V5d29yZHNbXCJmb3Jlc3RncmVlblwiXSA9IFwiIzIyOEIyMlwiO1xuICAgIENvbG9yS2V5d29yZHNbXCJnYWluc2Jvcm9cIl0gPSBcIiNEQ0RDRENcIjtcbiAgICBDb2xvcktleXdvcmRzW1wiZ2hvc3R3aGl0ZVwiXSA9IFwiI0Y4RjhGRlwiO1xuICAgIENvbG9yS2V5d29yZHNbXCJnb2xkXCJdID0gXCIjRkZENzAwXCI7XG4gICAgQ29sb3JLZXl3b3Jkc1tcImdvbGRlbnJvZFwiXSA9IFwiI0RBQTUyMFwiO1xuICAgIENvbG9yS2V5d29yZHNbXCJncmVlbnllbGxvd1wiXSA9IFwiI0FERkYyRlwiO1xuICAgIENvbG9yS2V5d29yZHNbXCJncmV5XCJdID0gXCIjODA4MDgwXCI7XG4gICAgQ29sb3JLZXl3b3Jkc1tcImhvbmV5ZGV3XCJdID0gXCIjRjBGRkYwXCI7XG4gICAgQ29sb3JLZXl3b3Jkc1tcImhvdHBpbmtcIl0gPSBcIiNGRjY5QjRcIjtcbiAgICBDb2xvcktleXdvcmRzW1wiaW5kaWFucmVkXCJdID0gXCIjQ0Q1QzVDXCI7XG4gICAgQ29sb3JLZXl3b3Jkc1tcImluZGlnb1wiXSA9IFwiIzRCMDA4MlwiO1xuICAgIENvbG9yS2V5d29yZHNbXCJpdm9yeVwiXSA9IFwiI0ZGRkZGMFwiO1xuICAgIENvbG9yS2V5d29yZHNbXCJraGFraVwiXSA9IFwiI0YwRTY4Q1wiO1xuICAgIENvbG9yS2V5d29yZHNbXCJsYXZlbmRlclwiXSA9IFwiI0U2RTZGQVwiO1xuICAgIENvbG9yS2V5d29yZHNbXCJsYXZlbmRlcmJsdXNoXCJdID0gXCIjRkZGMEY1XCI7XG4gICAgQ29sb3JLZXl3b3Jkc1tcImxhd25ncmVlblwiXSA9IFwiIzdDRkMwMFwiO1xuICAgIENvbG9yS2V5d29yZHNbXCJsZW1vbmNoaWZmb25cIl0gPSBcIiNGRkZBQ0RcIjtcbiAgICBDb2xvcktleXdvcmRzW1wibGlnaHRibHVlXCJdID0gXCIjQUREOEU2XCI7XG4gICAgQ29sb3JLZXl3b3Jkc1tcImxpZ2h0Y29yYWxcIl0gPSBcIiNGMDgwODBcIjtcbiAgICBDb2xvcktleXdvcmRzW1wibGlnaHRjeWFuXCJdID0gXCIjRTBGRkZGXCI7XG4gICAgQ29sb3JLZXl3b3Jkc1tcImxpZ2h0Z29sZGVucm9keWVsbG93XCJdID0gXCIjRkFGQUQyXCI7XG4gICAgQ29sb3JLZXl3b3Jkc1tcImxpZ2h0Z3JheVwiXSA9IFwiI0QzRDNEM1wiO1xuICAgIENvbG9yS2V5d29yZHNbXCJsaWdodGdyZWVuXCJdID0gXCIjOTBFRTkwXCI7XG4gICAgQ29sb3JLZXl3b3Jkc1tcImxpZ2h0Z3JleVwiXSA9IFwiI0QzRDNEM1wiO1xuICAgIENvbG9yS2V5d29yZHNbXCJsaWdodHBpbmtcIl0gPSBcIiNGRkI2QzFcIjtcbiAgICBDb2xvcktleXdvcmRzW1wibGlnaHRzYWxtb25cIl0gPSBcIiNGRkEwN0FcIjtcbiAgICBDb2xvcktleXdvcmRzW1wibGlnaHRzZWFncmVlblwiXSA9IFwiIzIwQjJBQVwiO1xuICAgIENvbG9yS2V5d29yZHNbXCJsaWdodHNreWJsdWVcIl0gPSBcIiM4N0NFRkFcIjtcbiAgICBDb2xvcktleXdvcmRzW1wibGlnaHRzbGF0ZWdyYXlcIl0gPSBcIiM3Nzg4OTlcIjtcbiAgICBDb2xvcktleXdvcmRzW1wibGlnaHRzbGF0ZWdyZXlcIl0gPSBcIiM3Nzg4OTlcIjtcbiAgICBDb2xvcktleXdvcmRzW1wibGlnaHRzdGVlbGJsdWVcIl0gPSBcIiNCMEM0REVcIjtcbiAgICBDb2xvcktleXdvcmRzW1wibGlnaHR5ZWxsb3dcIl0gPSBcIiNGRkZGRTBcIjtcbiAgICBDb2xvcktleXdvcmRzW1wibGltZWdyZWVuXCJdID0gXCIjMzJDRDMyXCI7XG4gICAgQ29sb3JLZXl3b3Jkc1tcImxpbmVuXCJdID0gXCIjRkFGMEU2XCI7XG4gICAgQ29sb3JLZXl3b3Jkc1tcIm1hZ2VudGFcIl0gPSBcIiNGRjAwRkZcIjtcbiAgICBDb2xvcktleXdvcmRzW1wibWVkaXVtYXF1YW1hcmluZVwiXSA9IFwiIzY2Q0RBQVwiO1xuICAgIENvbG9yS2V5d29yZHNbXCJtZWRpdW1ibHVlXCJdID0gXCIjMDAwMENEXCI7XG4gICAgQ29sb3JLZXl3b3Jkc1tcIm1lZGl1bW9yY2hpZFwiXSA9IFwiI0JBNTVEM1wiO1xuICAgIENvbG9yS2V5d29yZHNbXCJtZWRpdW1wdXJwbGVcIl0gPSBcIiM5MzcwREJcIjtcbiAgICBDb2xvcktleXdvcmRzW1wibWVkaXVtc2VhZ3JlZW5cIl0gPSBcIiMzQ0IzNzFcIjtcbiAgICBDb2xvcktleXdvcmRzW1wibWVkaXVtc2xhdGVibHVlXCJdID0gXCIjN0I2OEVFXCI7XG4gICAgQ29sb3JLZXl3b3Jkc1tcIm1lZGl1bXNwcmluZ2dyZWVuXCJdID0gXCIjMDBGQTlBXCI7XG4gICAgQ29sb3JLZXl3b3Jkc1tcIm1lZGl1bXR1cnF1b2lzZVwiXSA9IFwiIzQ4RDFDQ1wiO1xuICAgIENvbG9yS2V5d29yZHNbXCJtZWRpdW12aW9sZXRyZWRcIl0gPSBcIiNDNzE1ODVcIjtcbiAgICBDb2xvcktleXdvcmRzW1wibWlkbmlnaHRibHVlXCJdID0gXCIjMTkxOTcwXCI7XG4gICAgQ29sb3JLZXl3b3Jkc1tcIm1pbnRjcmVhbVwiXSA9IFwiI0Y1RkZGQVwiO1xuICAgIENvbG9yS2V5d29yZHNbXCJtaXN0eXJvc2VcIl0gPSBcIiNGRkU0RTFcIjtcbiAgICBDb2xvcktleXdvcmRzW1wibW9jY2FzaW5cIl0gPSBcIiNGRkU0QjVcIjtcbiAgICBDb2xvcktleXdvcmRzW1wibmF2YWpvd2hpdGVcIl0gPSBcIiNGRkRFQURcIjtcbiAgICBDb2xvcktleXdvcmRzW1wib2xkbGFjZVwiXSA9IFwiI0ZERjVFNlwiO1xuICAgIENvbG9yS2V5d29yZHNbXCJvbGl2ZWRyYWJcIl0gPSBcIiM2QjhFMjNcIjtcbiAgICBDb2xvcktleXdvcmRzW1wib3JhbmdlcmVkXCJdID0gXCIjRkY0NTAwXCI7XG4gICAgQ29sb3JLZXl3b3Jkc1tcIm9yY2hpZFwiXSA9IFwiI0RBNzBENlwiO1xuICAgIENvbG9yS2V5d29yZHNbXCJwYWxlZ29sZGVucm9kXCJdID0gXCIjRUVFOEFBXCI7XG4gICAgQ29sb3JLZXl3b3Jkc1tcInBhbGVncmVlblwiXSA9IFwiIzk4RkI5OFwiO1xuICAgIENvbG9yS2V5d29yZHNbXCJwYWxldHVycXVvaXNlXCJdID0gXCIjQUZFRUVFXCI7XG4gICAgQ29sb3JLZXl3b3Jkc1tcInBhbGV2aW9sZXRyZWRcIl0gPSBcIiNEQjcwOTNcIjtcbiAgICBDb2xvcktleXdvcmRzW1wicGFwYXlhd2hpcFwiXSA9IFwiI0ZGRUZENVwiO1xuICAgIENvbG9yS2V5d29yZHNbXCJwZWFjaHB1ZmZcIl0gPSBcIiNGRkRBQjlcIjtcbiAgICBDb2xvcktleXdvcmRzW1wicGVydVwiXSA9IFwiI0NEODUzRlwiO1xuICAgIENvbG9yS2V5d29yZHNbXCJwaW5rXCJdID0gXCIjRkZDMENCXCI7XG4gICAgQ29sb3JLZXl3b3Jkc1tcInBsdW1cIl0gPSBcIiNEREEwRERcIjtcbiAgICBDb2xvcktleXdvcmRzW1wicG93ZGVyYmx1ZVwiXSA9IFwiI0IwRTBFNlwiO1xuICAgIENvbG9yS2V5d29yZHNbXCJyb3N5YnJvd25cIl0gPSBcIiNCQzhGOEZcIjtcbiAgICBDb2xvcktleXdvcmRzW1wicm95YWxibHVlXCJdID0gXCIjNDE2OUUxXCI7XG4gICAgQ29sb3JLZXl3b3Jkc1tcInNhZGRsZWJyb3duXCJdID0gXCIjOEI0NTEzXCI7XG4gICAgQ29sb3JLZXl3b3Jkc1tcInNhbG1vblwiXSA9IFwiI0ZBODA3MlwiO1xuICAgIENvbG9yS2V5d29yZHNbXCJzYW5keWJyb3duXCJdID0gXCIjRjRBNDYwXCI7XG4gICAgQ29sb3JLZXl3b3Jkc1tcInNlYWdyZWVuXCJdID0gXCIjMkU4QjU3XCI7XG4gICAgQ29sb3JLZXl3b3Jkc1tcInNlYXNoZWxsXCJdID0gXCIjRkZGNUVFXCI7XG4gICAgQ29sb3JLZXl3b3Jkc1tcInNpZW5uYVwiXSA9IFwiI0EwNTIyRFwiO1xuICAgIENvbG9yS2V5d29yZHNbXCJza3libHVlXCJdID0gXCIjODdDRUVCXCI7XG4gICAgQ29sb3JLZXl3b3Jkc1tcInNsYXRlYmx1ZVwiXSA9IFwiIzZBNUFDRFwiO1xuICAgIENvbG9yS2V5d29yZHNbXCJzbGF0ZWdyYXlcIl0gPSBcIiM3MDgwOTBcIjtcbiAgICBDb2xvcktleXdvcmRzW1wic2xhdGVncmV5XCJdID0gXCIjNzA4MDkwXCI7XG4gICAgQ29sb3JLZXl3b3Jkc1tcInNub3dcIl0gPSBcIiNGRkZBRkFcIjtcbiAgICBDb2xvcktleXdvcmRzW1wic3ByaW5nZ3JlZW5cIl0gPSBcIiMwMEZGN0ZcIjtcbiAgICBDb2xvcktleXdvcmRzW1wic3RlZWxibHVlXCJdID0gXCIjNDY4MkI0XCI7XG4gICAgQ29sb3JLZXl3b3Jkc1tcInRhblwiXSA9IFwiI0QyQjQ4Q1wiO1xuICAgIENvbG9yS2V5d29yZHNbXCJ0aGlzdGxlXCJdID0gXCIjRDhCRkQ4XCI7XG4gICAgQ29sb3JLZXl3b3Jkc1tcInRvbWF0b1wiXSA9IFwiI0ZGNjM0N1wiO1xuICAgIENvbG9yS2V5d29yZHNbXCJ0dXJxdW9pc2VcIl0gPSBcIiM0MEUwRDBcIjtcbiAgICBDb2xvcktleXdvcmRzW1widmlvbGV0XCJdID0gXCIjRUU4MkVFXCI7XG4gICAgQ29sb3JLZXl3b3Jkc1tcIndoZWF0XCJdID0gXCIjRjVERUIzXCI7XG4gICAgQ29sb3JLZXl3b3Jkc1tcIndoaXRlc21va2VcIl0gPSBcIiNGNUY1RjVcIjtcbiAgICBDb2xvcktleXdvcmRzW1wieWVsbG93Z3JlZW5cIl0gPSBcIiM5QUNEMzJcIjtcbiAgICBDb2xvcktleXdvcmRzW1wicmViZWNjYXB1cnBsZVwiXSA9IFwiIzY2MzM5OVwiO1xufSkoQ29sb3JLZXl3b3JkcyB8fCAoQ29sb3JLZXl3b3JkcyA9IHt9KSk7XG5leHBvcnQgY29uc3QgQ09MT1JfS0VZUyA9IE9iamVjdC5rZXlzKENvbG9yS2V5d29yZHMpO1xuZXhwb3J0IGNvbnN0IENPTE9SX1BST1BTID0ge1xuICAgIEhFWDogWydSJywgJ0cnLCAnQicsICdBJ10sXG4gICAgUkdCOiBbJ1InLCAnRycsICdCJywgJ0EnXSxcbiAgICBIU0w6IFsnSCcsICdTJywgJ0wnLCAnQSddLFxuICAgIENJRUxhYjogWydMJywgJ2EnLCAnYicsICdBJ10sXG4gICAgQ01ZSzogWydDJywgJ00nLCAnWScsICdLJywgJ0EnXVxufTtcbmV4cG9ydCBjb25zdCBWQUxJRF9DT0xPUl9PQkpFQ1RTID0ge1xuICAgIEJHUjogQ29sb3JNb2RlbC5SR0IsXG4gICAgQUJHUjogQ29sb3JNb2RlbC5SR0IsXG4gICAgSExTOiBDb2xvck1vZGVsLkhTTCxcbiAgICBBSExTOiBDb2xvck1vZGVsLkhTTCxcbiAgICBMQUI6IENvbG9yTW9kZWwuQ0lFTGFiLFxuICAgIEFMQUI6IENvbG9yTW9kZWwuQ0lFTGFiLFxuICAgIENLTVk6IENvbG9yTW9kZWwuQ01ZSyxcbiAgICBBQ0tNWTogQ29sb3JNb2RlbC5DTVlLXG59O1xuZXhwb3J0IHZhciBUeXBlT2Y7XG4oZnVuY3Rpb24gKFR5cGVPZikge1xuICAgIFR5cGVPZltcIk5VTUJFUlwiXSA9IFwibnVtYmVyXCI7XG4gICAgVHlwZU9mW1wiQk9PTEVBTlwiXSA9IFwiYm9vbGVhblwiO1xufSkoVHlwZU9mIHx8IChUeXBlT2YgPSB7fSkpO1xuIiwiaW1wb3J0IHsgQ29sb3JNb2RlbCB9IGZyb20gJy4vZW51bXMnO1xuZXhwb3J0IGNvbnN0IENPTE9SUkVHUyA9IHtcbiAgICBbQ29sb3JNb2RlbC5IRVhdOiAvXiMoPzooW2EtZlxcZF0pKFthLWZcXGRdKShbYS1mXFxkXSkoW2EtZlxcZF0pP3woW2EtZlxcZF17Mn0pKFthLWZcXGRdezJ9KShbYS1mXFxkXXsyfSkoW2EtZlxcZF17Mn0pPykkL2ksXG4gICAgW0NvbG9yTW9kZWwuUkdCXTogL15yZ2JhP1xccypcXChcXHMqKD86KCg/OlxcZCpcXC4pP1xcZCslPylcXHMqLFxccyooKD86XFxkKlxcLik/XFxkKyU/KVxccyosXFxzKigoPzpcXGQqXFwuKT9cXGQrJT8pKD86XFxzKixcXHMqKCg/OlxcZCpcXC4pP1xcZCspKT98KCg/OlxcZCpcXC4pP1xcZCslPylcXHMqKCg/OlxcZCpcXC4pP1xcZCslPylcXHMqKCg/OlxcZCpcXC4pP1xcZCslPykoPzpcXHMqXFwvXFxzKigoPzpcXGQqXFwuKT9cXGQrJT8pKT8pXFxzKlxcKSQvLFxuICAgIFtDb2xvck1vZGVsLkhTTF06IC9eaHNsYT9cXHMqXFwoXFxzKig/OigtPyg/OlxcZCpcXC4pP1xcZCsoPzpkZWd8Z3JhZHxyYWR8dHVybik/KVxccyosXFxzKigoPzpcXGQqXFwuKT9cXGQrKSVcXHMqLFxccyooKD86XFxkKlxcLik/XFxkKyklKD86XFxzKixcXHMqKCg/OlxcZCpcXC4pP1xcZCspKT98KC0/KD86XFxkKlxcLik/XFxkKyg/OmRlZ3xncmFkfHJhZHx0dXJuKT8pXFxzKigoPzpcXGQqXFwuKT9cXGQrKSVcXHMqKCg/OlxcZCpcXC4pP1xcZCspJSg/OlxccypcXC9cXHMqKCg/OlxcZCpcXC4pP1xcZCslPykpPylcXHMqXFwpJC8sXG4gICAgW0NvbG9yTW9kZWwuQ0lFTGFiXTogL15sYWJcXHMqXFwoXFxzKig/OigoPzpcXGQqXFwuKT9cXGQrJT8pXFxzKigtPyg/OlxcZCpcXC4pP1xcZCslPylcXHMqKC0/KD86XFxkKlxcLik/XFxkKyU/KSg/OlxccypcXC9cXHMqKCg/OlxcZCpcXC4pP1xcZCslPykpPylcXHMqXFwpJC8sXG4gICAgW0NvbG9yTW9kZWwuQ01ZS106IC9eKD86ZGV2aWNlLWNteWt8Y215aylcXHMqXFwoXFxzKig/OigoPzpcXGQqXFwuKT9cXGQrJT8pXFxzKixcXHMqKCg/OlxcZCpcXC4pP1xcZCslPylcXHMqLFxccyooKD86XFxkKlxcLik/XFxkKyU/KVxccyosXFxzKigoPzpcXGQqXFwuKT9cXGQrJT8pKD86XFxzKixcXHMqKCg/OlxcZCpcXC4pP1xcZCspKT98KCg/OlxcZCpcXC4pP1xcZCslPylcXHMqKCg/OlxcZCpcXC4pP1xcZCslPylcXHMqKCg/OlxcZCpcXC4pP1xcZCslPylcXHMqKCg/OlxcZCpcXC4pP1xcZCslPykoPzpcXHMqXFwvXFxzKigoPzpcXGQqXFwuKT9cXGQrJT8pKT8pXFxzKlxcKSQvXG59O1xuZXhwb3J0IGNvbnN0IEhTTF9IVUUgPSAvXigtPyg/OlxcZCpcXC4pP1xcZCspKCg/OmRlZ3xncmFkfHJhZHx0dXJuKT8pJC87XG5leHBvcnQgY29uc3QgUENFTlQgPSAvXigtP1xcZCsoPzpcXC5cXGQrKT98LT9cXC5cXGQrKSUkLztcbmV4cG9ydCBjb25zdCBIRVggPSAvXjB4KFthLWZcXGRdezEsMn0pJC9pO1xuZXhwb3J0IGNvbnN0IFRFTVBMQVRFX1ZBUiA9IC9cXHsoXFxkKylcXH0vZztcbmV4cG9ydCBjb25zdCBDT01NQVNfQU5EX05FWFRfQ0hBUlMgPSAvLCggK3xcXGQrKS9nO1xuZXhwb3J0IGNvbnN0IFNQQUNFUyA9IC8gKy87XG4iLCJleHBvcnQgY29uc3QgRVJST1JTID0ge1xuICAgIE5PVF9BQ0NFUFRFRF9TVFJJTkdfSU5QVVQ6ICdUaGUgcHJvdmlkZWQgc3RyaW5nIGNvbG9yIGRvZXNuXFwndCBoYXZlIGEgY29ycmVjdCBmb3JtYXQnLFxuICAgIE5PVF9BQ0NFUFRFRF9PQkpFQ1RfSU5QVVQ6ICdUaGUgcHJvdmlkZWQgY29sb3Igb2JqZWN0IGRvZXNuXFwndCBoYXZlIHRoZSBwcm9wZXIga2V5cyBvciBmb3JtYXQnXG59O1xuIiwiZXhwb3J0IHZhciBBbmdsZXNVbml0RW51bTtcbihmdW5jdGlvbiAoQW5nbGVzVW5pdEVudW0pIHtcbiAgICBBbmdsZXNVbml0RW51bVtcIk5PTkVcIl0gPSBcIm5vbmVcIjtcbiAgICBBbmdsZXNVbml0RW51bVtcIkRFR1JFRVNcIl0gPSBcImRlZ1wiO1xuICAgIEFuZ2xlc1VuaXRFbnVtW1wiR1JBRElBTlNcIl0gPSBcImdyYWRcIjtcbiAgICBBbmdsZXNVbml0RW51bVtcIlJBRElBTlNcIl0gPSBcInJhZFwiO1xuICAgIEFuZ2xlc1VuaXRFbnVtW1wiVFVSTlNcIl0gPSBcInR1cm5cIjtcbn0pKEFuZ2xlc1VuaXRFbnVtIHx8IChBbmdsZXNVbml0RW51bSA9IHt9KSk7XG5leHBvcnQgdmFyIENvbG9yVW5pdEVudW07XG4oZnVuY3Rpb24gKENvbG9yVW5pdEVudW0pIHtcbiAgICBDb2xvclVuaXRFbnVtW1wiTk9ORVwiXSA9IFwibm9uZVwiO1xuICAgIENvbG9yVW5pdEVudW1bXCJQRVJDRU5UXCJdID0gXCJwZXJjZW50XCI7XG59KShDb2xvclVuaXRFbnVtIHx8IChDb2xvclVuaXRFbnVtID0ge30pKTtcbmV4cG9ydCB2YXIgQ01ZS0Z1bmN0aW9uRW51bTtcbihmdW5jdGlvbiAoQ01ZS0Z1bmN0aW9uRW51bSkge1xuICAgIENNWUtGdW5jdGlvbkVudW1bXCJERVZJQ0VfQ01ZS1wiXSA9IFwiZGV2aWNlLWNteWtcIjtcbiAgICBDTVlLRnVuY3Rpb25FbnVtW1wiQ01ZS1wiXSA9IFwiY215a1wiO1xufSkoQ01ZS0Z1bmN0aW9uRW51bSB8fCAoQ01ZS0Z1bmN0aW9uRW51bSA9IHt9KSk7XG4iLCJpbXBvcnQgeyBBbmdsZXNVbml0RW51bSwgQ29sb3JVbml0RW51bSwgQ01ZS0Z1bmN0aW9uRW51bSB9IGZyb20gJ0B0eXBlcyc7XG5pbXBvcnQgeyBNQVhfREVDSU1BTFMgfSBmcm9tICcuL251bWJlcnMnO1xuZXhwb3J0IGNvbnN0IERFRkFVTFRfT1BUSU9OUyA9IHtcbiAgICBkZWNpbWFsczogTUFYX0RFQ0lNQUxTLFxuICAgIGxlZ2FjeUNTUzogZmFsc2UsXG4gICAgc3BhY2VzQWZ0ZXJDb21tYXM6IGZhbHNlLFxuICAgIGFuZ2xlc1VuaXQ6IEFuZ2xlc1VuaXRFbnVtLk5PTkUsXG4gICAgcmdiVW5pdDogQ29sb3JVbml0RW51bS5OT05FLFxuICAgIGxhYlVuaXQ6IENvbG9yVW5pdEVudW0uTk9ORSxcbiAgICBjbXlrVW5pdDogQ29sb3JVbml0RW51bS5QRVJDRU5ULFxuICAgIGFscGhhVW5pdDogQ29sb3JVbml0RW51bS5OT05FLFxuICAgIGNteWtGdW5jdGlvbjogQ01ZS0Z1bmN0aW9uRW51bS5ERVZJQ0VfQ01ZS1xufTtcbiIsImV4cG9ydCAqIGZyb20gJy4vbnVtYmVycyc7XG5leHBvcnQgKiBmcm9tICcuL2VudW1zJztcbmV4cG9ydCAqIGZyb20gJy4vZW51bXMtc3RyaW5ncyc7XG5leHBvcnQgKiBmcm9tICcuL3JlZ2V4cHMnO1xuZXhwb3J0ICogZnJvbSAnLi9lcnJvcnMnO1xuZXhwb3J0ICogZnJvbSAnLi9vcHRpb25zJztcbiIsImltcG9ydCB7IEFuZ2xlc1VuaXRFbnVtLCBDb2xvclVuaXRFbnVtLCBDTVlLRnVuY3Rpb25FbnVtIH0gZnJvbSAnQHR5cGVzJztcbmltcG9ydCB7IFBDRU5ULCBIRVgsIE1BWF9ERUNJTUFMUywgREVGQVVMVF9PUFRJT05TLCBDT01NQVNfQU5EX05FWFRfQ0hBUlMsIFNQQUNFUywgQ09MT1JSRUdTLCBIU0xfSFVFLCBUeXBlT2YsIEhhcm1vbnksIE1peCwgfSBmcm9tICcjY29uc3RhbnRzJztcbmV4cG9ydCBjb25zdCBoYXNQcm9wID0gKG9iaiwgcHJvcCkgPT4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwgcHJvcCk7XG5leHBvcnQgY29uc3QgcGVyY2VudE51bWJlciA9IChwZXJjZW50KSA9PiB7XG4gICAgcmV0dXJuICtgJHtwZXJjZW50fWAucmVwbGFjZShQQ0VOVCwgJyQxJyk7XG59O1xuZXhwb3J0IGNvbnN0IHBlcmNlbnQgPSAocGVyY2VudCkgPT4gUENFTlQudGVzdChgJHtwZXJjZW50fWApXG4gICAgPyBwZXJjZW50TnVtYmVyKHBlcmNlbnQpXG4gICAgOiBNYXRoLm1pbigrcGVyY2VudCwgMTAwKTtcbmV4cG9ydCBjb25zdCBnZXRERUMgPSAoaGV4KSA9PiB7XG4gICAgaWYgKGhleC5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgaGV4ICs9IGhleDtcbiAgICB9XG4gICAgcmV0dXJuIHBhcnNlSW50KGhleCwgMTYpO1xufTtcbmV4cG9ydCBjb25zdCBnZXRIRVggPSAobnVtYmVyKSA9PiB7XG4gICAgY29uc3QgaGV4ID0gcm91bmQobnVtYmVyLCAwKS50b1N0cmluZygxNikudG9VcHBlckNhc2UoKTtcbiAgICBpZiAoaGV4Lmxlbmd0aCA9PT0gMSkge1xuICAgICAgICByZXR1cm4gYDB4MCR7aGV4fWA7XG4gICAgfVxuICAgIHJldHVybiBgMHgke2hleH1gO1xufTtcbmV4cG9ydCBjb25zdCB0b0hFWCA9IChoKSA9PiB7XG4gICAgbGV0IGhleCA9IHJvdW5kKGgsIDApLnRvU3RyaW5nKDE2KS50b1VwcGVyQ2FzZSgpO1xuICAgIGlmIChoZXgubGVuZ3RoID09PSAxKSB7XG4gICAgICAgIGhleCA9IGAwJHtoZXh9YDtcbiAgICB9XG4gICAgcmV0dXJuIGhleDtcbn07XG5leHBvcnQgY29uc3QgZnJvbTI1NU51bWJlclRvUGVyY2VudCA9ICh2YWx1ZSwgZGVjaW1hbHMpID0+IHJvdW5kKHZhbHVlIC8gMjU1ICogMTAwLCBkZWNpbWFscyk7XG5leHBvcnQgY29uc3QgZnJvbTEyNU51bWJlclRvUGVyY2VudCA9ICh2YWx1ZSwgZGVjaW1hbHMpID0+IHJvdW5kKHZhbHVlIC8gMTI1ICogMTAwLCBkZWNpbWFscyk7XG5leHBvcnQgY29uc3QgZ2V0QmFzZTI1NU51bWJlciA9IChjb2xvciwgYWxwaGEgPSBmYWxzZSkgPT4ge1xuICAgIGlmICghYWxwaGEgJiYgUENFTlQudGVzdChjb2xvcikpIHtcbiAgICAgICAgcmV0dXJuIE1hdGgubWluKDI1NSAqIHBlcmNlbnROdW1iZXIoY29sb3IpIC8gMTAwLCAyNTUpO1xuICAgIH1cbiAgICBpZiAoSEVYLnRlc3QoY29sb3IpKSB7XG4gICAgICAgIGlmIChjb2xvci5sZW5ndGggPT09IDMpIHtcbiAgICAgICAgICAgIGNvbG9yICs9IGNvbG9yLnNsaWNlKC0xKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYWxwaGFcbiAgICAgICAgICAgID8gcm91bmQoY29sb3IpIC8gMjU1XG4gICAgICAgICAgICA6IHJvdW5kKGNvbG9yKTtcbiAgICB9XG4gICAgcmV0dXJuIE1hdGgubWluKCtjb2xvciwgYWxwaGEgPyAxIDogMjU1KTtcbn07XG5leHBvcnQgY29uc3QgZ2V0QmFzZTEyNU51bWJlciA9IChjb2xvcikgPT4ge1xuICAgIGlmIChQQ0VOVC50ZXN0KGNvbG9yKSkge1xuICAgICAgICByZXR1cm4gbWlubWF4KDEyNSAqIHBlcmNlbnROdW1iZXIoY29sb3IpIC8gMTAwLCAtMTI1LCAxMjUpO1xuICAgIH1cbiAgICByZXR1cm4gbWlubWF4KCtjb2xvciwgLTEyNSwgMTI1KTtcbn07XG5leHBvcnQgY29uc3QgZ2V0Q01ZS051bWJlciA9IChjb2xvcikgPT4gTWF0aC5taW4oUENFTlQudGVzdChjb2xvcikgPyBwZXJjZW50TnVtYmVyKGNvbG9yKSAvIDEwMCA6ICtjb2xvciwgMSk7XG5leHBvcnQgY29uc3QgZ2V0T3JkZXJlZEFycmF5U3RyaW5nID0gKGtleXMpID0+IFsuLi5rZXlzXS5zb3J0KCkuam9pbignJykudG9VcHBlckNhc2UoKTtcbmV4cG9ydCBjb25zdCByb3VuZCA9ICh2YWx1ZSwgZGVjaW1hbHMgPSBNQVhfREVDSU1BTFMpID0+IHtcbiAgICBjb25zdCBleHAgPSBNYXRoLnBvdygxMCwgZGVjaW1hbHMpO1xuICAgIHJldHVybiBNYXRoLnJvdW5kKCt2YWx1ZSAqIGV4cCkgLyBleHA7XG59O1xuZXhwb3J0IGNvbnN0IG1pbm1heCA9IChuLCBtaW4sIG1heCkgPT4gTWF0aC5tYXgobWluLCBNYXRoLm1pbihuLCBtYXgpKTtcbmV4cG9ydCBjb25zdCBkZWdyZWVzID0gKHJhZGlhbikgPT4gcmFkaWFuICogMTgwIC8gTWF0aC5QSTtcbmV4cG9ydCBjb25zdCByYWRpYW5zID0gKGRlZ3JlZXMpID0+IGRlZ3JlZXMgKiBNYXRoLlBJIC8gMTgwO1xuY29uc3QgcGkyID0gMzYwO1xuZXhwb3J0IGNvbnN0IG5vcm1hbGl6ZUh1ZSA9IChodWUpID0+IHtcbiAgICBpZiAodHlwZW9mIGh1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgY29uc3QgbWF0Y2hlcyA9IGh1ZS5tYXRjaChIU0xfSFVFKTtcbiAgICAgICAgY29uc3QgdmFsdWUgPSArbWF0Y2hlc1sxXTtcbiAgICAgICAgY29uc3QgdW5pdHMgPSBtYXRjaGVzWzJdO1xuICAgICAgICBzd2l0Y2ggKHVuaXRzKSB7XG4gICAgICAgICAgICBjYXNlIEFuZ2xlc1VuaXRFbnVtLlJBRElBTlM6XG4gICAgICAgICAgICAgICAgaHVlID0gcm91bmQoZGVncmVlcyh2YWx1ZSkpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBBbmdsZXNVbml0RW51bS5UVVJOUzpcbiAgICAgICAgICAgICAgICBodWUgPSByb3VuZCh2YWx1ZSAqIHBpMik7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIEFuZ2xlc1VuaXRFbnVtLkdSQURJQU5TOlxuICAgICAgICAgICAgICAgIGh1ZSA9IHJvdW5kKDkgLyAxMCAqIHZhbHVlKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgQW5nbGVzVW5pdEVudW0uREVHUkVFUzpcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgaHVlID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKGh1ZSA+IDM2MCB8fCBodWUgPCAwKSB7XG4gICAgICAgIGh1ZSAtPSBNYXRoLmZsb29yKGh1ZSAvIHBpMikgKiBwaTI7XG4gICAgfVxuICAgIHJldHVybiBodWU7XG59O1xuZXhwb3J0IGNvbnN0IHRyYW5zbGF0ZURlZ3JlZXMgPSAoZGVncmVlcywgdW5pdHMpID0+IHtcbiAgICBsZXQgaHVlO1xuICAgIHN3aXRjaCAodW5pdHMpIHtcbiAgICAgICAgY2FzZSBBbmdsZXNVbml0RW51bS5SQURJQU5TOlxuICAgICAgICAgICAgaHVlID0gcm91bmQocmFkaWFucyhkZWdyZWVzKSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBBbmdsZXNVbml0RW51bS5UVVJOUzpcbiAgICAgICAgICAgIGh1ZSA9IHJvdW5kKGRlZ3JlZXMgLyBwaTIpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgQW5nbGVzVW5pdEVudW0uR1JBRElBTlM6XG4gICAgICAgICAgICBodWUgPSByb3VuZCgxMCAvIDkgKiBkZWdyZWVzKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIEFuZ2xlc1VuaXRFbnVtLkRFR1JFRVM6XG4gICAgICAgIGNhc2UgQW5nbGVzVW5pdEVudW0uTk9ORTpcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIGh1ZSA9IGRlZ3JlZXM7XG4gICAgfVxuICAgIHJldHVybiBodWU7XG59O1xuZXhwb3J0IGNvbnN0IGdldE9wdGlvbnNGcm9tQ29sb3JJbnB1dCA9IChvcHRpb25zLCAuLi5jb2xvcnMpID0+IHtcbiAgICBjb25zdCBjc3NDb2xvcnMgPSBbXTtcbiAgICBjb25zdCBoc2xDb2xvcnMgPSBbXTtcbiAgICBjb25zdCByZ2JDb2xvcnMgPSBbXTtcbiAgICBjb25zdCBsYWJDb2xvcnMgPSBbXTtcbiAgICBjb25zdCBjbXlrQ29sb3JzID0gW107XG4gICAgY29uc3QgYWxwaGFWYWx1ZXMgPSBbXTtcbiAgICBjb25zdCBhbmdsZXNVbml0VmFsdWVzID0gT2JqZWN0LnZhbHVlcyhBbmdsZXNVbml0RW51bSk7XG4gICAgY29uc3QgY29sb3JVbml0VmFsdWVzID0gT2JqZWN0LnZhbHVlcyhDb2xvclVuaXRFbnVtKTtcbiAgICBjb25zdCBjbXlrRnVuY3Rpb25WYWx1ZXMgPSBPYmplY3QudmFsdWVzKENNWUtGdW5jdGlvbkVudW0pO1xuICAgIGNvbnN0IG1hdGNoT3B0aW9ucyA9IHtcbiAgICAgICAgbGVnYWN5Q1NTOiAwLFxuICAgICAgICBzcGFjZXNBZnRlckNvbW1hczogMCxcbiAgICAgICAgY215a0Z1bmN0aW9uOiAwXG4gICAgfTtcbiAgICBmb3IgKGNvbnN0IGNvbG9yIG9mIGNvbG9ycykge1xuICAgICAgICBpZiAodHlwZW9mIGNvbG9yID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgY3NzQ29sb3JzLnB1c2goY29sb3IpO1xuICAgICAgICAgICAgaWYgKGNvbG9yLmluY2x1ZGVzKCcsJykpIHtcbiAgICAgICAgICAgICAgICBtYXRjaE9wdGlvbnMubGVnYWN5Q1NTKys7XG4gICAgICAgICAgICAgICAgY29uc3QgY29tbWFzV2l0aE5leHRDaGFyYWN0ZXIgPSBjb2xvci5tYXRjaChDT01NQVNfQU5EX05FWFRfQ0hBUlMpO1xuICAgICAgICAgICAgICAgIGlmIChuZXcgU2V0KGNvbW1hc1dpdGhOZXh0Q2hhcmFjdGVyKS5zaXplID09PSAxICYmXG4gICAgICAgICAgICAgICAgICAgIFNQQUNFUy50ZXN0KGNvbW1hc1dpdGhOZXh0Q2hhcmFjdGVyWzBdLnNsaWNlKDEpKSkge1xuICAgICAgICAgICAgICAgICAgICBtYXRjaE9wdGlvbnMuc3BhY2VzQWZ0ZXJDb21tYXMrKztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY29sb3IubWF0Y2goQ09MT1JSRUdTLkhTTCkpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBtYXRjaCA9IGNvbG9yLm1hdGNoKENPTE9SUkVHUy5IU0wpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGFuZ2xlID0gbWF0Y2hbMV0gfHwgbWF0Y2hbNV07XG4gICAgICAgICAgICAgICAgY29uc3QgYWxwaGEgPSBtYXRjaFs4XTtcbiAgICAgICAgICAgICAgICBjb25zdCBhbmdsZVVuaXQgPSBhbmdsZS5tYXRjaChIU0xfSFVFKVsyXTtcbiAgICAgICAgICAgICAgICBoc2xDb2xvcnMucHVzaChhbmdsZVVuaXQgPT09ICcnXG4gICAgICAgICAgICAgICAgICAgID8gQW5nbGVzVW5pdEVudW0uTk9ORVxuICAgICAgICAgICAgICAgICAgICA6IGFuZ2xlVW5pdCk7XG4gICAgICAgICAgICAgICAgYWxwaGFWYWx1ZXMucHVzaChQQ0VOVC50ZXN0KGFscGhhKSk7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoQ09MT1JSRUdTLlJHQi50ZXN0KGNvbG9yKSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IG1hdGNoID0gY29sb3IubWF0Y2goQ09MT1JSRUdTLlJHQik7XG4gICAgICAgICAgICAgICAgY29uc3QgUiA9IG1hdGNoWzFdIHx8IG1hdGNoWzVdO1xuICAgICAgICAgICAgICAgIGNvbnN0IEcgPSBtYXRjaFsyXSB8fCBtYXRjaFs2XTtcbiAgICAgICAgICAgICAgICBjb25zdCBCID0gbWF0Y2hbM10gfHwgbWF0Y2hbN107XG4gICAgICAgICAgICAgICAgY29uc3QgQSA9IG1hdGNoWzhdO1xuICAgICAgICAgICAgICAgIHJnYkNvbG9ycy5wdXNoKFBDRU5ULnRlc3QoUikgJiZcbiAgICAgICAgICAgICAgICAgICAgUENFTlQudGVzdChHKSAmJlxuICAgICAgICAgICAgICAgICAgICBQQ0VOVC50ZXN0KEIpKTtcbiAgICAgICAgICAgICAgICBhbHBoYVZhbHVlcy5wdXNoKFBDRU5ULnRlc3QoQSkpO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKENPTE9SUkVHUy5DSUVMYWIudGVzdChjb2xvcikpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBtYXRjaCA9IGNvbG9yLm1hdGNoKENPTE9SUkVHUy5DSUVMYWIpO1xuICAgICAgICAgICAgICAgIGNvbnN0IEwgPSBtYXRjaFsxXTtcbiAgICAgICAgICAgICAgICBjb25zdCBhID0gbWF0Y2hbMl07XG4gICAgICAgICAgICAgICAgY29uc3QgYiA9IG1hdGNoWzNdO1xuICAgICAgICAgICAgICAgIGNvbnN0IEEgPSBtYXRjaFs0XTtcbiAgICAgICAgICAgICAgICBsYWJDb2xvcnMucHVzaChQQ0VOVC50ZXN0KEwpICYmXG4gICAgICAgICAgICAgICAgICAgIFBDRU5ULnRlc3QoYSkgJiZcbiAgICAgICAgICAgICAgICAgICAgUENFTlQudGVzdChiKSk7XG4gICAgICAgICAgICAgICAgYWxwaGFWYWx1ZXMucHVzaChQQ0VOVC50ZXN0KEEpKTtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjb2xvci5tYXRjaChDT0xPUlJFR1MuQ01ZSykpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBtYXRjaCA9IGNvbG9yLm1hdGNoKENPTE9SUkVHUy5DTVlLKTtcbiAgICAgICAgICAgICAgICBjb25zdCBDID0gbWF0Y2hbMV0gfHwgbWF0Y2hbNl07XG4gICAgICAgICAgICAgICAgY29uc3QgTSA9IG1hdGNoWzJdIHx8IG1hdGNoWzddO1xuICAgICAgICAgICAgICAgIGNvbnN0IFkgPSBtYXRjaFszXSB8fCBtYXRjaFs4XTtcbiAgICAgICAgICAgICAgICBjb25zdCBLID0gbWF0Y2hbNF0gfHwgbWF0Y2hbOV07XG4gICAgICAgICAgICAgICAgY29uc3QgQSA9IG1hdGNoWzEwXTtcbiAgICAgICAgICAgICAgICBjbXlrQ29sb3JzLnB1c2goUENFTlQudGVzdChDKSAmJlxuICAgICAgICAgICAgICAgICAgICBQQ0VOVC50ZXN0KE0pICYmXG4gICAgICAgICAgICAgICAgICAgIFBDRU5ULnRlc3QoWSkgJiZcbiAgICAgICAgICAgICAgICAgICAgUENFTlQudGVzdChLKSk7XG4gICAgICAgICAgICAgICAgaWYgKGNvbG9yLnN0YXJ0c1dpdGgoJ2NteWsnKSkge1xuICAgICAgICAgICAgICAgICAgICBtYXRjaE9wdGlvbnMuY215a0Z1bmN0aW9uKys7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGFscGhhVmFsdWVzLnB1c2goUENFTlQudGVzdChBKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgZGVjaW1hbHM6IHR5cGVvZiBvcHRpb25zLmRlY2ltYWxzID09PSBUeXBlT2YuTlVNQkVSXG4gICAgICAgICAgICA/IG9wdGlvbnMuZGVjaW1hbHNcbiAgICAgICAgICAgIDogREVGQVVMVF9PUFRJT05TLmRlY2ltYWxzLFxuICAgICAgICBsZWdhY3lDU1M6IHR5cGVvZiBvcHRpb25zLmxlZ2FjeUNTUyA9PT0gVHlwZU9mLkJPT0xFQU5cbiAgICAgICAgICAgID8gb3B0aW9ucy5sZWdhY3lDU1NcbiAgICAgICAgICAgIDogQm9vbGVhbihjc3NDb2xvcnMubGVuZ3RoICYmXG4gICAgICAgICAgICAgICAgbWF0Y2hPcHRpb25zLmxlZ2FjeUNTUyA9PT0gY3NzQ29sb3JzLmxlbmd0aCkgfHwgREVGQVVMVF9PUFRJT05TLmxlZ2FjeUNTUyxcbiAgICAgICAgc3BhY2VzQWZ0ZXJDb21tYXM6IHR5cGVvZiBvcHRpb25zLnNwYWNlc0FmdGVyQ29tbWFzID09PSBUeXBlT2YuQk9PTEVBTlxuICAgICAgICAgICAgPyBvcHRpb25zLnNwYWNlc0FmdGVyQ29tbWFzXG4gICAgICAgICAgICA6IEJvb2xlYW4oY3NzQ29sb3JzLmxlbmd0aCAmJlxuICAgICAgICAgICAgICAgIG1hdGNoT3B0aW9ucy5zcGFjZXNBZnRlckNvbW1hcyA9PT0gY3NzQ29sb3JzLmxlbmd0aCkgfHwgREVGQVVMVF9PUFRJT05TLnNwYWNlc0FmdGVyQ29tbWFzLFxuICAgICAgICBhbmdsZXNVbml0OiBvcHRpb25zLmFuZ2xlc1VuaXQgJiYgYW5nbGVzVW5pdFZhbHVlcy5pbmNsdWRlcyhvcHRpb25zLmFuZ2xlc1VuaXQpXG4gICAgICAgICAgICA/IG9wdGlvbnMuYW5nbGVzVW5pdFxuICAgICAgICAgICAgOiAobmV3IFNldChoc2xDb2xvcnMpLnNpemUgPT09IDFcbiAgICAgICAgICAgICAgICA/IGhzbENvbG9yc1swXVxuICAgICAgICAgICAgICAgIDogREVGQVVMVF9PUFRJT05TLmFuZ2xlc1VuaXQpLFxuICAgICAgICByZ2JVbml0OiBvcHRpb25zLnJnYlVuaXQgJiYgY29sb3JVbml0VmFsdWVzLmluY2x1ZGVzKG9wdGlvbnMucmdiVW5pdClcbiAgICAgICAgICAgID8gb3B0aW9ucy5yZ2JVbml0XG4gICAgICAgICAgICA6IChuZXcgU2V0KHJnYkNvbG9ycykuc2l6ZSA9PT0gMSAmJiByZ2JDb2xvcnNbMF1cbiAgICAgICAgICAgICAgICA/IENvbG9yVW5pdEVudW0uUEVSQ0VOVFxuICAgICAgICAgICAgICAgIDogREVGQVVMVF9PUFRJT05TLnJnYlVuaXQpLFxuICAgICAgICBsYWJVbml0OiBvcHRpb25zLmxhYlVuaXQgJiYgY29sb3JVbml0VmFsdWVzLmluY2x1ZGVzKG9wdGlvbnMubGFiVW5pdClcbiAgICAgICAgICAgID8gb3B0aW9ucy5sYWJVbml0XG4gICAgICAgICAgICA6IChuZXcgU2V0KGxhYkNvbG9ycykuc2l6ZSA9PT0gMSAmJiBsYWJDb2xvcnNbMF1cbiAgICAgICAgICAgICAgICA/IENvbG9yVW5pdEVudW0uUEVSQ0VOVFxuICAgICAgICAgICAgICAgIDogREVGQVVMVF9PUFRJT05TLmxhYlVuaXQpLFxuICAgICAgICBjbXlrVW5pdDogb3B0aW9ucy5jbXlrVW5pdCAmJiBjb2xvclVuaXRWYWx1ZXMuaW5jbHVkZXMob3B0aW9ucy5jbXlrVW5pdClcbiAgICAgICAgICAgID8gb3B0aW9ucy5jbXlrVW5pdFxuICAgICAgICAgICAgOiAobmV3IFNldChjbXlrQ29sb3JzKS5zaXplID09PSAxICYmICFjbXlrQ29sb3JzWzBdXG4gICAgICAgICAgICAgICAgPyBDb2xvclVuaXRFbnVtLk5PTkVcbiAgICAgICAgICAgICAgICA6IERFRkFVTFRfT1BUSU9OUy5jbXlrVW5pdCksXG4gICAgICAgIGFscGhhVW5pdDogb3B0aW9ucy5hbHBoYVVuaXQgJiYgY29sb3JVbml0VmFsdWVzLmluY2x1ZGVzKG9wdGlvbnMuYWxwaGFVbml0KVxuICAgICAgICAgICAgPyBvcHRpb25zLmFscGhhVW5pdFxuICAgICAgICAgICAgOiAobmV3IFNldChhbHBoYVZhbHVlcykuc2l6ZSA9PT0gMSAmJiBhbHBoYVZhbHVlc1swXVxuICAgICAgICAgICAgICAgID8gQ29sb3JVbml0RW51bS5QRVJDRU5UXG4gICAgICAgICAgICAgICAgOiBERUZBVUxUX09QVElPTlMuYWxwaGFVbml0KSxcbiAgICAgICAgY215a0Z1bmN0aW9uOiBvcHRpb25zLmNteWtGdW5jdGlvbiAmJiBjbXlrRnVuY3Rpb25WYWx1ZXMuaW5jbHVkZXMob3B0aW9ucy5jbXlrRnVuY3Rpb24pXG4gICAgICAgICAgICA/IG9wdGlvbnMuY215a0Z1bmN0aW9uXG4gICAgICAgICAgICA6IChjbXlrQ29sb3JzLmxlbmd0aCAmJiBjbXlrQ29sb3JzLmxlbmd0aCA9PT0gbWF0Y2hPcHRpb25zLmNteWtGdW5jdGlvblxuICAgICAgICAgICAgICAgID8gQ01ZS0Z1bmN0aW9uRW51bS5DTVlLXG4gICAgICAgICAgICAgICAgOiBERUZBVUxUX09QVElPTlMuY215a0Z1bmN0aW9uKVxuICAgIH07XG59O1xuZXhwb3J0IGNvbnN0IGlzSGFybW9ueSA9IChwYXJhbSkgPT4ge1xuICAgIHJldHVybiBgJHtwYXJhbX1gIGluIEhhcm1vbnk7XG59O1xuZXhwb3J0IGNvbnN0IGlzTWl4ID0gKHBhcmFtKSA9PiB7XG4gICAgcmV0dXJuIGAke3BhcmFtfWAgaW4gTWl4O1xufTtcbiIsImltcG9ydCB7IHJvdW5kLCBtaW5tYXggfSBmcm9tICcjaGVscGVycyc7XG5jb25zdCBNQVRSSVhfTFJHQl9YWVpfRDUwID0gW1xuICAgIFswLjQzNjA3NDcsIDAuMzg1MDY0OSwgMC4xNDMwODA0XSxcbiAgICBbMC4yMjI1MDQ1LCAwLjcxNjg3ODYsIDAuMDYwNjE2OV0sXG4gICAgWzAuMDEzOTMyMiwgMC4wOTcxMDQ1LCAwLjcxNDE3MzNdXG5dO1xuY29uc3QgTUFUUklYX1hZWl9ENTBfTFJHQiA9IFtcbiAgICBbMy4xMzM4NTYxLCAtMS42MTY4NjY3LCAtMC40OTA2MTQ2XSxcbiAgICBbLTAuOTc4NzY4NCwgMS45MTYxNDE1LCAwLjAzMzQ1NF0sXG4gICAgWzAuMDcxOTQ1MywgLTAuMjI4OTkxNCwgMS40MDUyNDI3XVxuXTtcbmNvbnN0IFRSSVNUSU1VTFVTX0Q1MCA9IE1BVFJJWF9MUkdCX1hZWl9ENTAubWFwKChtYXRyaXgpID0+IHtcbiAgICByZXR1cm4gbWF0cml4LnJlZHVjZSgoc3VtLCB2YWx1ZSkgPT4gc3VtICsgdmFsdWUsIDApO1xufSk7XG5jb25zdCBodWVUb1JHQiA9ICh0MSwgdDIsIGh1ZSkgPT4ge1xuICAgIGlmIChodWUgPCAwKSB7XG4gICAgICAgIGh1ZSArPSA2O1xuICAgIH1cbiAgICBpZiAoaHVlID49IDYpIHtcbiAgICAgICAgaHVlIC09IDY7XG4gICAgfVxuICAgIGlmIChodWUgPCAxKSB7XG4gICAgICAgIHJldHVybiByb3VuZCgoKHQyIC0gdDEpICogaHVlICsgdDEpICogMjU1KTtcbiAgICB9XG4gICAgZWxzZSBpZiAoaHVlIDwgMykge1xuICAgICAgICByZXR1cm4gcm91bmQodDIgKiAyNTUpO1xuICAgIH1cbiAgICBlbHNlIGlmIChodWUgPCA0KSB7XG4gICAgICAgIHJldHVybiByb3VuZCgoKHQyIC0gdDEpICogKDQgLSBodWUpICsgdDEpICogMjU1KTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiByb3VuZCh0MSAqIDI1NSk7XG4gICAgfVxufTtcbmNvbnN0IHJnYlRvTGluZWFyTGlnaHRSR0IgPSAodmFsdWUpID0+IHtcbiAgICByZXR1cm4gdmFsdWUgPD0gMC4wNDA0NVxuICAgICAgICA/IHZhbHVlIC8gMTIuOTJcbiAgICAgICAgOiAoKHZhbHVlICsgMC4wNTUpIC8gMS4wNTUpICoqIDIuNDtcbn07XG5jb25zdCBsaW5lYXJMaWdodFJHQlRvUkdCID0gKHZhbHVlKSA9PiB7XG4gICAgcmV0dXJuIHZhbHVlIDw9IDAuMDAzMTMwOFxuICAgICAgICA/IDEyLjkyICogdmFsdWVcbiAgICAgICAgOiAxLjA1NSAqICh2YWx1ZSAqKiAoMSAvIDIuNCkpIC0gMC4wNTU7XG59O1xuY29uc3QgbWF0cml4VmVjdG9yTXVsdGlwbGljYXRpb24gPSAodjEsIHYyLCB2MywgbWF0cml4KSA9PiB7XG4gICAgY29uc3QgcmVzdWx0ID0gWzAsIDAsIDBdO1xuICAgIGNvbnN0IGxpbmVhclJHQiA9IFt2MSwgdjIsIHYzXTtcbiAgICBtYXRyaXguZm9yRWFjaCgoYXJyYXksIGluZGV4KSA9PiB7XG4gICAgICAgIGFycmF5LmZvckVhY2goKHZhbHVlLCBtaW5kZXgpID0+IHtcbiAgICAgICAgICAgIHJlc3VsdFtpbmRleF0gKz0gdmFsdWUgKiBsaW5lYXJSR0JbbWluZGV4XTtcbiAgICAgICAgfSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG5jb25zdCBmcm9tX0NJRV9YWVpfRDUwX3RvX0NJRV9MQUIgPSAoeCwgeSwgeikgPT4ge1xuICAgIGNvbnN0IGYgPSAodCkgPT4ge1xuICAgICAgICByZXR1cm4gdCA+ICg2IC8gMjkpICoqIDNcbiAgICAgICAgICAgID8gTWF0aC5jYnJ0KHQpXG4gICAgICAgICAgICA6IHQgLyAoMyAqICg2IC8gMjkpICoqIDIpICsgKDQgLyAyOSk7XG4gICAgfTtcbiAgICBjb25zdCBmeCA9IGYoeCAvIFRSSVNUSU1VTFVTX0Q1MFswXSk7XG4gICAgY29uc3QgZnkgPSBmKHkgLyBUUklTVElNVUxVU19ENTBbMV0pO1xuICAgIGNvbnN0IGZ6ID0gZih6IC8gVFJJU1RJTVVMVVNfRDUwWzJdKTtcbiAgICByZXR1cm4gW1xuICAgICAgICAxMTYgKiBmeSAtIDE2LFxuICAgICAgICA1MDAgKiAoZnggLSBmeSksXG4gICAgICAgIDIwMCAqIChmeSAtIGZ6KVxuICAgIF07XG59O1xuY29uc3QgZnJvbV9DSUVfTEFCX3RvX0NJRV9YWVpfRDUwID0gKEwsIGEsIGIpID0+IHtcbiAgICBjb25zdCBmID0gKHQpID0+IHtcbiAgICAgICAgcmV0dXJuIHQgPiA2IC8gMjlcbiAgICAgICAgICAgID8gdCAqKiAzXG4gICAgICAgICAgICA6IDMgKiAoNiAvIDI5KSAqKiAyICogKHQgLSA0IC8gMjkpO1xuICAgIH07XG4gICAgY29uc3QgZmwgPSAoTCArIDE2KSAvIDExNjtcbiAgICBjb25zdCBmYSA9IGEgLyA1MDA7XG4gICAgY29uc3QgZmIgPSBiIC8gMjAwO1xuICAgIHJldHVybiBbXG4gICAgICAgIFRSSVNUSU1VTFVTX0Q1MFswXSAqIGYoZmwgKyBmYSksXG4gICAgICAgIFRSSVNUSU1VTFVTX0Q1MFsxXSAqIGYoZmwpLFxuICAgICAgICBUUklTVElNVUxVU19ENTBbMl0gKiBmKGZsIC0gZmIpXG4gICAgXTtcbn07XG5leHBvcnQgY29uc3QgaHNsVG9SR0IgPSAoSCwgUywgTCkgPT4ge1xuICAgIEggLz0gNjA7XG4gICAgUyAvPSAxMDA7XG4gICAgTCAvPSAxMDA7XG4gICAgY29uc3QgdDIgPSAoTCA8PSAuNSlcbiAgICAgICAgPyBMICogKFMgKyAxKVxuICAgICAgICA6IEwgKyBTIC0gKEwgKiBTKTtcbiAgICBjb25zdCB0MSA9IEwgKiAyIC0gdDI7XG4gICAgY29uc3QgUiA9IGh1ZVRvUkdCKHQxLCB0MiwgSCArIDIpO1xuICAgIGNvbnN0IEcgPSBodWVUb1JHQih0MSwgdDIsIEgpO1xuICAgIGNvbnN0IEIgPSBodWVUb1JHQih0MSwgdDIsIEggLSAyKTtcbiAgICByZXR1cm4geyBSLCBHLCBCIH07XG59O1xuZXhwb3J0IGNvbnN0IHJnYlRvSFNMID0gKFIsIEcsIEIsIEEgPSAxKSA9PiB7XG4gICAgUiAvPSAyNTU7XG4gICAgRyAvPSAyNTU7XG4gICAgQiAvPSAyNTU7XG4gICAgQSA9IE1hdGgubWluKEEsIDEpO1xuICAgIGNvbnN0IE1BWCA9IE1hdGgubWF4KFIsIEcsIEIpO1xuICAgIGNvbnN0IE1JTiA9IE1hdGgubWluKFIsIEcsIEIpO1xuICAgIGNvbnN0IEQgPSBNQVggLSBNSU47XG4gICAgbGV0IEggPSAwO1xuICAgIGxldCBTID0gMDtcbiAgICBjb25zdCBMID0gKE1BWCArIE1JTikgLyAyO1xuICAgIGlmIChEICE9PSAwKSB7XG4gICAgICAgIHN3aXRjaCAoTUFYKSB7XG4gICAgICAgICAgICBjYXNlIFI6XG4gICAgICAgICAgICAgICAgSCA9ICgoRyAtIEIpIC8gRCkgJSA2O1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBHOlxuICAgICAgICAgICAgICAgIEggPSAoQiAtIFIpIC8gRCArIDI7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIEI6XG4gICAgICAgICAgICAgICAgSCA9IChSIC0gRykgLyBEICsgNDtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBIID0gcm91bmQoSCAqIDYwKTtcbiAgICAgICAgaWYgKEggPCAwKSB7XG4gICAgICAgICAgICBIICs9IDM2MDtcbiAgICAgICAgfVxuICAgICAgICBTID0gRCAvICgxIC0gTWF0aC5hYnMoMiAqIEwgLSAxKSk7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAgIEgsXG4gICAgICAgIFM6IHJvdW5kKFMgKiAxMDApLFxuICAgICAgICBMOiByb3VuZChMICogMTAwKSxcbiAgICAgICAgQVxuICAgIH07XG59O1xuZXhwb3J0IGNvbnN0IHJnYlRvTGFiID0gKFIsIEcsIEIpID0+IHtcbiAgICBjb25zdCBMSU5FQVJfTElHSFRfUkdCID0gW1xuICAgICAgICBSIC8gMjU1LFxuICAgICAgICBHIC8gMjU1LFxuICAgICAgICBCIC8gMjU1XG4gICAgXS5tYXAocmdiVG9MaW5lYXJMaWdodFJHQik7XG4gICAgY29uc3QgQ0lFX1hZWl9ENTAgPSBtYXRyaXhWZWN0b3JNdWx0aXBsaWNhdGlvbihMSU5FQVJfTElHSFRfUkdCWzBdLCBMSU5FQVJfTElHSFRfUkdCWzFdLCBMSU5FQVJfTElHSFRfUkdCWzJdLCBNQVRSSVhfTFJHQl9YWVpfRDUwKTtcbiAgICBjb25zdCBDSUVfTEFCID0gZnJvbV9DSUVfWFlaX0Q1MF90b19DSUVfTEFCKENJRV9YWVpfRDUwWzBdLCBDSUVfWFlaX0Q1MFsxXSwgQ0lFX1hZWl9ENTBbMl0pO1xuICAgIHJldHVybiB7XG4gICAgICAgIEw6IENJRV9MQUJbMF0sXG4gICAgICAgIGE6IENJRV9MQUJbMV0sXG4gICAgICAgIGI6IENJRV9MQUJbMl1cbiAgICB9O1xufTtcbmV4cG9ydCBjb25zdCBsYWJUb1JnYiA9IChMLCBhLCBiKSA9PiB7XG4gICAgY29uc3QgQ0lFX1hZWl9ENTAgPSBmcm9tX0NJRV9MQUJfdG9fQ0lFX1hZWl9ENTAoTCwgYSwgYik7XG4gICAgY29uc3QgTElORUFSX0xJR0hUX1JHQiA9IG1hdHJpeFZlY3Rvck11bHRpcGxpY2F0aW9uKENJRV9YWVpfRDUwWzBdLCBDSUVfWFlaX0Q1MFsxXSwgQ0lFX1hZWl9ENTBbMl0sIE1BVFJJWF9YWVpfRDUwX0xSR0IpO1xuICAgIGNvbnN0IFJHQiA9IExJTkVBUl9MSUdIVF9SR0IubWFwKGxpbmVhckxpZ2h0UkdCVG9SR0IpO1xuICAgIHJldHVybiB7XG4gICAgICAgIFI6IG1pbm1heChSR0JbMF0gKiAyNTUsIDAsIDI1NSksXG4gICAgICAgIEc6IG1pbm1heChSR0JbMV0gKiAyNTUsIDAsIDI1NSksXG4gICAgICAgIEI6IG1pbm1heChSR0JbMl0gKiAyNTUsIDAsIDI1NSlcbiAgICB9O1xufTtcbmV4cG9ydCBjb25zdCBjbXlrVG9SR0IgPSAoQywgTSwgWSwgSykgPT4ge1xuICAgIEsgPSAxIC0gSztcbiAgICBjb25zdCBSID0gcm91bmQoMjU1ICogKDEgLSBDKSAqIEspO1xuICAgIGNvbnN0IEcgPSByb3VuZCgyNTUgKiAoMSAtIE0pICogSyk7XG4gICAgY29uc3QgQiA9IHJvdW5kKDI1NSAqICgxIC0gWSkgKiBLKTtcbiAgICByZXR1cm4geyBSLCBHLCBCIH07XG59O1xuZXhwb3J0IGNvbnN0IHJnYlRvQ01ZSyA9IChSLCBHLCBCKSA9PiB7XG4gICAgUiAvPSAyNTU7XG4gICAgRyAvPSAyNTU7XG4gICAgQiAvPSAyNTU7XG4gICAgY29uc3QgSyA9IDEgLSBNYXRoLm1heChSLCBHLCBCKTtcbiAgICBjb25zdCBLMSA9IDEgLSBLO1xuICAgIGNvbnN0IEMgPSBLMSAmJiAoSzEgLSBSKSAvIEsxO1xuICAgIGNvbnN0IE0gPSBLMSAmJiAoSzEgLSBHKSAvIEsxO1xuICAgIGNvbnN0IFkgPSBLMSAmJiAoSzEgLSBCKSAvIEsxO1xuICAgIHJldHVybiB7XG4gICAgICAgIEM6IHJvdW5kKEMgKiAxMDApLFxuICAgICAgICBNOiByb3VuZChNICogMTAwKSxcbiAgICAgICAgWTogcm91bmQoWSAqIDEwMCksXG4gICAgICAgIEs6IHJvdW5kKEsgKiAxMDApXG4gICAgfTtcbn07XG5leHBvcnQgY29uc3QgcmdiVG9SWUIgPSAoUiwgRywgQikgPT4ge1xuICAgIGNvbnN0IEl3ID0gTWF0aC5taW4oUiwgRywgQik7XG4gICAgY29uc3QgSWIgPSBNYXRoLm1pbigyNTUgLSBSLCAyNTUgLSBHLCAyNTUgLSBCKTtcbiAgICBjb25zdCByUkdCID0gUiAtIEl3O1xuICAgIGNvbnN0IGdSR0IgPSBHIC0gSXc7XG4gICAgY29uc3QgYlJHQiA9IEIgLSBJdztcbiAgICBjb25zdCBtaW5SRyA9IE1hdGgubWluKHJSR0IsIGdSR0IpO1xuICAgIGNvbnN0IHJSWUIgPSByUkdCIC0gbWluUkc7XG4gICAgY29uc3QgeVJZQiA9IChnUkdCICsgbWluUkcpIC8gMjtcbiAgICBjb25zdCBiUllCID0gKGJSR0IgKyBnUkdCIC0gbWluUkcpIC8gMjtcbiAgICBjb25zdCBuID0gTWF0aC5tYXgoclJZQiwgeVJZQiwgYlJZQikgLyBNYXRoLm1heChyUkdCLCBnUkdCLCBiUkdCKTtcbiAgICBjb25zdCBOID0gaXNOYU4obikgfHwgbiA9PT0gSW5maW5pdHkgfHwgbiA8PSAwID8gMSA6IG47XG4gICAgcmV0dXJuIHtcbiAgICAgICAgUjogclJZQiAvIE4gKyBJYixcbiAgICAgICAgWTogeVJZQiAvIE4gKyBJYixcbiAgICAgICAgQjogYlJZQiAvIE4gKyBJYlxuICAgIH07XG59O1xuZXhwb3J0IGNvbnN0IHJ5YlRvUkdCID0gKFIsIFksIEIpID0+IHtcbiAgICBjb25zdCBJdyA9IE1hdGgubWluKFIsIFksIEIpO1xuICAgIGNvbnN0IEliID0gTWF0aC5taW4oMjU1IC0gUiwgMjU1IC0gWSwgMjU1IC0gQik7XG4gICAgY29uc3QgclJZQiA9IFIgLSBJdztcbiAgICBjb25zdCB5UllCID0gWSAtIEl3O1xuICAgIGNvbnN0IGJSWUIgPSBCIC0gSXc7XG4gICAgY29uc3QgbWluWUIgPSBNYXRoLm1pbih5UllCLCBiUllCKTtcbiAgICBjb25zdCByUkdCID0gclJZQiArIHlSWUIgLSBtaW5ZQjtcbiAgICBjb25zdCBnUkdCID0geVJZQiArIG1pbllCO1xuICAgIGNvbnN0IGJSR0IgPSAyICogKGJSWUIgLSBtaW5ZQik7XG4gICAgY29uc3QgbiA9IE1hdGgubWF4KHJSR0IsIGdSR0IsIGJSR0IpIC8gTWF0aC5tYXgoclJZQiwgeVJZQiwgYlJZQik7XG4gICAgY29uc3QgTiA9IGlzTmFOKG4pIHx8IG4gPT09IEluZmluaXR5IHx8IG4gPD0gMCA/IDEgOiBuO1xuICAgIHJldHVybiB7XG4gICAgICAgIFI6IHJSR0IgLyBOICsgSWIsXG4gICAgICAgIEc6IGdSR0IgLyBOICsgSWIsXG4gICAgICAgIEI6IGJSR0IgLyBOICsgSWJcbiAgICB9O1xufTtcbmV4cG9ydCBjb25zdCBodWVSWUIgPSAoaHVlLCB0b1JZQikgPT4ge1xuICAgIGlmIChodWUgPCAwKVxuICAgICAgICBodWUgKz0gMzYwO1xuICAgIGlmIChodWUgPiAzNjApXG4gICAgICAgIGh1ZSAtPSAzNjA7XG4gICAgaWYgKGh1ZSA9PT0gMzYwIHx8IGh1ZSA9PT0gMClcbiAgICAgICAgcmV0dXJuIGh1ZTtcbiAgICBjb25zdCBtYXAxID0gW1xuICAgICAgICBbMCwgMTIwXSxcbiAgICAgICAgWzEyMCwgMTgwXSxcbiAgICAgICAgWzE4MCwgMjQwXSxcbiAgICAgICAgWzI0MCwgMzYwXVxuICAgIF07XG4gICAgY29uc3QgbWFwMiA9IFtcbiAgICAgICAgWzAsIDYwXSxcbiAgICAgICAgWzYwLCAxMjBdLFxuICAgICAgICBbMTIwLCAyNDBdLFxuICAgICAgICBbMjQwLCAzNjBdXG4gICAgXTtcbiAgICBjb25zdCBmcm9tID0gdG9SWUIgPyBtYXAxIDogbWFwMjtcbiAgICBjb25zdCB0byA9IHRvUllCID8gbWFwMiA6IG1hcDE7XG4gICAgbGV0IEEgPSAwO1xuICAgIGxldCBCID0gMDtcbiAgICBsZXQgQyA9IDA7XG4gICAgbGV0IEQgPSAwO1xuICAgIGZyb20uZmluZCgoYXJyLCBpbmRleCkgPT4ge1xuICAgICAgICBpZiAoaHVlID49IGFyclswXSAmJiBodWUgPCBhcnJbMV0pIHtcbiAgICAgICAgICAgIEEgPSBhcnJbMF07XG4gICAgICAgICAgICBCID0gYXJyWzFdO1xuICAgICAgICAgICAgQyA9IHRvW2luZGV4XVswXTtcbiAgICAgICAgICAgIEQgPSB0b1tpbmRleF1bMV07XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSk7XG4gICAgcmV0dXJuIEMgKyAoaHVlIC0gQSkgKiAoKEQgLSBDKSAvIChCIC0gQSkpO1xufTtcbiIsImltcG9ydCB7IEFuZ2xlc1VuaXRFbnVtLCBDb2xvclVuaXRFbnVtIH0gZnJvbSAnQHR5cGVzJztcbmltcG9ydCB7IENvbG9yTW9kZWwsIFRFTVBMQVRFX1ZBUiwgQ09MT1JfUFJPUFMsIFZBTElEX0NPTE9SX09CSkVDVFMgfSBmcm9tICcjY29uc3RhbnRzJztcbmltcG9ydCB7IHRvSEVYLCByb3VuZCwgcGVyY2VudCwgZ2V0T3JkZXJlZEFycmF5U3RyaW5nLCBmcm9tMjU1TnVtYmVyVG9QZXJjZW50LCBmcm9tMTI1TnVtYmVyVG9QZXJjZW50LCB0cmFuc2xhdGVEZWdyZWVzIH0gZnJvbSAnI2hlbHBlcnMnO1xuY29uc3QgZ2V0Q29tbWEgPSAod2l0aFNwYWNlKSA9PiB3aXRoU3BhY2VcbiAgICA/ICcsICdcbiAgICA6ICcsJztcbmNvbnN0IHByZXBhcmVDb2xvckZvckNzcyA9IChjb2xvciwgdHJhbnNmb3JtZXIpID0+IHtcbiAgICBjb25zdCBwcm9wcyA9IGdldE9yZGVyZWRBcnJheVN0cmluZyhPYmplY3Qua2V5cyhjb2xvcikpO1xuICAgIGNvbnN0IG1vZGVsID0gVkFMSURfQ09MT1JfT0JKRUNUU1twcm9wc107XG4gICAgY29uc3Qga2V5cyA9IENPTE9SX1BST1BTW21vZGVsXTtcbiAgICByZXR1cm4ga2V5cy5yZWR1Y2UoKHJlc3VsdCwga2V5LCBpbmRleCkgPT4ge1xuICAgICAgICBjb25zdCB2YWx1ZSA9IGNvbG9yW2tleV07XG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICByZXN1bHQucHVzaCh0cmFuc2Zvcm1lcih2YWx1ZSwgaW5kZXgpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0sIFtdKTtcbn07XG5jb25zdCBnZXRSZXN1bHRGcm9tVGVtcGxhdGUgPSAodGVtcGxhdGUsIHZhcnMpID0+IHtcbiAgICByZXR1cm4gdGVtcGxhdGUucmVwbGFjZShURU1QTEFURV9WQVIsIChfX21hdGNoLCBpbmRleFN0cikgPT4ge1xuICAgICAgICBjb25zdCBpbmRleCA9ICtpbmRleFN0ciAtIDE7XG4gICAgICAgIHJldHVybiBgJHt2YXJzW2luZGV4XX1gO1xuICAgIH0pO1xufTtcbmNvbnN0IGdldEFscGhhID0gKHZhbHVlLCBvcHRpb25zLCBpZ25vcmVMZWdhY3kgPSBmYWxzZSkgPT4ge1xuICAgIGNvbnN0IHsgYWxwaGFVbml0LCBsZWdhY3lDU1MsIGRlY2ltYWxzIH0gPSBvcHRpb25zO1xuICAgIGlmIChhbHBoYVVuaXQgPT09IENvbG9yVW5pdEVudW0uUEVSQ0VOVCAmJlxuICAgICAgICAoIWxlZ2FjeUNTUyB8fFxuICAgICAgICAgICAgaWdub3JlTGVnYWN5KSkge1xuICAgICAgICByZXR1cm4gYCR7cm91bmQodmFsdWUgKiAxMDAsIGRlY2ltYWxzKX0lYDtcbiAgICB9XG4gICAgcmV0dXJuIHJvdW5kKHZhbHVlLCBkZWNpbWFscyk7XG59O1xuZXhwb3J0IGNvbnN0IENTUyA9IHtcbiAgICBbQ29sb3JNb2RlbC5IRVhdOiAoY29sb3IpID0+IHtcbiAgICAgICAgY29uc3QgdHJhbnNmb3JtZXIgPSAodmFsdWUpID0+IHRvSEVYKHJvdW5kKHZhbHVlKSk7XG4gICAgICAgIGNvbnN0IHZhbHVlcyA9IHByZXBhcmVDb2xvckZvckNzcyhjb2xvciwgdHJhbnNmb3JtZXIpO1xuICAgICAgICBjb25zdCB0ZW1wbGF0ZSA9IHZhbHVlcy5sZW5ndGggPT09IDRcbiAgICAgICAgICAgID8gJyN7MX17Mn17M317NH0nXG4gICAgICAgICAgICA6ICcjezF9ezJ9ezN9JztcbiAgICAgICAgcmV0dXJuIGdldFJlc3VsdEZyb21UZW1wbGF0ZSh0ZW1wbGF0ZSwgdmFsdWVzKTtcbiAgICB9LFxuICAgIFtDb2xvck1vZGVsLlJHQl06IChjb2xvciwgb3B0aW9ucykgPT4ge1xuICAgICAgICBjb25zdCB7IGRlY2ltYWxzLCBsZWdhY3lDU1MsIHNwYWNlc0FmdGVyQ29tbWFzLCByZ2JVbml0IH0gPSBvcHRpb25zO1xuICAgICAgICBjb25zdCBjb21tYSA9IGdldENvbW1hKHNwYWNlc0FmdGVyQ29tbWFzKTtcbiAgICAgICAgY29uc3QgdHJhbnNmb3JtZXIgPSAodmFsdWUsIGluZGV4KSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gcmdiVW5pdCA9PT0gQ29sb3JVbml0RW51bS5QRVJDRU5UICYmIGluZGV4IDwgM1xuICAgICAgICAgICAgICAgID8gYCR7ZnJvbTI1NU51bWJlclRvUGVyY2VudCh2YWx1ZSwgZGVjaW1hbHMpfSVgXG4gICAgICAgICAgICAgICAgOiAoaW5kZXggPT09IDNcbiAgICAgICAgICAgICAgICAgICAgPyBnZXRBbHBoYSh2YWx1ZSwgb3B0aW9ucylcbiAgICAgICAgICAgICAgICAgICAgOiByb3VuZCh2YWx1ZSwgZGVjaW1hbHMpKTtcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgdmFsdWVzID0gcHJlcGFyZUNvbG9yRm9yQ3NzKGNvbG9yLCB0cmFuc2Zvcm1lcik7XG4gICAgICAgIGNvbnN0IHRlbXBsYXRlID0gbGVnYWN5Q1NTXG4gICAgICAgICAgICA/ICh2YWx1ZXMubGVuZ3RoID09PSA0XG4gICAgICAgICAgICAgICAgPyBgcmdiYSh7MX0ke2NvbW1hfXsyfSR7Y29tbWF9ezN9JHtjb21tYX17NH0pYFxuICAgICAgICAgICAgICAgIDogYHJnYih7MX0ke2NvbW1hfXsyfSR7Y29tbWF9ezN9KWApXG4gICAgICAgICAgICA6ICh2YWx1ZXMubGVuZ3RoID09PSA0XG4gICAgICAgICAgICAgICAgPyBgcmdiKHsxfSB7Mn0gezN9IC8gezR9KWBcbiAgICAgICAgICAgICAgICA6IGByZ2IoezF9IHsyfSB7M30pYCk7XG4gICAgICAgIHJldHVybiBnZXRSZXN1bHRGcm9tVGVtcGxhdGUodGVtcGxhdGUsIHZhbHVlcyk7XG4gICAgfSxcbiAgICBbQ29sb3JNb2RlbC5IU0xdOiAoY29sb3IsIG9wdGlvbnMpID0+IHtcbiAgICAgICAgY29uc3QgeyBkZWNpbWFscywgbGVnYWN5Q1NTLCBzcGFjZXNBZnRlckNvbW1hcywgYW5nbGVzVW5pdCB9ID0gb3B0aW9ucztcbiAgICAgICAgY29uc3QgY29tbWEgPSBnZXRDb21tYShzcGFjZXNBZnRlckNvbW1hcyk7XG4gICAgICAgIGNvbnN0IHRyYW5zZm9ybWVyID0gKHZhbHVlLCBpbmRleCkgPT4ge1xuICAgICAgICAgICAgaWYgKGluZGV4ID09PSAwICYmXG4gICAgICAgICAgICAgICAgYW5nbGVzVW5pdCAhPT0gQW5nbGVzVW5pdEVudW0uTk9ORSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHRyYW5zbGF0ZWQgPSByb3VuZCh0cmFuc2xhdGVEZWdyZWVzKHZhbHVlLCBhbmdsZXNVbml0KSwgZGVjaW1hbHMpO1xuICAgICAgICAgICAgICAgIHJldHVybiBgJHt0cmFuc2xhdGVkfSR7YW5nbGVzVW5pdH1gO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGluZGV4ID09PSAzXG4gICAgICAgICAgICAgICAgPyBnZXRBbHBoYSh2YWx1ZSwgb3B0aW9ucylcbiAgICAgICAgICAgICAgICA6IHJvdW5kKHZhbHVlLCBkZWNpbWFscyk7XG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IHZhbHVlcyA9IHByZXBhcmVDb2xvckZvckNzcyhjb2xvciwgdHJhbnNmb3JtZXIpO1xuICAgICAgICBjb25zdCB0ZW1wbGF0ZSA9IGxlZ2FjeUNTU1xuICAgICAgICAgICAgPyAodmFsdWVzLmxlbmd0aCA9PT0gNFxuICAgICAgICAgICAgICAgID8gYGhzbGEoezF9JHtjb21tYX17Mn0lJHtjb21tYX17M30lJHtjb21tYX17NH0pYFxuICAgICAgICAgICAgICAgIDogYGhzbCh7MX0ke2NvbW1hfXsyfSUke2NvbW1hfXszfSUpYClcbiAgICAgICAgICAgIDogKHZhbHVlcy5sZW5ndGggPT09IDRcbiAgICAgICAgICAgICAgICA/IGBoc2woezF9IHsyfSUgezN9JSAvIHs0fSlgXG4gICAgICAgICAgICAgICAgOiBgaHNsKHsxfSB7Mn0lIHszfSUpYCk7XG4gICAgICAgIHJldHVybiBnZXRSZXN1bHRGcm9tVGVtcGxhdGUodGVtcGxhdGUsIHZhbHVlcyk7XG4gICAgfSxcbiAgICBbQ29sb3JNb2RlbC5DSUVMYWJdOiAoY29sb3IsIG9wdGlvbnMpID0+IHtcbiAgICAgICAgY29uc3QgeyBkZWNpbWFscywgbGFiVW5pdCB9ID0gb3B0aW9ucztcbiAgICAgICAgY29uc3QgdHJhbnNmb3JtZXIgPSAodmFsdWUsIGluZGV4KSA9PiB7XG4gICAgICAgICAgICBpZiAoaW5kZXggPT09IDApIHtcbiAgICAgICAgICAgICAgICBjb25zdCBMID0gcm91bmQocGVyY2VudCh2YWx1ZSksIGRlY2ltYWxzKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gbGFiVW5pdCA9PT0gQ29sb3JVbml0RW51bS5QRVJDRU5UXG4gICAgICAgICAgICAgICAgICAgID8gYCR7TH0lYFxuICAgICAgICAgICAgICAgICAgICA6IGAke0x9YDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpbmRleCA8IDMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbGFiVW5pdCA9PT0gQ29sb3JVbml0RW51bS5QRVJDRU5UXG4gICAgICAgICAgICAgICAgICAgID8gYCR7ZnJvbTEyNU51bWJlclRvUGVyY2VudCh2YWx1ZSwgZGVjaW1hbHMpfSVgXG4gICAgICAgICAgICAgICAgICAgIDogcm91bmQodmFsdWUsIGRlY2ltYWxzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBnZXRBbHBoYSh2YWx1ZSwgb3B0aW9ucywgdHJ1ZSk7XG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IHZhbHVlcyA9IHByZXBhcmVDb2xvckZvckNzcyhjb2xvciwgdHJhbnNmb3JtZXIpO1xuICAgICAgICBjb25zdCB0ZW1wbGF0ZSA9IHZhbHVlcy5sZW5ndGggPT09IDRcbiAgICAgICAgICAgID8gYGxhYih7MX0gezJ9IHszfSAvIHs0fSlgXG4gICAgICAgICAgICA6IGBsYWIoezF9IHsyfSB7M30pYDtcbiAgICAgICAgcmV0dXJuIGdldFJlc3VsdEZyb21UZW1wbGF0ZSh0ZW1wbGF0ZSwgdmFsdWVzKTtcbiAgICB9LFxuICAgIFtDb2xvck1vZGVsLkNNWUtdOiAoY29sb3IsIG9wdGlvbnMpID0+IHtcbiAgICAgICAgY29uc3QgeyBkZWNpbWFscywgbGVnYWN5Q1NTLCBzcGFjZXNBZnRlckNvbW1hcywgY215a1VuaXQsIGNteWtGdW5jdGlvbiB9ID0gb3B0aW9ucztcbiAgICAgICAgY29uc3QgY29tbWEgPSBnZXRDb21tYShzcGFjZXNBZnRlckNvbW1hcyk7XG4gICAgICAgIGNvbnN0IHRyYW5zZm9ybWVyID0gKHZhbHVlLCBpbmRleCkgPT4ge1xuICAgICAgICAgICAgaWYgKGNteWtVbml0ID09PSBDb2xvclVuaXRFbnVtLlBFUkNFTlQgJiZcbiAgICAgICAgICAgICAgICBpbmRleCA8IDQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYCR7cm91bmQodmFsdWUsIGRlY2ltYWxzKX0lYDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBpbmRleCA9PT0gNFxuICAgICAgICAgICAgICAgID8gZ2V0QWxwaGEodmFsdWUsIG9wdGlvbnMpXG4gICAgICAgICAgICAgICAgOiByb3VuZCh2YWx1ZSAvIDEwMCwgZGVjaW1hbHMpO1xuICAgICAgICB9O1xuICAgICAgICBjb25zdCB2YWx1ZXMgPSBwcmVwYXJlQ29sb3JGb3JDc3MoY29sb3IsIHRyYW5zZm9ybWVyKTtcbiAgICAgICAgY29uc3QgdGVtcGxhdGUgPSBsZWdhY3lDU1NcbiAgICAgICAgICAgID8gKHZhbHVlcy5sZW5ndGggPT09IDVcbiAgICAgICAgICAgICAgICA/IGAke2NteWtGdW5jdGlvbn0oezF9JHtjb21tYX17Mn0ke2NvbW1hfXszfSR7Y29tbWF9ezR9JHtjb21tYX17NX0pYFxuICAgICAgICAgICAgICAgIDogYCR7Y215a0Z1bmN0aW9ufSh7MX0ke2NvbW1hfXsyfSR7Y29tbWF9ezN9JHtjb21tYX17NH0pYClcbiAgICAgICAgICAgIDogKHZhbHVlcy5sZW5ndGggPT09IDVcbiAgICAgICAgICAgICAgICA/IGAke2NteWtGdW5jdGlvbn0oezF9IHsyfSB7M30gezR9IC8gezV9KWBcbiAgICAgICAgICAgICAgICA6IGAke2NteWtGdW5jdGlvbn0oezF9IHsyfSB7M30gezR9KWApO1xuICAgICAgICByZXR1cm4gZ2V0UmVzdWx0RnJvbVRlbXBsYXRlKHRlbXBsYXRlLCB2YWx1ZXMpO1xuICAgIH1cbn07XG4iLCJpbXBvcnQgeyBIRVgsIFBDRU5ULCBDb2xvck1vZGVsLCBNaXgsIENvbG9yS2V5d29yZHMsIENPTE9SUkVHUywgQ09MT1JfS0VZUywgRVJST1JTLCBWQUxJRF9DT0xPUl9PQkpFQ1RTIH0gZnJvbSAnI2NvbnN0YW50cyc7XG5pbXBvcnQgeyBnZXRPcmRlcmVkQXJyYXlTdHJpbmcsIGdldERFQywgZ2V0SEVYLCBnZXRCYXNlMjU1TnVtYmVyLCBnZXRCYXNlMTI1TnVtYmVyLCBnZXRDTVlLTnVtYmVyLCBoYXNQcm9wLCBwZXJjZW50LCBwZXJjZW50TnVtYmVyLCByb3VuZCwgbWlubWF4LCBub3JtYWxpemVIdWUgfSBmcm9tICcjaGVscGVycyc7XG5pbXBvcnQgeyByZ2JUb0hTTCwgaHNsVG9SR0IsIGNteWtUb1JHQiwgcmdiVG9DTVlLLCByZ2JUb1JZQiwgcnliVG9SR0IsIHJnYlRvTGFiLCBsYWJUb1JnYiwgaHVlUllCIH0gZnJvbSAnI2NvbG9yL3RyYW5zbGF0b3JzJztcbmltcG9ydCB7IENTUyB9IGZyb20gJyNjb2xvci9jc3MnO1xuZXhwb3J0IGNvbnN0IG5vcm1hbGl6ZUFscGhhID0gKGFscGhhKSA9PiB7XG4gICAgaWYgKHR5cGVvZiBhbHBoYSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgaWYgKFBDRU5ULnRlc3QoYWxwaGEpKSB7XG4gICAgICAgICAgICBhbHBoYSA9IHBlcmNlbnROdW1iZXIoYWxwaGEpIC8gMTAwO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgYWxwaGEgPSArYWxwaGE7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIChpc05hTigrYWxwaGEpIHx8IGFscGhhID4gMSkgPyAxIDogcm91bmQoYWxwaGEpO1xufTtcbmNvbnN0IGhhcm1vbnkgPSAoY29sb3IsIGFuZ2xlcywgbW9kZSkgPT4gYW5nbGVzLnJlZHVjZSgoYXJyLCBudW0pID0+IChbXG4gICAgLi4uYXJyLFxuICAgIHtcbiAgICAgICAgLi4uY29sb3IsXG4gICAgICAgIEg6IG1vZGUgPT09IE1peC5BRERJVElWRVxuICAgICAgICAgICAgPyBub3JtYWxpemVIdWUoY29sb3IuSCArIG51bSlcbiAgICAgICAgICAgIDogbm9ybWFsaXplSHVlKGh1ZVJZQihodWVSWUIoY29sb3IuSCwgZmFsc2UpICsgbnVtLCB0cnVlKSlcbiAgICB9XG5dKSwgW3sgLi4uY29sb3IgfV0pO1xuZXhwb3J0IGNvbnN0IGFuYWxvZ291cyA9IChjb2xvciwgbW9kZSkgPT4gaGFybW9ueShjb2xvciwgWzMwLCAtMzBdLCBtb2RlKTtcbmV4cG9ydCBjb25zdCBjb21wbGVtZW50YXJ5ID0gKGNvbG9yLCBtb2RlKSA9PiBoYXJtb255KGNvbG9yLCBbMTgwXSwgbW9kZSk7XG5leHBvcnQgY29uc3Qgc3BsaXRDb21wbGVtZW50YXJ5ID0gKGNvbG9yLCBtb2RlKSA9PiBoYXJtb255KGNvbG9yLCBbMTUwLCAtMTUwXSwgbW9kZSk7XG5leHBvcnQgY29uc3QgdHJpYWRpYyA9IChjb2xvciwgbW9kZSkgPT4gaGFybW9ueShjb2xvciwgWzEyMCwgLTEyMF0sIG1vZGUpO1xuZXhwb3J0IGNvbnN0IHRldHJhZGljID0gKGNvbG9yLCBtb2RlKSA9PiBoYXJtb255KGNvbG9yLCBbNjAsIC0xMjAsIDE4MF0sIG1vZGUpO1xuZXhwb3J0IGNvbnN0IHNxdWFyZSA9IChjb2xvciwgbW9kZSkgPT4gaGFybW9ueShjb2xvciwgWzkwLCAtOTAsIDE4MF0sIG1vZGUpO1xuY29uc3QgZ2V0Q29sb3JNb2RlbEZyb21TdHJpbmcgPSAoY29sb3IpID0+IHtcbiAgICBsZXQgbW9kZWw7XG4gICAgT2JqZWN0LmtleXMoQ29sb3JNb2RlbCkuc29tZSgocCkgPT4ge1xuICAgICAgICBjb25zdCByZWcgPSBDT0xPUlJFR1NbcF07XG4gICAgICAgIGlmIChyZWcudGVzdChjb2xvcikpIHtcbiAgICAgICAgICAgIG1vZGVsID0gcDtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgaWYgKCFtb2RlbCAmJlxuICAgICAgICAhIX5DT0xPUl9LRVlTLmluZGV4T2YoY29sb3IpKSB7XG4gICAgICAgIG1vZGVsID0gQ29sb3JNb2RlbC5IRVg7XG4gICAgfVxuICAgIGlmICghbW9kZWwpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKEVSUk9SUy5OT1RfQUNDRVBURURfU1RSSU5HX0lOUFVUKTtcbiAgICB9XG4gICAgcmV0dXJuIG1vZGVsO1xufTtcbmNvbnN0IGdldENvbG9yTW9kZWxGcm9tT2JqZWN0ID0gKGNvbG9yKSA9PiB7XG4gICAgbGV0IG1vZGVsO1xuICAgIGxldCBpbnZhbGlkID0gZmFsc2U7XG4gICAgY29uc3QgcHJvcHMgPSBnZXRPcmRlcmVkQXJyYXlTdHJpbmcoT2JqZWN0LmtleXMoY29sb3IpKTtcbiAgICBpZiAoVkFMSURfQ09MT1JfT0JKRUNUU1twcm9wc10pIHtcbiAgICAgICAgbW9kZWwgPSBWQUxJRF9DT0xPUl9PQkpFQ1RTW3Byb3BzXTtcbiAgICB9XG4gICAgaWYgKG1vZGVsICYmIG1vZGVsID09PSBDb2xvck1vZGVsLlJHQikge1xuICAgICAgICBjb25zdCBoYXNJbnZhbGlkSGV4ID0gT2JqZWN0LmVudHJpZXMoY29sb3IpLnNvbWUoKGl0ZW0pID0+IHtcbiAgICAgICAgICAgIHJldHVybiAhSEVYLnRlc3QoYCR7aXRlbVsxXX1gKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IGhhc0ludmFsaWRSZWdiID0gT2JqZWN0LmVudHJpZXMoY29sb3IpLnNvbWUoKGl0ZW0pID0+IHtcbiAgICAgICAgICAgIHJldHVybiAhKFBDRU5ULnRlc3QoYCR7aXRlbVsxXX1gKSB8fFxuICAgICAgICAgICAgICAgICghSEVYLnRlc3QoYCR7aXRlbVsxXX1gKSAmJlxuICAgICAgICAgICAgICAgICAgICAhaXNOYU4oK2l0ZW1bMV0pICYmXG4gICAgICAgICAgICAgICAgICAgICtpdGVtWzFdIDw9IDI1NSkpO1xuICAgICAgICB9KTtcbiAgICAgICAgaWYgKGhhc0ludmFsaWRIZXggJiYgaGFzSW52YWxpZFJlZ2IpIHtcbiAgICAgICAgICAgIGludmFsaWQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmICghaGFzSW52YWxpZEhleCkge1xuICAgICAgICAgICAgbW9kZWwgPSBDb2xvck1vZGVsLkhFWDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoIW1vZGVsIHx8IGludmFsaWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKEVSUk9SUy5OT1RfQUNDRVBURURfT0JKRUNUX0lOUFVUKTtcbiAgICB9XG4gICAgcmV0dXJuIG1vZGVsO1xufTtcbmV4cG9ydCBjb25zdCBnZXRDb2xvck1vZGVsID0gKGNvbG9yKSA9PiB0eXBlb2YgY29sb3IgPT09ICdzdHJpbmcnXG4gICAgPyBnZXRDb2xvck1vZGVsRnJvbVN0cmluZyhjb2xvcilcbiAgICA6IGdldENvbG9yTW9kZWxGcm9tT2JqZWN0KGNvbG9yKTtcbmV4cG9ydCBjb25zdCBnZXRSR0JPYmplY3RGcm9tU3RyaW5nID0ge1xuICAgIFtDb2xvck1vZGVsLkhFWF0oY29sb3IpIHtcbiAgICAgICAgY29uc3QgY29sb3JTdHIgPSAhfkNPTE9SX0tFWVMuaW5kZXhPZihjb2xvcilcbiAgICAgICAgICAgID8gY29sb3JcbiAgICAgICAgICAgIDogQ29sb3JLZXl3b3Jkc1tjb2xvcl07XG4gICAgICAgIGNvbnN0IG1hdGNoID0gY29sb3JTdHIubWF0Y2goQ09MT1JSRUdTLkhFWCk7XG4gICAgICAgIGNvbnN0IG9iamVjdCA9IHtcbiAgICAgICAgICAgIFI6IGdldERFQyhtYXRjaFsxXSB8fCBtYXRjaFs1XSksXG4gICAgICAgICAgICBHOiBnZXRERUMobWF0Y2hbMl0gfHwgbWF0Y2hbNl0pLFxuICAgICAgICAgICAgQjogZ2V0REVDKG1hdGNoWzNdIHx8IG1hdGNoWzddKVxuICAgICAgICB9O1xuICAgICAgICBjb25zdCBBID0gbWF0Y2hbNF0gfHwgbWF0Y2hbOF07XG4gICAgICAgIGlmIChBICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIG9iamVjdC5BID0gZ2V0REVDKEEpIC8gMjU1O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvYmplY3Q7XG4gICAgfSxcbiAgICBbQ29sb3JNb2RlbC5SR0JdKGNvbG9yKSB7XG4gICAgICAgIGNvbnN0IG1hdGNoID0gY29sb3IubWF0Y2goQ09MT1JSRUdTLlJHQik7XG4gICAgICAgIGNvbnN0IFIgPSBnZXRCYXNlMjU1TnVtYmVyKG1hdGNoWzFdIHx8IG1hdGNoWzVdKTtcbiAgICAgICAgY29uc3QgRyA9IGdldEJhc2UyNTVOdW1iZXIobWF0Y2hbMl0gfHwgbWF0Y2hbNl0pO1xuICAgICAgICBjb25zdCBCID0gZ2V0QmFzZTI1NU51bWJlcihtYXRjaFszXSB8fCBtYXRjaFs3XSk7XG4gICAgICAgIGNvbnN0IEEgPSBtYXRjaFs0XSB8fCBtYXRjaFs4XTtcbiAgICAgICAgY29uc3Qgb2JqZWN0ID0ge1xuICAgICAgICAgICAgUjogTWF0aC5taW4oUiwgMjU1KSxcbiAgICAgICAgICAgIEc6IE1hdGgubWluKEcsIDI1NSksXG4gICAgICAgICAgICBCOiBNYXRoLm1pbihCLCAyNTUpXG4gICAgICAgIH07XG4gICAgICAgIGlmIChBICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIG9iamVjdC5BID0gbm9ybWFsaXplQWxwaGEoQSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG9iamVjdDtcbiAgICB9LFxuICAgIFtDb2xvck1vZGVsLkhTTF0oY29sb3IpIHtcbiAgICAgICAgY29uc3QgbWF0Y2ggPSBjb2xvci5tYXRjaChDT0xPUlJFR1MuSFNMKTtcbiAgICAgICAgY29uc3QgSCA9IG5vcm1hbGl6ZUh1ZShtYXRjaFsxXSB8fCBtYXRjaFs1XSk7XG4gICAgICAgIGNvbnN0IFMgPSBwZXJjZW50KG1hdGNoWzJdIHx8IG1hdGNoWzZdKTtcbiAgICAgICAgY29uc3QgTCA9IHBlcmNlbnQobWF0Y2hbM10gfHwgbWF0Y2hbN10pO1xuICAgICAgICBjb25zdCBBID0gbWF0Y2hbNF0gfHwgbWF0Y2hbOF07XG4gICAgICAgIGNvbnN0IFJHQiA9IGhzbFRvUkdCKEgsIFMsIEwpO1xuICAgICAgICBpZiAoQSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBSR0IuQSA9IG5vcm1hbGl6ZUFscGhhKEEpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBSR0I7XG4gICAgfSxcbiAgICBbQ29sb3JNb2RlbC5DSUVMYWJdKGNvbG9yKSB7XG4gICAgICAgIGNvbnN0IG1hdGNoID0gY29sb3IubWF0Y2goQ09MT1JSRUdTLkNJRUxhYik7XG4gICAgICAgIGNvbnN0IEwgPSBwZXJjZW50KG1hdGNoWzFdKTtcbiAgICAgICAgY29uc3QgYSA9IGdldEJhc2UxMjVOdW1iZXIobWF0Y2hbMl0pO1xuICAgICAgICBjb25zdCBiID0gZ2V0QmFzZTEyNU51bWJlcihtYXRjaFszXSk7XG4gICAgICAgIGNvbnN0IEEgPSBtYXRjaFs0XTtcbiAgICAgICAgY29uc3QgUkdCID0gbGFiVG9SZ2IoTCwgYSwgYik7XG4gICAgICAgIGlmIChBICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIFJHQi5BID0gbm9ybWFsaXplQWxwaGEoQSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFJHQjtcbiAgICB9LFxuICAgIFtDb2xvck1vZGVsLkNNWUtdKGNvbG9yKSB7XG4gICAgICAgIGNvbnN0IG1hdGNoID0gY29sb3IubWF0Y2goQ09MT1JSRUdTLkNNWUspO1xuICAgICAgICBjb25zdCBDID0gZ2V0Q01ZS051bWJlcihtYXRjaFsxXSB8fCBtYXRjaFs2XSk7XG4gICAgICAgIGNvbnN0IE0gPSBnZXRDTVlLTnVtYmVyKG1hdGNoWzJdIHx8IG1hdGNoWzddKTtcbiAgICAgICAgY29uc3QgWSA9IGdldENNWUtOdW1iZXIobWF0Y2hbM10gfHwgbWF0Y2hbOF0pO1xuICAgICAgICBjb25zdCBLID0gZ2V0Q01ZS051bWJlcihtYXRjaFs0XSB8fCBtYXRjaFs5XSk7XG4gICAgICAgIGNvbnN0IEEgPSBtYXRjaFs1XSB8fCBtYXRjaFsxMF07XG4gICAgICAgIGNvbnN0IFJHQiA9IGNteWtUb1JHQihDLCBNLCBZLCBLKTtcbiAgICAgICAgaWYgKEEgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgUkdCLkEgPSBub3JtYWxpemVBbHBoYShBKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gUkdCO1xuICAgIH1cbn07XG5leHBvcnQgY29uc3QgZ2V0UkdCT2JqZWN0RnJvbU9iamVjdCA9IHtcbiAgICBbQ29sb3JNb2RlbC5IRVhdKGNvbG9yKSB7XG4gICAgICAgIGNvbnN0IG9iamVjdCA9IHtcbiAgICAgICAgICAgIFI6IGdldEJhc2UyNTVOdW1iZXIoYCR7Y29sb3IuUn1gKSxcbiAgICAgICAgICAgIEc6IGdldEJhc2UyNTVOdW1iZXIoYCR7Y29sb3IuR31gKSxcbiAgICAgICAgICAgIEI6IGdldEJhc2UyNTVOdW1iZXIoYCR7Y29sb3IuQn1gKVxuICAgICAgICB9O1xuICAgICAgICBpZiAoaGFzUHJvcChjb2xvciwgJ0EnKSkge1xuICAgICAgICAgICAgb2JqZWN0LkEgPSBNYXRoLm1pbihnZXRCYXNlMjU1TnVtYmVyKGAke2NvbG9yLkF9YCwgdHJ1ZSksIDEpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvYmplY3Q7XG4gICAgfSxcbiAgICBbQ29sb3JNb2RlbC5SR0JdKGNvbG9yKSB7XG4gICAgICAgIHJldHVybiB0aGlzLkhFWChjb2xvcik7XG4gICAgfSxcbiAgICBbQ29sb3JNb2RlbC5IU0xdKGNvbG9yKSB7XG4gICAgICAgIGNvbnN0IFMgPSBwZXJjZW50KGAke2NvbG9yLlN9YCk7XG4gICAgICAgIGNvbnN0IEwgPSBwZXJjZW50KGAke2NvbG9yLkx9YCk7XG4gICAgICAgIGNvbnN0IFJHQiA9IGhzbFRvUkdCKG5vcm1hbGl6ZUh1ZShjb2xvci5IKSwgUywgTCk7XG4gICAgICAgIGlmIChoYXNQcm9wKGNvbG9yLCAnQScpKSB7XG4gICAgICAgICAgICBSR0IuQSA9IG5vcm1hbGl6ZUFscGhhKGNvbG9yLkEpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBSR0I7XG4gICAgfSxcbiAgICBbQ29sb3JNb2RlbC5DSUVMYWJdKGNvbG9yKSB7XG4gICAgICAgIGNvbnN0IEwgPSBwZXJjZW50KGAke2NvbG9yLkx9YCk7XG4gICAgICAgIGNvbnN0IGEgPSBnZXRCYXNlMTI1TnVtYmVyKGAke2NvbG9yLmF9YCk7XG4gICAgICAgIGNvbnN0IGIgPSBnZXRCYXNlMTI1TnVtYmVyKGAke2NvbG9yLmJ9YCk7XG4gICAgICAgIGNvbnN0IFJHQiA9IGxhYlRvUmdiKEwsIGEsIGIpO1xuICAgICAgICBpZiAoaGFzUHJvcChjb2xvciwgJ0EnKSkge1xuICAgICAgICAgICAgUkdCLkEgPSBub3JtYWxpemVBbHBoYShjb2xvci5BKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gUkdCO1xuICAgIH0sXG4gICAgW0NvbG9yTW9kZWwuQ01ZS10oY29sb3IpIHtcbiAgICAgICAgY29uc3QgQyA9IGdldENNWUtOdW1iZXIoYCR7Y29sb3IuQ31gKTtcbiAgICAgICAgY29uc3QgTSA9IGdldENNWUtOdW1iZXIoYCR7Y29sb3IuTX1gKTtcbiAgICAgICAgY29uc3QgWSA9IGdldENNWUtOdW1iZXIoYCR7Y29sb3IuWX1gKTtcbiAgICAgICAgY29uc3QgSyA9IGdldENNWUtOdW1iZXIoYCR7Y29sb3IuS31gKTtcbiAgICAgICAgY29uc3QgUkdCID0gY215a1RvUkdCKEMsIE0sIFksIEspO1xuICAgICAgICBpZiAoaGFzUHJvcChjb2xvciwgJ0EnKSkge1xuICAgICAgICAgICAgUkdCLkEgPSBub3JtYWxpemVBbHBoYShjb2xvci5BKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gUkdCO1xuICAgIH1cbn07XG5leHBvcnQgY29uc3QgZ2V0UkdCT2JqZWN0ID0gKGNvbG9yLCBtb2RlbCA9IGdldENvbG9yTW9kZWwoY29sb3IpKSA9PiB7XG4gICAgcmV0dXJuIHR5cGVvZiBjb2xvciA9PT0gJ3N0cmluZydcbiAgICAgICAgPyBnZXRSR0JPYmplY3RGcm9tU3RyaW5nW21vZGVsXShjb2xvcilcbiAgICAgICAgOiBnZXRSR0JPYmplY3RGcm9tT2JqZWN0W21vZGVsXShjb2xvcik7XG59O1xuZXhwb3J0IGNvbnN0IHRyYW5zbGF0ZUNvbG9yID0ge1xuICAgIFtDb2xvck1vZGVsLkhFWF0oY29sb3IpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIFI6IGdldEhFWChjb2xvci5SKSxcbiAgICAgICAgICAgIEc6IGdldEhFWChjb2xvci5HKSxcbiAgICAgICAgICAgIEI6IGdldEhFWChjb2xvci5CKVxuICAgICAgICB9O1xuICAgIH0sXG4gICAgSEVYQShjb2xvcikge1xuICAgICAgICBjb25zdCBSR0IgPSB0cmFuc2xhdGVDb2xvci5IRVgoY29sb3IpO1xuICAgICAgICBSR0IuQSA9IGhhc1Byb3AoY29sb3IsICdBJylcbiAgICAgICAgICAgID8gZ2V0SEVYKGNvbG9yLkEgKiAyNTUpXG4gICAgICAgICAgICA6ICcweEZGJztcbiAgICAgICAgcmV0dXJuIFJHQjtcbiAgICB9LFxuICAgIFtDb2xvck1vZGVsLlJHQl0oY29sb3IsIGRlY2ltYWxzKSB7XG4gICAgICAgIGNvbnN0IFJHQiA9IHJvdW5kUkdCT2JqZWN0KGNvbG9yLCBkZWNpbWFscyk7XG4gICAgICAgIGlmIChoYXNQcm9wKFJHQiwgJ0EnKSkge1xuICAgICAgICAgICAgZGVsZXRlIFJHQi5BO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBSR0I7XG4gICAgfSxcbiAgICBSR0JBKGNvbG9yLCBkZWNpbWFscykge1xuICAgICAgICBjb25zdCBSR0IgPSB0cmFuc2xhdGVDb2xvci5SR0IoY29sb3IsIGRlY2ltYWxzKTtcbiAgICAgICAgUkdCLkEgPSBoYXNQcm9wKGNvbG9yLCAnQScpXG4gICAgICAgICAgICA/IHJvdW5kKGNvbG9yLkEpXG4gICAgICAgICAgICA6IDE7XG4gICAgICAgIHJldHVybiBSR0I7XG4gICAgfSxcbiAgICBbQ29sb3JNb2RlbC5IU0xdKGNvbG9yLCBkZWNpbWFscykge1xuICAgICAgICBjb25zdCBIU0wgPSByZ2JUb0hTTChjb2xvci5SLCBjb2xvci5HLCBjb2xvci5CKTtcbiAgICAgICAgZGVsZXRlIEhTTC5BO1xuICAgICAgICByZXR1cm4gcm91bmRIU0xPYmplY3QoSFNMLCBkZWNpbWFscyk7XG4gICAgfSxcbiAgICBIU0xBKGNvbG9yLCBkZWNpbWFscykge1xuICAgICAgICBjb25zdCBIU0wgPSB0cmFuc2xhdGVDb2xvci5IU0woY29sb3IsIGRlY2ltYWxzKTtcbiAgICAgICAgSFNMLkEgPSBoYXNQcm9wKGNvbG9yLCAnQScpXG4gICAgICAgICAgICA/IHJvdW5kKGNvbG9yLkEsIGRlY2ltYWxzKVxuICAgICAgICAgICAgOiAxO1xuICAgICAgICByZXR1cm4gSFNMO1xuICAgIH0sXG4gICAgW0NvbG9yTW9kZWwuQ0lFTGFiXShjb2xvciwgZGVjaW1hbHMpIHtcbiAgICAgICAgY29uc3QgTGFiID0gcmdiVG9MYWIoY29sb3IuUiwgY29sb3IuRywgY29sb3IuQik7XG4gICAgICAgIHJldHVybiByb3VuZENJRUxhYk9iamVjdChMYWIsIGRlY2ltYWxzKTtcbiAgICB9LFxuICAgIENJRUxhYkEoY29sb3IsIGRlY2ltYWxzKSB7XG4gICAgICAgIGNvbnN0IExhYiA9IHRyYW5zbGF0ZUNvbG9yLkNJRUxhYihjb2xvciwgZGVjaW1hbHMpO1xuICAgICAgICBMYWIuQSA9IGhhc1Byb3AoY29sb3IsICdBJylcbiAgICAgICAgICAgID8gcm91bmQoY29sb3IuQSwgZGVjaW1hbHMpXG4gICAgICAgICAgICA6IDE7XG4gICAgICAgIHJldHVybiBMYWI7XG4gICAgfSxcbiAgICBbQ29sb3JNb2RlbC5DTVlLXShjb2xvciwgZGVjaW1hbHMpIHtcbiAgICAgICAgcmV0dXJuIHJvdW5kQ01ZS09iamVjdChyZ2JUb0NNWUsoY29sb3IuUiwgY29sb3IuRywgY29sb3IuQiksIGRlY2ltYWxzKTtcbiAgICB9LFxuICAgIENNWUtBKGNvbG9yLCBkZWNpbWFscykge1xuICAgICAgICBjb25zdCBDTVlLID0gdHJhbnNsYXRlQ29sb3IuQ01ZSyhjb2xvciwgZGVjaW1hbHMpO1xuICAgICAgICBDTVlLLkEgPSBoYXNQcm9wKGNvbG9yLCAnQScpXG4gICAgICAgICAgICA/IHJvdW5kKGNvbG9yLkEsIGRlY2ltYWxzKVxuICAgICAgICAgICAgOiAxO1xuICAgICAgICByZXR1cm4gQ01ZSztcbiAgICB9XG59O1xuZXhwb3J0IGNvbnN0IGJsZW5kID0gKGZyb20sIHRvLCBzdGVwcykgPT4ge1xuICAgIGNvbnN0IGRpdiA9IHN0ZXBzIC0gMTtcbiAgICBjb25zdCBkaWZmUiA9ICh0by5SIC0gZnJvbS5SKSAvIGRpdjtcbiAgICBjb25zdCBkaWZmRyA9ICh0by5HIC0gZnJvbS5HKSAvIGRpdjtcbiAgICBjb25zdCBkaWZmQiA9ICh0by5CIC0gZnJvbS5CKSAvIGRpdjtcbiAgICBjb25zdCBmcm9tQSA9IG5vcm1hbGl6ZUFscGhhKGZyb20uQSk7XG4gICAgY29uc3QgdG9BID0gbm9ybWFsaXplQWxwaGEodG8uQSk7XG4gICAgY29uc3QgZGlmZkEgPSAodG9BIC0gZnJvbUEpIC8gZGl2O1xuICAgIHJldHVybiBBcnJheShzdGVwcykuZmlsbChudWxsKS5tYXAoKF9fbiwgaSkgPT4ge1xuICAgICAgICBpZiAoaSA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIGZyb207XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGkgPT09IGRpdikge1xuICAgICAgICAgICAgcmV0dXJuIHRvO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBSOiByb3VuZChmcm9tLlIgKyBkaWZmUiAqIGkpLFxuICAgICAgICAgICAgRzogcm91bmQoZnJvbS5HICsgZGlmZkcgKiBpKSxcbiAgICAgICAgICAgIEI6IHJvdW5kKGZyb20uQiArIGRpZmZCICogaSksXG4gICAgICAgICAgICBBOiByb3VuZChmcm9tQSArIGRpZmZBICogaSlcbiAgICAgICAgfTtcbiAgICB9KTtcbn07XG5leHBvcnQgY29uc3QgZ2V0Q29sb3JNaXh0dXJlID0gKGNvbG9yLCBzdGVwcywgc2hhZGVzLCBvcHRpb25zKSA9PiB7XG4gICAgY29uc3QgbW9kZWwgPSBnZXRDb2xvck1vZGVsKGNvbG9yKTtcbiAgICBjb25zdCBpc0NTUyA9IHR5cGVvZiBjb2xvciA9PT0gJ3N0cmluZyc7XG4gICAgY29uc3QgUkdCID0gZ2V0UkdCT2JqZWN0KGNvbG9yLCBtb2RlbCk7XG4gICAgY29uc3QgaGFzQWxwaGEgPSAoKHR5cGVvZiBjb2xvciA9PT0gJ3N0cmluZycgJiYgaGFzUHJvcChSR0IsICdBJykpIHx8XG4gICAgICAgICh0eXBlb2YgY29sb3IgIT09ICdzdHJpbmcnICYmIGhhc1Byb3AoY29sb3IsICdBJykpKTtcbiAgICBjb25zdCBIU0wgPSByZ2JUb0hTTChSR0IuUiwgUkdCLkcsIFJHQi5CLCBSR0IuQSk7XG4gICAgaWYgKCFoYXNBbHBoYSlcbiAgICAgICAgZGVsZXRlIEhTTC5BO1xuICAgIGNvbnN0IGluY3JlbWVudCA9IHNoYWRlc1xuICAgICAgICA/IEhTTC5MIC8gKHN0ZXBzICsgMSlcbiAgICAgICAgOiAoMTAwIC0gSFNMLkwpIC8gKHN0ZXBzICsgMSk7XG4gICAgY29uc3QgaHNsTWFwID0gQXJyYXkoc3RlcHMpLmZpbGwobnVsbCkubWFwKChfX24sIGkpID0+ICh7XG4gICAgICAgIC4uLkhTTCxcbiAgICAgICAgTDogSFNMLkwgKyBpbmNyZW1lbnQgKiAoaSArIDEpICogKDEgLSArc2hhZGVzICogMilcbiAgICB9KSk7XG4gICAgc3dpdGNoIChtb2RlbCkge1xuICAgICAgICBjYXNlIENvbG9yTW9kZWwuSEVYOlxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcmV0dXJuIGhzbE1hcC5tYXAoKEhTTENvbG9yKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgUkdCQ29sb3IgPSBoc2xUb1JHQihIU0xDb2xvci5ILCBIU0xDb2xvci5TLCBIU0xDb2xvci5MKTtcbiAgICAgICAgICAgICAgICBpZiAoaGFzQWxwaGEpXG4gICAgICAgICAgICAgICAgICAgIFJHQkNvbG9yLkEgPSBIU0xDb2xvci5BO1xuICAgICAgICAgICAgICAgIHJldHVybiBpc0NTU1xuICAgICAgICAgICAgICAgICAgICA/IGhhc0FscGhhXG4gICAgICAgICAgICAgICAgICAgICAgICA/IENTUy5IRVgoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC4uLlJHQkNvbG9yLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIEE6IHJvdW5kKFJHQkNvbG9yLkEgKiAyNTUpXG4gICAgICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICAgICAgOiBDU1MuSEVYKFJHQkNvbG9yKVxuICAgICAgICAgICAgICAgICAgICA6IGhhc0FscGhhXG4gICAgICAgICAgICAgICAgICAgICAgICA/IHRyYW5zbGF0ZUNvbG9yLkhFWEEoUkdCQ29sb3IpXG4gICAgICAgICAgICAgICAgICAgICAgICA6IHRyYW5zbGF0ZUNvbG9yLkhFWChSR0JDb2xvcik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgY2FzZSBDb2xvck1vZGVsLlJHQjpcbiAgICAgICAgICAgIHJldHVybiBoc2xNYXAubWFwKChIU0xDb2xvcikgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IFJHQkNvbG9yID0gaHNsVG9SR0IoSFNMQ29sb3IuSCwgSFNMQ29sb3IuUywgSFNMQ29sb3IuTCk7XG4gICAgICAgICAgICAgICAgaWYgKGhhc0FscGhhKVxuICAgICAgICAgICAgICAgICAgICBSR0JDb2xvci5BID0gSFNMQ29sb3IuQTtcbiAgICAgICAgICAgICAgICByZXR1cm4gaXNDU1NcbiAgICAgICAgICAgICAgICAgICAgPyBDU1MuUkdCKFJHQkNvbG9yLCBvcHRpb25zKVxuICAgICAgICAgICAgICAgICAgICA6IGhhc0FscGhhXG4gICAgICAgICAgICAgICAgICAgICAgICA/IHRyYW5zbGF0ZUNvbG9yLlJHQkEoUkdCQ29sb3IsIG9wdGlvbnMuZGVjaW1hbHMpXG4gICAgICAgICAgICAgICAgICAgICAgICA6IHRyYW5zbGF0ZUNvbG9yLlJHQihSR0JDb2xvciwgb3B0aW9ucy5kZWNpbWFscyk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgY2FzZSBDb2xvck1vZGVsLkhTTDpcbiAgICAgICAgICAgIHJldHVybiBoc2xNYXAubWFwKChIU0xDb2xvcikgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBpc0NTU1xuICAgICAgICAgICAgICAgICAgICA/IENTUy5IU0woSFNMQ29sb3IsIG9wdGlvbnMpXG4gICAgICAgICAgICAgICAgICAgIDogaGFzQWxwaGFcbiAgICAgICAgICAgICAgICAgICAgICAgID8gdHJhbnNsYXRlQ29sb3IuSFNMQSh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLi4uaHNsVG9SR0IoSFNMQ29sb3IuSCwgSFNMQ29sb3IuUywgSFNMQ29sb3IuTCksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgQTogSFNMQ29sb3IuQVxuICAgICAgICAgICAgICAgICAgICAgICAgfSwgb3B0aW9ucy5kZWNpbWFscylcbiAgICAgICAgICAgICAgICAgICAgICAgIDogdHJhbnNsYXRlQ29sb3IuSFNMKGhzbFRvUkdCKEhTTENvbG9yLkgsIEhTTENvbG9yLlMsIEhTTENvbG9yLkwpLCBvcHRpb25zLmRlY2ltYWxzKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICBjYXNlIENvbG9yTW9kZWwuQ0lFTGFiOlxuICAgICAgICAgICAgcmV0dXJuIGhzbE1hcC5tYXAoKEhTTENvbG9yKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgUkdCQ29sb3IgPSBoc2xUb1JHQihIU0xDb2xvci5ILCBIU0xDb2xvci5TLCBIU0xDb2xvci5MKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gaXNDU1NcbiAgICAgICAgICAgICAgICAgICAgPyBDU1MuQ0lFTGFiKGhhc0FscGhhXG4gICAgICAgICAgICAgICAgICAgICAgICA/IHRyYW5zbGF0ZUNvbG9yLkNJRUxhYkEoUkdCQ29sb3IsIG9wdGlvbnMuZGVjaW1hbHMpXG4gICAgICAgICAgICAgICAgICAgICAgICA6IHRyYW5zbGF0ZUNvbG9yLkNJRUxhYihSR0JDb2xvciwgb3B0aW9ucy5kZWNpbWFscyksIG9wdGlvbnMpXG4gICAgICAgICAgICAgICAgICAgIDogaGFzQWxwaGFcbiAgICAgICAgICAgICAgICAgICAgICAgID8gdHJhbnNsYXRlQ29sb3IuQ0lFTGFiQSh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLi4uUkdCQ29sb3IsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgQTogSFNMQ29sb3IuQVxuICAgICAgICAgICAgICAgICAgICAgICAgfSwgb3B0aW9ucy5kZWNpbWFscylcbiAgICAgICAgICAgICAgICAgICAgICAgIDogdHJhbnNsYXRlQ29sb3IuQ0lFTGFiKFJHQkNvbG9yLCBvcHRpb25zLmRlY2ltYWxzKTtcbiAgICAgICAgICAgIH0pO1xuICAgIH1cbn07XG5leHBvcnQgY29uc3QgY29sb3JIYXJtb255ID0ge1xuICAgIGJ1aWxkSGFybW9ueShjb2xvciwgaGFybW9ueUZ1bmN0aW9uLCBtb2RlLCBvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IG1vZGVsID0gZ2V0Q29sb3JNb2RlbChjb2xvcik7XG4gICAgICAgIGNvbnN0IFJHQiA9IGdldFJHQk9iamVjdChjb2xvciwgbW9kZWwpO1xuICAgICAgICBjb25zdCBIU0wgPSByZ2JUb0hTTChSR0IuUiwgUkdCLkcsIFJHQi5CLCBSR0IuQSk7XG4gICAgICAgIGNvbnN0IGhhc0FscGhhID0gKCh0eXBlb2YgY29sb3IgPT09ICdzdHJpbmcnICYmIGhhc1Byb3AoUkdCLCAnQScpKSB8fFxuICAgICAgICAgICAgKHR5cGVvZiBjb2xvciAhPT0gJ3N0cmluZycgJiYgaGFzUHJvcChjb2xvciwgJ0EnKSkpO1xuICAgICAgICBjb25zdCBpc0NTUyA9IHR5cGVvZiBjb2xvciA9PT0gJ3N0cmluZyc7XG4gICAgICAgIHN3aXRjaCAobW9kZWwpIHtcbiAgICAgICAgICAgIGNhc2UgQ29sb3JNb2RlbC5IRVg6XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHJldHVybiBoYXNBbHBoYVxuICAgICAgICAgICAgICAgICAgICA/IHRoaXMuSEVYQShyb3VuZEhTTE9iamVjdChIU0wsIDApLCBoYXJtb255RnVuY3Rpb24sIG1vZGUsIGlzQ1NTKVxuICAgICAgICAgICAgICAgICAgICA6IHRoaXMuSEVYKHJvdW5kSFNMT2JqZWN0KEhTTCwgMCksIGhhcm1vbnlGdW5jdGlvbiwgbW9kZSwgaXNDU1MpO1xuICAgICAgICAgICAgY2FzZSBDb2xvck1vZGVsLkhTTDpcbiAgICAgICAgICAgICAgICByZXR1cm4gaGFzQWxwaGFcbiAgICAgICAgICAgICAgICAgICAgPyB0aGlzLkhTTEEoSFNMLCBoYXJtb255RnVuY3Rpb24sIG1vZGUsIGlzQ1NTLCBvcHRpb25zKVxuICAgICAgICAgICAgICAgICAgICA6IHRoaXMuSFNMKEhTTCwgaGFybW9ueUZ1bmN0aW9uLCBtb2RlLCBpc0NTUywgb3B0aW9ucyk7XG4gICAgICAgICAgICBjYXNlIENvbG9yTW9kZWwuUkdCOlxuICAgICAgICAgICAgICAgIHJldHVybiBoYXNBbHBoYVxuICAgICAgICAgICAgICAgICAgICA/IHRoaXMuUkdCQShIU0wsIGhhcm1vbnlGdW5jdGlvbiwgbW9kZSwgaXNDU1MsIG9wdGlvbnMpXG4gICAgICAgICAgICAgICAgICAgIDogdGhpcy5SR0IoSFNMLCBoYXJtb255RnVuY3Rpb24sIG1vZGUsIGlzQ1NTLCBvcHRpb25zKTtcbiAgICAgICAgICAgIGNhc2UgQ29sb3JNb2RlbC5DSUVMYWI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIGhhc0FscGhhXG4gICAgICAgICAgICAgICAgICAgID8gdGhpcy5DSUVMYWJBKEhTTCwgaGFybW9ueUZ1bmN0aW9uLCBtb2RlLCBpc0NTUywgb3B0aW9ucylcbiAgICAgICAgICAgICAgICAgICAgOiB0aGlzLkNJRUxhYihIU0wsIGhhcm1vbnlGdW5jdGlvbiwgbW9kZSwgaXNDU1MsIG9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgfSxcbiAgICBbQ29sb3JNb2RlbC5IRVhdKGNvbG9yLCBoYXJtb255RnVuY3Rpb24sIG1vZGUsIGNzcykge1xuICAgICAgICBjb25zdCBhcnJheSA9IGhhcm1vbnlGdW5jdGlvbihjb2xvciwgbW9kZSk7XG4gICAgICAgIHJldHVybiBhcnJheS5tYXAoKGMpID0+IChjc3NcbiAgICAgICAgICAgID8gQ1NTLkhFWChoc2xUb1JHQihjLkgsIGMuUywgYy5MKSlcbiAgICAgICAgICAgIDogdHJhbnNsYXRlQ29sb3IuSEVYKGhzbFRvUkdCKGMuSCwgYy5TLCBjLkwpKSkpO1xuICAgIH0sXG4gICAgSEVYQShjb2xvciwgaGFybW9ueUZ1bmN0aW9uLCBtb2RlLCBjc3MpIHtcbiAgICAgICAgY29uc3QgYXJyYXkgPSBoYXJtb255RnVuY3Rpb24oY29sb3IsIG1vZGUpO1xuICAgICAgICByZXR1cm4gYXJyYXkubWFwKChjKSA9PiAoY3NzXG4gICAgICAgICAgICA/IENTUy5IRVgoe1xuICAgICAgICAgICAgICAgIC4uLmhzbFRvUkdCKGMuSCwgYy5TLCBjLkwpLFxuICAgICAgICAgICAgICAgIEE6IG5vcm1hbGl6ZUFscGhhKGMuQSkgKiAyNTVcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICA6IHRyYW5zbGF0ZUNvbG9yLkhFWEEoe1xuICAgICAgICAgICAgICAgIC4uLmhzbFRvUkdCKGMuSCwgYy5TLCBjLkwpLFxuICAgICAgICAgICAgICAgIEE6IG5vcm1hbGl6ZUFscGhhKGMuQSlcbiAgICAgICAgICAgIH0pKSk7XG4gICAgfSxcbiAgICBbQ29sb3JNb2RlbC5SR0JdKGNvbG9yLCBoYXJtb255RnVuY3Rpb24sIG1vZGUsIGNzcywgb3B0aW9ucykge1xuICAgICAgICBjb25zdCBhcnJheSA9IGhhcm1vbnlGdW5jdGlvbihjb2xvciwgbW9kZSk7XG4gICAgICAgIHJldHVybiBhcnJheS5tYXAoKGMpID0+IChjc3NcbiAgICAgICAgICAgID8gQ1NTLlJHQihoc2xUb1JHQihjLkgsIGMuUywgYy5MKSwgb3B0aW9ucylcbiAgICAgICAgICAgIDogdHJhbnNsYXRlQ29sb3IuUkdCKGhzbFRvUkdCKGMuSCwgYy5TLCBjLkwpLCBvcHRpb25zLmRlY2ltYWxzKSkpO1xuICAgIH0sXG4gICAgUkdCQShjb2xvciwgaGFybW9ueUZ1bmN0aW9uLCBtb2RlLCBjc3MsIG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgYXJyYXkgPSBoYXJtb255RnVuY3Rpb24oY29sb3IsIG1vZGUpO1xuICAgICAgICByZXR1cm4gYXJyYXkubWFwKChjKSA9PiAoY3NzXG4gICAgICAgICAgICA/IENTUy5SR0Ioe1xuICAgICAgICAgICAgICAgIC4uLmhzbFRvUkdCKGMuSCwgYy5TLCBjLkwpLFxuICAgICAgICAgICAgICAgIEE6IG5vcm1hbGl6ZUFscGhhKGMuQSlcbiAgICAgICAgICAgIH0sIG9wdGlvbnMpXG4gICAgICAgICAgICA6IHRyYW5zbGF0ZUNvbG9yLlJHQkEoe1xuICAgICAgICAgICAgICAgIC4uLmhzbFRvUkdCKGMuSCwgYy5TLCBjLkwpLFxuICAgICAgICAgICAgICAgIEE6IG5vcm1hbGl6ZUFscGhhKGMuQSlcbiAgICAgICAgICAgIH0sIG9wdGlvbnMuZGVjaW1hbHMpKSk7XG4gICAgfSxcbiAgICBbQ29sb3JNb2RlbC5IU0xdKGNvbG9yLCBoYXJtb255RnVuY3Rpb24sIG1vZGUsIGNzcywgb3B0aW9ucykge1xuICAgICAgICBjb25zdCBhcnJheSA9IGhhcm1vbnlGdW5jdGlvbihjb2xvciwgbW9kZSk7XG4gICAgICAgIHJldHVybiBhcnJheS5tYXAoKGMpID0+IChjc3NcbiAgICAgICAgICAgID8gQ1NTLkhTTCh7XG4gICAgICAgICAgICAgICAgSDogYy5ILFxuICAgICAgICAgICAgICAgIFM6IGMuUyxcbiAgICAgICAgICAgICAgICBMOiBjLkxcbiAgICAgICAgICAgIH0sIG9wdGlvbnMpXG4gICAgICAgICAgICA6IHRyYW5zbGF0ZUNvbG9yLkhTTChoc2xUb1JHQihjLkgsIGMuUywgYy5MKSwgb3B0aW9ucy5kZWNpbWFscykpKTtcbiAgICB9LFxuICAgIEhTTEEoY29sb3IsIGhhcm1vbnlGdW5jdGlvbiwgbW9kZSwgY3NzLCBvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IGFycmF5ID0gaGFybW9ueUZ1bmN0aW9uKGNvbG9yLCBtb2RlKTtcbiAgICAgICAgcmV0dXJuIGFycmF5Lm1hcCgoYykgPT4gKGNzc1xuICAgICAgICAgICAgPyBDU1MuSFNMKHtcbiAgICAgICAgICAgICAgICAuLi5jLFxuICAgICAgICAgICAgICAgIEE6IG5vcm1hbGl6ZUFscGhhKGMuQSlcbiAgICAgICAgICAgIH0sIG9wdGlvbnMpXG4gICAgICAgICAgICA6IHRyYW5zbGF0ZUNvbG9yLkhTTEEoe1xuICAgICAgICAgICAgICAgIC4uLmhzbFRvUkdCKGMuSCwgYy5TLCBjLkwpLFxuICAgICAgICAgICAgICAgIEE6IG5vcm1hbGl6ZUFscGhhKGMuQSlcbiAgICAgICAgICAgIH0sIG9wdGlvbnMuZGVjaW1hbHMpKSk7XG4gICAgfSxcbiAgICBbQ29sb3JNb2RlbC5DSUVMYWJdKGNvbG9yLCBoYXJtb255RnVuY3Rpb24sIG1vZGUsIGNzcywgb3B0aW9ucykge1xuICAgICAgICBjb25zdCBhcnJheSA9IGhhcm1vbnlGdW5jdGlvbihjb2xvciwgbW9kZSk7XG4gICAgICAgIHJldHVybiBhcnJheS5tYXAoKGMpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IFJHQiA9IGhzbFRvUkdCKGMuSCwgYy5TLCBjLkwpO1xuICAgICAgICAgICAgcmV0dXJuIChjc3NcbiAgICAgICAgICAgICAgICA/IENTUy5DSUVMYWIocmdiVG9MYWIoUkdCLlIsIFJHQi5HLCBSR0IuQiksIG9wdGlvbnMpXG4gICAgICAgICAgICAgICAgOiB0cmFuc2xhdGVDb2xvci5DSUVMYWIoUkdCLCBvcHRpb25zLmRlY2ltYWxzKSk7XG4gICAgICAgIH0pO1xuICAgIH0sXG4gICAgQ0lFTGFiQShjb2xvciwgaGFybW9ueUZ1bmN0aW9uLCBtb2RlLCBjc3MsIG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgYXJyYXkgPSBoYXJtb255RnVuY3Rpb24oY29sb3IsIG1vZGUpO1xuICAgICAgICByZXR1cm4gYXJyYXkubWFwKChjKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBSR0IgPSBoc2xUb1JHQihjLkgsIGMuUywgYy5MKTtcbiAgICAgICAgICAgIHJldHVybiAoY3NzXG4gICAgICAgICAgICAgICAgPyBDU1MuQ0lFTGFiKHtcbiAgICAgICAgICAgICAgICAgICAgLi4ucmdiVG9MYWIoUkdCLlIsIFJHQi5HLCBSR0IuQiksXG4gICAgICAgICAgICAgICAgICAgIEE6IG5vcm1hbGl6ZUFscGhhKGMuQSlcbiAgICAgICAgICAgICAgICB9LCBvcHRpb25zKVxuICAgICAgICAgICAgICAgIDogdHJhbnNsYXRlQ29sb3IuQ0lFTGFiQSh7XG4gICAgICAgICAgICAgICAgICAgIC4uLlJHQixcbiAgICAgICAgICAgICAgICAgICAgQTogbm9ybWFsaXplQWxwaGEoYy5BKVxuICAgICAgICAgICAgICAgIH0sIG9wdGlvbnMuZGVjaW1hbHMpKTtcbiAgICAgICAgfSk7XG4gICAgfVxufTtcbmV4cG9ydCBjb25zdCBjb2xvck1peGVyID0ge1xuICAgIG1peChjb2xvcnMsIG1vZGUpIHtcbiAgICAgICAgY29uc3QgcmdiTWFwID0gY29sb3JzLm1hcCgoY29sb3IpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IG1vZGVsID0gZ2V0Q29sb3JNb2RlbChjb2xvcik7XG4gICAgICAgICAgICByZXR1cm4gZ2V0UkdCT2JqZWN0KGNvbG9yLCBtb2RlbCk7XG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCByeWJNYXAgPSBtb2RlID09PSBNaXguU1VCVFJBQ1RJVkVcbiAgICAgICAgICAgID8gcmdiTWFwLm1hcCgoY29sb3IpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBSWUIgPSByZ2JUb1JZQihjb2xvci5SLCBjb2xvci5HLCBjb2xvci5CKTtcbiAgICAgICAgICAgICAgICBpZiAoaGFzUHJvcChjb2xvciwgJ0EnKSkge1xuICAgICAgICAgICAgICAgICAgICBSWUIuQSA9IGNvbG9yLkE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBSWUI7XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgOiBudWxsO1xuICAgICAgICBmdW5jdGlvbiBjcmVhdGVNaXgoaXRlbXMpIHtcbiAgICAgICAgICAgIGNvbnN0IGluaXRpYWwgPSBtb2RlID09PSBNaXguQURESVRJVkVcbiAgICAgICAgICAgICAgICA/IHsgUjogMCwgRzogMCwgQjogMCwgQTogMCB9XG4gICAgICAgICAgICAgICAgOiB7IFI6IDAsIFk6IDAsIEI6IDAsIEE6IDAgfTtcbiAgICAgICAgICAgIHJldHVybiBpdGVtcy5yZWR1Y2UoKG1peCwgY29sb3IpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBjb2xvckEgPSBoYXNQcm9wKGNvbG9yLCAnQScpID8gY29sb3IuQSA6IDE7XG4gICAgICAgICAgICAgICAgY29uc3QgY29tbW9uID0ge1xuICAgICAgICAgICAgICAgICAgICBSOiBNYXRoLm1pbihtaXguUiArIGNvbG9yLlIgKiBjb2xvckEsIDI1NSksXG4gICAgICAgICAgICAgICAgICAgIEI6IE1hdGgubWluKG1peC5CICsgY29sb3IuQiAqIGNvbG9yQSwgMjU1KSxcbiAgICAgICAgICAgICAgICAgICAgQTogMSAtICgxIC0gY29sb3JBKSAqICgxIC0gbWl4LkEpXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBjb25zdCBtaXhHWSA9ICdHJyBpbiBtaXhcbiAgICAgICAgICAgICAgICAgICAgPyBtaXguR1xuICAgICAgICAgICAgICAgICAgICA6IG1peC5ZO1xuICAgICAgICAgICAgICAgIGNvbnN0IGNvbG9yR1kgPSAnRycgaW4gY29sb3JcbiAgICAgICAgICAgICAgICAgICAgPyBjb2xvci5HXG4gICAgICAgICAgICAgICAgICAgIDogY29sb3IuWTtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAuLi5jb21tb24sXG4gICAgICAgICAgICAgICAgICAgIC4uLihtb2RlID09PSBNaXguQURESVRJVkVcbiAgICAgICAgICAgICAgICAgICAgICAgID8geyBHOiBNYXRoLm1pbihtaXhHWSArIGNvbG9yR1kgKiBjb2xvckEsIDI1NSkgfVxuICAgICAgICAgICAgICAgICAgICAgICAgOiB7IFk6IE1hdGgubWluKG1peEdZICsgY29sb3JHWSAqIGNvbG9yQSwgMjU1KSB9KVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9LCBpbml0aWFsKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgbWl4O1xuICAgICAgICBpZiAobW9kZSA9PT0gTWl4LkFERElUSVZFKSB7XG4gICAgICAgICAgICBtaXggPSBjcmVhdGVNaXgocmdiTWFwKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IFJZQiA9IGNyZWF0ZU1peChyeWJNYXApO1xuICAgICAgICAgICAgbWl4ID0gcnliVG9SR0IoUllCLlIsIFJZQi5ZLCBSWUIuQik7XG4gICAgICAgICAgICBtaXguQSA9IFJZQi5BO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBSOiByb3VuZChtaXguUiksXG4gICAgICAgICAgICBHOiByb3VuZChtaXguRyksXG4gICAgICAgICAgICBCOiByb3VuZChtaXguQiksXG4gICAgICAgICAgICBBOiBtaW5tYXgobWl4LkEsIDAsIDEpXG4gICAgICAgIH07XG4gICAgfSxcbiAgICBbQ29sb3JNb2RlbC5IRVhdKGNvbG9ycywgbW9kZSwgY3NzKSB7XG4gICAgICAgIGNvbnN0IG1peCA9IHRoaXMubWl4KGNvbG9ycywgbW9kZSk7XG4gICAgICAgIGRlbGV0ZSBtaXguQTtcbiAgICAgICAgcmV0dXJuIChjc3NcbiAgICAgICAgICAgID8gQ1NTLkhFWChtaXgpXG4gICAgICAgICAgICA6IHRyYW5zbGF0ZUNvbG9yLkhFWChtaXgpKTtcbiAgICB9LFxuICAgIEhFWEEoY29sb3JzLCBtb2RlLCBjc3MpIHtcbiAgICAgICAgY29uc3QgbWl4ID0gdGhpcy5taXgoY29sb3JzLCBtb2RlKTtcbiAgICAgICAgbWl4LkEgPSBjc3NcbiAgICAgICAgICAgID8gbm9ybWFsaXplQWxwaGEobWl4LkEpICogMjU1XG4gICAgICAgICAgICA6IG5vcm1hbGl6ZUFscGhhKG1peC5BKTtcbiAgICAgICAgcmV0dXJuIChjc3NcbiAgICAgICAgICAgID8gQ1NTLkhFWChtaXgpXG4gICAgICAgICAgICA6IHRyYW5zbGF0ZUNvbG9yLkhFWEEobWl4KSk7XG4gICAgfSxcbiAgICBbQ29sb3JNb2RlbC5SR0JdKGNvbG9ycywgbW9kZSwgY3NzLCBvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IG1peCA9IHRoaXMubWl4KGNvbG9ycywgbW9kZSk7XG4gICAgICAgIGRlbGV0ZSBtaXguQTtcbiAgICAgICAgcmV0dXJuIChjc3NcbiAgICAgICAgICAgID8gQ1NTLlJHQihtaXgsIG9wdGlvbnMpXG4gICAgICAgICAgICA6IHRyYW5zbGF0ZUNvbG9yLlJHQihtaXgsIG9wdGlvbnMuZGVjaW1hbHMpKTtcbiAgICB9LFxuICAgIFJHQkEoY29sb3JzLCBtb2RlLCBjc3MsIG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgbWl4ID0gdGhpcy5taXgoY29sb3JzLCBtb2RlKTtcbiAgICAgICAgcmV0dXJuIChjc3NcbiAgICAgICAgICAgID8gQ1NTLlJHQihtaXgsIG9wdGlvbnMpXG4gICAgICAgICAgICA6IHRyYW5zbGF0ZUNvbG9yLlJHQkEobWl4LCBvcHRpb25zLmRlY2ltYWxzKSk7XG4gICAgfSxcbiAgICBbQ29sb3JNb2RlbC5IU0xdKGNvbG9ycywgbW9kZSwgY3NzLCBvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IG1peCA9IHRoaXMubWl4KGNvbG9ycywgbW9kZSk7XG4gICAgICAgIGNvbnN0IEhTTCA9IHJnYlRvSFNMKG1peC5SLCBtaXguRywgbWl4LkIpO1xuICAgICAgICBkZWxldGUgbWl4LkE7XG4gICAgICAgIGRlbGV0ZSBIU0wuQTtcbiAgICAgICAgcmV0dXJuIChjc3NcbiAgICAgICAgICAgID8gQ1NTLkhTTChIU0wsIG9wdGlvbnMpXG4gICAgICAgICAgICA6IHRyYW5zbGF0ZUNvbG9yLkhTTChtaXgsIG9wdGlvbnMuZGVjaW1hbHMpKTtcbiAgICB9LFxuICAgIEhTTEEoY29sb3JzLCBtb2RlLCBjc3MsIG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgbWl4ID0gdGhpcy5taXgoY29sb3JzLCBtb2RlKTtcbiAgICAgICAgY29uc3QgSFNMID0gcmdiVG9IU0wobWl4LlIsIG1peC5HLCBtaXguQiwgbWl4LkEpO1xuICAgICAgICByZXR1cm4gKGNzc1xuICAgICAgICAgICAgPyBDU1MuSFNMKEhTTCwgb3B0aW9ucylcbiAgICAgICAgICAgIDogdHJhbnNsYXRlQ29sb3IuSFNMQShtaXgsIG9wdGlvbnMuZGVjaW1hbHMpKTtcbiAgICB9LFxuICAgIFtDb2xvck1vZGVsLkNJRUxhYl0oY29sb3JzLCBtb2RlLCBjc3MsIG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgbWl4ID0gdGhpcy5taXgoY29sb3JzLCBtb2RlKTtcbiAgICAgICAgY29uc3QgTGFiID0gcmdiVG9MYWIobWl4LlIsIG1peC5HLCBtaXguQik7XG4gICAgICAgIGRlbGV0ZSBtaXguQTtcbiAgICAgICAgcmV0dXJuIChjc3NcbiAgICAgICAgICAgID8gQ1NTLkNJRUxhYihMYWIsIG9wdGlvbnMpXG4gICAgICAgICAgICA6IHRyYW5zbGF0ZUNvbG9yLkNJRUxhYkEobWl4LCBvcHRpb25zLmRlY2ltYWxzKSk7XG4gICAgfSxcbiAgICBDSUVMYWJBKGNvbG9ycywgbW9kZSwgY3NzLCBvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IG1peCA9IHRoaXMubWl4KGNvbG9ycywgbW9kZSk7XG4gICAgICAgIGNvbnN0IExhYiA9IHJnYlRvTGFiKG1peC5SLCBtaXguRywgbWl4LkIpO1xuICAgICAgICBpZiAoaGFzUHJvcChtaXgsICdBJykpIHtcbiAgICAgICAgICAgIExhYi5BID0gbWl4LkE7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIChjc3NcbiAgICAgICAgICAgID8gQ1NTLkNJRUxhYihMYWIsIG9wdGlvbnMpXG4gICAgICAgICAgICA6IHRyYW5zbGF0ZUNvbG9yLkNJRUxhYkEobWl4LCBvcHRpb25zLmRlY2ltYWxzKSk7XG4gICAgfVxufTtcbmV4cG9ydCBjb25zdCByb3VuZFJHQk9iamVjdCA9IChjb2xvciwgZGVjaW1hbHMpID0+IHtcbiAgICBjb25zdCBSID0gcm91bmQoY29sb3IuUiwgZGVjaW1hbHMpO1xuICAgIGNvbnN0IEcgPSByb3VuZChjb2xvci5HLCBkZWNpbWFscyk7XG4gICAgY29uc3QgQiA9IHJvdW5kKGNvbG9yLkIsIGRlY2ltYWxzKTtcbiAgICByZXR1cm4ge1xuICAgICAgICBSLFxuICAgICAgICBHLFxuICAgICAgICBCLFxuICAgICAgICAuLi4oaGFzUHJvcChjb2xvciwgJ0EnKVxuICAgICAgICAgICAgPyB7XG4gICAgICAgICAgICAgICAgQTogcm91bmQoY29sb3IuQSwgZGVjaW1hbHMpXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICA6IHt9KVxuICAgIH07XG59O1xuZXhwb3J0IGNvbnN0IHJvdW5kSFNMT2JqZWN0ID0gKGNvbG9yLCBkZWNpbWFscykgPT4ge1xuICAgIHJldHVybiB7XG4gICAgICAgIEg6IHJvdW5kKGNvbG9yLkgsIGRlY2ltYWxzKSxcbiAgICAgICAgUzogcm91bmQoY29sb3IuUywgZGVjaW1hbHMpLFxuICAgICAgICBMOiByb3VuZChjb2xvci5MLCBkZWNpbWFscyksXG4gICAgICAgIC4uLihoYXNQcm9wKGNvbG9yLCAnQScpXG4gICAgICAgICAgICA/IHtcbiAgICAgICAgICAgICAgICBBOiByb3VuZChjb2xvci5BLCBkZWNpbWFscylcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIDoge30pXG4gICAgfTtcbn07XG5leHBvcnQgY29uc3Qgcm91bmRDSUVMYWJPYmplY3QgPSAoY29sb3IsIGRlY2ltYWxzKSA9PiB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgTDogcm91bmQoY29sb3IuTCwgZGVjaW1hbHMpLFxuICAgICAgICBhOiByb3VuZChjb2xvci5hLCBkZWNpbWFscyksXG4gICAgICAgIGI6IHJvdW5kKGNvbG9yLmIsIGRlY2ltYWxzKVxuICAgIH07XG59O1xuZXhwb3J0IGNvbnN0IHJvdW5kQ01ZS09iamVjdCA9IChjb2xvciwgZGVjaW1hbHMpID0+IHtcbiAgICByZXR1cm4ge1xuICAgICAgICBDOiByb3VuZChjb2xvci5DLCBkZWNpbWFscyksXG4gICAgICAgIE06IHJvdW5kKGNvbG9yLk0sIGRlY2ltYWxzKSxcbiAgICAgICAgWTogcm91bmQoY29sb3IuWSwgZGVjaW1hbHMpLFxuICAgICAgICBLOiByb3VuZChjb2xvci5LLCBkZWNpbWFscylcbiAgICB9O1xufTtcbiIsImltcG9ydCB7IEhhcm1vbnksIE1peCwgREVGQVVMVF9CTEVORF9TVEVQUywgREVGQVVMVF9TSEFERVNfVElOVFNfU1RFUFMgfSBmcm9tICcjY29uc3RhbnRzJztcbmltcG9ydCB7IHJnYlRvSFNMLCBoc2xUb1JHQiwgcmdiVG9MYWIsIGxhYlRvUmdiLCByZ2JUb0NNWUssIGNteWtUb1JHQiB9IGZyb20gJyNjb2xvci90cmFuc2xhdG9ycyc7XG5pbXBvcnQgKiBhcyB1dGlscyBmcm9tICcjY29sb3IvdXRpbHMnO1xuaW1wb3J0IHsgQ1NTIH0gZnJvbSAnI2NvbG9yL2Nzcyc7XG5pbXBvcnQgeyByb3VuZCwgbWlubWF4LCBnZXRPcHRpb25zRnJvbUNvbG9ySW5wdXQsIG5vcm1hbGl6ZUh1ZSwgaXNIYXJtb255LCBpc01peCB9IGZyb20gJyNoZWxwZXJzJztcbmNvbnN0IGdldENvbG9yUmV0dXJuID0gKGNvbG9yLCBtb2RlbCwgZGVjaW1hbHMsIHRyYW5zbGF0ZUZ1bmN0aW9uKSA9PiB7XG4gICAgY29uc3QgcmdiT2JqZWN0ID0gdXRpbHMuZ2V0UkdCT2JqZWN0KGNvbG9yLCBtb2RlbCk7XG4gICAgcmV0dXJuIHRyYW5zbGF0ZUZ1bmN0aW9uKHJnYk9iamVjdCwgZGVjaW1hbHMpO1xufTtcbmNvbnN0IGdldEJsZW5kUmV0dXJuID0gKGZyb20sIHRvLCBzdGVwcywgZGVjaW1hbHMsIHRyYW5zbGF0ZUZ1bmN0aW9uKSA9PiB7XG4gICAgaWYgKHN0ZXBzIDwgMSlcbiAgICAgICAgc3RlcHMgPSBERUZBVUxUX0JMRU5EX1NURVBTO1xuICAgIGNvbnN0IGZyb21SR0JPYmplY3QgPSB1dGlscy5nZXRSR0JPYmplY3QoZnJvbSk7XG4gICAgY29uc3QgdG9SR0JPYmplY3QgPSB1dGlscy5nZXRSR0JPYmplY3QodG8pO1xuICAgIGNvbnN0IGJsZW5kQXJyYXkgPSB1dGlscy5ibGVuZChmcm9tUkdCT2JqZWN0LCB0b1JHQk9iamVjdCwgc3RlcHMpO1xuICAgIHJldHVybiBibGVuZEFycmF5Lm1hcCgoY29sb3IpID0+IHtcbiAgICAgICAgcmV0dXJuIHRyYW5zbGF0ZUZ1bmN0aW9uKGNvbG9yLCBkZWNpbWFscyk7XG4gICAgfSk7XG59O1xuY29uc3QgZ2V0SGFybW9ueVJldHVybiA9IChoYXJtb255LCBjb2xvciwgbW9kZSwgb3B0aW9ucykgPT4ge1xuICAgIHJldHVybiAoe1xuICAgICAgICBbSGFybW9ueS5BTkFMT0dPVVNdOiB1dGlscy5jb2xvckhhcm1vbnkuYnVpbGRIYXJtb255KGNvbG9yLCB1dGlscy5hbmFsb2dvdXMsIG1vZGUsIG9wdGlvbnMpLFxuICAgICAgICBbSGFybW9ueS5DT01QTEVNRU5UQVJZXTogdXRpbHMuY29sb3JIYXJtb255LmJ1aWxkSGFybW9ueShjb2xvciwgdXRpbHMuY29tcGxlbWVudGFyeSwgbW9kZSwgb3B0aW9ucyksXG4gICAgICAgIFtIYXJtb255LlNQTElUX0NPTVBMRU1FTlRBUlldOiB1dGlscy5jb2xvckhhcm1vbnkuYnVpbGRIYXJtb255KGNvbG9yLCB1dGlscy5zcGxpdENvbXBsZW1lbnRhcnksIG1vZGUsIG9wdGlvbnMpLFxuICAgICAgICBbSGFybW9ueS5UUklBRElDXTogdXRpbHMuY29sb3JIYXJtb255LmJ1aWxkSGFybW9ueShjb2xvciwgdXRpbHMudHJpYWRpYywgbW9kZSwgb3B0aW9ucyksXG4gICAgICAgIFtIYXJtb255LlRFVFJBRElDXTogdXRpbHMuY29sb3JIYXJtb255LmJ1aWxkSGFybW9ueShjb2xvciwgdXRpbHMudGV0cmFkaWMsIG1vZGUsIG9wdGlvbnMpLFxuICAgICAgICBbSGFybW9ueS5TUVVBUkVdOiB1dGlscy5jb2xvckhhcm1vbnkuYnVpbGRIYXJtb255KGNvbG9yLCB1dGlscy5zcXVhcmUsIG1vZGUsIG9wdGlvbnMpXG4gICAgfSlbaGFybW9ueV07XG59O1xuZXhwb3J0IGNsYXNzIENvbG9yVHJhbnNsYXRvciB7XG4gICAgY29uc3RydWN0b3IoY29sb3IsIG9wdGlvbnMgPSB7fSkge1xuICAgICAgICB0aGlzLl9vcHRpb25zID0gZ2V0T3B0aW9uc0Zyb21Db2xvcklucHV0KG9wdGlvbnMsIGNvbG9yKTtcbiAgICAgICAgdGhpcy5yZ2IgPSB1dGlscy5nZXRSR0JPYmplY3QoY29sb3IpO1xuICAgICAgICB0aGlzLnVwZGF0ZUhTTCgpO1xuICAgICAgICB0aGlzLnVwZGF0ZUxhYigpO1xuICAgICAgICB0aGlzLnVwZGF0ZUNNWUsoKTtcbiAgICB9XG4gICAgdXBkYXRlUkdCKCkge1xuICAgICAgICB0aGlzLnJnYiA9IHtcbiAgICAgICAgICAgIC4uLmhzbFRvUkdCKHRoaXMuaHNsLkgsIHRoaXMuaHNsLlMsIHRoaXMuaHNsLkwpLFxuICAgICAgICAgICAgQTogdGhpcy5oc2wuQVxuICAgICAgICB9O1xuICAgIH1cbiAgICB1cGRhdGVSR0JGcm9tQ01ZSygpIHtcbiAgICAgICAgdGhpcy5yZ2IgPSB7XG4gICAgICAgICAgICAuLi5jbXlrVG9SR0IodGhpcy5jbXlrLkMsIHRoaXMuY215ay5NLCB0aGlzLmNteWsuWSwgdGhpcy5jbXlrLkspLFxuICAgICAgICAgICAgQTogdGhpcy5yZ2IuQVxuICAgICAgICB9O1xuICAgIH1cbiAgICB1cGRhdGVSR0JGcm9tTGFiKCkge1xuICAgICAgICB0aGlzLnJnYiA9IHtcbiAgICAgICAgICAgIC4uLmxhYlRvUmdiKHRoaXMubGFiLkwsIHRoaXMubGFiLmEsIHRoaXMubGFiLmIpLFxuICAgICAgICAgICAgQTogdGhpcy5yZ2IuQVxuICAgICAgICB9O1xuICAgIH1cbiAgICB1cGRhdGVIU0woKSB7XG4gICAgICAgIHRoaXMuaHNsID0gcmdiVG9IU0wodGhpcy5yZ2IuUiwgdGhpcy5yZ2IuRywgdGhpcy5yZ2IuQiwgdGhpcy5yZ2IuQSk7XG4gICAgfVxuICAgIHVwZGF0ZUxhYigpIHtcbiAgICAgICAgdGhpcy5sYWIgPSB7XG4gICAgICAgICAgICAuLi5yZ2JUb0xhYih0aGlzLnJnYi5SLCB0aGlzLnJnYi5HLCB0aGlzLnJnYi5CKSxcbiAgICAgICAgICAgIEE6IHRoaXMucmdiLkFcbiAgICAgICAgfTtcbiAgICB9XG4gICAgdXBkYXRlQ01ZSygpIHtcbiAgICAgICAgdGhpcy5jbXlrID0gcmdiVG9DTVlLKHRoaXMucmdiLlIsIHRoaXMucmdiLkcsIHRoaXMucmdiLkIpO1xuICAgIH1cbiAgICBzZXRPcHRpb25zKG9wdGlvbnMgPSB7fSkge1xuICAgICAgICB0aGlzLl9vcHRpb25zID0ge1xuICAgICAgICAgICAgLi4udGhpcy5fb3B0aW9ucyxcbiAgICAgICAgICAgIC4uLm9wdGlvbnNcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIHNldEgoSCkge1xuICAgICAgICB0aGlzLmhzbC5IID0gbm9ybWFsaXplSHVlKEgpO1xuICAgICAgICB0aGlzLnVwZGF0ZVJHQigpO1xuICAgICAgICB0aGlzLnVwZGF0ZUxhYigpO1xuICAgICAgICB0aGlzLnVwZGF0ZUNNWUsoKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIHNldFMoUykge1xuICAgICAgICB0aGlzLmhzbC5TID0gbWlubWF4KFMsIDAsIDEwMCk7XG4gICAgICAgIHRoaXMudXBkYXRlUkdCKCk7XG4gICAgICAgIHRoaXMudXBkYXRlTGFiKCk7XG4gICAgICAgIHRoaXMudXBkYXRlQ01ZSygpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgc2V0TChMKSB7XG4gICAgICAgIHRoaXMuaHNsLkwgPSBtaW5tYXgoTCwgMCwgMTAwKTtcbiAgICAgICAgdGhpcy51cGRhdGVSR0IoKTtcbiAgICAgICAgdGhpcy51cGRhdGVMYWIoKTtcbiAgICAgICAgdGhpcy51cGRhdGVDTVlLKCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBzZXRSKFIpIHtcbiAgICAgICAgdGhpcy5yZ2IuUiA9IG1pbm1heChSLCAwLCAyNTUpO1xuICAgICAgICB0aGlzLnVwZGF0ZUhTTCgpO1xuICAgICAgICB0aGlzLnVwZGF0ZUxhYigpO1xuICAgICAgICB0aGlzLnVwZGF0ZUNNWUsoKTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBzZXRHKEcpIHtcbiAgICAgICAgdGhpcy5yZ2IuRyA9IG1pbm1heChHLCAwLCAyNTUpO1xuICAgICAgICB0aGlzLnVwZGF0ZUhTTCgpO1xuICAgICAgICB0aGlzLnVwZGF0ZUxhYigpO1xuICAgICAgICB0aGlzLnVwZGF0ZUNNWUsoKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIHNldEIoQikge1xuICAgICAgICB0aGlzLnJnYi5CID0gbWlubWF4KEIsIDAsIDI1NSk7XG4gICAgICAgIHRoaXMudXBkYXRlSFNMKCk7XG4gICAgICAgIHRoaXMudXBkYXRlTGFiKCk7XG4gICAgICAgIHRoaXMudXBkYXRlQ01ZSygpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgc2V0Q0lFTChMKSB7XG4gICAgICAgIHRoaXMubGFiLkwgPSBtaW5tYXgoTCwgMCwgMTAwKTtcbiAgICAgICAgdGhpcy51cGRhdGVSR0JGcm9tTGFiKCk7XG4gICAgICAgIHRoaXMudXBkYXRlSFNMKCk7XG4gICAgICAgIHRoaXMudXBkYXRlQ01ZSygpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgc2V0Q0lFYShhKSB7XG4gICAgICAgIHRoaXMubGFiLmEgPSBtaW5tYXgoYSwgLTEyNSwgMTI1KTtcbiAgICAgICAgdGhpcy51cGRhdGVSR0JGcm9tTGFiKCk7XG4gICAgICAgIHRoaXMudXBkYXRlSFNMKCk7XG4gICAgICAgIHRoaXMudXBkYXRlQ01ZSygpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgc2V0Q0lFYihiKSB7XG4gICAgICAgIHRoaXMubGFiLmIgPSBtaW5tYXgoYiwgLTEyNSwgMTI1KTtcbiAgICAgICAgdGhpcy51cGRhdGVSR0JGcm9tTGFiKCk7XG4gICAgICAgIHRoaXMudXBkYXRlSFNMKCk7XG4gICAgICAgIHRoaXMudXBkYXRlQ01ZSygpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgc2V0QShBKSB7XG4gICAgICAgIHRoaXMuaHNsLkEgPSB0aGlzLnJnYi5BID0gbWlubWF4KEEsIDAsIDEpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgc2V0QyhDKSB7XG4gICAgICAgIHRoaXMuY215ay5DID0gbWlubWF4KEMsIDAsIDEwMCk7XG4gICAgICAgIHRoaXMudXBkYXRlUkdCRnJvbUNNWUsoKTtcbiAgICAgICAgdGhpcy51cGRhdGVIU0woKTtcbiAgICAgICAgdGhpcy51cGRhdGVMYWIoKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIHNldE0oTSkge1xuICAgICAgICB0aGlzLmNteWsuTSA9IG1pbm1heChNLCAwLCAxMDApO1xuICAgICAgICB0aGlzLnVwZGF0ZVJHQkZyb21DTVlLKCk7XG4gICAgICAgIHRoaXMudXBkYXRlSFNMKCk7XG4gICAgICAgIHRoaXMudXBkYXRlTGFiKCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBzZXRZKFkpIHtcbiAgICAgICAgdGhpcy5jbXlrLlkgPSBtaW5tYXgoWSwgMCwgMTAwKTtcbiAgICAgICAgdGhpcy51cGRhdGVSR0JGcm9tQ01ZSygpO1xuICAgICAgICB0aGlzLnVwZGF0ZUhTTCgpO1xuICAgICAgICB0aGlzLnVwZGF0ZUxhYigpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgc2V0SyhLKSB7XG4gICAgICAgIHRoaXMuY215ay5LID0gbWlubWF4KEssIDAsIDEwMCk7XG4gICAgICAgIHRoaXMudXBkYXRlUkdCRnJvbUNNWUsoKTtcbiAgICAgICAgdGhpcy51cGRhdGVIU0woKTtcbiAgICAgICAgdGhpcy51cGRhdGVMYWIoKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIGdldCBvcHRpb25zKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fb3B0aW9ucztcbiAgICB9XG4gICAgZ2V0IEgoKSB7XG4gICAgICAgIHJldHVybiByb3VuZCh0aGlzLmhzbC5ILCB0aGlzLm9wdGlvbnMuZGVjaW1hbHMpO1xuICAgIH1cbiAgICBnZXQgUygpIHtcbiAgICAgICAgcmV0dXJuIHJvdW5kKHRoaXMuaHNsLlMsIHRoaXMub3B0aW9ucy5kZWNpbWFscyk7XG4gICAgfVxuICAgIGdldCBMKCkge1xuICAgICAgICByZXR1cm4gcm91bmQodGhpcy5oc2wuTCwgdGhpcy5vcHRpb25zLmRlY2ltYWxzKTtcbiAgICB9XG4gICAgZ2V0IENJRUwoKSB7XG4gICAgICAgIHJldHVybiByb3VuZCh0aGlzLmxhYi5MLCB0aGlzLm9wdGlvbnMuZGVjaW1hbHMpO1xuICAgIH1cbiAgICBnZXQgQ0lFYSgpIHtcbiAgICAgICAgcmV0dXJuIHJvdW5kKHRoaXMubGFiLmEsIHRoaXMub3B0aW9ucy5kZWNpbWFscyk7XG4gICAgfVxuICAgIGdldCBDSUViKCkge1xuICAgICAgICByZXR1cm4gcm91bmQodGhpcy5sYWIuYiwgdGhpcy5vcHRpb25zLmRlY2ltYWxzKTtcbiAgICB9XG4gICAgZ2V0IFIoKSB7XG4gICAgICAgIHJldHVybiByb3VuZCh0aGlzLnJnYi5SLCB0aGlzLm9wdGlvbnMuZGVjaW1hbHMpO1xuICAgIH1cbiAgICBnZXQgRygpIHtcbiAgICAgICAgcmV0dXJuIHJvdW5kKHRoaXMucmdiLkcsIHRoaXMub3B0aW9ucy5kZWNpbWFscyk7XG4gICAgfVxuICAgIGdldCBCKCkge1xuICAgICAgICByZXR1cm4gcm91bmQodGhpcy5yZ2IuQiwgdGhpcy5vcHRpb25zLmRlY2ltYWxzKTtcbiAgICB9XG4gICAgZ2V0IEEoKSB7XG4gICAgICAgIHJldHVybiByb3VuZCh0aGlzLmhzbC5BLCB0aGlzLm9wdGlvbnMuZGVjaW1hbHMpO1xuICAgIH1cbiAgICBnZXQgQygpIHtcbiAgICAgICAgcmV0dXJuIHJvdW5kKHRoaXMuY215ay5DLCB0aGlzLm9wdGlvbnMuZGVjaW1hbHMpO1xuICAgIH1cbiAgICBnZXQgTSgpIHtcbiAgICAgICAgcmV0dXJuIHJvdW5kKHRoaXMuY215ay5NLCB0aGlzLm9wdGlvbnMuZGVjaW1hbHMpO1xuICAgIH1cbiAgICBnZXQgWSgpIHtcbiAgICAgICAgcmV0dXJuIHJvdW5kKHRoaXMuY215ay5ZLCB0aGlzLm9wdGlvbnMuZGVjaW1hbHMpO1xuICAgIH1cbiAgICBnZXQgSygpIHtcbiAgICAgICAgcmV0dXJuIHJvdW5kKHRoaXMuY215ay5LLCB0aGlzLm9wdGlvbnMuZGVjaW1hbHMpO1xuICAgIH1cbiAgICBnZXQgSEVYT2JqZWN0KCkge1xuICAgICAgICByZXR1cm4gdXRpbHMudHJhbnNsYXRlQ29sb3IuSEVYKHRoaXMucmdiKTtcbiAgICB9XG4gICAgZ2V0IEhFWEFPYmplY3QoKSB7XG4gICAgICAgIHJldHVybiB1dGlscy50cmFuc2xhdGVDb2xvci5IRVhBKHRoaXMucmdiKTtcbiAgICB9XG4gICAgZ2V0IFJHQk9iamVjdCgpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIFI6IHRoaXMuUixcbiAgICAgICAgICAgIEc6IHRoaXMuRyxcbiAgICAgICAgICAgIEI6IHRoaXMuQlxuICAgICAgICB9O1xuICAgIH1cbiAgICBnZXQgUkdCQU9iamVjdCgpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIC4uLnRoaXMuUkdCT2JqZWN0LFxuICAgICAgICAgICAgQTogdGhpcy5BXG4gICAgICAgIH07XG4gICAgfVxuICAgIGdldCBIU0xPYmplY3QoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBIOiB0aGlzLkgsXG4gICAgICAgICAgICBTOiB0aGlzLlMsXG4gICAgICAgICAgICBMOiB0aGlzLkxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgZ2V0IEhTTEFPYmplY3QoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAuLi50aGlzLkhTTE9iamVjdCxcbiAgICAgICAgICAgIEE6IHRoaXMuQVxuICAgICAgICB9O1xuICAgIH1cbiAgICBnZXQgQ0lFTGFiT2JqZWN0KCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgTDogdGhpcy5DSUVMLFxuICAgICAgICAgICAgYTogdGhpcy5DSUVhLFxuICAgICAgICAgICAgYjogdGhpcy5DSUViXG4gICAgICAgIH07XG4gICAgfVxuICAgIGdldCBDSUVMYWJBT2JqZWN0KCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgLi4udGhpcy5DSUVMYWJPYmplY3QsXG4gICAgICAgICAgICBBOiB0aGlzLkFcbiAgICAgICAgfTtcbiAgICB9XG4gICAgZ2V0IENNWUtPYmplY3QoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBDOiB0aGlzLkMsXG4gICAgICAgICAgICBNOiB0aGlzLk0sXG4gICAgICAgICAgICBZOiB0aGlzLlksXG4gICAgICAgICAgICBLOiB0aGlzLktcbiAgICAgICAgfTtcbiAgICB9XG4gICAgZ2V0IENNWUtBT2JqZWN0KCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgLi4udGhpcy5DTVlLT2JqZWN0LFxuICAgICAgICAgICAgQTogdGhpcy5BXG4gICAgICAgIH07XG4gICAgfVxuICAgIGdldCBIRVgoKSB7XG4gICAgICAgIHJldHVybiBDU1MuSEVYKHtcbiAgICAgICAgICAgIFI6IHRoaXMuUixcbiAgICAgICAgICAgIEc6IHRoaXMuRyxcbiAgICAgICAgICAgIEI6IHRoaXMuQlxuICAgICAgICB9KTtcbiAgICB9XG4gICAgZ2V0IEhFWEEoKSB7XG4gICAgICAgIHJldHVybiBDU1MuSEVYKHtcbiAgICAgICAgICAgIFI6IHRoaXMuUixcbiAgICAgICAgICAgIEc6IHRoaXMuRyxcbiAgICAgICAgICAgIEI6IHRoaXMuQixcbiAgICAgICAgICAgIEE6IHRoaXMuQSAqIDI1NVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgZ2V0IFJHQigpIHtcbiAgICAgICAgcmV0dXJuIENTUy5SR0Ioe1xuICAgICAgICAgICAgUjogdGhpcy5SLFxuICAgICAgICAgICAgRzogdGhpcy5HLFxuICAgICAgICAgICAgQjogdGhpcy5CXG4gICAgICAgIH0sIHRoaXMub3B0aW9ucyk7XG4gICAgfVxuICAgIGdldCBSR0JBKCkge1xuICAgICAgICByZXR1cm4gQ1NTLlJHQih7XG4gICAgICAgICAgICBSOiB0aGlzLlIsXG4gICAgICAgICAgICBHOiB0aGlzLkcsXG4gICAgICAgICAgICBCOiB0aGlzLkIsXG4gICAgICAgICAgICBBOiB0aGlzLkFcbiAgICAgICAgfSwgdGhpcy5vcHRpb25zKTtcbiAgICB9XG4gICAgZ2V0IEhTTCgpIHtcbiAgICAgICAgcmV0dXJuIENTUy5IU0woe1xuICAgICAgICAgICAgSDogdGhpcy5ILFxuICAgICAgICAgICAgUzogdGhpcy5TLFxuICAgICAgICAgICAgTDogdGhpcy5MXG4gICAgICAgIH0sIHRoaXMub3B0aW9ucyk7XG4gICAgfVxuICAgIGdldCBIU0xBKCkge1xuICAgICAgICByZXR1cm4gQ1NTLkhTTCh7XG4gICAgICAgICAgICBIOiB0aGlzLkgsXG4gICAgICAgICAgICBTOiB0aGlzLlMsXG4gICAgICAgICAgICBMOiB0aGlzLkwsXG4gICAgICAgICAgICBBOiB0aGlzLkFcbiAgICAgICAgfSwgdGhpcy5vcHRpb25zKTtcbiAgICB9XG4gICAgZ2V0IENJRUxhYigpIHtcbiAgICAgICAgcmV0dXJuIENTUy5DSUVMYWIoe1xuICAgICAgICAgICAgTDogdGhpcy5DSUVMLFxuICAgICAgICAgICAgYTogdGhpcy5DSUVhLFxuICAgICAgICAgICAgYjogdGhpcy5DSUViXG4gICAgICAgIH0sIHRoaXMub3B0aW9ucyk7XG4gICAgfVxuICAgIGdldCBDSUVMYWJBKCkge1xuICAgICAgICByZXR1cm4gQ1NTLkNJRUxhYih7XG4gICAgICAgICAgICBMOiB0aGlzLkNJRUwsXG4gICAgICAgICAgICBhOiB0aGlzLkNJRWEsXG4gICAgICAgICAgICBiOiB0aGlzLkNJRWIsXG4gICAgICAgICAgICBBOiB0aGlzLkFcbiAgICAgICAgfSwgdGhpcy5vcHRpb25zKTtcbiAgICB9XG4gICAgZ2V0IENNWUsoKSB7XG4gICAgICAgIHJldHVybiBDU1MuQ01ZSyh7XG4gICAgICAgICAgICBDOiB0aGlzLkMsXG4gICAgICAgICAgICBNOiB0aGlzLk0sXG4gICAgICAgICAgICBZOiB0aGlzLlksXG4gICAgICAgICAgICBLOiB0aGlzLktcbiAgICAgICAgfSwgdGhpcy5vcHRpb25zKTtcbiAgICB9XG4gICAgZ2V0IENNWUtBKCkge1xuICAgICAgICByZXR1cm4gQ1NTLkNNWUsoe1xuICAgICAgICAgICAgQzogdGhpcy5DLFxuICAgICAgICAgICAgTTogdGhpcy5NLFxuICAgICAgICAgICAgWTogdGhpcy5ZLFxuICAgICAgICAgICAgSzogdGhpcy5LLFxuICAgICAgICAgICAgQTogdGhpcy5BXG4gICAgICAgIH0sIHRoaXMub3B0aW9ucyk7XG4gICAgfVxuICAgIHN0YXRpYyB0b0hFWE9iamVjdChjb2xvcikge1xuICAgICAgICBjb25zdCBtb2RlbCA9IHV0aWxzLmdldENvbG9yTW9kZWwoY29sb3IpO1xuICAgICAgICByZXR1cm4gZ2V0Q29sb3JSZXR1cm4oY29sb3IsIG1vZGVsLCAwLCB1dGlscy50cmFuc2xhdGVDb2xvci5IRVgpO1xuICAgIH1cbiAgICBzdGF0aWMgdG9IRVgoY29sb3IpIHtcbiAgICAgICAgcmV0dXJuIENTUy5IRVgoQ29sb3JUcmFuc2xhdG9yLnRvSEVYT2JqZWN0KGNvbG9yKSk7XG4gICAgfVxuICAgIHN0YXRpYyB0b0hFWEFPYmplY3QoY29sb3IpIHtcbiAgICAgICAgY29uc3QgbW9kZWwgPSB1dGlscy5nZXRDb2xvck1vZGVsKGNvbG9yKTtcbiAgICAgICAgcmV0dXJuIGdldENvbG9yUmV0dXJuKGNvbG9yLCBtb2RlbCwgMCwgdXRpbHMudHJhbnNsYXRlQ29sb3IuSEVYQSk7XG4gICAgfVxuICAgIHN0YXRpYyB0b0hFWEEoY29sb3IpIHtcbiAgICAgICAgcmV0dXJuIENTUy5IRVgoQ29sb3JUcmFuc2xhdG9yLnRvSEVYQU9iamVjdChjb2xvcikpO1xuICAgIH1cbiAgICBzdGF0aWMgdG9SR0JPYmplY3QoY29sb3IsIG9wdGlvbnMgPSB7fSkge1xuICAgICAgICBjb25zdCBtb2RlbCA9IHV0aWxzLmdldENvbG9yTW9kZWwoY29sb3IpO1xuICAgICAgICByZXR1cm4gZ2V0Q29sb3JSZXR1cm4oY29sb3IsIG1vZGVsLCBvcHRpb25zLmRlY2ltYWxzLCB1dGlscy50cmFuc2xhdGVDb2xvci5SR0IpO1xuICAgIH1cbiAgICBzdGF0aWMgdG9SR0IoY29sb3IsIG9wdGlvbnMgPSB7fSkge1xuICAgICAgICBjb25zdCBtb2RlbCA9IHV0aWxzLmdldENvbG9yTW9kZWwoY29sb3IpO1xuICAgICAgICBjb25zdCBkZXRlY3RlZE9wdGlvbnMgPSBnZXRPcHRpb25zRnJvbUNvbG9ySW5wdXQob3B0aW9ucywgY29sb3IpO1xuICAgICAgICBjb25zdCByZ2IgPSBnZXRDb2xvclJldHVybihjb2xvciwgbW9kZWwsIG9wdGlvbnMuZGVjaW1hbHMsIHV0aWxzLnRyYW5zbGF0ZUNvbG9yLlJHQik7XG4gICAgICAgIHJldHVybiBDU1MuUkdCKHJnYiwgZGV0ZWN0ZWRPcHRpb25zKTtcbiAgICB9XG4gICAgc3RhdGljIHRvUkdCQU9iamVjdChjb2xvciwgb3B0aW9ucyA9IHt9KSB7XG4gICAgICAgIGNvbnN0IG1vZGVsID0gdXRpbHMuZ2V0Q29sb3JNb2RlbChjb2xvcik7XG4gICAgICAgIHJldHVybiBnZXRDb2xvclJldHVybihjb2xvciwgbW9kZWwsIG9wdGlvbnMuZGVjaW1hbHMsIHV0aWxzLnRyYW5zbGF0ZUNvbG9yLlJHQkEpO1xuICAgIH1cbiAgICBzdGF0aWMgdG9SR0JBKGNvbG9yLCBvcHRpb25zID0ge30pIHtcbiAgICAgICAgY29uc3QgbW9kZWwgPSB1dGlscy5nZXRDb2xvck1vZGVsKGNvbG9yKTtcbiAgICAgICAgY29uc3QgZGV0ZWN0ZWRPcHRpb25zID0gZ2V0T3B0aW9uc0Zyb21Db2xvcklucHV0KG9wdGlvbnMsIGNvbG9yKTtcbiAgICAgICAgY29uc3QgcmdiYSA9IGdldENvbG9yUmV0dXJuKGNvbG9yLCBtb2RlbCwgb3B0aW9ucy5kZWNpbWFscywgdXRpbHMudHJhbnNsYXRlQ29sb3IuUkdCQSk7XG4gICAgICAgIHJldHVybiBDU1MuUkdCKHJnYmEsIGRldGVjdGVkT3B0aW9ucyk7XG4gICAgfVxuICAgIHN0YXRpYyB0b0hTTE9iamVjdChjb2xvciwgb3B0aW9ucyA9IHt9KSB7XG4gICAgICAgIGNvbnN0IG1vZGVsID0gdXRpbHMuZ2V0Q29sb3JNb2RlbChjb2xvcik7XG4gICAgICAgIHJldHVybiBnZXRDb2xvclJldHVybihjb2xvciwgbW9kZWwsIG9wdGlvbnMuZGVjaW1hbHMsIHV0aWxzLnRyYW5zbGF0ZUNvbG9yLkhTTCk7XG4gICAgfVxuICAgIHN0YXRpYyB0b0hTTChjb2xvciwgb3B0aW9ucyA9IHt9KSB7XG4gICAgICAgIGNvbnN0IG1vZGVsID0gdXRpbHMuZ2V0Q29sb3JNb2RlbChjb2xvcik7XG4gICAgICAgIGNvbnN0IGRldGVjdGVkT3B0aW9ucyA9IGdldE9wdGlvbnNGcm9tQ29sb3JJbnB1dChvcHRpb25zLCBjb2xvcik7XG4gICAgICAgIGNvbnN0IGhzbCA9IGdldENvbG9yUmV0dXJuKGNvbG9yLCBtb2RlbCwgb3B0aW9ucy5kZWNpbWFscywgdXRpbHMudHJhbnNsYXRlQ29sb3IuSFNMKTtcbiAgICAgICAgcmV0dXJuIENTUy5IU0woaHNsLCBkZXRlY3RlZE9wdGlvbnMpO1xuICAgIH1cbiAgICBzdGF0aWMgdG9IU0xBT2JqZWN0KGNvbG9yLCBvcHRpb25zID0ge30pIHtcbiAgICAgICAgY29uc3QgbW9kZWwgPSB1dGlscy5nZXRDb2xvck1vZGVsKGNvbG9yKTtcbiAgICAgICAgcmV0dXJuIGdldENvbG9yUmV0dXJuKGNvbG9yLCBtb2RlbCwgb3B0aW9ucy5kZWNpbWFscywgdXRpbHMudHJhbnNsYXRlQ29sb3IuSFNMQSk7XG4gICAgfVxuICAgIHN0YXRpYyB0b0hTTEEoY29sb3IsIG9wdGlvbnMgPSB7fSkge1xuICAgICAgICBjb25zdCBtb2RlbCA9IHV0aWxzLmdldENvbG9yTW9kZWwoY29sb3IpO1xuICAgICAgICBjb25zdCBkZXRlY3RlZE9wdGlvbnMgPSBnZXRPcHRpb25zRnJvbUNvbG9ySW5wdXQob3B0aW9ucywgY29sb3IpO1xuICAgICAgICBjb25zdCBoc2xhID0gZ2V0Q29sb3JSZXR1cm4oY29sb3IsIG1vZGVsLCBvcHRpb25zLmRlY2ltYWxzLCB1dGlscy50cmFuc2xhdGVDb2xvci5IU0xBKTtcbiAgICAgICAgcmV0dXJuIENTUy5IU0woaHNsYSwgZGV0ZWN0ZWRPcHRpb25zKTtcbiAgICB9XG4gICAgc3RhdGljIHRvQ0lFTGFiT2JqZWN0KGNvbG9yLCBvcHRpb25zID0ge30pIHtcbiAgICAgICAgY29uc3QgbW9kZWwgPSB1dGlscy5nZXRDb2xvck1vZGVsKGNvbG9yKTtcbiAgICAgICAgcmV0dXJuIGdldENvbG9yUmV0dXJuKGNvbG9yLCBtb2RlbCwgb3B0aW9ucy5kZWNpbWFscywgdXRpbHMudHJhbnNsYXRlQ29sb3IuQ0lFTGFiKTtcbiAgICB9XG4gICAgc3RhdGljIHRvQ0lFTGFiKGNvbG9yLCBvcHRpb25zID0ge30pIHtcbiAgICAgICAgY29uc3QgbW9kZWwgPSB1dGlscy5nZXRDb2xvck1vZGVsKGNvbG9yKTtcbiAgICAgICAgY29uc3QgZGV0ZWN0ZWRPcHRpb25zID0gZ2V0T3B0aW9uc0Zyb21Db2xvcklucHV0KG9wdGlvbnMsIGNvbG9yKTtcbiAgICAgICAgY29uc3QgbGFiID0gZ2V0Q29sb3JSZXR1cm4oY29sb3IsIG1vZGVsLCBvcHRpb25zLmRlY2ltYWxzLCB1dGlscy50cmFuc2xhdGVDb2xvci5DSUVMYWIpO1xuICAgICAgICByZXR1cm4gQ1NTLkNJRUxhYihsYWIsIGRldGVjdGVkT3B0aW9ucyk7XG4gICAgfVxuICAgIHN0YXRpYyB0b0NJRUxhYkFPYmplY3QoY29sb3IsIG9wdGlvbnMgPSB7fSkge1xuICAgICAgICBjb25zdCBtb2RlbCA9IHV0aWxzLmdldENvbG9yTW9kZWwoY29sb3IpO1xuICAgICAgICByZXR1cm4gZ2V0Q29sb3JSZXR1cm4oY29sb3IsIG1vZGVsLCBvcHRpb25zLmRlY2ltYWxzLCB1dGlscy50cmFuc2xhdGVDb2xvci5DSUVMYWJBKTtcbiAgICB9XG4gICAgc3RhdGljIHRvQ0lFTGFiQShjb2xvciwgb3B0aW9ucyA9IHt9KSB7XG4gICAgICAgIGNvbnN0IG1vZGVsID0gdXRpbHMuZ2V0Q29sb3JNb2RlbChjb2xvcik7XG4gICAgICAgIGNvbnN0IGRldGVjdGVkT3B0aW9ucyA9IGdldE9wdGlvbnNGcm9tQ29sb3JJbnB1dChvcHRpb25zLCBjb2xvcik7XG4gICAgICAgIGNvbnN0IGxhYiA9IGdldENvbG9yUmV0dXJuKGNvbG9yLCBtb2RlbCwgb3B0aW9ucy5kZWNpbWFscywgdXRpbHMudHJhbnNsYXRlQ29sb3IuQ0lFTGFiQSk7XG4gICAgICAgIHJldHVybiBDU1MuQ0lFTGFiKGxhYiwgZGV0ZWN0ZWRPcHRpb25zKTtcbiAgICB9XG4gICAgc3RhdGljIHRvQ01ZS09iamVjdChjb2xvciwgb3B0aW9ucyA9IHt9KSB7XG4gICAgICAgIGNvbnN0IG1vZGVsID0gdXRpbHMuZ2V0Q29sb3JNb2RlbChjb2xvcik7XG4gICAgICAgIHJldHVybiBnZXRDb2xvclJldHVybihjb2xvciwgbW9kZWwsIG9wdGlvbnMuZGVjaW1hbHMsIHV0aWxzLnRyYW5zbGF0ZUNvbG9yLkNNWUspO1xuICAgIH1cbiAgICBzdGF0aWMgdG9DTVlLKGNvbG9yLCBvcHRpb25zID0ge30pIHtcbiAgICAgICAgY29uc3QgbW9kZWwgPSB1dGlscy5nZXRDb2xvck1vZGVsKGNvbG9yKTtcbiAgICAgICAgY29uc3QgZGV0ZWN0ZWRPcHRpb25zID0gZ2V0T3B0aW9uc0Zyb21Db2xvcklucHV0KG9wdGlvbnMsIGNvbG9yKTtcbiAgICAgICAgY29uc3QgY215ayA9IGdldENvbG9yUmV0dXJuKGNvbG9yLCBtb2RlbCwgb3B0aW9ucy5kZWNpbWFscywgdXRpbHMudHJhbnNsYXRlQ29sb3IuQ01ZSyk7XG4gICAgICAgIHJldHVybiBDU1MuQ01ZSyhjbXlrLCBkZXRlY3RlZE9wdGlvbnMpO1xuICAgIH1cbiAgICBzdGF0aWMgdG9DTVlLQU9iamVjdChjb2xvciwgb3B0aW9ucyA9IHt9KSB7XG4gICAgICAgIGNvbnN0IG1vZGVsID0gdXRpbHMuZ2V0Q29sb3JNb2RlbChjb2xvcik7XG4gICAgICAgIHJldHVybiBnZXRDb2xvclJldHVybihjb2xvciwgbW9kZWwsIG9wdGlvbnMuZGVjaW1hbHMsIHV0aWxzLnRyYW5zbGF0ZUNvbG9yLkNNWUtBKTtcbiAgICB9XG4gICAgc3RhdGljIHRvQ01ZS0EoY29sb3IsIG9wdGlvbnMgPSB7fSkge1xuICAgICAgICBjb25zdCBtb2RlbCA9IHV0aWxzLmdldENvbG9yTW9kZWwoY29sb3IpO1xuICAgICAgICBjb25zdCBkZXRlY3RlZE9wdGlvbnMgPSBnZXRPcHRpb25zRnJvbUNvbG9ySW5wdXQob3B0aW9ucywgY29sb3IpO1xuICAgICAgICBjb25zdCBjbXlrYSA9IGdldENvbG9yUmV0dXJuKGNvbG9yLCBtb2RlbCwgb3B0aW9ucy5kZWNpbWFscywgdXRpbHMudHJhbnNsYXRlQ29sb3IuQ01ZS0EpO1xuICAgICAgICByZXR1cm4gQ1NTLkNNWUsoY215a2EsIGRldGVjdGVkT3B0aW9ucyk7XG4gICAgfVxuICAgIHN0YXRpYyBnZXRCbGVuZEhFWE9iamVjdChmcm9tLCB0bywgc3RlcHMgPSBERUZBVUxUX0JMRU5EX1NURVBTKSB7XG4gICAgICAgIHJldHVybiBnZXRCbGVuZFJldHVybihmcm9tLCB0bywgc3RlcHMsIDAsIHV0aWxzLnRyYW5zbGF0ZUNvbG9yLkhFWCk7XG4gICAgfVxuICAgIHN0YXRpYyBnZXRCbGVuZEhFWChmcm9tLCB0bywgc3RlcHMgPSBERUZBVUxUX0JMRU5EX1NURVBTKSB7XG4gICAgICAgIHJldHVybiBDb2xvclRyYW5zbGF0b3IuZ2V0QmxlbmRIRVhPYmplY3QoZnJvbSwgdG8sIHN0ZXBzKVxuICAgICAgICAgICAgLm1hcCgoY29sb3IpID0+IENTUy5IRVgoY29sb3IpKTtcbiAgICB9XG4gICAgc3RhdGljIGdldEJsZW5kSEVYQU9iamVjdChmcm9tLCB0bywgc3RlcHMgPSBERUZBVUxUX0JMRU5EX1NURVBTKSB7XG4gICAgICAgIHJldHVybiBnZXRCbGVuZFJldHVybihmcm9tLCB0bywgc3RlcHMsIDAsIHV0aWxzLnRyYW5zbGF0ZUNvbG9yLkhFWEEpO1xuICAgIH1cbiAgICBzdGF0aWMgZ2V0QmxlbmRIRVhBKGZyb20sIHRvLCBzdGVwcyA9IERFRkFVTFRfQkxFTkRfU1RFUFMpIHtcbiAgICAgICAgcmV0dXJuIENvbG9yVHJhbnNsYXRvci5nZXRCbGVuZEhFWEFPYmplY3QoZnJvbSwgdG8sIHN0ZXBzKVxuICAgICAgICAgICAgLm1hcCgoY29sb3IpID0+IENTUy5IRVgoY29sb3IpKTtcbiAgICB9XG4gICAgc3RhdGljIGdldEJsZW5kUkdCT2JqZWN0KGZyb20sIHRvLCB0aGlyZFBhcmFtZXRlciwgZm91cnRoUGFyYW1ldGVyKSB7XG4gICAgICAgIGlmICh0eXBlb2YgdGhpcmRQYXJhbWV0ZXIgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICByZXR1cm4gZ2V0QmxlbmRSZXR1cm4oZnJvbSwgdG8sIHRoaXJkUGFyYW1ldGVyLCBmb3VydGhQYXJhbWV0ZXI/LmRlY2ltYWxzLCB1dGlscy50cmFuc2xhdGVDb2xvci5SR0IpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBnZXRCbGVuZFJldHVybihmcm9tLCB0bywgREVGQVVMVF9CTEVORF9TVEVQUywgdGhpcmRQYXJhbWV0ZXI/LmRlY2ltYWxzLCB1dGlscy50cmFuc2xhdGVDb2xvci5SR0IpO1xuICAgIH1cbiAgICBzdGF0aWMgZ2V0QmxlbmRSR0IoZnJvbSwgdG8sIHRoaXJkUGFyYW1ldGVyLCBmb3VydGhQYXJhbWV0ZXIpIHtcbiAgICAgICAgaWYgKHR5cGVvZiB0aGlyZFBhcmFtZXRlciA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgIHJldHVybiBnZXRCbGVuZFJldHVybihmcm9tLCB0bywgdGhpcmRQYXJhbWV0ZXIsIGZvdXJ0aFBhcmFtZXRlcj8uZGVjaW1hbHMsIHV0aWxzLnRyYW5zbGF0ZUNvbG9yLlJHQilcbiAgICAgICAgICAgICAgICAubWFwKChjb2xvcikgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBDU1MuUkdCKGNvbG9yLCBnZXRPcHRpb25zRnJvbUNvbG9ySW5wdXQoZm91cnRoUGFyYW1ldGVyIHx8IHt9LCBmcm9tLCB0bykpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGdldEJsZW5kUmV0dXJuKGZyb20sIHRvLCBERUZBVUxUX0JMRU5EX1NURVBTLCB0aGlyZFBhcmFtZXRlcj8uZGVjaW1hbHMsIHV0aWxzLnRyYW5zbGF0ZUNvbG9yLlJHQilcbiAgICAgICAgICAgIC5tYXAoKGNvbG9yKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gQ1NTLlJHQihjb2xvciwgZ2V0T3B0aW9uc0Zyb21Db2xvcklucHV0KHRoaXJkUGFyYW1ldGVyIHx8IHt9LCBmcm9tLCB0bykpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgc3RhdGljIGdldEJsZW5kUkdCQU9iamVjdChmcm9tLCB0bywgdGhpcmRQYXJhbWV0ZXIsIGZvdXJ0aFBhcmFtZXRlcikge1xuICAgICAgICBpZiAodHlwZW9mIHRoaXJkUGFyYW1ldGVyID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgcmV0dXJuIGdldEJsZW5kUmV0dXJuKGZyb20sIHRvLCB0aGlyZFBhcmFtZXRlciwgZm91cnRoUGFyYW1ldGVyPy5kZWNpbWFscywgdXRpbHMudHJhbnNsYXRlQ29sb3IuUkdCQSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGdldEJsZW5kUmV0dXJuKGZyb20sIHRvLCBERUZBVUxUX0JMRU5EX1NURVBTLCB0aGlyZFBhcmFtZXRlcj8uZGVjaW1hbHMsIHV0aWxzLnRyYW5zbGF0ZUNvbG9yLlJHQkEpO1xuICAgIH1cbiAgICBzdGF0aWMgZ2V0QmxlbmRSR0JBKGZyb20sIHRvLCB0aGlyZFBhcmFtZXRlciwgZm91cnRoUGFyYW1ldGVyKSB7XG4gICAgICAgIGlmICh0eXBlb2YgdGhpcmRQYXJhbWV0ZXIgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICByZXR1cm4gZ2V0QmxlbmRSZXR1cm4oZnJvbSwgdG8sIHRoaXJkUGFyYW1ldGVyLCBmb3VydGhQYXJhbWV0ZXI/LmRlY2ltYWxzLCB1dGlscy50cmFuc2xhdGVDb2xvci5SR0JBKVxuICAgICAgICAgICAgICAgIC5tYXAoKGNvbG9yKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIENTUy5SR0IoY29sb3IsIGdldE9wdGlvbnNGcm9tQ29sb3JJbnB1dChmb3VydGhQYXJhbWV0ZXIgfHwge30sIGZyb20sIHRvKSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZ2V0QmxlbmRSZXR1cm4oZnJvbSwgdG8sIERFRkFVTFRfQkxFTkRfU1RFUFMsIHRoaXJkUGFyYW1ldGVyPy5kZWNpbWFscywgdXRpbHMudHJhbnNsYXRlQ29sb3IuUkdCQSlcbiAgICAgICAgICAgIC5tYXAoKGNvbG9yKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gQ1NTLlJHQihjb2xvciwgZ2V0T3B0aW9uc0Zyb21Db2xvcklucHV0KHRoaXJkUGFyYW1ldGVyIHx8IHt9LCBmcm9tLCB0bykpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgc3RhdGljIGdldEJsZW5kSFNMT2JqZWN0KGZyb20sIHRvLCB0aGlyZFBhcmFtZXRlciwgZm91cnRoUGFyYW1ldGVyKSB7XG4gICAgICAgIGlmICh0eXBlb2YgdGhpcmRQYXJhbWV0ZXIgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICByZXR1cm4gZ2V0QmxlbmRSZXR1cm4oZnJvbSwgdG8sIHRoaXJkUGFyYW1ldGVyLCBmb3VydGhQYXJhbWV0ZXI/LmRlY2ltYWxzLCB1dGlscy50cmFuc2xhdGVDb2xvci5IU0wpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBnZXRCbGVuZFJldHVybihmcm9tLCB0bywgREVGQVVMVF9CTEVORF9TVEVQUywgZm91cnRoUGFyYW1ldGVyPy5kZWNpbWFscywgdXRpbHMudHJhbnNsYXRlQ29sb3IuSFNMKTtcbiAgICB9XG4gICAgc3RhdGljIGdldEJsZW5kSFNMKGZyb20sIHRvLCB0aGlyZFBhcmFtZXRlciwgZm91cnRoUGFyYW1ldGVyKSB7XG4gICAgICAgIGlmICh0eXBlb2YgdGhpcmRQYXJhbWV0ZXIgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICByZXR1cm4gZ2V0QmxlbmRSZXR1cm4oZnJvbSwgdG8sIHRoaXJkUGFyYW1ldGVyLCBmb3VydGhQYXJhbWV0ZXI/LmRlY2ltYWxzLCB1dGlscy50cmFuc2xhdGVDb2xvci5IU0wpXG4gICAgICAgICAgICAgICAgLm1hcCgoY29sb3IpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gQ1NTLkhTTChjb2xvciwgZ2V0T3B0aW9uc0Zyb21Db2xvcklucHV0KGZvdXJ0aFBhcmFtZXRlciB8fCB7fSwgZnJvbSwgdG8pKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBnZXRCbGVuZFJldHVybihmcm9tLCB0bywgREVGQVVMVF9CTEVORF9TVEVQUywgdGhpcmRQYXJhbWV0ZXI/LmRlY2ltYWxzLCB1dGlscy50cmFuc2xhdGVDb2xvci5IU0wpXG4gICAgICAgICAgICAubWFwKChjb2xvcikgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIENTUy5IU0woY29sb3IsIGdldE9wdGlvbnNGcm9tQ29sb3JJbnB1dCh0aGlyZFBhcmFtZXRlciB8fCB7fSwgZnJvbSwgdG8pKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHN0YXRpYyBnZXRCbGVuZEhTTEFPYmplY3QoZnJvbSwgdG8sIHRoaXJkUGFyYW1ldGVyLCBmb3VydGhQYXJhbWV0ZXIpIHtcbiAgICAgICAgaWYgKHR5cGVvZiB0aGlyZFBhcmFtZXRlciA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgIHJldHVybiBnZXRCbGVuZFJldHVybihmcm9tLCB0bywgdGhpcmRQYXJhbWV0ZXIsIGZvdXJ0aFBhcmFtZXRlcj8uZGVjaW1hbHMsIHV0aWxzLnRyYW5zbGF0ZUNvbG9yLkhTTEEpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBnZXRCbGVuZFJldHVybihmcm9tLCB0bywgREVGQVVMVF9CTEVORF9TVEVQUywgdGhpcmRQYXJhbWV0ZXI/LmRlY2ltYWxzLCB1dGlscy50cmFuc2xhdGVDb2xvci5IU0xBKTtcbiAgICB9XG4gICAgc3RhdGljIGdldEJsZW5kSFNMQShmcm9tLCB0bywgdGhpcmRQYXJhbWV0ZXIsIGZvdXJ0aFBhcmFtZXRlcikge1xuICAgICAgICBpZiAodHlwZW9mIHRoaXJkUGFyYW1ldGVyID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgcmV0dXJuIGdldEJsZW5kUmV0dXJuKGZyb20sIHRvLCB0aGlyZFBhcmFtZXRlciwgZm91cnRoUGFyYW1ldGVyPy5kZWNpbWFscywgdXRpbHMudHJhbnNsYXRlQ29sb3IuSFNMQSlcbiAgICAgICAgICAgICAgICAubWFwKChjb2xvcikgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBDU1MuSFNMKGNvbG9yLCBnZXRPcHRpb25zRnJvbUNvbG9ySW5wdXQoZm91cnRoUGFyYW1ldGVyIHx8IHt9LCBmcm9tLCB0bykpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGdldEJsZW5kUmV0dXJuKGZyb20sIHRvLCBERUZBVUxUX0JMRU5EX1NURVBTLCB0aGlyZFBhcmFtZXRlcj8uZGVjaW1hbHMsIHV0aWxzLnRyYW5zbGF0ZUNvbG9yLkhTTEEpXG4gICAgICAgICAgICAubWFwKChjb2xvcikgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIENTUy5IU0woY29sb3IsIGdldE9wdGlvbnNGcm9tQ29sb3JJbnB1dCh0aGlyZFBhcmFtZXRlciB8fCB7fSwgZnJvbSwgdG8pKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHN0YXRpYyBnZXRCbGVuZENJRUxhYk9iamVjdChmcm9tLCB0bywgdGhpcmRQYXJhbWV0ZXIsIGZvdXJ0aFBhcmFtZXRlcikge1xuICAgICAgICBpZiAodHlwZW9mIHRoaXJkUGFyYW1ldGVyID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgcmV0dXJuIGdldEJsZW5kUmV0dXJuKGZyb20sIHRvLCB0aGlyZFBhcmFtZXRlciwgZm91cnRoUGFyYW1ldGVyPy5kZWNpbWFscywgdXRpbHMudHJhbnNsYXRlQ29sb3IuQ0lFTGFiKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZ2V0QmxlbmRSZXR1cm4oZnJvbSwgdG8sIERFRkFVTFRfQkxFTkRfU1RFUFMsIHRoaXJkUGFyYW1ldGVyPy5kZWNpbWFscywgdXRpbHMudHJhbnNsYXRlQ29sb3IuQ0lFTGFiKTtcbiAgICB9XG4gICAgc3RhdGljIGdldEJsZW5kQ0lFTGFiKGZyb20sIHRvLCB0aGlyZFBhcmFtZXRlciwgZm91cnRoUGFyYW1ldGVyKSB7XG4gICAgICAgIGlmICh0eXBlb2YgdGhpcmRQYXJhbWV0ZXIgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICByZXR1cm4gZ2V0QmxlbmRSZXR1cm4oZnJvbSwgdG8sIHRoaXJkUGFyYW1ldGVyLCBmb3VydGhQYXJhbWV0ZXI/LmRlY2ltYWxzLCB1dGlscy50cmFuc2xhdGVDb2xvci5DSUVMYWIpXG4gICAgICAgICAgICAgICAgLm1hcCgoY29sb3IpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gQ1NTLkNJRUxhYihjb2xvciwgZ2V0T3B0aW9uc0Zyb21Db2xvcklucHV0KGZvdXJ0aFBhcmFtZXRlciB8fCB7fSwgZnJvbSwgdG8pKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBnZXRCbGVuZFJldHVybihmcm9tLCB0bywgREVGQVVMVF9CTEVORF9TVEVQUywgdGhpcmRQYXJhbWV0ZXI/LmRlY2ltYWxzLCB1dGlscy50cmFuc2xhdGVDb2xvci5DSUVMYWIpXG4gICAgICAgICAgICAubWFwKChjb2xvcikgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIENTUy5DSUVMYWIoY29sb3IsIGdldE9wdGlvbnNGcm9tQ29sb3JJbnB1dCh0aGlyZFBhcmFtZXRlciB8fCB7fSwgZnJvbSwgdG8pKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHN0YXRpYyBnZXRCbGVuZENJRUxhYkFPYmplY3QoZnJvbSwgdG8sIHRoaXJkUGFyYW1ldGVyLCBmb3VydGhQYXJhbWV0ZXIpIHtcbiAgICAgICAgaWYgKHR5cGVvZiB0aGlyZFBhcmFtZXRlciA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgIHJldHVybiBnZXRCbGVuZFJldHVybihmcm9tLCB0bywgdGhpcmRQYXJhbWV0ZXIsIGZvdXJ0aFBhcmFtZXRlcj8uZGVjaW1hbHMsIHV0aWxzLnRyYW5zbGF0ZUNvbG9yLkNJRUxhYkEpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBnZXRCbGVuZFJldHVybihmcm9tLCB0bywgREVGQVVMVF9CTEVORF9TVEVQUywgdGhpcmRQYXJhbWV0ZXI/LmRlY2ltYWxzLCB1dGlscy50cmFuc2xhdGVDb2xvci5DSUVMYWJBKTtcbiAgICB9XG4gICAgc3RhdGljIGdldEJsZW5kQ0lFTGFiQShmcm9tLCB0bywgdGhpcmRQYXJhbWV0ZXIsIGZvdXJ0aFBhcmFtZXRlcikge1xuICAgICAgICBpZiAodHlwZW9mIHRoaXJkUGFyYW1ldGVyID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgcmV0dXJuIGdldEJsZW5kUmV0dXJuKGZyb20sIHRvLCB0aGlyZFBhcmFtZXRlciwgZm91cnRoUGFyYW1ldGVyPy5kZWNpbWFscywgdXRpbHMudHJhbnNsYXRlQ29sb3IuQ0lFTGFiQSlcbiAgICAgICAgICAgICAgICAubWFwKChjb2xvcikgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBDU1MuQ0lFTGFiKGNvbG9yLCBnZXRPcHRpb25zRnJvbUNvbG9ySW5wdXQoZm91cnRoUGFyYW1ldGVyIHx8IHt9LCBmcm9tLCB0bykpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGdldEJsZW5kUmV0dXJuKGZyb20sIHRvLCBERUZBVUxUX0JMRU5EX1NURVBTLCB0aGlyZFBhcmFtZXRlcj8uZGVjaW1hbHMsIHV0aWxzLnRyYW5zbGF0ZUNvbG9yLkNJRUxhYkEpXG4gICAgICAgICAgICAubWFwKChjb2xvcikgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIENTUy5DSUVMYWIoY29sb3IsIGdldE9wdGlvbnNGcm9tQ29sb3JJbnB1dCh0aGlyZFBhcmFtZXRlciB8fCB7fSwgZnJvbSwgdG8pKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHN0YXRpYyBnZXRNaXhIRVhPYmplY3QoY29sb3JzLCBtb2RlID0gTWl4LkFERElUSVZFKSB7XG4gICAgICAgIHJldHVybiB1dGlscy5jb2xvck1peGVyLkhFWChjb2xvcnMsIG1vZGUsIGZhbHNlKTtcbiAgICB9XG4gICAgc3RhdGljIGdldE1peEhFWChjb2xvcnMsIG1vZGUgPSBNaXguQURESVRJVkUpIHtcbiAgICAgICAgcmV0dXJuIHV0aWxzLmNvbG9yTWl4ZXIuSEVYKGNvbG9ycywgbW9kZSwgdHJ1ZSk7XG4gICAgfVxuICAgIHN0YXRpYyBnZXRNaXhIRVhBT2JqZWN0KGNvbG9ycywgbW9kZSA9IE1peC5BRERJVElWRSkge1xuICAgICAgICByZXR1cm4gdXRpbHMuY29sb3JNaXhlci5IRVhBKGNvbG9ycywgbW9kZSwgZmFsc2UpO1xuICAgIH1cbiAgICBzdGF0aWMgZ2V0TWl4SEVYQShjb2xvcnMsIG1vZGUgPSBNaXguQURESVRJVkUpIHtcbiAgICAgICAgcmV0dXJuIHV0aWxzLmNvbG9yTWl4ZXIuSEVYQShjb2xvcnMsIG1vZGUsIHRydWUpO1xuICAgIH1cbiAgICBzdGF0aWMgZ2V0TWl4UkdCT2JqZWN0KGNvbG9ycywgc2Vjb25kUGFyYW1ldGVyLCB0aGlyZFBhcmFtZXRlcikge1xuICAgICAgICBpZiAodHlwZW9mIHNlY29uZFBhcmFtZXRlciA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHJldHVybiB1dGlscy5jb2xvck1peGVyLlJHQihjb2xvcnMsIHNlY29uZFBhcmFtZXRlciwgZmFsc2UsIGdldE9wdGlvbnNGcm9tQ29sb3JJbnB1dCh0aGlyZFBhcmFtZXRlciB8fCB7fSwgLi4uY29sb3JzKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHV0aWxzLmNvbG9yTWl4ZXIuUkdCKGNvbG9ycywgTWl4LkFERElUSVZFLCBmYWxzZSwgZ2V0T3B0aW9uc0Zyb21Db2xvcklucHV0KHNlY29uZFBhcmFtZXRlciB8fCB7fSwgLi4uY29sb3JzKSk7XG4gICAgfVxuICAgIHN0YXRpYyBnZXRNaXhSR0IoY29sb3JzLCBzZWNvbmRQYXJhbWV0ZXIsIHRoaXJkUGFyYW1ldGVyKSB7XG4gICAgICAgIGlmICh0eXBlb2Ygc2Vjb25kUGFyYW1ldGVyID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgcmV0dXJuIHV0aWxzLmNvbG9yTWl4ZXIuUkdCKGNvbG9ycywgc2Vjb25kUGFyYW1ldGVyLCB0cnVlLCBnZXRPcHRpb25zRnJvbUNvbG9ySW5wdXQodGhpcmRQYXJhbWV0ZXIgfHwge30sIC4uLmNvbG9ycykpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB1dGlscy5jb2xvck1peGVyLlJHQihjb2xvcnMsIE1peC5BRERJVElWRSwgdHJ1ZSwgZ2V0T3B0aW9uc0Zyb21Db2xvcklucHV0KHNlY29uZFBhcmFtZXRlciB8fCB7fSwgLi4uY29sb3JzKSk7XG4gICAgfVxuICAgIHN0YXRpYyBnZXRNaXhSR0JBT2JqZWN0KGNvbG9ycywgc2Vjb25kUGFyYW1ldGVyLCB0aGlyZFBhcmFtZXRlcikge1xuICAgICAgICBpZiAodHlwZW9mIHNlY29uZFBhcmFtZXRlciA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHJldHVybiB1dGlscy5jb2xvck1peGVyLlJHQkEoY29sb3JzLCBzZWNvbmRQYXJhbWV0ZXIsIGZhbHNlLCBnZXRPcHRpb25zRnJvbUNvbG9ySW5wdXQodGhpcmRQYXJhbWV0ZXIgfHwge30sIC4uLmNvbG9ycykpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB1dGlscy5jb2xvck1peGVyLlJHQkEoY29sb3JzLCBNaXguQURESVRJVkUsIGZhbHNlLCBnZXRPcHRpb25zRnJvbUNvbG9ySW5wdXQoc2Vjb25kUGFyYW1ldGVyIHx8IHt9LCAuLi5jb2xvcnMpKTtcbiAgICB9XG4gICAgc3RhdGljIGdldE1peFJHQkEoY29sb3JzLCBzZWNvbmRQYXJhbWV0ZXIsIHRoaXJkUGFyYW1ldGVyKSB7XG4gICAgICAgIGlmICh0eXBlb2Ygc2Vjb25kUGFyYW1ldGVyID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgcmV0dXJuIHV0aWxzLmNvbG9yTWl4ZXIuUkdCQShjb2xvcnMsIHNlY29uZFBhcmFtZXRlciwgdHJ1ZSwgZ2V0T3B0aW9uc0Zyb21Db2xvcklucHV0KHRoaXJkUGFyYW1ldGVyIHx8IHt9LCAuLi5jb2xvcnMpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdXRpbHMuY29sb3JNaXhlci5SR0JBKGNvbG9ycywgTWl4LkFERElUSVZFLCB0cnVlLCBnZXRPcHRpb25zRnJvbUNvbG9ySW5wdXQoc2Vjb25kUGFyYW1ldGVyIHx8IHt9LCAuLi5jb2xvcnMpKTtcbiAgICB9XG4gICAgc3RhdGljIGdldE1peEhTTE9iamVjdChjb2xvcnMsIHNlY29uZFBhcmFtZXRlciwgdGhpcmRQYXJhbWV0ZXIpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBzZWNvbmRQYXJhbWV0ZXIgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICByZXR1cm4gdXRpbHMuY29sb3JNaXhlci5IU0woY29sb3JzLCBzZWNvbmRQYXJhbWV0ZXIsIGZhbHNlLCBnZXRPcHRpb25zRnJvbUNvbG9ySW5wdXQodGhpcmRQYXJhbWV0ZXIgfHwge30sIC4uLmNvbG9ycykpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB1dGlscy5jb2xvck1peGVyLkhTTChjb2xvcnMsIE1peC5BRERJVElWRSwgZmFsc2UsIGdldE9wdGlvbnNGcm9tQ29sb3JJbnB1dChzZWNvbmRQYXJhbWV0ZXIgfHwge30sIC4uLmNvbG9ycykpO1xuICAgIH1cbiAgICBzdGF0aWMgZ2V0TWl4SFNMKGNvbG9ycywgc2Vjb25kUGFyYW1ldGVyLCB0aGlyZFBhcmFtZXRlcikge1xuICAgICAgICBpZiAodHlwZW9mIHNlY29uZFBhcmFtZXRlciA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHJldHVybiB1dGlscy5jb2xvck1peGVyLkhTTChjb2xvcnMsIHNlY29uZFBhcmFtZXRlciwgdHJ1ZSwgZ2V0T3B0aW9uc0Zyb21Db2xvcklucHV0KHRoaXJkUGFyYW1ldGVyIHx8IHt9LCAuLi5jb2xvcnMpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdXRpbHMuY29sb3JNaXhlci5IU0woY29sb3JzLCBNaXguQURESVRJVkUsIHRydWUsIGdldE9wdGlvbnNGcm9tQ29sb3JJbnB1dChzZWNvbmRQYXJhbWV0ZXIgfHwge30sIC4uLmNvbG9ycykpO1xuICAgIH1cbiAgICBzdGF0aWMgZ2V0TWl4SFNMQU9iamVjdChjb2xvcnMsIHNlY29uZFBhcmFtZXRlciwgdGhpcmRQYXJhbWV0ZXIpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBzZWNvbmRQYXJhbWV0ZXIgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICByZXR1cm4gdXRpbHMuY29sb3JNaXhlci5IU0xBKGNvbG9ycywgc2Vjb25kUGFyYW1ldGVyLCBmYWxzZSwgZ2V0T3B0aW9uc0Zyb21Db2xvcklucHV0KHRoaXJkUGFyYW1ldGVyIHx8IHt9LCAuLi5jb2xvcnMpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdXRpbHMuY29sb3JNaXhlci5IU0xBKGNvbG9ycywgTWl4LkFERElUSVZFLCBmYWxzZSwgZ2V0T3B0aW9uc0Zyb21Db2xvcklucHV0KHNlY29uZFBhcmFtZXRlciB8fCB7fSwgLi4uY29sb3JzKSk7XG4gICAgfVxuICAgIHN0YXRpYyBnZXRNaXhIU0xBKGNvbG9ycywgc2Vjb25kUGFyYW1ldGVyLCB0aGlyZFBhcmFtZXRlcikge1xuICAgICAgICBpZiAodHlwZW9mIHNlY29uZFBhcmFtZXRlciA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHJldHVybiB1dGlscy5jb2xvck1peGVyLkhTTEEoY29sb3JzLCBzZWNvbmRQYXJhbWV0ZXIsIHRydWUsIGdldE9wdGlvbnNGcm9tQ29sb3JJbnB1dCh0aGlyZFBhcmFtZXRlciB8fCB7fSwgLi4uY29sb3JzKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHV0aWxzLmNvbG9yTWl4ZXIuSFNMQShjb2xvcnMsIE1peC5BRERJVElWRSwgdHJ1ZSwgZ2V0T3B0aW9uc0Zyb21Db2xvcklucHV0KHNlY29uZFBhcmFtZXRlciB8fCB7fSwgLi4uY29sb3JzKSk7XG4gICAgfVxuICAgIHN0YXRpYyBnZXRNaXhDSUVMYWJPYmplY3QoY29sb3JzLCBzZWNvbmRQYXJhbWV0ZXIsIHRoaXJkUGFyYW1ldGVyKSB7XG4gICAgICAgIGlmICh0eXBlb2Ygc2Vjb25kUGFyYW1ldGVyID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgcmV0dXJuIHV0aWxzLmNvbG9yTWl4ZXIuQ0lFTGFiKGNvbG9ycywgc2Vjb25kUGFyYW1ldGVyLCBmYWxzZSwgZ2V0T3B0aW9uc0Zyb21Db2xvcklucHV0KHRoaXJkUGFyYW1ldGVyIHx8IHt9LCAuLi5jb2xvcnMpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdXRpbHMuY29sb3JNaXhlci5DSUVMYWIoY29sb3JzLCBNaXguQURESVRJVkUsIGZhbHNlLCBnZXRPcHRpb25zRnJvbUNvbG9ySW5wdXQoc2Vjb25kUGFyYW1ldGVyIHx8IHt9LCAuLi5jb2xvcnMpKTtcbiAgICB9XG4gICAgc3RhdGljIGdldE1peENJRUxhYihjb2xvcnMsIHNlY29uZFBhcmFtZXRlciwgdGhpcmRQYXJhbWV0ZXIpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBzZWNvbmRQYXJhbWV0ZXIgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICByZXR1cm4gdXRpbHMuY29sb3JNaXhlci5DSUVMYWIoY29sb3JzLCBzZWNvbmRQYXJhbWV0ZXIsIHRydWUsIGdldE9wdGlvbnNGcm9tQ29sb3JJbnB1dCh0aGlyZFBhcmFtZXRlciB8fCB7fSwgLi4uY29sb3JzKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHV0aWxzLmNvbG9yTWl4ZXIuQ0lFTGFiKGNvbG9ycywgTWl4LkFERElUSVZFLCB0cnVlLCBnZXRPcHRpb25zRnJvbUNvbG9ySW5wdXQoc2Vjb25kUGFyYW1ldGVyIHx8IHt9LCAuLi5jb2xvcnMpKTtcbiAgICB9XG4gICAgc3RhdGljIGdldE1peENJRUxhYkFPYmplY3QoY29sb3JzLCBzZWNvbmRQYXJhbWV0ZXIsIHRoaXJkUGFyYW1ldGVyKSB7XG4gICAgICAgIGlmICh0eXBlb2Ygc2Vjb25kUGFyYW1ldGVyID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgcmV0dXJuIHV0aWxzLmNvbG9yTWl4ZXIuQ0lFTGFiQShjb2xvcnMsIHNlY29uZFBhcmFtZXRlciwgZmFsc2UsIGdldE9wdGlvbnNGcm9tQ29sb3JJbnB1dCh0aGlyZFBhcmFtZXRlciB8fCB7fSwgLi4uY29sb3JzKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHV0aWxzLmNvbG9yTWl4ZXIuQ0lFTGFiQShjb2xvcnMsIE1peC5BRERJVElWRSwgZmFsc2UsIGdldE9wdGlvbnNGcm9tQ29sb3JJbnB1dChzZWNvbmRQYXJhbWV0ZXIgfHwge30sIC4uLmNvbG9ycykpO1xuICAgIH1cbiAgICBzdGF0aWMgZ2V0TWl4Q0lFTGFiQShjb2xvcnMsIHNlY29uZFBhcmFtZXRlciwgdGhpcmRQYXJhbWV0ZXIpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBzZWNvbmRQYXJhbWV0ZXIgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICByZXR1cm4gdXRpbHMuY29sb3JNaXhlci5DSUVMYWJBKGNvbG9ycywgc2Vjb25kUGFyYW1ldGVyLCB0cnVlLCBnZXRPcHRpb25zRnJvbUNvbG9ySW5wdXQodGhpcmRQYXJhbWV0ZXIgfHwge30sIC4uLmNvbG9ycykpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB1dGlscy5jb2xvck1peGVyLkNJRUxhYkEoY29sb3JzLCBNaXguQURESVRJVkUsIHRydWUsIGdldE9wdGlvbnNGcm9tQ29sb3JJbnB1dChzZWNvbmRQYXJhbWV0ZXIgfHwge30sIC4uLmNvbG9ycykpO1xuICAgIH1cbiAgICBzdGF0aWMgZ2V0U2hhZGVzKGNvbG9yLCBzZWNvbmRQYXJhbWV0ZXIsIHRoaXJkUGFyYW1ldGVyKSB7XG4gICAgICAgIGlmICh0eXBlb2Ygc2Vjb25kUGFyYW1ldGVyID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgcmV0dXJuIHV0aWxzLmdldENvbG9yTWl4dHVyZShjb2xvciwgc2Vjb25kUGFyYW1ldGVyLCB0cnVlLCBnZXRPcHRpb25zRnJvbUNvbG9ySW5wdXQodGhpcmRQYXJhbWV0ZXIgfHwge30sIGNvbG9yKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHV0aWxzLmdldENvbG9yTWl4dHVyZShjb2xvciwgREVGQVVMVF9TSEFERVNfVElOVFNfU1RFUFMsIHRydWUsIGdldE9wdGlvbnNGcm9tQ29sb3JJbnB1dChzZWNvbmRQYXJhbWV0ZXIgfHwge30sIGNvbG9yKSk7XG4gICAgfVxuICAgIHN0YXRpYyBnZXRUaW50cyhjb2xvciwgc2Vjb25kUGFyYW1ldGVyLCB0aGlyZFBhcmFtZXRlcikge1xuICAgICAgICBpZiAodHlwZW9mIHNlY29uZFBhcmFtZXRlciA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgIHJldHVybiB1dGlscy5nZXRDb2xvck1peHR1cmUoY29sb3IsIHNlY29uZFBhcmFtZXRlciwgZmFsc2UsIGdldE9wdGlvbnNGcm9tQ29sb3JJbnB1dCh0aGlyZFBhcmFtZXRlciB8fCB7fSwgY29sb3IpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdXRpbHMuZ2V0Q29sb3JNaXh0dXJlKGNvbG9yLCBERUZBVUxUX1NIQURFU19USU5UU19TVEVQUywgZmFsc2UsIGdldE9wdGlvbnNGcm9tQ29sb3JJbnB1dChzZWNvbmRQYXJhbWV0ZXIgfHwge30sIGNvbG9yKSk7XG4gICAgfVxuICAgIHN0YXRpYyBnZXRIYXJtb255KGNvbG9yLCBzZWNvbmRQYXJhbSwgdGhpcmRQYXJhbSwgZm91cnRoUGFyYW0pIHtcbiAgICAgICAgaWYgKGlzSGFybW9ueShzZWNvbmRQYXJhbSkpIHtcbiAgICAgICAgICAgIHJldHVybiBnZXRIYXJtb255UmV0dXJuKHNlY29uZFBhcmFtLCBjb2xvciwgaXNNaXgodGhpcmRQYXJhbSlcbiAgICAgICAgICAgICAgICA/IHRoaXJkUGFyYW1cbiAgICAgICAgICAgICAgICA6IE1peC5BRERJVElWRSwgZ2V0T3B0aW9uc0Zyb21Db2xvcklucHV0KGlzTWl4KHRoaXJkUGFyYW0pXG4gICAgICAgICAgICAgICAgPyAoZm91cnRoUGFyYW0gfHwge30pXG4gICAgICAgICAgICAgICAgOiB0aGlyZFBhcmFtIHx8IHt9LCBjb2xvcikpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGlzTWl4KHNlY29uZFBhcmFtKSkge1xuICAgICAgICAgICAgcmV0dXJuIGdldEhhcm1vbnlSZXR1cm4oSGFybW9ueS5DT01QTEVNRU5UQVJZLCBjb2xvciwgc2Vjb25kUGFyYW0sIGdldE9wdGlvbnNGcm9tQ29sb3JJbnB1dCh0aGlyZFBhcmFtIHx8IHt9LCBjb2xvcikpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBnZXRIYXJtb255UmV0dXJuKEhhcm1vbnkuQ09NUExFTUVOVEFSWSwgY29sb3IsIE1peC5BRERJVElWRSwgZ2V0T3B0aW9uc0Zyb21Db2xvcklucHV0KHNlY29uZFBhcmFtIHx8IHt9LCBjb2xvcikpO1xuICAgIH1cbn1cbmV4cG9ydCB7IEhhcm1vbnksIE1peCB9O1xuIiwiaW1wb3J0ICcuL3N0eWxlcy5zY3NzJztcblxuZXhwb3J0IGRlZmF1bHQgKENvbG9yVHJhbnNsYXRvcikgPT4ge1xuXG4gICAgY29uc3QgY29udGFpbmVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgY29uc3QgY29sb3IgPSBuZXcgQ29sb3JUcmFuc2xhdG9yKCdoc2woMTgwIDEwMCUgNTAlKScsIHsgZGVjaW1hbHM6IDAgfSk7XG5cbiAgICBmb3IgKGxldCByb3cgPSAwOyByb3cgPCAxMDsgcm93KyspIHtcblxuICAgICAgICBmb3IgKGxldCBjb2wgPSAwOyBjb2wgPCAxMDsgY29sKyspIHtcblxuICAgICAgICAgICAgY29sb3JcbiAgICAgICAgICAgICAgICAuc2V0Uyhyb3cgKiAxMClcbiAgICAgICAgICAgICAgICAuc2V0TChjb2wgKiA1ICsgMzApO1xuXG4gICAgICAgICAgICBjb25zdCBib3ggPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcblxuICAgICAgICAgICAgYm94LmNsYXNzTGlzdC5hZGQoJ2JveCcpO1xuICAgICAgICAgICAgYm94LnN0eWxlLmJhY2tncm91bmQgPSBjb2xvci5IRVg7XG5cbiAgICAgICAgICAgIGJveC5pbm5lclRleHQgPVxuICAgICAgICAgICAgICAgIGBSOiR7Y29sb3IuUn1cbiAgICAgICAgICAgICAgICAgRzoke2NvbG9yLkd9XG4gICAgICAgICAgICAgICAgIEI6JHtjb2xvci5CfWA7XG4gICAgICAgICAgICBjb250YWluZXIuYXBwZW5kQ2hpbGQoYm94KTtcblxuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGNvbnRhaW5lcjtcblxufTsiLCJpbXBvcnQgJy4vc3R5bGVzLnNjc3MnO1xuXG5leHBvcnQgZGVmYXVsdCAoQ29sb3JUcmFuc2xhdG9yKSA9PiB7XG5cbiAgICBjb25zdCBjb250YWluZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICBjb25zdCBjb2xvciA9IG5ldyBDb2xvclRyYW5zbGF0b3IoeyBSOiAyNTUsIEc6IDAsIEI6IDAgfSk7XG4gICAgY29uc3QgaHVlID0gWzAsIDMwLCA2MCwgMTIwLCAyNDAsIDI4MCwgMzIwLCAwXTtcbiAgICBsZXQgcmFpbmJvdztcblxuICAgIGZvciAobGV0IHIgPSAwOyByIDwgaHVlLmxlbmd0aDsgcisrKSB7XG5cbiAgICAgICAgY29sb3Iuc2V0SChodWVbcl0pO1xuXG4gICAgICAgIGNvbnN0IGJvdyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuXG4gICAgICAgIGJvdy5jbGFzc0xpc3QuYWRkKCdyYWluYm93Jyk7XG4gICAgICAgIGJvdy5zdHlsZS5iYWNrZ3JvdW5kID0gY29sb3IuSEVYO1xuXG4gICAgICAgIGlmIChyYWluYm93KSB7XG4gICAgICAgICAgICByYWluYm93LmFwcGVuZENoaWxkKGJvdyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb250YWluZXIuYXBwZW5kQ2hpbGQoYm93KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJhaW5ib3cgPSBib3c7XG4gICAgfVxuXG4gICAgcmFpbmJvdy5zdHlsZS5iYWNrZ3JvdW5kID0gJyMzMzMnO1xuXG4gICAgcmV0dXJuIGNvbnRhaW5lcjtcblxufTsiLCJpbXBvcnQgJy4vc3R5bGVzLnNjc3MnO1xuXG5leHBvcnQgZGVmYXVsdCAoQ29sb3JUcmFuc2xhdG9yKSA9PiB7XG5cbiAgICBjb25zdCBjb250YWluZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICBjb25zdCBoc2wgPSB7IEg6IDAsIFM6ICc5MCUnLCBMOiAnNTAlJyB9O1xuICAgIGNvbnN0IGh1ZSA9IFt1bmRlZmluZWQsIDU1LCAzMCwgMCwgMjkwLCAyMjAsIDEzMF07XG4gICAgY29uc3QgdG90YWwgPSBodWUubGVuZ3RoO1xuXG4gICAgZm9yIChsZXQgcm93ID0gMDsgcm93IDwgdG90YWw7IHJvdysrKSB7XG5cbiAgICAgICAgZm9yIChsZXQgY29sID0gMDsgY29sIDwgdG90YWw7IGNvbCsrKSB7XG5cbiAgICAgICAgICAgIGxldCBpbmRleCA9IHRvdGFsIC0gcm93ICsgY29sO1xuICAgICAgICAgICAgaWYgKGluZGV4ID49IHRvdGFsKSB7XG4gICAgICAgICAgICAgICAgaW5kZXggLT0gdG90YWw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBoc2wuSCA9IGh1ZVtpbmRleF07XG4gICAgICAgICAgICBjb25zdCByZ2IgPSBodWVbaW5kZXhdID09PSB1bmRlZmluZWRcbiAgICAgICAgICAgICAgICA/ICcjRkZGJ1xuICAgICAgICAgICAgICAgIDogQ29sb3JUcmFuc2xhdG9yLnRvSEVYKGhzbCk7XG4gICAgICAgICAgICBjb25zdCBib3ggPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcblxuICAgICAgICAgICAgYm94LmNsYXNzTGlzdC5hZGQoJ2ZsYWcnKTtcbiAgICAgICAgICAgIGJveC5zdHlsZS5iYWNrZ3JvdW5kID0gcmdiO1xuXG4gICAgICAgICAgICBjb250YWluZXIuYXBwZW5kQ2hpbGQoYm94KTtcblxuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGNvbnRhaW5lcjtcblxufTsiLCJpbXBvcnQgJy4vc3R5bGVzLnNjc3MnO1xuXG5leHBvcnQgZGVmYXVsdCAoQ29sb3JUcmFuc2xhdG9yKSA9PiB7XG5cbiAgICBjb25zdCBjb250YWluZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICBjb25zdCBoZXhDb2xvcnMgPSBbXG4gICAgICAgICcjRkUyNzEyJywgJyNGRTU0MDknLCAnI0ZCOTkwMicsXG4gICAgICAgICcjRkFCRDAzJywgJyNGRkZFMzInLCAnI0QxRUEyQycsXG4gICAgICAgICcjNjZCMTMyJywgJyMwMzkyQ0UnLCAnIzAyNDdGRScsXG4gICAgICAgICcjM0QwMEE1JywgJyM4NjAxQjAnLCAnI0E3MTk0QidcbiAgICBdO1xuXG4gICAgaGV4Q29sb3JzLmZvckVhY2goKGNvbG9yKSA9PiB7XG5cbiAgICAgICAgY29uc3QgcmdiID0gQ29sb3JUcmFuc2xhdG9yLnRvUkdCKGNvbG9yKTtcbiAgICAgICAgY29uc3QgaHNsID0gQ29sb3JUcmFuc2xhdG9yLnRvSFNMKGNvbG9yLCB7IGRlY2ltYWxzOiAwIH0pO1xuICAgICAgICBjb25zdCBsYWIgPSBDb2xvclRyYW5zbGF0b3IudG9DSUVMYWIoY29sb3IsIHsgZGVjaW1hbHM6IDAgfSk7XG5cbiAgICAgICAgY29uc3QgcmdiRGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgIGNvbnN0IGhzbERpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICBjb25zdCBsYWJEaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcblxuICAgICAgICByZ2JEaXYuc3R5bGUuYmFja2dyb3VuZENvbG9yID0gcmdiO1xuICAgICAgICByZ2JEaXYudGV4dENvbnRlbnQgPSByZ2I7XG5cbiAgICAgICAgaHNsRGl2LnN0eWxlLmJhY2tncm91bmRDb2xvciA9IGhzbDtcbiAgICAgICAgaHNsRGl2LnRleHRDb250ZW50ID0gaHNsO1xuXG4gICAgICAgIGxhYkRpdi5zdHlsZS5iYWNrZ3JvdW5kQ29sb3IgPSBsYWI7XG4gICAgICAgIGxhYkRpdi50ZXh0Q29udGVudCA9IGxhYjtcblxuICAgICAgICBjb250YWluZXIuYXBwZW5kQ2hpbGQocmdiRGl2KTtcbiAgICAgICAgY29udGFpbmVyLmFwcGVuZENoaWxkKGhzbERpdik7XG4gICAgICAgIGNvbnRhaW5lci5hcHBlbmRDaGlsZChsYWJEaXYpO1xuXG4gICAgfSk7XG5cbiAgICByZXR1cm4gY29udGFpbmVyO1xuXG59OyIsImltcG9ydCAnLi9zdHlsZXMuc2Nzcyc7XG5cbmV4cG9ydCBkZWZhdWx0IChDb2xvclRyYW5zbGF0b3IpID0+IHtcblxuICAgIGNvbnN0IGNvbnRhaW5lciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIGNvbnN0IGNvbG9ycyA9IFtcbiAgICAgICAgJ3JlZCcsXG4gICAgICAgICdsaW1lJyxcbiAgICAgICAgJ2JsdWUnLFxuICAgICAgICAnYXF1YScsXG4gICAgICAgICd5ZWxsb3cnLFxuICAgICAgICAnZnVjaHNpYSdcbiAgICBdO1xuICAgIGNvbnN0IHRvdGFsID0gY29sb3JzLmxlbmd0aDtcblxuICAgIGZvciAobGV0IHJvdyA9IDA7IHJvdyA8IHRvdGFsOyByb3crKykge1xuXG4gICAgICAgIGNvbnN0IGhzbCA9IENvbG9yVHJhbnNsYXRvci50b0hTTE9iamVjdChjb2xvcnNbcm93XSk7XG4gICAgICAgIGNvbnN0IHN0ZXAgPSBoc2wuUyAvICh0b3RhbCAtIDEpO1xuXG4gICAgICAgIGZvciAobGV0IGNvbCA9IDA7IGNvbCA8IHRvdGFsOyBjb2wrKykge1xuXG4gICAgICAgICAgICBjb25zdCByZ2IgPSBDb2xvclRyYW5zbGF0b3IudG9IRVgoaHNsKTtcbiAgICAgICAgICAgIGNvbnN0IGNteWsgPSBDb2xvclRyYW5zbGF0b3IudG9DTVlLT2JqZWN0KGhzbCwgeyBkZWNpbWFsczogMCB9KTtcblxuICAgICAgICAgICAgY29uc3QgYm94ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgICAgICBib3guY2xhc3NMaXN0LmFkZCgnYm94Jyk7XG4gICAgICAgICAgICBib3guc3R5bGUuYmFja2dyb3VuZCA9IHJnYjtcbiAgICAgICAgICAgIGJveC5pbm5lclRleHQgPSBgQzoke2NteWsuQ31cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgTToke2NteWsuTX1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgWToke2NteWsuWX1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgSzoke2NteWsuS31gO1xuXG4gICAgICAgICAgICBjb250YWluZXIuYXBwZW5kQ2hpbGQoYm94KTtcblxuICAgICAgICAgICAgaHNsLlMgLT0gc3RlcDtcblxuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGNvbnRhaW5lcjtcblxufTsiLCJpbXBvcnQgJy4vc3R5bGVzLnNjc3MnO1xuXG5leHBvcnQgZGVmYXVsdCAoQ29sb3JUcmFuc2xhdG9yKSA9PiB7XG5cbiAgICBjb25zdCBjb250YWluZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICBjb25zdCByb3dzID0gMTE7XG4gICAgY29uc3QgbXVsdCA9IDM7XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJvd3M7IGkrKykge1xuXG4gICAgICAgIGNvbnN0IGJsZW5kcyA9IENvbG9yVHJhbnNsYXRvci5nZXRCbGVuZEhFWCgnI0YwMCcsICcjRkYwJywgbXVsdCArIGkgKiBtdWx0KTtcblxuICAgICAgICBibGVuZHMuZm9yRWFjaCgoYmxlbmQsIGluZGV4KSA9PiB7XG4gICAgICAgICAgICBjb25zdCBib3ggPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgICAgIGJveC5jbGFzc0xpc3QuYWRkKCdib3gnLCBgZmlsZSR7aX1gKTtcbiAgICAgICAgICAgIGJveC5zdHlsZS5iYWNrZ3JvdW5kID0gYmxlbmQ7XG4gICAgICAgICAgICBib3guaW5uZXJUZXh0ID0gaW5kZXggKyAxO1xuICAgICAgICAgICAgY29udGFpbmVyLmFwcGVuZENoaWxkKGJveCk7XG4gICAgICAgIH0pO1xuXG4gICAgfVxuXG4gICAgcmV0dXJuIGNvbnRhaW5lcjtcblxufTsiLCJpbXBvcnQgJy4vc3R5bGVzLnNjc3MnO1xuXG5leHBvcnQgZGVmYXVsdCAoQ29sb3JUcmFuc2xhdG9yKSA9PiB7XG5cbiAgICBjb25zdCBjb250YWluZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcblxuICAgIGNvbnN0IGNvbG9ycyA9IFsnI0YwMCcsICcjRkY4MDAwJywgJyNGRjAnLCAnIzBGMCcsICcjMDBGJywgJyNBMEYnLCAnI0YwQSddO1xuXG4gICAgY29uc3QgY3JlYXRlQm94ID0gKGNvbG9yLCB0eXBlKSA9PiB7XG4gICAgICAgIGNvbnN0IGJveCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICBib3guY2xhc3NMaXN0LmFkZCgnYm94Jyk7XG4gICAgICAgIGJveC5zdHlsZS5iYWNrZ3JvdW5kQ29sb3IgPSBjb2xvcjtcbiAgICAgICAgaWYgKHR5cGUpIGJveC5kYXRhc2V0LnR5cGUgPSB0eXBlO1xuICAgICAgICBjb250YWluZXIuYXBwZW5kQ2hpbGQoYm94KTtcbiAgICB9O1xuXG4gICAgY29sb3JzLmZvckVhY2goKGNvbG9yKSA9PiB7XG4gICAgICAgIGNvbnN0IHNoYWRlcyA9IENvbG9yVHJhbnNsYXRvci5nZXRTaGFkZXMoY29sb3IsIDMpLnJldmVyc2UoKTtcbiAgICAgICAgY29uc3QgdGludHMgPSBDb2xvclRyYW5zbGF0b3IuZ2V0VGludHMoY29sb3IsIDMpO1xuICAgICAgICBzaGFkZXMuZm9yRWFjaCgoc2hhZGUpID0+IGNyZWF0ZUJveChzaGFkZSwgJ3NoYWRlJykpO1xuICAgICAgICBjcmVhdGVCb3goY29sb3IpO1xuICAgICAgICB0aW50cy5mb3JFYWNoKCh0aW50KSA9PiBjcmVhdGVCb3godGludCwgJ3RpbnQnKSk7XG4gICAgfSk7XG5cbiAgICByZXR1cm4gY29udGFpbmVyO1xuXG59OyIsImltcG9ydCAnLi9zdHlsZXMuc2Nzcyc7XG5cblxuZXhwb3J0IGRlZmF1bHQgKENvbG9yVHJhbnNsYXRvcikgPT4ge1xuXG4gICAgY29uc3QgY29udGFpbmVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG5cbiAgICBjb25zdCBtaXhlcyA9IFtcbiAgICAgICAgJyNGMDAnLFxuICAgICAgICAnIzBGMCcsXG4gICAgICAgICcjMDBGJyxcbiAgICAgICAgWzEsIDNdLFxuICAgICAgICBbMSwgMl0sXG4gICAgICAgIFsyLCAzXSxcbiAgICAgICAgWzEsIDIsIDNdXG4gICAgXTtcblxuICAgIGNvbnN0IGZpbGxQbGFuZXMgPSAoKSA9PiB7XG4gICAgICAgIGNvbnN0IHBsYW5lcyA9IGNvbnRhaW5lci5xdWVyeVNlbGVjdG9yQWxsKCcjcGxhbmVzIHBhdGgnKTtcbiAgICAgICAgcGxhbmVzLmZvckVhY2goKHBsYW5lLCBpbmRleCkgPT4ge1xuICAgICAgICAgICAgbGV0IGNvbG9yID0gJyNDQ0MnO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBtaXhlc1tpbmRleF0gPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgY29sb3IgPSBtaXhlc1tpbmRleF07XG4gICAgICAgICAgICB9IGVsc2UgaWYobWl4ZXNbaW5kZXhdKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgY29sb3JzID0gbWl4ZXNbaW5kZXhdLm1hcCgoaSkgPT4gbWl4ZXNbaSAtIDFdKTtcbiAgICAgICAgICAgICAgICBjb2xvciA9IG1peGVzW2luZGV4XSA9IENvbG9yVHJhbnNsYXRvci5nZXRNaXhIRVgoY29sb3JzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHBsYW5lLnNldEF0dHJpYnV0ZSgnZmlsbCcsIGNvbG9yKTtcbiAgICAgICAgfSk7XG4gICAgfTtcblxuICAgIGZldGNoKCdpbWFnZXMvY29sb3ItbWl4ZXMuc3ZnJylcbiAgICAgICAgLnRoZW4ocmVzdWx0ID0+IHJlc3VsdC50ZXh0KCkpXG4gICAgICAgIC50aGVuKChzdmdDb2RlKSA9PiB7XG4gICAgICAgICAgICBjb250YWluZXIuaW5uZXJIVE1MID0gc3ZnQ29kZTtcbiAgICAgICAgICAgIGZpbGxQbGFuZXMoKTtcbiAgICAgICAgfSk7XG5cbiAgICByZXR1cm4gY29udGFpbmVyO1xuXG59OyIsImltcG9ydCAnLi9zdHlsZXMuc2Nzcyc7XG5cbmV4cG9ydCBkZWZhdWx0IChDb2xvclRyYW5zbGF0b3IsIHsgTWl4IH0pID0+IHtcblxuICAgIGNvbnN0IGNvbnRhaW5lciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuXG4gICAgY29uc3QgbWl4ZXMgPSBbXG4gICAgICAgICcjRjAwJyxcbiAgICAgICAgJyNGRjAnLFxuICAgICAgICAnIzAwRicsXG4gICAgICAgIFsxLCAzXSxcbiAgICAgICAgWzEsIDJdLFxuICAgICAgICBbMiwgM10sXG4gICAgICAgIFsxLCAyLCAzXVxuICAgIF07XG5cbiAgICBjb25zdCBmaWxsUGxhbmVzID0gKCkgPT4ge1xuICAgICAgICBjb25zdCBwbGFuZXMgPSBjb250YWluZXIucXVlcnlTZWxlY3RvckFsbCgnI3BsYW5lcyBwYXRoJyk7XG4gICAgICAgIHBsYW5lcy5mb3JFYWNoKChwbGFuZSwgaW5kZXgpID0+IHtcbiAgICAgICAgICAgIGxldCBjb2xvciA9ICcjQ0NDJztcbiAgICAgICAgICAgIGlmICh0eXBlb2YgbWl4ZXNbaW5kZXhdID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIGNvbG9yID0gbWl4ZXNbaW5kZXhdO1xuICAgICAgICAgICAgfSBlbHNlIGlmKG1peGVzW2luZGV4XSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGNvbG9ycyA9IG1peGVzW2luZGV4XS5tYXAoKGkpID0+IG1peGVzW2kgLSAxXSk7XG4gICAgICAgICAgICAgICAgY29sb3IgPSBtaXhlc1tpbmRleF0gPSBDb2xvclRyYW5zbGF0b3IuZ2V0TWl4SEVYKGNvbG9ycywgTWl4LlNVQlRSQUNUSVZFKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHBsYW5lLnNldEF0dHJpYnV0ZSgnZmlsbCcsIGNvbG9yKTtcbiAgICAgICAgfSk7XG4gICAgfTtcblxuICAgIGZldGNoKCdpbWFnZXMvY29sb3ItbWl4ZXMuc3ZnJylcbiAgICAgICAgLnRoZW4ocmVzdWx0ID0+IHJlc3VsdC50ZXh0KCkpXG4gICAgICAgIC50aGVuKChzdmdDb2RlKSA9PiB7XG4gICAgICAgICAgICBjb250YWluZXIuaW5uZXJIVE1MID0gc3ZnQ29kZTtcbiAgICAgICAgICAgIGZpbGxQbGFuZXMoKTtcbiAgICAgICAgfSk7XG5cbiAgICByZXR1cm4gY29udGFpbmVyO1xuXG59OyIsImltcG9ydCAnLi9zdHlsZXMuc2Nzcyc7XG5cbmV4cG9ydCBkZWZhdWx0IChDb2xvclRyYW5zbGF0b3IsIHsgSGFybW9ueSB9KSA9PiB7XG5cbiAgICBjb25zdCBjb250YWluZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcblxuICAgIGNvbnN0IGhhcm1vbmllcyA9IFtcbiAgICAgICAgeyBsYWJlbDogJ0NvbXBsZW1lbnRhcnknLCAgICAgICB2YWx1ZTogSGFybW9ueS5DT01QTEVNRU5UQVJZIH0sXG4gICAgICAgIHsgbGFiZWw6ICdTcGxpdCBDb21wbGVtZW50YXJ5JywgdmFsdWU6IEhhcm1vbnkuU1BMSVRfQ09NUExFTUVOVEFSWSB9LFxuICAgICAgICB7IGxhYmVsOiAnQW5hbG9nb3VzJywgICAgICAgICAgIHZhbHVlOiBIYXJtb255LkFOQUxPR09VUyB9LFxuICAgICAgICB7IGxhYmVsOiAnVHJpYWRpYycsICAgICAgICAgICAgIHZhbHVlOiBIYXJtb255LlRSSUFESUMgfSxcbiAgICAgICAgeyBsYWJlbDogJ1RldHJhZGljJywgICAgICAgICAgICB2YWx1ZTogSGFybW9ueS5URVRSQURJQyB9LFxuICAgICAgICB7IGxhYmVsOiAnU3F1YXJlJywgICAgICAgICAgICAgIHZhbHVlOiBIYXJtb255LlNRVUFSRSB9XG4gICAgXTtcblxuICAgIGNvbnN0IGJhc2VDb2xvciA9ICcjRjAwJztcblxuICAgIGNvbnN0IGNyZWF0ZUVsZW1lbnQgPSAoY2xhc3NOYW1lLCBwYXJlbnQpID0+IHtcbiAgICAgICAgY29uc3QgZGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgIGRpdi5jbGFzc0xpc3QuYWRkKGNsYXNzTmFtZSk7XG4gICAgICAgIHBhcmVudC5hcHBlbmRDaGlsZChkaXYpO1xuICAgICAgICByZXR1cm4gZGl2O1xuICAgIH07XG5cbiAgICBjb25zdCBjcmVhdGVIYXJtb255ID0gKGl0ZW0pID0+IHtcblxuICAgICAgICBjb25zdCB3cmFwcGVyID0gY3JlYXRlRWxlbWVudCgnd3JhcHBlcicsIGNvbnRhaW5lcik7XG4gICAgICAgIGNvbnN0IHdoZWVsID0gY3JlYXRlRWxlbWVudCgnd2hlZWwnLCB3cmFwcGVyKTtcbiAgICAgICAgY29uc3QgaGFybW9ueSA9IGNyZWF0ZUVsZW1lbnQoJ2hhcm1vbnknLCB3cmFwcGVyKTtcbiAgICAgICAgY3JlYXRlRWxlbWVudCgnbGFiZWwnLCB3cmFwcGVyKS5pbm5lclRleHQgPSBpdGVtLmxhYmVsO1xuXG4gICAgICAgIGZldGNoKCdpbWFnZXMvd2hlZWwtYWRkaXRpdmUuc3ZnJylcbiAgICAgICAgICAgIC50aGVuKHJlc3VsdCA9PiByZXN1bHQudGV4dCgpKVxuICAgICAgICAgICAgLnRoZW4oKHN2Z0NvZGUpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBoYXJtb255Q29sb3JzID0gQ29sb3JUcmFuc2xhdG9yLmdldEhhcm1vbnkoYmFzZUNvbG9yLCBpdGVtLnZhbHVlKTtcbiAgICAgICAgICAgICAgICBjb25zdCBzZWxlY3RvciA9ICdwYXRoJyArIGhhcm1vbnlDb2xvcnMubWFwKChjb2xvcikgPT4gYDpub3QoW2ZpbGw9XCIke2NvbG9yfVwiXSlgKS5qb2luKCcnKTtcbiAgICAgICAgICAgICAgICB3aGVlbC5pbm5lckhUTUwgPSBzdmdDb2RlO1xuICAgICAgICAgICAgICAgIGhhcm1vbnlDb2xvcnMuZm9yRWFjaCgoaGV4KSA9PiBjcmVhdGVFbGVtZW50KCdib3gnLCBoYXJtb255KS5zdHlsZS5iYWNrZ3JvdW5kID0gaGV4KTtcbiAgICAgICAgICAgICAgICB3aGVlbC5xdWVyeVNlbGVjdG9yQWxsKHNlbGVjdG9yKS5mb3JFYWNoKChwYXRoKSA9PiBwYXRoLnNldEF0dHJpYnV0ZSgnZmlsbC1vcGFjaXR5JywgJzAuMjUnKSk7XG4gICAgICAgICAgICB9KTtcblxuICAgIH07XG5cbiAgICBoYXJtb25pZXMuZm9yRWFjaCgoaXRlbSkgPT4gY3JlYXRlSGFybW9ueShpdGVtKSk7XG5cbiAgICByZXR1cm4gY29udGFpbmVyO1xuXG59OyIsImltcG9ydCAnLi9zdHlsZXMuc2Nzcyc7XG5cbmV4cG9ydCBkZWZhdWx0IChDb2xvclRyYW5zbGF0b3IsIHsgSGFybW9ueSwgTWl4IH0pID0+IHtcblxuICAgIGNvbnN0IGNvbnRhaW5lciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuXG4gICAgY29uc3QgaGFybW9uaWVzID0gW1xuICAgICAgICB7IGxhYmVsOiAnQ29tcGxlbWVudGFyeScsICAgICAgIHZhbHVlOiBIYXJtb255LkNPTVBMRU1FTlRBUlkgfSxcbiAgICAgICAgeyBsYWJlbDogJ1NwbGl0IENvbXBsZW1lbnRhcnknLCB2YWx1ZTogSGFybW9ueS5TUExJVF9DT01QTEVNRU5UQVJZIH0sXG4gICAgICAgIHsgbGFiZWw6ICdBbmFsb2dvdXMnLCAgICAgICAgICAgdmFsdWU6IEhhcm1vbnkuQU5BTE9HT1VTIH0sXG4gICAgICAgIHsgbGFiZWw6ICdUcmlhZGljJywgICAgICAgICAgICAgdmFsdWU6IEhhcm1vbnkuVFJJQURJQyB9LFxuICAgICAgICB7IGxhYmVsOiAnVGV0cmFkaWMnLCAgICAgICAgICAgIHZhbHVlOiBIYXJtb255LlRFVFJBRElDIH0sXG4gICAgICAgIHsgbGFiZWw6ICdTcXVhcmUnLCAgICAgICAgICAgICAgdmFsdWU6IEhhcm1vbnkuU1FVQVJFIH1cbiAgICBdO1xuXG4gICAgY29uc3QgYmFzZUNvbG9yID0gJyNGMDAnO1xuXG4gICAgY29uc3QgY3JlYXRlRWxlbWVudCA9IChjbGFzc05hbWUsIHBhcmVudCkgPT4ge1xuICAgICAgICBjb25zdCBkaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgZGl2LmNsYXNzTGlzdC5hZGQoY2xhc3NOYW1lKTtcbiAgICAgICAgcGFyZW50LmFwcGVuZENoaWxkKGRpdik7XG4gICAgICAgIHJldHVybiBkaXY7XG4gICAgfTtcblxuICAgIGNvbnN0IGNyZWF0ZUhhcm1vbnkgPSAoaXRlbSkgPT4ge1xuXG4gICAgICAgIGNvbnN0IHdyYXBwZXIgPSBjcmVhdGVFbGVtZW50KCd3cmFwcGVyJywgY29udGFpbmVyKTtcbiAgICAgICAgY29uc3Qgd2hlZWwgPSBjcmVhdGVFbGVtZW50KCd3aGVlbCcsIHdyYXBwZXIpO1xuICAgICAgICBjb25zdCBoYXJtb255ID0gY3JlYXRlRWxlbWVudCgnaGFybW9ueScsIHdyYXBwZXIpO1xuICAgICAgICBjcmVhdGVFbGVtZW50KCdsYWJlbCcsIHdyYXBwZXIpLmlubmVyVGV4dCA9IGl0ZW0ubGFiZWw7XG5cbiAgICAgICAgZmV0Y2goJ2ltYWdlcy93aGVlbC1zdWJ0cmFjdGl2ZS5zdmcnKVxuICAgICAgICAgICAgLnRoZW4ocmVzdWx0ID0+IHJlc3VsdC50ZXh0KCkpXG4gICAgICAgICAgICAudGhlbigoc3ZnQ29kZSkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IGhhcm1vbnlDb2xvcnMgPSBDb2xvclRyYW5zbGF0b3IuZ2V0SGFybW9ueShiYXNlQ29sb3IsIGl0ZW0udmFsdWUsIE1peC5TVUJUUkFDVElWRSk7XG4gICAgICAgICAgICAgICAgY29uc3Qgc2VsZWN0b3IgPSAncGF0aCcgKyBoYXJtb255Q29sb3JzLm1hcCgoY29sb3IpID0+IGA6bm90KFtmaWxsPVwiJHtjb2xvcn1cIl0pYCkuam9pbignJyk7XG4gICAgICAgICAgICAgICAgd2hlZWwuaW5uZXJIVE1MID0gc3ZnQ29kZTtcbiAgICAgICAgICAgICAgICBoYXJtb255Q29sb3JzLmZvckVhY2goKGhleCkgPT4gY3JlYXRlRWxlbWVudCgnYm94JywgaGFybW9ueSkuc3R5bGUuYmFja2dyb3VuZCA9IGhleCk7XG4gICAgICAgICAgICAgICAgd2hlZWwucXVlcnlTZWxlY3RvckFsbChzZWxlY3RvcikuZm9yRWFjaCgocGF0aCkgPT4gcGF0aC5zZXRBdHRyaWJ1dGUoJ2ZpbGwtb3BhY2l0eScsICcwLjI1JykpO1xuICAgICAgICAgICAgfSk7XG5cbiAgICB9O1xuXG4gICAgaGFybW9uaWVzLmZvckVhY2goKGl0ZW0pID0+IGNyZWF0ZUhhcm1vbnkoaXRlbSkpO1xuXG4gICAgcmV0dXJuIGNvbnRhaW5lcjtcblxufTsiLCJpbXBvcnQgJy4uLy4uL25vZGVfbW9kdWxlcy9nb29nbGUtY29kZS1wcmV0dGlmeS9iaW4vcnVuX3ByZXR0aWZ5Lm1pbic7XG5pbXBvcnQgJy4uLy4uL25vZGVfbW9kdWxlcy9nb29nbGUtY29kZS1wcmV0dGlmeS9iaW4vcHJldHRpZnkubWluLmNzcyc7XG5pbXBvcnQgJy4uLy4uL25vZGVfbW9kdWxlcy9nb29nbGUtY29kZS1wcmV0dGlmeS9zdHlsZXMvZGVzZXJ0LmNzcyc7XG5pbXBvcnQgJ3doYXR3Zy1mZXRjaCc7XG5pbXBvcnQgJy4vc3R5bGVzLnNjc3MnO1xuaW1wb3J0IHsgQ29sb3JUcmFuc2xhdG9yLCBIYXJtb255LCBNaXggfSBmcm9tICcuLi8nO1xuaW1wb3J0IGRlbW8xIGZyb20gJy4vZGVtbzEnO1xuaW1wb3J0IGRlbW8yIGZyb20gJy4vZGVtbzInO1xuaW1wb3J0IGRlbW8zIGZyb20gJy4vZGVtbzMnO1xuaW1wb3J0IGRlbW80IGZyb20gJy4vZGVtbzQnO1xuaW1wb3J0IGRlbW81IGZyb20gJy4vZGVtbzUnO1xuaW1wb3J0IGRlbW82IGZyb20gJy4vZGVtbzYnO1xuaW1wb3J0IGRlbW83IGZyb20gJy4vZGVtbzcnO1xuaW1wb3J0IGRlbW84IGZyb20gJy4vZGVtbzgnO1xuaW1wb3J0IGRlbW85IGZyb20gJy4vZGVtbzknO1xuaW1wb3J0IGRlbW8xMCBmcm9tICcuL2RlbW8xMCc7XG5pbXBvcnQgZGVtbzExIGZyb20gJy4vZGVtbzExJztcblxuY29uc3QgZnVuY3Rpb1RvU3RyaW5nID0gKGZuKSA9PiB7XG4gICAgY29uc3QgYXJ0aWNsZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2FydGljbGUnKTtcbiAgICBjb25zdCBwcmUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdwcmUnKTtcbiAgICBhcnRpY2xlLmNsYXNzTGlzdC5hZGQoJ2Z1bmN0aW9uLWNvbnRhaW5lcicpO1xuICAgIHByZS5jbGFzc0xpc3QuYWRkKCdwcmV0dHlwcmludCcpO1xuICAgIGFydGljbGUuYXBwZW5kQ2hpbGQocHJlKTtcbiAgICBwcmUuaW5uZXJIVE1MID0gZm4udG9TdHJpbmcoKS5yZXBsYWNlKCcoQ29sb3JUcmFuc2xhdG9yKScsICcoKScpO1xuICAgIHJldHVybiBhcnRpY2xlO1xufTtcblxuY29uc3QgZGVtb3MgPSBuZXcgTWFwKFtcbiAgICBbJ2RlbW8xJywgZGVtbzFdLFxuICAgIFsnZGVtbzInLCBkZW1vMl0sXG4gICAgWydkZW1vMycsIGRlbW8zXSxcbiAgICBbJ2RlbW80JywgZGVtbzRdLFxuICAgIFsnZGVtbzUnLCBkZW1vNV0sXG4gICAgWydkZW1vNicsIGRlbW82XSxcbiAgICBbJ2RlbW83JywgZGVtbzddLFxuICAgIFsnZGVtbzgnLCBkZW1vOF0sXG4gICAgWydkZW1vOScsIGRlbW85XSxcbiAgICBbJ2RlbW8xMCcsIGRlbW8xMF0sXG4gICAgWydkZW1vMTEnLCBkZW1vMTFdLFxuXSk7XG5cbmRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ0RPTUNvbnRlbnRMb2FkZWQnLCAoKSA9PiB7XG4gICAgZGVtb3MuZm9yRWFjaCgobW9kdWxlLCBkaXYpID0+IHtcbiAgICAgICAgY29uc3QgZGVtbyA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGRpdik7XG4gICAgICAgIGNvbnN0IGNvbnRhaW5lciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICBjb25zdCB3cmFwcGVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG5cbiAgICAgICAgY29udGFpbmVyLmNsYXNzTGlzdC5hZGQoJ2RlbW8tY29udGFpbmVyJyk7XG4gICAgICAgIHdyYXBwZXIuY2xhc3NMaXN0LmFkZCgnZGVtby13cmFwcGVyJyk7XG5cbiAgICAgICAgd3JhcHBlci5hcHBlbmRDaGlsZChtb2R1bGUoQ29sb3JUcmFuc2xhdG9yLCB7IEhhcm1vbnksIE1peCB9KSk7XG4gICAgICAgIGNvbnRhaW5lci5hcHBlbmRDaGlsZCh3cmFwcGVyKTtcbiAgICAgICAgZGVtby5hcHBlbmRDaGlsZChjb250YWluZXIpO1xuICAgICAgICBkZW1vLmFwcGVuZENoaWxkKGZ1bmN0aW9Ub1N0cmluZyhtb2R1bGUpKTtcbiAgICB9KTtcbn0pOyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///405\n')}},__webpack_module_cache__={};function __webpack_require__(I){var g=__webpack_module_cache__[I];if(void 0!==g)return g.exports;var C=__webpack_module_cache__[I]={exports:{}};return __webpack_modules__[I](C,C.exports,__webpack_require__),C.exports}__webpack_require__.g=function(){if("object"==typeof globalThis)return globalThis;try{return this||new Function("return this")()}catch(I){if("object"==typeof window)return window}}(),__webpack_require__.r=I=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(I,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(I,"__esModule",{value:!0})};var __webpack_exports__=__webpack_require__(405),__webpack_export_target__=window;for(var i in __webpack_exports__)__webpack_export_target__[i]=__webpack_exports__[i];__webpack_exports__.__esModule&&Object.defineProperty(__webpack_export_target__,"__esModule",{value:!0})})();