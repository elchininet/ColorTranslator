(()=>{var __webpack_modules__={538:(module,exports)=>{eval('var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!function(){var r=null;\n(function(){function X(e){function j(){try{J.doScroll("left")}catch(e){P(j,50);return}w("poll")}function w(j){if(!(j.type=="readystatechange"&&x.readyState!="complete")&&((j.type=="load"?n:x)[z](i+j.type,w,!1),!m&&(m=!0)))e.call(n,j.type||j)}var Y=x.addEventListener,m=!1,C=!0,t=Y?"addEventListener":"attachEvent",z=Y?"removeEventListener":"detachEvent",i=Y?"":"on";if(x.readyState=="complete")e.call(n,"lazy");else{if(x.createEventObject&&J.doScroll){try{C=!n.frameElement}catch(A){}C&&j()}x[t](i+"DOMContentLoaded",\nw,!1);x[t](i+"readystatechange",w,!1);n[t](i+"load",w,!1)}}function Q(){S&&X(function(){var e=K.length;$(e?function(){for(var j=0;j<e;++j)(function(e){P(function(){n.exports[K[e]].apply(n,arguments)},0)})(j)}:void 0)})}for(var n=window,P=n.setTimeout,x=document,J=x.documentElement,L=x.head||x.getElementsByTagName("head")[0]||J,z="",A=x.scripts,m=A.length;--m>=0;){var M=A[m],T=M.src.match(/^[^#?]*\\/run_prettify\\.js(\\?[^#]*)?(?:#.*)?$/);if(T){z=T[1]||"";M.parentNode.removeChild(M);break}}var S=!0,D=\n[],N=[],K=[];z.replace(/[&?]([^&=]+)=([^&]+)/g,function(e,j,w){w=decodeURIComponent(w);j=decodeURIComponent(j);j=="autorun"?S=!/^[0fn]/i.test(w):j=="lang"?D.push(w):j=="skin"?N.push(w):j=="callback"&&K.push(w)});m=0;for(z=D.length;m<z;++m)(function(){var e=x.createElement("script");e.onload=e.onerror=e.onreadystatechange=function(){if(e&&(!e.readyState||/loaded|complete/.test(e.readyState)))e.onerror=e.onload=e.onreadystatechange=r,--R,R||P(Q,0),e.parentNode&&e.parentNode.removeChild(e),e=r};e.type=\n"text/javascript";e.src="https://google-code-prettify.googlecode.com/svn/loader/lang-"+encodeURIComponent(D[m])+".js";L.insertBefore(e,L.firstChild)})(D[m]);for(var R=D.length,A=[],m=0,z=N.length;m<z;++m)A.push("https://google-code-prettify.googlecode.com/svn/loader/skins/"+encodeURIComponent(N[m])+".css");A.push("https://google-code-prettify.googlecode.com/svn/loader/prettify.css");(function(e){function j(m){if(m!==w){var n=x.createElement("link");n.rel="stylesheet";n.type="text/css";if(m+1<w)n.error=\nn.onerror=function(){j(m+1)};n.href=e[m];L.appendChild(n)}}var w=e.length;j(0)})(A);var $=function(){window.PR_SHOULD_USE_CONTINUATION=!0;var e;(function(){function j(a){function d(f){var b=f.charCodeAt(0);if(b!==92)return b;var a=f.charAt(1);return(b=i[a])?b:"0"<=a&&a<="7"?parseInt(f.substring(1),8):a==="u"||a==="x"?parseInt(f.substring(2),16):f.charCodeAt(1)}function h(f){if(f<32)return(f<16?"\\\\x0":"\\\\x")+f.toString(16);f=String.fromCharCode(f);return f==="\\\\"||f==="-"||f==="]"||f==="^"?"\\\\"+f:\nf}function b(f){var b=f.substring(1,f.length-1).match(/\\\\u[\\dA-Fa-f]{4}|\\\\x[\\dA-Fa-f]{2}|\\\\[0-3][0-7]{0,2}|\\\\[0-7]{1,2}|\\\\[\\S\\s]|[^\\\\]/g),f=[],a=b[0]==="^",c=["["];a&&c.push("^");for(var a=a?1:0,g=b.length;a<g;++a){var k=b[a];if(/\\\\[bdsw]/i.test(k))c.push(k);else{var k=d(k),o;a+2<g&&"-"===b[a+1]?(o=d(b[a+2]),a+=2):o=k;f.push([k,o]);o<65||k>122||(o<65||k>90||f.push([Math.max(65,k)|32,Math.min(o,90)|32]),o<97||k>122||f.push([Math.max(97,k)&-33,Math.min(o,122)&-33]))}}f.sort(function(f,a){return f[0]-\na[0]||a[1]-f[1]});b=[];g=[];for(a=0;a<f.length;++a)k=f[a],k[0]<=g[1]+1?g[1]=Math.max(g[1],k[1]):b.push(g=k);for(a=0;a<b.length;++a)k=b[a],c.push(h(k[0])),k[1]>k[0]&&(k[1]+1>k[0]&&c.push("-"),c.push(h(k[1])));c.push("]");return c.join("")}function e(f){for(var a=f.source.match(/\\[(?:[^\\\\\\]]|\\\\[\\S\\s])*]|\\\\u[\\dA-Fa-f]{4}|\\\\x[\\dA-Fa-f]{2}|\\\\\\d+|\\\\[^\\dux]|\\(\\?[!:=]|[()^]|[^()[\\\\^]+/g),c=a.length,d=[],g=0,k=0;g<c;++g){var o=a[g];o==="("?++k:"\\\\"===o.charAt(0)&&(o=+o.substring(1))&&(o<=k?d[o]=-1:a[g]=h(o))}for(g=\n1;g<d.length;++g)-1===d[g]&&(d[g]=++j);for(k=g=0;g<c;++g)o=a[g],o==="("?(++k,d[k]||(a[g]="(?:")):"\\\\"===o.charAt(0)&&(o=+o.substring(1))&&o<=k&&(a[g]="\\\\"+d[o]);for(g=0;g<c;++g)"^"===a[g]&&"^"!==a[g+1]&&(a[g]="");if(f.ignoreCase&&F)for(g=0;g<c;++g)o=a[g],f=o.charAt(0),o.length>=2&&f==="["?a[g]=b(o):f!=="\\\\"&&(a[g]=o.replace(/[A-Za-z]/g,function(a){a=a.charCodeAt(0);return"["+String.fromCharCode(a&-33,a|32)+"]"}));return a.join("")}for(var j=0,F=!1,l=!1,I=0,c=a.length;I<c;++I){var p=a[I];if(p.ignoreCase)l=\n!0;else if(/[a-z]/i.test(p.source.replace(/\\\\u[\\da-f]{4}|\\\\x[\\da-f]{2}|\\\\[^UXux]/gi,""))){F=!0;l=!1;break}}for(var i={b:8,t:9,n:10,v:11,f:12,r:13},q=[],I=0,c=a.length;I<c;++I){p=a[I];if(p.global||p.multiline)throw Error(""+p);q.push("(?:"+e(p)+")")}return RegExp(q.join("|"),l?"gi":"g")}function m(a,d){function h(a){var c=a.nodeType;if(c==1){if(!b.test(a.className)){for(c=a.firstChild;c;c=c.nextSibling)h(c);c=a.nodeName.toLowerCase();if("br"===c||"li"===c)e[l]="\\n",F[l<<1]=j++,F[l++<<1|1]=a}}else if(c==\n3||c==4)c=a.nodeValue,c.length&&(c=d?c.replace(/\\r\\n?/g,"\\n"):c.replace(/[\\t\\n\\r ]+/g," "),e[l]=c,F[l<<1]=j,j+=c.length,F[l++<<1|1]=a)}var b=/(?:^|\\s)nocode(?:\\s|$)/,e=[],j=0,F=[],l=0;h(a);return{a:e.join("").replace(/\\n$/,""),d:F}}function n(a,d,h,b){d&&(a={a:d,e:a},h(a),b.push.apply(b,a.g))}function x(a){for(var d=void 0,h=a.firstChild;h;h=h.nextSibling)var b=h.nodeType,d=b===1?d?a:h:b===3?S.test(h.nodeValue)?a:d:d;return d===a?void 0:d}function C(a,d){function h(a){for(var l=a.e,j=[l,"pln"],c=\n0,p=a.a.match(e)||[],m={},q=0,f=p.length;q<f;++q){var B=p[q],y=m[B],u=void 0,g;if(typeof y==="string")g=!1;else{var k=b[B.charAt(0)];if(k)u=B.match(k[1]),y=k[0];else{for(g=0;g<i;++g)if(k=d[g],u=B.match(k[1])){y=k[0];break}u||(y="pln")}if((g=y.length>=5&&"lang-"===y.substring(0,5))&&!(u&&typeof u[1]==="string"))g=!1,y="src";g||(m[B]=y)}k=c;c+=B.length;if(g){g=u[1];var o=B.indexOf(g),H=o+g.length;u[2]&&(H=B.length-u[2].length,o=H-g.length);y=y.substring(5);n(l+k,B.substring(0,o),h,j);n(l+k+o,g,A(y,\ng),j);n(l+k+H,B.substring(H),h,j)}else j.push(l+k,y)}a.g=j}var b={},e;(function(){for(var h=a.concat(d),l=[],i={},c=0,p=h.length;c<p;++c){var m=h[c],q=m[3];if(q)for(var f=q.length;--f>=0;)b[q.charAt(f)]=m;m=m[1];q=""+m;i.hasOwnProperty(q)||(l.push(m),i[q]=r)}l.push(/[\\S\\s]/);e=j(l)})();var i=d.length;return h}function t(a){var d=[],h=[];a.tripleQuotedStrings?d.push(["str",/^(?:\'\'\'(?:[^\'\\\\]|\\\\[\\S\\s]|\'\'?(?=[^\']))*(?:\'\'\'|$)|"""(?:[^"\\\\]|\\\\[\\S\\s]|""?(?=[^"]))*(?:"""|$)|\'(?:[^\'\\\\]|\\\\[\\S\\s])*(?:\'|$)|"(?:[^"\\\\]|\\\\[\\S\\s])*(?:"|$))/,\nr,"\'\\""]):a.multiLineStrings?d.push(["str",/^(?:\'(?:[^\'\\\\]|\\\\[\\S\\s])*(?:\'|$)|"(?:[^"\\\\]|\\\\[\\S\\s])*(?:"|$)|`(?:[^\\\\`]|\\\\[\\S\\s])*(?:`|$))/,r,"\'\\"`"]):d.push(["str",/^(?:\'(?:[^\\n\\r\'\\\\]|\\\\.)*(?:\'|$)|"(?:[^\\n\\r"\\\\]|\\\\.)*(?:"|$))/,r,"\\"\'"]);a.verbatimStrings&&h.push(["str",/^@"(?:[^"]|"")*(?:"|$)/,r]);var b=a.hashComments;b&&(a.cStyleComments?(b>1?d.push(["com",/^#(?:##(?:[^#]|#(?!##))*(?:###|$)|.*)/,r,"#"]):d.push(["com",/^#(?:(?:define|e(?:l|nd)if|else|error|ifn?def|include|line|pragma|undef|warning)\\b|[^\\n\\r]*)/,\nr,"#"]),h.push(["str",/^<(?:(?:(?:\\.\\.\\/)*|\\/?)(?:[\\w-]+(?:\\/[\\w-]+)+)?[\\w-]+\\.h(?:h|pp|\\+\\+)?|[a-z]\\w*)>/,r])):d.push(["com",/^#[^\\n\\r]*/,r,"#"]));a.cStyleComments&&(h.push(["com",/^\\/\\/[^\\n\\r]*/,r]),h.push(["com",/^\\/\\*[\\S\\s]*?(?:\\*\\/|$)/,r]));if(b=a.regexLiterals){var e=(b=b>1?"":"\\n\\r")?".":"[\\\\S\\\\s]";h.push(["lang-regex",RegExp("^(?:^^\\\\.?|[+-]|[!=]=?=?|\\\\#|%=?|&&?=?|\\\\(|\\\\*=?|[+\\\\-]=|->|\\\\/=?|::?|<<?=?|>>?>?=?|,|;|\\\\?|@|\\\\[|~|{|\\\\^\\\\^?=?|\\\\|\\\\|?=?|break|case|continue|delete|do|else|finally|instanceof|return|throw|try|typeof)\\\\s*("+\n("/(?=[^/*"+b+"])(?:[^/\\\\x5B\\\\x5C"+b+"]|\\\\x5C"+e+"|\\\\x5B(?:[^\\\\x5C\\\\x5D"+b+"]|\\\\x5C"+e+")*(?:\\\\x5D|$))+/")+")")])}(b=a.types)&&h.push(["typ",b]);b=(""+a.keywords).replace(/^ | $/g,"");b.length&&h.push(["kwd",RegExp("^(?:"+b.replace(/[\\s,]+/g,"|")+")\\\\b"),r]);d.push(["pln",/^\\s+/,r," \\r\\n\\t\\u00a0"]);b="^.[^\\\\s\\\\w.$@\'\\"`/\\\\\\\\]*";a.regexLiterals&&(b+="(?!s*/)");h.push(["lit",/^@[$_a-z][\\w$@]*/i,r],["typ",/^(?:[@_]?[A-Z]+[a-z][\\w$@]*|\\w+_t\\b)/,r],["pln",/^[$_a-z][\\w$@]*/i,r],["lit",/^(?:0x[\\da-f]+|(?:\\d(?:_\\d+)*\\d*(?:\\.\\d*)?|\\.\\d\\+)(?:e[+-]?\\d+)?)[a-z]*/i,\nr,"0123456789"],["pln",/^\\\\[\\S\\s]?/,r],["pun",RegExp(b),r]);return C(d,h)}function z(a,d,h){function b(a){var c=a.nodeType;if(c==1&&!j.test(a.className))if("br"===a.nodeName)e(a),a.parentNode&&a.parentNode.removeChild(a);else for(a=a.firstChild;a;a=a.nextSibling)b(a);else if((c==3||c==4)&&h){var d=a.nodeValue,i=d.match(m);if(i)c=d.substring(0,i.index),a.nodeValue=c,(d=d.substring(i.index+i[0].length))&&a.parentNode.insertBefore(l.createTextNode(d),a.nextSibling),e(a),c||a.parentNode.removeChild(a)}}\nfunction e(a){function b(a,c){var d=c?a.cloneNode(!1):a,f=a.parentNode;if(f){var f=b(f,1),h=a.nextSibling;f.appendChild(d);for(var e=h;e;e=h)h=e.nextSibling,f.appendChild(e)}return d}for(;!a.nextSibling;)if(a=a.parentNode,!a)return;for(var a=b(a.nextSibling,0),d;(d=a.parentNode)&&d.nodeType===1;)a=d;c.push(a)}for(var j=/(?:^|\\s)nocode(?:\\s|$)/,m=/\\r\\n?|\\n/,l=a.ownerDocument,i=l.createElement("li");a.firstChild;)i.appendChild(a.firstChild);for(var c=[i],p=0;p<c.length;++p)b(c[p]);d===(d|0)&&c[0].setAttribute("value",\nd);var n=l.createElement("ol");n.className="linenums";for(var d=Math.max(0,d-1|0)||0,p=0,q=c.length;p<q;++p)i=c[p],i.className="L"+(p+d)%10,i.firstChild||i.appendChild(l.createTextNode("\\u00a0")),n.appendChild(i);a.appendChild(n)}function i(a,d){for(var h=d.length;--h>=0;){var b=d[h];U.hasOwnProperty(b)?V.console&&console.warn("cannot override language handler %s",b):U[b]=a}}function A(a,d){if(!a||!U.hasOwnProperty(a))a=/^\\s*</.test(d)?"default-markup":"default-code";return U[a]}function D(a){var d=\na.h;try{var h=m(a.c,a.i),b=h.a;a.a=b;a.d=h.d;a.e=0;A(d,b)(a);var e=/\\bMSIE\\s(\\d+)/.exec(navigator.userAgent),e=e&&+e[1]<=8,d=/\\n/g,i=a.a,j=i.length,h=0,l=a.d,n=l.length,b=0,c=a.g,p=c.length,t=0;c[p]=j;var q,f;for(f=q=0;f<p;)c[f]!==c[f+2]?(c[q++]=c[f++],c[q++]=c[f++]):f+=2;p=q;for(f=q=0;f<p;){for(var x=c[f],y=c[f+1],u=f+2;u+2<=p&&c[u+1]===y;)u+=2;c[q++]=x;c[q++]=y;f=u}c.length=q;var g=a.c,k;if(g)k=g.style.display,g.style.display="none";try{for(;b<n;){var o=l[b+2]||j,H=c[t+2]||j,u=Math.min(o,H),E=l[b+\n1],W;if(E.nodeType!==1&&(W=i.substring(h,u))){e&&(W=W.replace(d,"\\r"));E.nodeValue=W;var Z=E.ownerDocument,s=Z.createElement("span");s.className=c[t+1];var z=E.parentNode;z.replaceChild(s,E);s.appendChild(E);h<o&&(l[b+1]=E=Z.createTextNode(i.substring(u,o)),z.insertBefore(E,s.nextSibling))}h=u;h>=o&&(b+=2);h>=H&&(t+=2)}}finally{if(g)g.style.display=k}}catch(v){V.console&&console.log(v&&v.stack||v)}}var V=window,G=["break,continue,do,else,for,if,return,while"],O=[[G,"auto,case,char,const,default,double,enum,extern,float,goto,inline,int,long,register,short,signed,sizeof,static,struct,switch,typedef,union,unsigned,void,volatile"],\n"catch,class,delete,false,import,new,operator,private,protected,public,this,throw,true,try,typeof"],J=[O,"alignof,align_union,asm,axiom,bool,concept,concept_map,const_cast,constexpr,decltype,delegate,dynamic_cast,explicit,export,friend,generic,late_check,mutable,namespace,nullptr,property,reinterpret_cast,static_assert,static_cast,template,typeid,typename,using,virtual,where"],K=[O,"abstract,assert,boolean,byte,extends,final,finally,implements,import,instanceof,interface,null,native,package,strictfp,super,synchronized,throws,transient"],\nL=[K,"as,base,by,checked,decimal,delegate,descending,dynamic,event,fixed,foreach,from,group,implicit,in,internal,into,is,let,lock,object,out,override,orderby,params,partial,readonly,ref,sbyte,sealed,stackalloc,string,select,uint,ulong,unchecked,unsafe,ushort,var,virtual,where"],O=[O,"debugger,eval,export,function,get,null,set,undefined,var,with,Infinity,NaN"],M=[G,"and,as,assert,class,def,del,elif,except,exec,finally,from,global,import,in,is,lambda,nonlocal,not,or,pass,print,raise,try,with,yield,False,True,None"],\nN=[G,"alias,and,begin,case,class,def,defined,elsif,end,ensure,false,in,module,next,nil,not,or,redo,rescue,retry,self,super,then,true,undef,unless,until,when,yield,BEGIN,END"],R=[G,"as,assert,const,copy,drop,enum,extern,fail,false,fn,impl,let,log,loop,match,mod,move,mut,priv,pub,pure,ref,self,static,struct,true,trait,type,unsafe,use"],G=[G,"case,done,elif,esac,eval,fi,function,in,local,set,then,until"],Q=/^(DIR|FILE|vector|(de|priority_)?queue|list|stack|(const_)?iterator|(multi)?(set|map)|bitset|u?(int|float)\\d*)\\b/,\nS=/\\S/,T=t({keywords:[J,L,O,"caller,delete,die,do,dump,elsif,eval,exit,foreach,for,goto,if,import,last,local,my,next,no,our,print,package,redo,require,sub,undef,unless,until,use,wantarray,while,BEGIN,END",M,N,G],hashComments:!0,cStyleComments:!0,multiLineStrings:!0,regexLiterals:!0}),U={};i(T,["default-code"]);i(C([],[["pln",/^[^<?]+/],["dec",/^<!\\w[^>]*(?:>|$)/],["com",/^<\\!--[\\S\\s]*?(?:--\\>|$)/],["lang-",/^<\\?([\\S\\s]+?)(?:\\?>|$)/],["lang-",/^<%([\\S\\s]+?)(?:%>|$)/],["pun",/^(?:<[%?]|[%?]>)/],["lang-",\n/^<xmp\\b[^>]*>([\\S\\s]+?)<\\/xmp\\b[^>]*>/i],["lang-js",/^<script\\b[^>]*>([\\S\\s]*?)(<\\/script\\b[^>]*>)/i],["lang-css",/^<style\\b[^>]*>([\\S\\s]*?)(<\\/style\\b[^>]*>)/i],["lang-in.tag",/^(<\\/?[a-z][^<>]*>)/i]]),["default-markup","htm","html","mxml","xhtml","xml","xsl"]);i(C([["pln",/^\\s+/,r," \\t\\r\\n"],["atv",/^(?:"[^"]*"?|\'[^\']*\'?)/,r,"\\"\'"]],[["tag",/^^<\\/?[a-z](?:[\\w-.:]*\\w)?|\\/?>$/i],["atn",/^(?!style[\\s=]|on)[a-z](?:[\\w:-]*\\w)?/i],["lang-uq.val",/^=\\s*([^\\s"\'>]*(?:[^\\s"\'/>]|\\/(?=\\s)))/],["pun",/^[/<->]+/],\n["lang-js",/^on\\w+\\s*=\\s*"([^"]+)"/i],["lang-js",/^on\\w+\\s*=\\s*\'([^\']+)\'/i],["lang-js",/^on\\w+\\s*=\\s*([^\\s"\'>]+)/i],["lang-css",/^style\\s*=\\s*"([^"]+)"/i],["lang-css",/^style\\s*=\\s*\'([^\']+)\'/i],["lang-css",/^style\\s*=\\s*([^\\s"\'>]+)/i]]),["in.tag"]);i(C([],[["atv",/^[\\S\\s]+/]]),["uq.val"]);i(t({keywords:J,hashComments:!0,cStyleComments:!0,types:Q}),["c","cc","cpp","cxx","cyc","m"]);i(t({keywords:"null,true,false"}),["json"]);i(t({keywords:L,hashComments:!0,cStyleComments:!0,verbatimStrings:!0,types:Q}),\n["cs"]);i(t({keywords:K,cStyleComments:!0}),["java"]);i(t({keywords:G,hashComments:!0,multiLineStrings:!0}),["bash","bsh","csh","sh"]);i(t({keywords:M,hashComments:!0,multiLineStrings:!0,tripleQuotedStrings:!0}),["cv","py","python"]);i(t({keywords:"caller,delete,die,do,dump,elsif,eval,exit,foreach,for,goto,if,import,last,local,my,next,no,our,print,package,redo,require,sub,undef,unless,until,use,wantarray,while,BEGIN,END",hashComments:!0,multiLineStrings:!0,regexLiterals:2}),["perl","pl","pm"]);i(t({keywords:N,\nhashComments:!0,multiLineStrings:!0,regexLiterals:!0}),["rb","ruby"]);i(t({keywords:O,cStyleComments:!0,regexLiterals:!0}),["javascript","js"]);i(t({keywords:"all,and,by,catch,class,else,extends,false,finally,for,if,in,is,isnt,loop,new,no,not,null,of,off,on,or,return,super,then,throw,true,try,unless,until,when,while,yes",hashComments:3,cStyleComments:!0,multilineStrings:!0,tripleQuotedStrings:!0,regexLiterals:!0}),["coffee"]);i(t({keywords:R,cStyleComments:!0,multilineStrings:!0}),["rc","rs","rust"]);\ni(C([],[["str",/^[\\S\\s]+/]]),["regex"]);var X=V.PR={createSimpleLexer:C,registerLangHandler:i,sourceDecorator:t,PR_ATTRIB_NAME:"atn",PR_ATTRIB_VALUE:"atv",PR_COMMENT:"com",PR_DECLARATION:"dec",PR_KEYWORD:"kwd",PR_LITERAL:"lit",PR_NOCODE:"nocode",PR_PLAIN:"pln",PR_PUNCTUATION:"pun",PR_SOURCE:"src",PR_STRING:"str",PR_TAG:"tag",PR_TYPE:"typ",prettyPrintOne:function(a,d,e){var b=document.createElement("div");b.innerHTML="<pre>"+a+"</pre>";b=b.firstChild;e&&z(b,e,!0);D({h:d,j:e,c:b,i:1});return b.innerHTML},\nprettyPrint:e=e=function(a,d){function e(){for(var b=V.PR_SHOULD_USE_CONTINUATION?c.now()+250:Infinity;p<j.length&&c.now()<b;p++){for(var d=j[p],m=k,l=d;l=l.previousSibling;){var n=l.nodeType,s=(n===7||n===8)&&l.nodeValue;if(s?!/^\\??prettify\\b/.test(s):n!==3||/\\S/.test(l.nodeValue))break;if(s){m={};s.replace(/\\b(\\w+)=([\\w%+\\-.:]+)/g,function(a,b,c){m[b]=c});break}}l=d.className;if((m!==k||f.test(l))&&!w.test(l)){n=!1;for(s=d.parentNode;s;s=s.parentNode)if(g.test(s.tagName)&&s.className&&f.test(s.className)){n=\n!0;break}if(!n){d.className+=" prettyprinted";n=m.lang;if(!n){var n=l.match(q),A;if(!n&&(A=x(d))&&u.test(A.tagName))n=A.className.match(q);n&&(n=n[1])}if(y.test(d.tagName))s=1;else var s=d.currentStyle,v=i.defaultView,s=(s=s?s.whiteSpace:v&&v.getComputedStyle?v.getComputedStyle(d,r).getPropertyValue("white-space"):0)&&"pre"===s.substring(0,3);v=m.linenums;if(!(v=v==="true"||+v))v=(v=l.match(/\\blinenums\\b(?::(\\d+))?/))?v[1]&&v[1].length?+v[1]:!0:!1;v&&z(d,v,s);t={h:n,c:d,j:v,i:s};D(t)}}}p<j.length?\nP(e,250):"function"===typeof a&&a()}for(var b=d||document.body,i=b.ownerDocument||document,b=[b.getElementsByTagName("pre"),b.getElementsByTagName("code"),b.getElementsByTagName("xmp")],j=[],m=0;m<b.length;++m)for(var l=0,n=b[m].length;l<n;++l)j.push(b[m][l]);var b=r,c=Date;c.now||(c={now:function(){return+new Date}});var p=0,t,q=/\\blang(?:uage)?-([\\w.]+)(?!\\S)/,f=/\\bprettyprint\\b/,w=/\\bprettyprinted\\b/,y=/pre|xmp/i,u=/^code$/i,g=/^(?:pre|code|xmp)$/i,k={};e()}}; true&&\n!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = (function(){return X}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))})();return e}();R||P(Q,0)})();}()\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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YSw0REFBNEQsc0JBQXNCLEtBQUssdUJBQXVCLG9CQUFvQixFQUFFLCtDQUErQyxtRUFBbUUsTUFBTSxLQUFLLG1EQUFtRCxPQUFPLEVBQUUsT0FBTyxjQUFjLG1DQUFtQyxLQUFLLG1CQUFtQixFQUFFLHVFQUF1RTtBQUNqZ0IsR0FBRyxNQUFNLE9BQU8sOEJBQThCLFNBQVMsT0FBTyxtQkFBbUIsMERBQTBELFlBQVkseUJBQXlCLHlLQUF5SyxhQUFhLDhGQUE4RixZQUFZLEdBQUcsaUJBQWlCLE9BQU87QUFDM2Usb0NBQW9DLCtKQUErSixXQUFXLDhCQUE4QixJQUFJLG9CQUFvQixlQUFlLFdBQVcsZUFBZSxpQkFBaUIsRUFBRSw2SUFBNkksTUFBTSxLQUFzQztBQUN6ZixpQ0FBOEIsRUFBRSxtQ0FBQyxXQUFXLFNBQVM7QUFBQSxrR0FBQyxDQUFDLElBQUksU0FBUyxHQUFHLFVBQVUsS0FBSyIsInNvdXJjZXMiOlsid2VicGFjazovL2NvbG9ydHJhbnNsYXRvci8uL25vZGVfbW9kdWxlcy9nb29nbGUtY29kZS1wcmV0dGlmeS9iaW4vcnVuX3ByZXR0aWZ5Lm1pbi5qcz8xM2NjIl0sInNvdXJjZXNDb250ZW50IjpbIiFmdW5jdGlvbigpe3ZhciByPW51bGw7XG4oZnVuY3Rpb24oKXtmdW5jdGlvbiBYKGUpe2Z1bmN0aW9uIGooKXt0cnl7Si5kb1Njcm9sbChcImxlZnRcIil9Y2F0Y2goZSl7UChqLDUwKTtyZXR1cm59dyhcInBvbGxcIil9ZnVuY3Rpb24gdyhqKXtpZighKGoudHlwZT09XCJyZWFkeXN0YXRlY2hhbmdlXCImJngucmVhZHlTdGF0ZSE9XCJjb21wbGV0ZVwiKSYmKChqLnR5cGU9PVwibG9hZFwiP246eClbel0oaStqLnR5cGUsdywhMSksIW0mJihtPSEwKSkpZS5jYWxsKG4sai50eXBlfHxqKX12YXIgWT14LmFkZEV2ZW50TGlzdGVuZXIsbT0hMSxDPSEwLHQ9WT9cImFkZEV2ZW50TGlzdGVuZXJcIjpcImF0dGFjaEV2ZW50XCIsej1ZP1wicmVtb3ZlRXZlbnRMaXN0ZW5lclwiOlwiZGV0YWNoRXZlbnRcIixpPVk/XCJcIjpcIm9uXCI7aWYoeC5yZWFkeVN0YXRlPT1cImNvbXBsZXRlXCIpZS5jYWxsKG4sXCJsYXp5XCIpO2Vsc2V7aWYoeC5jcmVhdGVFdmVudE9iamVjdCYmSi5kb1Njcm9sbCl7dHJ5e0M9IW4uZnJhbWVFbGVtZW50fWNhdGNoKEEpe31DJiZqKCl9eFt0XShpK1wiRE9NQ29udGVudExvYWRlZFwiLFxudywhMSk7eFt0XShpK1wicmVhZHlzdGF0ZWNoYW5nZVwiLHcsITEpO25bdF0oaStcImxvYWRcIix3LCExKX19ZnVuY3Rpb24gUSgpe1MmJlgoZnVuY3Rpb24oKXt2YXIgZT1LLmxlbmd0aDskKGU/ZnVuY3Rpb24oKXtmb3IodmFyIGo9MDtqPGU7KytqKShmdW5jdGlvbihlKXtQKGZ1bmN0aW9uKCl7bi5leHBvcnRzW0tbZV1dLmFwcGx5KG4sYXJndW1lbnRzKX0sMCl9KShqKX06dm9pZCAwKX0pfWZvcih2YXIgbj13aW5kb3csUD1uLnNldFRpbWVvdXQseD1kb2N1bWVudCxKPXguZG9jdW1lbnRFbGVtZW50LEw9eC5oZWFkfHx4LmdldEVsZW1lbnRzQnlUYWdOYW1lKFwiaGVhZFwiKVswXXx8Six6PVwiXCIsQT14LnNjcmlwdHMsbT1BLmxlbmd0aDstLW0+PTA7KXt2YXIgTT1BW21dLFQ9TS5zcmMubWF0Y2goL15bXiM/XSpcXC9ydW5fcHJldHRpZnlcXC5qcyhcXD9bXiNdKik/KD86Iy4qKT8kLyk7aWYoVCl7ej1UWzFdfHxcIlwiO00ucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChNKTticmVha319dmFyIFM9ITAsRD1cbltdLE49W10sSz1bXTt6LnJlcGxhY2UoL1smP10oW14mPV0rKT0oW14mXSspL2csZnVuY3Rpb24oZSxqLHcpe3c9ZGVjb2RlVVJJQ29tcG9uZW50KHcpO2o9ZGVjb2RlVVJJQ29tcG9uZW50KGopO2o9PVwiYXV0b3J1blwiP1M9IS9eWzBmbl0vaS50ZXN0KHcpOmo9PVwibGFuZ1wiP0QucHVzaCh3KTpqPT1cInNraW5cIj9OLnB1c2godyk6aj09XCJjYWxsYmFja1wiJiZLLnB1c2godyl9KTttPTA7Zm9yKHo9RC5sZW5ndGg7bTx6OysrbSkoZnVuY3Rpb24oKXt2YXIgZT14LmNyZWF0ZUVsZW1lbnQoXCJzY3JpcHRcIik7ZS5vbmxvYWQ9ZS5vbmVycm9yPWUub25yZWFkeXN0YXRlY2hhbmdlPWZ1bmN0aW9uKCl7aWYoZSYmKCFlLnJlYWR5U3RhdGV8fC9sb2FkZWR8Y29tcGxldGUvLnRlc3QoZS5yZWFkeVN0YXRlKSkpZS5vbmVycm9yPWUub25sb2FkPWUub25yZWFkeXN0YXRlY2hhbmdlPXIsLS1SLFJ8fFAoUSwwKSxlLnBhcmVudE5vZGUmJmUucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChlKSxlPXJ9O2UudHlwZT1cblwidGV4dC9qYXZhc2NyaXB0XCI7ZS5zcmM9XCJodHRwczovL2dvb2dsZS1jb2RlLXByZXR0aWZ5Lmdvb2dsZWNvZGUuY29tL3N2bi9sb2FkZXIvbGFuZy1cIitlbmNvZGVVUklDb21wb25lbnQoRFttXSkrXCIuanNcIjtMLmluc2VydEJlZm9yZShlLEwuZmlyc3RDaGlsZCl9KShEW21dKTtmb3IodmFyIFI9RC5sZW5ndGgsQT1bXSxtPTAsej1OLmxlbmd0aDttPHo7KyttKUEucHVzaChcImh0dHBzOi8vZ29vZ2xlLWNvZGUtcHJldHRpZnkuZ29vZ2xlY29kZS5jb20vc3ZuL2xvYWRlci9za2lucy9cIitlbmNvZGVVUklDb21wb25lbnQoTlttXSkrXCIuY3NzXCIpO0EucHVzaChcImh0dHBzOi8vZ29vZ2xlLWNvZGUtcHJldHRpZnkuZ29vZ2xlY29kZS5jb20vc3ZuL2xvYWRlci9wcmV0dGlmeS5jc3NcIik7KGZ1bmN0aW9uKGUpe2Z1bmN0aW9uIGoobSl7aWYobSE9PXcpe3ZhciBuPXguY3JlYXRlRWxlbWVudChcImxpbmtcIik7bi5yZWw9XCJzdHlsZXNoZWV0XCI7bi50eXBlPVwidGV4dC9jc3NcIjtpZihtKzE8dyluLmVycm9yPVxubi5vbmVycm9yPWZ1bmN0aW9uKCl7aihtKzEpfTtuLmhyZWY9ZVttXTtMLmFwcGVuZENoaWxkKG4pfX12YXIgdz1lLmxlbmd0aDtqKDApfSkoQSk7dmFyICQ9ZnVuY3Rpb24oKXt3aW5kb3cuUFJfU0hPVUxEX1VTRV9DT05USU5VQVRJT049ITA7dmFyIGU7KGZ1bmN0aW9uKCl7ZnVuY3Rpb24gaihhKXtmdW5jdGlvbiBkKGYpe3ZhciBiPWYuY2hhckNvZGVBdCgwKTtpZihiIT09OTIpcmV0dXJuIGI7dmFyIGE9Zi5jaGFyQXQoMSk7cmV0dXJuKGI9aVthXSk/YjpcIjBcIjw9YSYmYTw9XCI3XCI/cGFyc2VJbnQoZi5zdWJzdHJpbmcoMSksOCk6YT09PVwidVwifHxhPT09XCJ4XCI/cGFyc2VJbnQoZi5zdWJzdHJpbmcoMiksMTYpOmYuY2hhckNvZGVBdCgxKX1mdW5jdGlvbiBoKGYpe2lmKGY8MzIpcmV0dXJuKGY8MTY/XCJcXFxceDBcIjpcIlxcXFx4XCIpK2YudG9TdHJpbmcoMTYpO2Y9U3RyaW5nLmZyb21DaGFyQ29kZShmKTtyZXR1cm4gZj09PVwiXFxcXFwifHxmPT09XCItXCJ8fGY9PT1cIl1cInx8Zj09PVwiXlwiP1wiXFxcXFwiK2Y6XG5mfWZ1bmN0aW9uIGIoZil7dmFyIGI9Zi5zdWJzdHJpbmcoMSxmLmxlbmd0aC0xKS5tYXRjaCgvXFxcXHVbXFxkQS1GYS1mXXs0fXxcXFxceFtcXGRBLUZhLWZdezJ9fFxcXFxbMC0zXVswLTddezAsMn18XFxcXFswLTddezEsMn18XFxcXFtcXFNcXHNdfFteXFxcXF0vZyksZj1bXSxhPWJbMF09PT1cIl5cIixjPVtcIltcIl07YSYmYy5wdXNoKFwiXlwiKTtmb3IodmFyIGE9YT8xOjAsZz1iLmxlbmd0aDthPGc7KythKXt2YXIgaz1iW2FdO2lmKC9cXFxcW2Jkc3ddL2kudGVzdChrKSljLnB1c2goayk7ZWxzZXt2YXIgaz1kKGspLG87YSsyPGcmJlwiLVwiPT09YlthKzFdPyhvPWQoYlthKzJdKSxhKz0yKTpvPWs7Zi5wdXNoKFtrLG9dKTtvPDY1fHxrPjEyMnx8KG88NjV8fGs+OTB8fGYucHVzaChbTWF0aC5tYXgoNjUsayl8MzIsTWF0aC5taW4obyw5MCl8MzJdKSxvPDk3fHxrPjEyMnx8Zi5wdXNoKFtNYXRoLm1heCg5NyxrKSYtMzMsTWF0aC5taW4obywxMjIpJi0zM10pKX19Zi5zb3J0KGZ1bmN0aW9uKGYsYSl7cmV0dXJuIGZbMF0tXG5hWzBdfHxhWzFdLWZbMV19KTtiPVtdO2c9W107Zm9yKGE9MDthPGYubGVuZ3RoOysrYSlrPWZbYV0sa1swXTw9Z1sxXSsxP2dbMV09TWF0aC5tYXgoZ1sxXSxrWzFdKTpiLnB1c2goZz1rKTtmb3IoYT0wO2E8Yi5sZW5ndGg7KythKWs9YlthXSxjLnB1c2goaChrWzBdKSksa1sxXT5rWzBdJiYoa1sxXSsxPmtbMF0mJmMucHVzaChcIi1cIiksYy5wdXNoKGgoa1sxXSkpKTtjLnB1c2goXCJdXCIpO3JldHVybiBjLmpvaW4oXCJcIil9ZnVuY3Rpb24gZShmKXtmb3IodmFyIGE9Zi5zb3VyY2UubWF0Y2goL1xcWyg/OlteXFxcXFxcXV18XFxcXFtcXFNcXHNdKSpdfFxcXFx1W1xcZEEtRmEtZl17NH18XFxcXHhbXFxkQS1GYS1mXXsyfXxcXFxcXFxkK3xcXFxcW15cXGR1eF18XFwoXFw/WyE6PV18WygpXl18W14oKVtcXFxcXl0rL2cpLGM9YS5sZW5ndGgsZD1bXSxnPTAsaz0wO2c8YzsrK2cpe3ZhciBvPWFbZ107bz09PVwiKFwiPysrazpcIlxcXFxcIj09PW8uY2hhckF0KDApJiYobz0rby5zdWJzdHJpbmcoMSkpJiYobzw9az9kW29dPS0xOmFbZ109aChvKSl9Zm9yKGc9XG4xO2c8ZC5sZW5ndGg7KytnKS0xPT09ZFtnXSYmKGRbZ109KytqKTtmb3Ioaz1nPTA7ZzxjOysrZylvPWFbZ10sbz09PVwiKFwiPygrK2ssZFtrXXx8KGFbZ109XCIoPzpcIikpOlwiXFxcXFwiPT09by5jaGFyQXQoMCkmJihvPStvLnN1YnN0cmluZygxKSkmJm88PWsmJihhW2ddPVwiXFxcXFwiK2Rbb10pO2ZvcihnPTA7ZzxjOysrZylcIl5cIj09PWFbZ10mJlwiXlwiIT09YVtnKzFdJiYoYVtnXT1cIlwiKTtpZihmLmlnbm9yZUNhc2UmJkYpZm9yKGc9MDtnPGM7KytnKW89YVtnXSxmPW8uY2hhckF0KDApLG8ubGVuZ3RoPj0yJiZmPT09XCJbXCI/YVtnXT1iKG8pOmYhPT1cIlxcXFxcIiYmKGFbZ109by5yZXBsYWNlKC9bQS1aYS16XS9nLGZ1bmN0aW9uKGEpe2E9YS5jaGFyQ29kZUF0KDApO3JldHVyblwiW1wiK1N0cmluZy5mcm9tQ2hhckNvZGUoYSYtMzMsYXwzMikrXCJdXCJ9KSk7cmV0dXJuIGEuam9pbihcIlwiKX1mb3IodmFyIGo9MCxGPSExLGw9ITEsST0wLGM9YS5sZW5ndGg7STxjOysrSSl7dmFyIHA9YVtJXTtpZihwLmlnbm9yZUNhc2UpbD1cbiEwO2Vsc2UgaWYoL1thLXpdL2kudGVzdChwLnNvdXJjZS5yZXBsYWNlKC9cXFxcdVtcXGRhLWZdezR9fFxcXFx4W1xcZGEtZl17Mn18XFxcXFteVVh1eF0vZ2ksXCJcIikpKXtGPSEwO2w9ITE7YnJlYWt9fWZvcih2YXIgaT17Yjo4LHQ6OSxuOjEwLHY6MTEsZjoxMixyOjEzfSxxPVtdLEk9MCxjPWEubGVuZ3RoO0k8YzsrK0kpe3A9YVtJXTtpZihwLmdsb2JhbHx8cC5tdWx0aWxpbmUpdGhyb3cgRXJyb3IoXCJcIitwKTtxLnB1c2goXCIoPzpcIitlKHApK1wiKVwiKX1yZXR1cm4gUmVnRXhwKHEuam9pbihcInxcIiksbD9cImdpXCI6XCJnXCIpfWZ1bmN0aW9uIG0oYSxkKXtmdW5jdGlvbiBoKGEpe3ZhciBjPWEubm9kZVR5cGU7aWYoYz09MSl7aWYoIWIudGVzdChhLmNsYXNzTmFtZSkpe2ZvcihjPWEuZmlyc3RDaGlsZDtjO2M9Yy5uZXh0U2libGluZyloKGMpO2M9YS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpO2lmKFwiYnJcIj09PWN8fFwibGlcIj09PWMpZVtsXT1cIlxcblwiLEZbbDw8MV09aisrLEZbbCsrPDwxfDFdPWF9fWVsc2UgaWYoYz09XG4zfHxjPT00KWM9YS5ub2RlVmFsdWUsYy5sZW5ndGgmJihjPWQ/Yy5yZXBsYWNlKC9cXHJcXG4/L2csXCJcXG5cIik6Yy5yZXBsYWNlKC9bXFx0XFxuXFxyIF0rL2csXCIgXCIpLGVbbF09YyxGW2w8PDFdPWosais9Yy5sZW5ndGgsRltsKys8PDF8MV09YSl9dmFyIGI9Lyg/Ol58XFxzKW5vY29kZSg/Olxcc3wkKS8sZT1bXSxqPTAsRj1bXSxsPTA7aChhKTtyZXR1cm57YTplLmpvaW4oXCJcIikucmVwbGFjZSgvXFxuJC8sXCJcIiksZDpGfX1mdW5jdGlvbiBuKGEsZCxoLGIpe2QmJihhPXthOmQsZTphfSxoKGEpLGIucHVzaC5hcHBseShiLGEuZykpfWZ1bmN0aW9uIHgoYSl7Zm9yKHZhciBkPXZvaWQgMCxoPWEuZmlyc3RDaGlsZDtoO2g9aC5uZXh0U2libGluZyl2YXIgYj1oLm5vZGVUeXBlLGQ9Yj09PTE/ZD9hOmg6Yj09PTM/Uy50ZXN0KGgubm9kZVZhbHVlKT9hOmQ6ZDtyZXR1cm4gZD09PWE/dm9pZCAwOmR9ZnVuY3Rpb24gQyhhLGQpe2Z1bmN0aW9uIGgoYSl7Zm9yKHZhciBsPWEuZSxqPVtsLFwicGxuXCJdLGM9XG4wLHA9YS5hLm1hdGNoKGUpfHxbXSxtPXt9LHE9MCxmPXAubGVuZ3RoO3E8ZjsrK3Epe3ZhciBCPXBbcV0seT1tW0JdLHU9dm9pZCAwLGc7aWYodHlwZW9mIHk9PT1cInN0cmluZ1wiKWc9ITE7ZWxzZXt2YXIgaz1iW0IuY2hhckF0KDApXTtpZihrKXU9Qi5tYXRjaChrWzFdKSx5PWtbMF07ZWxzZXtmb3IoZz0wO2c8aTsrK2cpaWYoaz1kW2ddLHU9Qi5tYXRjaChrWzFdKSl7eT1rWzBdO2JyZWFrfXV8fCh5PVwicGxuXCIpfWlmKChnPXkubGVuZ3RoPj01JiZcImxhbmctXCI9PT15LnN1YnN0cmluZygwLDUpKSYmISh1JiZ0eXBlb2YgdVsxXT09PVwic3RyaW5nXCIpKWc9ITEseT1cInNyY1wiO2d8fChtW0JdPXkpfWs9YztjKz1CLmxlbmd0aDtpZihnKXtnPXVbMV07dmFyIG89Qi5pbmRleE9mKGcpLEg9bytnLmxlbmd0aDt1WzJdJiYoSD1CLmxlbmd0aC11WzJdLmxlbmd0aCxvPUgtZy5sZW5ndGgpO3k9eS5zdWJzdHJpbmcoNSk7bihsK2ssQi5zdWJzdHJpbmcoMCxvKSxoLGopO24obCtrK28sZyxBKHksXG5nKSxqKTtuKGwraytILEIuc3Vic3RyaW5nKEgpLGgsail9ZWxzZSBqLnB1c2gobCtrLHkpfWEuZz1qfXZhciBiPXt9LGU7KGZ1bmN0aW9uKCl7Zm9yKHZhciBoPWEuY29uY2F0KGQpLGw9W10saT17fSxjPTAscD1oLmxlbmd0aDtjPHA7KytjKXt2YXIgbT1oW2NdLHE9bVszXTtpZihxKWZvcih2YXIgZj1xLmxlbmd0aDstLWY+PTA7KWJbcS5jaGFyQXQoZildPW07bT1tWzFdO3E9XCJcIittO2kuaGFzT3duUHJvcGVydHkocSl8fChsLnB1c2gobSksaVtxXT1yKX1sLnB1c2goL1tcXFNcXHNdLyk7ZT1qKGwpfSkoKTt2YXIgaT1kLmxlbmd0aDtyZXR1cm4gaH1mdW5jdGlvbiB0KGEpe3ZhciBkPVtdLGg9W107YS50cmlwbGVRdW90ZWRTdHJpbmdzP2QucHVzaChbXCJzdHJcIiwvXig/OicnJyg/OlteJ1xcXFxdfFxcXFxbXFxTXFxzXXwnJz8oPz1bXiddKSkqKD86JycnfCQpfFwiXCJcIig/OlteXCJcXFxcXXxcXFxcW1xcU1xcc118XCJcIj8oPz1bXlwiXSkpKig/OlwiXCJcInwkKXwnKD86W14nXFxcXF18XFxcXFtcXFNcXHNdKSooPzonfCQpfFwiKD86W15cIlxcXFxdfFxcXFxbXFxTXFxzXSkqKD86XCJ8JCkpLyxcbnIsXCInXFxcIlwiXSk6YS5tdWx0aUxpbmVTdHJpbmdzP2QucHVzaChbXCJzdHJcIiwvXig/OicoPzpbXidcXFxcXXxcXFxcW1xcU1xcc10pKig/Oid8JCl8XCIoPzpbXlwiXFxcXF18XFxcXFtcXFNcXHNdKSooPzpcInwkKXxgKD86W15cXFxcYF18XFxcXFtcXFNcXHNdKSooPzpgfCQpKS8scixcIidcXFwiYFwiXSk6ZC5wdXNoKFtcInN0clwiLC9eKD86Jyg/OlteXFxuXFxyJ1xcXFxdfFxcXFwuKSooPzonfCQpfFwiKD86W15cXG5cXHJcIlxcXFxdfFxcXFwuKSooPzpcInwkKSkvLHIsXCJcXFwiJ1wiXSk7YS52ZXJiYXRpbVN0cmluZ3MmJmgucHVzaChbXCJzdHJcIiwvXkBcIig/OlteXCJdfFwiXCIpKig/OlwifCQpLyxyXSk7dmFyIGI9YS5oYXNoQ29tbWVudHM7YiYmKGEuY1N0eWxlQ29tbWVudHM/KGI+MT9kLnB1c2goW1wiY29tXCIsL14jKD86IyMoPzpbXiNdfCMoPyEjIykpKig/OiMjI3wkKXwuKikvLHIsXCIjXCJdKTpkLnB1c2goW1wiY29tXCIsL14jKD86KD86ZGVmaW5lfGUoPzpsfG5kKWlmfGVsc2V8ZXJyb3J8aWZuP2RlZnxpbmNsdWRlfGxpbmV8cHJhZ21hfHVuZGVmfHdhcm5pbmcpXFxifFteXFxuXFxyXSopLyxcbnIsXCIjXCJdKSxoLnB1c2goW1wic3RyXCIsL148KD86KD86KD86XFwuXFwuXFwvKSp8XFwvPykoPzpbXFx3LV0rKD86XFwvW1xcdy1dKykrKT9bXFx3LV0rXFwuaCg/Omh8cHB8XFwrXFwrKT98W2Etel1cXHcqKT4vLHJdKSk6ZC5wdXNoKFtcImNvbVwiLC9eI1teXFxuXFxyXSovLHIsXCIjXCJdKSk7YS5jU3R5bGVDb21tZW50cyYmKGgucHVzaChbXCJjb21cIiwvXlxcL1xcL1teXFxuXFxyXSovLHJdKSxoLnB1c2goW1wiY29tXCIsL15cXC9cXCpbXFxTXFxzXSo/KD86XFwqXFwvfCQpLyxyXSkpO2lmKGI9YS5yZWdleExpdGVyYWxzKXt2YXIgZT0oYj1iPjE/XCJcIjpcIlxcblxcclwiKT9cIi5cIjpcIltcXFxcU1xcXFxzXVwiO2gucHVzaChbXCJsYW5nLXJlZ2V4XCIsUmVnRXhwKFwiXig/Ol5eXFxcXC4/fFsrLV18WyE9XT0/PT98XFxcXCN8JT0/fCYmPz0/fFxcXFwofFxcXFwqPT98WytcXFxcLV09fC0+fFxcXFwvPT98Ojo/fDw8Pz0/fD4+Pz4/PT98LHw7fFxcXFw/fEB8XFxcXFt8fnx7fFxcXFxeXFxcXF4/PT98XFxcXHxcXFxcfD89P3xicmVha3xjYXNlfGNvbnRpbnVlfGRlbGV0ZXxkb3xlbHNlfGZpbmFsbHl8aW5zdGFuY2VvZnxyZXR1cm58dGhyb3d8dHJ5fHR5cGVvZilcXFxccyooXCIrXG4oXCIvKD89W14vKlwiK2IrXCJdKSg/OlteL1xcXFx4NUJcXFxceDVDXCIrYitcIl18XFxcXHg1Q1wiK2UrXCJ8XFxcXHg1Qig/OlteXFxcXHg1Q1xcXFx4NURcIitiK1wiXXxcXFxceDVDXCIrZStcIikqKD86XFxcXHg1RHwkKSkrL1wiKStcIilcIildKX0oYj1hLnR5cGVzKSYmaC5wdXNoKFtcInR5cFwiLGJdKTtiPShcIlwiK2Eua2V5d29yZHMpLnJlcGxhY2UoL14gfCAkL2csXCJcIik7Yi5sZW5ndGgmJmgucHVzaChbXCJrd2RcIixSZWdFeHAoXCJeKD86XCIrYi5yZXBsYWNlKC9bXFxzLF0rL2csXCJ8XCIpK1wiKVxcXFxiXCIpLHJdKTtkLnB1c2goW1wicGxuXCIsL15cXHMrLyxyLFwiIFxcclxcblxcdFxcdTAwYTBcIl0pO2I9XCJeLlteXFxcXHNcXFxcdy4kQCdcXFwiYC9cXFxcXFxcXF0qXCI7YS5yZWdleExpdGVyYWxzJiYoYis9XCIoPyFzKi8pXCIpO2gucHVzaChbXCJsaXRcIiwvXkBbJF9hLXpdW1xcdyRAXSovaSxyXSxbXCJ0eXBcIiwvXig/OltAX10/W0EtWl0rW2Etel1bXFx3JEBdKnxcXHcrX3RcXGIpLyxyXSxbXCJwbG5cIiwvXlskX2Etel1bXFx3JEBdKi9pLHJdLFtcImxpdFwiLC9eKD86MHhbXFxkYS1mXSt8KD86XFxkKD86X1xcZCspKlxcZCooPzpcXC5cXGQqKT98XFwuXFxkXFwrKSg/OmVbKy1dP1xcZCspPylbYS16XSovaSxcbnIsXCIwMTIzNDU2Nzg5XCJdLFtcInBsblwiLC9eXFxcXFtcXFNcXHNdPy8scl0sW1wicHVuXCIsUmVnRXhwKGIpLHJdKTtyZXR1cm4gQyhkLGgpfWZ1bmN0aW9uIHooYSxkLGgpe2Z1bmN0aW9uIGIoYSl7dmFyIGM9YS5ub2RlVHlwZTtpZihjPT0xJiYhai50ZXN0KGEuY2xhc3NOYW1lKSlpZihcImJyXCI9PT1hLm5vZGVOYW1lKWUoYSksYS5wYXJlbnROb2RlJiZhLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoYSk7ZWxzZSBmb3IoYT1hLmZpcnN0Q2hpbGQ7YTthPWEubmV4dFNpYmxpbmcpYihhKTtlbHNlIGlmKChjPT0zfHxjPT00KSYmaCl7dmFyIGQ9YS5ub2RlVmFsdWUsaT1kLm1hdGNoKG0pO2lmKGkpYz1kLnN1YnN0cmluZygwLGkuaW5kZXgpLGEubm9kZVZhbHVlPWMsKGQ9ZC5zdWJzdHJpbmcoaS5pbmRleCtpWzBdLmxlbmd0aCkpJiZhLnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKGwuY3JlYXRlVGV4dE5vZGUoZCksYS5uZXh0U2libGluZyksZShhKSxjfHxhLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoYSl9fVxuZnVuY3Rpb24gZShhKXtmdW5jdGlvbiBiKGEsYyl7dmFyIGQ9Yz9hLmNsb25lTm9kZSghMSk6YSxmPWEucGFyZW50Tm9kZTtpZihmKXt2YXIgZj1iKGYsMSksaD1hLm5leHRTaWJsaW5nO2YuYXBwZW5kQ2hpbGQoZCk7Zm9yKHZhciBlPWg7ZTtlPWgpaD1lLm5leHRTaWJsaW5nLGYuYXBwZW5kQ2hpbGQoZSl9cmV0dXJuIGR9Zm9yKDshYS5uZXh0U2libGluZzspaWYoYT1hLnBhcmVudE5vZGUsIWEpcmV0dXJuO2Zvcih2YXIgYT1iKGEubmV4dFNpYmxpbmcsMCksZDsoZD1hLnBhcmVudE5vZGUpJiZkLm5vZGVUeXBlPT09MTspYT1kO2MucHVzaChhKX1mb3IodmFyIGo9Lyg/Ol58XFxzKW5vY29kZSg/Olxcc3wkKS8sbT0vXFxyXFxuP3xcXG4vLGw9YS5vd25lckRvY3VtZW50LGk9bC5jcmVhdGVFbGVtZW50KFwibGlcIik7YS5maXJzdENoaWxkOylpLmFwcGVuZENoaWxkKGEuZmlyc3RDaGlsZCk7Zm9yKHZhciBjPVtpXSxwPTA7cDxjLmxlbmd0aDsrK3ApYihjW3BdKTtkPT09KGR8MCkmJmNbMF0uc2V0QXR0cmlidXRlKFwidmFsdWVcIixcbmQpO3ZhciBuPWwuY3JlYXRlRWxlbWVudChcIm9sXCIpO24uY2xhc3NOYW1lPVwibGluZW51bXNcIjtmb3IodmFyIGQ9TWF0aC5tYXgoMCxkLTF8MCl8fDAscD0wLHE9Yy5sZW5ndGg7cDxxOysrcClpPWNbcF0saS5jbGFzc05hbWU9XCJMXCIrKHArZCklMTAsaS5maXJzdENoaWxkfHxpLmFwcGVuZENoaWxkKGwuY3JlYXRlVGV4dE5vZGUoXCJcXHUwMGEwXCIpKSxuLmFwcGVuZENoaWxkKGkpO2EuYXBwZW5kQ2hpbGQobil9ZnVuY3Rpb24gaShhLGQpe2Zvcih2YXIgaD1kLmxlbmd0aDstLWg+PTA7KXt2YXIgYj1kW2hdO1UuaGFzT3duUHJvcGVydHkoYik/Vi5jb25zb2xlJiZjb25zb2xlLndhcm4oXCJjYW5ub3Qgb3ZlcnJpZGUgbGFuZ3VhZ2UgaGFuZGxlciAlc1wiLGIpOlVbYl09YX19ZnVuY3Rpb24gQShhLGQpe2lmKCFhfHwhVS5oYXNPd25Qcm9wZXJ0eShhKSlhPS9eXFxzKjwvLnRlc3QoZCk/XCJkZWZhdWx0LW1hcmt1cFwiOlwiZGVmYXVsdC1jb2RlXCI7cmV0dXJuIFVbYV19ZnVuY3Rpb24gRChhKXt2YXIgZD1cbmEuaDt0cnl7dmFyIGg9bShhLmMsYS5pKSxiPWguYTthLmE9YjthLmQ9aC5kO2EuZT0wO0EoZCxiKShhKTt2YXIgZT0vXFxiTVNJRVxccyhcXGQrKS8uZXhlYyhuYXZpZ2F0b3IudXNlckFnZW50KSxlPWUmJitlWzFdPD04LGQ9L1xcbi9nLGk9YS5hLGo9aS5sZW5ndGgsaD0wLGw9YS5kLG49bC5sZW5ndGgsYj0wLGM9YS5nLHA9Yy5sZW5ndGgsdD0wO2NbcF09ajt2YXIgcSxmO2ZvcihmPXE9MDtmPHA7KWNbZl0hPT1jW2YrMl0/KGNbcSsrXT1jW2YrK10sY1txKytdPWNbZisrXSk6Zis9MjtwPXE7Zm9yKGY9cT0wO2Y8cDspe2Zvcih2YXIgeD1jW2ZdLHk9Y1tmKzFdLHU9ZisyO3UrMjw9cCYmY1t1KzFdPT09eTspdSs9MjtjW3ErK109eDtjW3ErK109eTtmPXV9Yy5sZW5ndGg9cTt2YXIgZz1hLmMsaztpZihnKWs9Zy5zdHlsZS5kaXNwbGF5LGcuc3R5bGUuZGlzcGxheT1cIm5vbmVcIjt0cnl7Zm9yKDtiPG47KXt2YXIgbz1sW2IrMl18fGosSD1jW3QrMl18fGosdT1NYXRoLm1pbihvLEgpLEU9bFtiK1xuMV0sVztpZihFLm5vZGVUeXBlIT09MSYmKFc9aS5zdWJzdHJpbmcoaCx1KSkpe2UmJihXPVcucmVwbGFjZShkLFwiXFxyXCIpKTtFLm5vZGVWYWx1ZT1XO3ZhciBaPUUub3duZXJEb2N1bWVudCxzPVouY3JlYXRlRWxlbWVudChcInNwYW5cIik7cy5jbGFzc05hbWU9Y1t0KzFdO3ZhciB6PUUucGFyZW50Tm9kZTt6LnJlcGxhY2VDaGlsZChzLEUpO3MuYXBwZW5kQ2hpbGQoRSk7aDxvJiYobFtiKzFdPUU9Wi5jcmVhdGVUZXh0Tm9kZShpLnN1YnN0cmluZyh1LG8pKSx6Lmluc2VydEJlZm9yZShFLHMubmV4dFNpYmxpbmcpKX1oPXU7aD49byYmKGIrPTIpO2g+PUgmJih0Kz0yKX19ZmluYWxseXtpZihnKWcuc3R5bGUuZGlzcGxheT1rfX1jYXRjaCh2KXtWLmNvbnNvbGUmJmNvbnNvbGUubG9nKHYmJnYuc3RhY2t8fHYpfX12YXIgVj13aW5kb3csRz1bXCJicmVhayxjb250aW51ZSxkbyxlbHNlLGZvcixpZixyZXR1cm4sd2hpbGVcIl0sTz1bW0csXCJhdXRvLGNhc2UsY2hhcixjb25zdCxkZWZhdWx0LGRvdWJsZSxlbnVtLGV4dGVybixmbG9hdCxnb3RvLGlubGluZSxpbnQsbG9uZyxyZWdpc3RlcixzaG9ydCxzaWduZWQsc2l6ZW9mLHN0YXRpYyxzdHJ1Y3Qsc3dpdGNoLHR5cGVkZWYsdW5pb24sdW5zaWduZWQsdm9pZCx2b2xhdGlsZVwiXSxcblwiY2F0Y2gsY2xhc3MsZGVsZXRlLGZhbHNlLGltcG9ydCxuZXcsb3BlcmF0b3IscHJpdmF0ZSxwcm90ZWN0ZWQscHVibGljLHRoaXMsdGhyb3csdHJ1ZSx0cnksdHlwZW9mXCJdLEo9W08sXCJhbGlnbm9mLGFsaWduX3VuaW9uLGFzbSxheGlvbSxib29sLGNvbmNlcHQsY29uY2VwdF9tYXAsY29uc3RfY2FzdCxjb25zdGV4cHIsZGVjbHR5cGUsZGVsZWdhdGUsZHluYW1pY19jYXN0LGV4cGxpY2l0LGV4cG9ydCxmcmllbmQsZ2VuZXJpYyxsYXRlX2NoZWNrLG11dGFibGUsbmFtZXNwYWNlLG51bGxwdHIscHJvcGVydHkscmVpbnRlcnByZXRfY2FzdCxzdGF0aWNfYXNzZXJ0LHN0YXRpY19jYXN0LHRlbXBsYXRlLHR5cGVpZCx0eXBlbmFtZSx1c2luZyx2aXJ0dWFsLHdoZXJlXCJdLEs9W08sXCJhYnN0cmFjdCxhc3NlcnQsYm9vbGVhbixieXRlLGV4dGVuZHMsZmluYWwsZmluYWxseSxpbXBsZW1lbnRzLGltcG9ydCxpbnN0YW5jZW9mLGludGVyZmFjZSxudWxsLG5hdGl2ZSxwYWNrYWdlLHN0cmljdGZwLHN1cGVyLHN5bmNocm9uaXplZCx0aHJvd3MsdHJhbnNpZW50XCJdLFxuTD1bSyxcImFzLGJhc2UsYnksY2hlY2tlZCxkZWNpbWFsLGRlbGVnYXRlLGRlc2NlbmRpbmcsZHluYW1pYyxldmVudCxmaXhlZCxmb3JlYWNoLGZyb20sZ3JvdXAsaW1wbGljaXQsaW4saW50ZXJuYWwsaW50byxpcyxsZXQsbG9jayxvYmplY3Qsb3V0LG92ZXJyaWRlLG9yZGVyYnkscGFyYW1zLHBhcnRpYWwscmVhZG9ubHkscmVmLHNieXRlLHNlYWxlZCxzdGFja2FsbG9jLHN0cmluZyxzZWxlY3QsdWludCx1bG9uZyx1bmNoZWNrZWQsdW5zYWZlLHVzaG9ydCx2YXIsdmlydHVhbCx3aGVyZVwiXSxPPVtPLFwiZGVidWdnZXIsZXZhbCxleHBvcnQsZnVuY3Rpb24sZ2V0LG51bGwsc2V0LHVuZGVmaW5lZCx2YXIsd2l0aCxJbmZpbml0eSxOYU5cIl0sTT1bRyxcImFuZCxhcyxhc3NlcnQsY2xhc3MsZGVmLGRlbCxlbGlmLGV4Y2VwdCxleGVjLGZpbmFsbHksZnJvbSxnbG9iYWwsaW1wb3J0LGluLGlzLGxhbWJkYSxub25sb2NhbCxub3Qsb3IscGFzcyxwcmludCxyYWlzZSx0cnksd2l0aCx5aWVsZCxGYWxzZSxUcnVlLE5vbmVcIl0sXG5OPVtHLFwiYWxpYXMsYW5kLGJlZ2luLGNhc2UsY2xhc3MsZGVmLGRlZmluZWQsZWxzaWYsZW5kLGVuc3VyZSxmYWxzZSxpbixtb2R1bGUsbmV4dCxuaWwsbm90LG9yLHJlZG8scmVzY3VlLHJldHJ5LHNlbGYsc3VwZXIsdGhlbix0cnVlLHVuZGVmLHVubGVzcyx1bnRpbCx3aGVuLHlpZWxkLEJFR0lOLEVORFwiXSxSPVtHLFwiYXMsYXNzZXJ0LGNvbnN0LGNvcHksZHJvcCxlbnVtLGV4dGVybixmYWlsLGZhbHNlLGZuLGltcGwsbGV0LGxvZyxsb29wLG1hdGNoLG1vZCxtb3ZlLG11dCxwcml2LHB1YixwdXJlLHJlZixzZWxmLHN0YXRpYyxzdHJ1Y3QsdHJ1ZSx0cmFpdCx0eXBlLHVuc2FmZSx1c2VcIl0sRz1bRyxcImNhc2UsZG9uZSxlbGlmLGVzYWMsZXZhbCxmaSxmdW5jdGlvbixpbixsb2NhbCxzZXQsdGhlbix1bnRpbFwiXSxRPS9eKERJUnxGSUxFfHZlY3RvcnwoZGV8cHJpb3JpdHlfKT9xdWV1ZXxsaXN0fHN0YWNrfChjb25zdF8pP2l0ZXJhdG9yfChtdWx0aSk/KHNldHxtYXApfGJpdHNldHx1PyhpbnR8ZmxvYXQpXFxkKilcXGIvLFxuUz0vXFxTLyxUPXQoe2tleXdvcmRzOltKLEwsTyxcImNhbGxlcixkZWxldGUsZGllLGRvLGR1bXAsZWxzaWYsZXZhbCxleGl0LGZvcmVhY2gsZm9yLGdvdG8saWYsaW1wb3J0LGxhc3QsbG9jYWwsbXksbmV4dCxubyxvdXIscHJpbnQscGFja2FnZSxyZWRvLHJlcXVpcmUsc3ViLHVuZGVmLHVubGVzcyx1bnRpbCx1c2Usd2FudGFycmF5LHdoaWxlLEJFR0lOLEVORFwiLE0sTixHXSxoYXNoQ29tbWVudHM6ITAsY1N0eWxlQ29tbWVudHM6ITAsbXVsdGlMaW5lU3RyaW5nczohMCxyZWdleExpdGVyYWxzOiEwfSksVT17fTtpKFQsW1wiZGVmYXVsdC1jb2RlXCJdKTtpKEMoW10sW1tcInBsblwiLC9eW148P10rL10sW1wiZGVjXCIsL148IVxcd1tePl0qKD86PnwkKS9dLFtcImNvbVwiLC9ePFxcIS0tW1xcU1xcc10qPyg/Oi0tXFw+fCQpL10sW1wibGFuZy1cIiwvXjxcXD8oW1xcU1xcc10rPykoPzpcXD8+fCQpL10sW1wibGFuZy1cIiwvXjwlKFtcXFNcXHNdKz8pKD86JT58JCkvXSxbXCJwdW5cIiwvXig/OjxbJT9dfFslP10+KS9dLFtcImxhbmctXCIsXG4vXjx4bXBcXGJbXj5dKj4oW1xcU1xcc10rPyk8XFwveG1wXFxiW14+XSo+L2ldLFtcImxhbmctanNcIiwvXjxzY3JpcHRcXGJbXj5dKj4oW1xcU1xcc10qPykoPFxcL3NjcmlwdFxcYltePl0qPikvaV0sW1wibGFuZy1jc3NcIiwvXjxzdHlsZVxcYltePl0qPihbXFxTXFxzXSo/KSg8XFwvc3R5bGVcXGJbXj5dKj4pL2ldLFtcImxhbmctaW4udGFnXCIsL14oPFxcLz9bYS16XVtePD5dKj4pL2ldXSksW1wiZGVmYXVsdC1tYXJrdXBcIixcImh0bVwiLFwiaHRtbFwiLFwibXhtbFwiLFwieGh0bWxcIixcInhtbFwiLFwieHNsXCJdKTtpKEMoW1tcInBsblwiLC9eXFxzKy8scixcIiBcXHRcXHJcXG5cIl0sW1wiYXR2XCIsL14oPzpcIlteXCJdKlwiP3wnW14nXSonPykvLHIsXCJcXFwiJ1wiXV0sW1tcInRhZ1wiLC9eXjxcXC8/W2Etel0oPzpbXFx3LS46XSpcXHcpP3xcXC8/PiQvaV0sW1wiYXRuXCIsL14oPyFzdHlsZVtcXHM9XXxvbilbYS16XSg/OltcXHc6LV0qXFx3KT8vaV0sW1wibGFuZy11cS52YWxcIiwvXj1cXHMqKFteXFxzXCInPl0qKD86W15cXHNcIicvPl18XFwvKD89XFxzKSkpL10sW1wicHVuXCIsL15bLzwtPl0rL10sXG5bXCJsYW5nLWpzXCIsL15vblxcdytcXHMqPVxccypcIihbXlwiXSspXCIvaV0sW1wibGFuZy1qc1wiLC9eb25cXHcrXFxzKj1cXHMqJyhbXiddKyknL2ldLFtcImxhbmctanNcIiwvXm9uXFx3K1xccyo9XFxzKihbXlxcc1wiJz5dKykvaV0sW1wibGFuZy1jc3NcIiwvXnN0eWxlXFxzKj1cXHMqXCIoW15cIl0rKVwiL2ldLFtcImxhbmctY3NzXCIsL15zdHlsZVxccyo9XFxzKicoW14nXSspJy9pXSxbXCJsYW5nLWNzc1wiLC9ec3R5bGVcXHMqPVxccyooW15cXHNcIic+XSspL2ldXSksW1wiaW4udGFnXCJdKTtpKEMoW10sW1tcImF0dlwiLC9eW1xcU1xcc10rL11dKSxbXCJ1cS52YWxcIl0pO2kodCh7a2V5d29yZHM6SixoYXNoQ29tbWVudHM6ITAsY1N0eWxlQ29tbWVudHM6ITAsdHlwZXM6UX0pLFtcImNcIixcImNjXCIsXCJjcHBcIixcImN4eFwiLFwiY3ljXCIsXCJtXCJdKTtpKHQoe2tleXdvcmRzOlwibnVsbCx0cnVlLGZhbHNlXCJ9KSxbXCJqc29uXCJdKTtpKHQoe2tleXdvcmRzOkwsaGFzaENvbW1lbnRzOiEwLGNTdHlsZUNvbW1lbnRzOiEwLHZlcmJhdGltU3RyaW5nczohMCx0eXBlczpRfSksXG5bXCJjc1wiXSk7aSh0KHtrZXl3b3JkczpLLGNTdHlsZUNvbW1lbnRzOiEwfSksW1wiamF2YVwiXSk7aSh0KHtrZXl3b3JkczpHLGhhc2hDb21tZW50czohMCxtdWx0aUxpbmVTdHJpbmdzOiEwfSksW1wiYmFzaFwiLFwiYnNoXCIsXCJjc2hcIixcInNoXCJdKTtpKHQoe2tleXdvcmRzOk0saGFzaENvbW1lbnRzOiEwLG11bHRpTGluZVN0cmluZ3M6ITAsdHJpcGxlUXVvdGVkU3RyaW5nczohMH0pLFtcImN2XCIsXCJweVwiLFwicHl0aG9uXCJdKTtpKHQoe2tleXdvcmRzOlwiY2FsbGVyLGRlbGV0ZSxkaWUsZG8sZHVtcCxlbHNpZixldmFsLGV4aXQsZm9yZWFjaCxmb3IsZ290byxpZixpbXBvcnQsbGFzdCxsb2NhbCxteSxuZXh0LG5vLG91cixwcmludCxwYWNrYWdlLHJlZG8scmVxdWlyZSxzdWIsdW5kZWYsdW5sZXNzLHVudGlsLHVzZSx3YW50YXJyYXksd2hpbGUsQkVHSU4sRU5EXCIsaGFzaENvbW1lbnRzOiEwLG11bHRpTGluZVN0cmluZ3M6ITAscmVnZXhMaXRlcmFsczoyfSksW1wicGVybFwiLFwicGxcIixcInBtXCJdKTtpKHQoe2tleXdvcmRzOk4sXG5oYXNoQ29tbWVudHM6ITAsbXVsdGlMaW5lU3RyaW5nczohMCxyZWdleExpdGVyYWxzOiEwfSksW1wicmJcIixcInJ1YnlcIl0pO2kodCh7a2V5d29yZHM6TyxjU3R5bGVDb21tZW50czohMCxyZWdleExpdGVyYWxzOiEwfSksW1wiamF2YXNjcmlwdFwiLFwianNcIl0pO2kodCh7a2V5d29yZHM6XCJhbGwsYW5kLGJ5LGNhdGNoLGNsYXNzLGVsc2UsZXh0ZW5kcyxmYWxzZSxmaW5hbGx5LGZvcixpZixpbixpcyxpc250LGxvb3AsbmV3LG5vLG5vdCxudWxsLG9mLG9mZixvbixvcixyZXR1cm4sc3VwZXIsdGhlbix0aHJvdyx0cnVlLHRyeSx1bmxlc3MsdW50aWwsd2hlbix3aGlsZSx5ZXNcIixoYXNoQ29tbWVudHM6MyxjU3R5bGVDb21tZW50czohMCxtdWx0aWxpbmVTdHJpbmdzOiEwLHRyaXBsZVF1b3RlZFN0cmluZ3M6ITAscmVnZXhMaXRlcmFsczohMH0pLFtcImNvZmZlZVwiXSk7aSh0KHtrZXl3b3JkczpSLGNTdHlsZUNvbW1lbnRzOiEwLG11bHRpbGluZVN0cmluZ3M6ITB9KSxbXCJyY1wiLFwicnNcIixcInJ1c3RcIl0pO1xuaShDKFtdLFtbXCJzdHJcIiwvXltcXFNcXHNdKy9dXSksW1wicmVnZXhcIl0pO3ZhciBYPVYuUFI9e2NyZWF0ZVNpbXBsZUxleGVyOkMscmVnaXN0ZXJMYW5nSGFuZGxlcjppLHNvdXJjZURlY29yYXRvcjp0LFBSX0FUVFJJQl9OQU1FOlwiYXRuXCIsUFJfQVRUUklCX1ZBTFVFOlwiYXR2XCIsUFJfQ09NTUVOVDpcImNvbVwiLFBSX0RFQ0xBUkFUSU9OOlwiZGVjXCIsUFJfS0VZV09SRDpcImt3ZFwiLFBSX0xJVEVSQUw6XCJsaXRcIixQUl9OT0NPREU6XCJub2NvZGVcIixQUl9QTEFJTjpcInBsblwiLFBSX1BVTkNUVUFUSU9OOlwicHVuXCIsUFJfU09VUkNFOlwic3JjXCIsUFJfU1RSSU5HOlwic3RyXCIsUFJfVEFHOlwidGFnXCIsUFJfVFlQRTpcInR5cFwiLHByZXR0eVByaW50T25lOmZ1bmN0aW9uKGEsZCxlKXt2YXIgYj1kb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO2IuaW5uZXJIVE1MPVwiPHByZT5cIithK1wiPC9wcmU+XCI7Yj1iLmZpcnN0Q2hpbGQ7ZSYmeihiLGUsITApO0Qoe2g6ZCxqOmUsYzpiLGk6MX0pO3JldHVybiBiLmlubmVySFRNTH0sXG5wcmV0dHlQcmludDplPWU9ZnVuY3Rpb24oYSxkKXtmdW5jdGlvbiBlKCl7Zm9yKHZhciBiPVYuUFJfU0hPVUxEX1VTRV9DT05USU5VQVRJT04/Yy5ub3coKSsyNTA6SW5maW5pdHk7cDxqLmxlbmd0aCYmYy5ub3coKTxiO3ArKyl7Zm9yKHZhciBkPWpbcF0sbT1rLGw9ZDtsPWwucHJldmlvdXNTaWJsaW5nOyl7dmFyIG49bC5ub2RlVHlwZSxzPShuPT09N3x8bj09PTgpJiZsLm5vZGVWYWx1ZTtpZihzPyEvXlxcPz9wcmV0dGlmeVxcYi8udGVzdChzKTpuIT09M3x8L1xcUy8udGVzdChsLm5vZGVWYWx1ZSkpYnJlYWs7aWYocyl7bT17fTtzLnJlcGxhY2UoL1xcYihcXHcrKT0oW1xcdyUrXFwtLjpdKykvZyxmdW5jdGlvbihhLGIsYyl7bVtiXT1jfSk7YnJlYWt9fWw9ZC5jbGFzc05hbWU7aWYoKG0hPT1rfHxmLnRlc3QobCkpJiYhdy50ZXN0KGwpKXtuPSExO2ZvcihzPWQucGFyZW50Tm9kZTtzO3M9cy5wYXJlbnROb2RlKWlmKGcudGVzdChzLnRhZ05hbWUpJiZzLmNsYXNzTmFtZSYmZi50ZXN0KHMuY2xhc3NOYW1lKSl7bj1cbiEwO2JyZWFrfWlmKCFuKXtkLmNsYXNzTmFtZSs9XCIgcHJldHR5cHJpbnRlZFwiO249bS5sYW5nO2lmKCFuKXt2YXIgbj1sLm1hdGNoKHEpLEE7aWYoIW4mJihBPXgoZCkpJiZ1LnRlc3QoQS50YWdOYW1lKSluPUEuY2xhc3NOYW1lLm1hdGNoKHEpO24mJihuPW5bMV0pfWlmKHkudGVzdChkLnRhZ05hbWUpKXM9MTtlbHNlIHZhciBzPWQuY3VycmVudFN0eWxlLHY9aS5kZWZhdWx0VmlldyxzPShzPXM/cy53aGl0ZVNwYWNlOnYmJnYuZ2V0Q29tcHV0ZWRTdHlsZT92LmdldENvbXB1dGVkU3R5bGUoZCxyKS5nZXRQcm9wZXJ0eVZhbHVlKFwid2hpdGUtc3BhY2VcIik6MCkmJlwicHJlXCI9PT1zLnN1YnN0cmluZygwLDMpO3Y9bS5saW5lbnVtcztpZighKHY9dj09PVwidHJ1ZVwifHwrdikpdj0odj1sLm1hdGNoKC9cXGJsaW5lbnVtc1xcYig/OjooXFxkKykpPy8pKT92WzFdJiZ2WzFdLmxlbmd0aD8rdlsxXTohMDohMTt2JiZ6KGQsdixzKTt0PXtoOm4sYzpkLGo6dixpOnN9O0QodCl9fX1wPGoubGVuZ3RoP1xuUChlLDI1MCk6XCJmdW5jdGlvblwiPT09dHlwZW9mIGEmJmEoKX1mb3IodmFyIGI9ZHx8ZG9jdW1lbnQuYm9keSxpPWIub3duZXJEb2N1bWVudHx8ZG9jdW1lbnQsYj1bYi5nZXRFbGVtZW50c0J5VGFnTmFtZShcInByZVwiKSxiLmdldEVsZW1lbnRzQnlUYWdOYW1lKFwiY29kZVwiKSxiLmdldEVsZW1lbnRzQnlUYWdOYW1lKFwieG1wXCIpXSxqPVtdLG09MDttPGIubGVuZ3RoOysrbSlmb3IodmFyIGw9MCxuPWJbbV0ubGVuZ3RoO2w8bjsrK2wpai5wdXNoKGJbbV1bbF0pO3ZhciBiPXIsYz1EYXRlO2Mubm93fHwoYz17bm93OmZ1bmN0aW9uKCl7cmV0dXJuK25ldyBEYXRlfX0pO3ZhciBwPTAsdCxxPS9cXGJsYW5nKD86dWFnZSk/LShbXFx3Ll0rKSg/IVxcUykvLGY9L1xcYnByZXR0eXByaW50XFxiLyx3PS9cXGJwcmV0dHlwcmludGVkXFxiLyx5PS9wcmV8eG1wL2ksdT0vXmNvZGUkL2ksZz0vXig/OnByZXxjb2RlfHhtcCkkL2ksaz17fTtlKCl9fTt0eXBlb2YgZGVmaW5lPT09XCJmdW5jdGlvblwiJiZkZWZpbmUuYW1kJiZcbmRlZmluZShcImdvb2dsZS1jb2RlLXByZXR0aWZ5XCIsW10sZnVuY3Rpb24oKXtyZXR1cm4gWH0pfSkoKTtyZXR1cm4gZX0oKTtSfHxQKFEsMCl9KSgpO30oKVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///538\n')},942:(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{"use strict";eval('// ESM COMPAT FLAG\n__webpack_require__.r(__webpack_exports__);\n\n// EXTERNAL MODULE: ./node_modules/google-code-prettify/bin/run_prettify.min.js\nvar run_prettify_min = __webpack_require__(538);\n;// CONCATENATED MODULE: ./node_modules/whatwg-fetch/fetch.js\nvar global =\n  (typeof globalThis !== \'undefined\' && globalThis) ||\n  (typeof self !== \'undefined\' && self) ||\n  (typeof global !== \'undefined\' && global)\n\nvar support = {\n  searchParams: \'URLSearchParams\' in global,\n  iterable: \'Symbol\' in global && \'iterator\' in Symbol,\n  blob:\n    \'FileReader\' in global &&\n    \'Blob\' in global &&\n    (function() {\n      try {\n        new Blob()\n        return true\n      } catch (e) {\n        return false\n      }\n    })(),\n  formData: \'FormData\' in global,\n  arrayBuffer: \'ArrayBuffer\' in global\n}\n\nfunction isDataView(obj) {\n  return obj && DataView.prototype.isPrototypeOf(obj)\n}\n\nif (support.arrayBuffer) {\n  var viewClasses = [\n    \'[object Int8Array]\',\n    \'[object Uint8Array]\',\n    \'[object Uint8ClampedArray]\',\n    \'[object Int16Array]\',\n    \'[object Uint16Array]\',\n    \'[object Int32Array]\',\n    \'[object Uint32Array]\',\n    \'[object Float32Array]\',\n    \'[object Float64Array]\'\n  ]\n\n  var isArrayBufferView =\n    ArrayBuffer.isView ||\n    function(obj) {\n      return obj && viewClasses.indexOf(Object.prototype.toString.call(obj)) > -1\n    }\n}\n\nfunction normalizeName(name) {\n  if (typeof name !== \'string\') {\n    name = String(name)\n  }\n  if (/[^a-z0-9\\-#$%&\'*+.^_`|~!]/i.test(name) || name === \'\') {\n    throw new TypeError(\'Invalid character in header field name: "\' + name + \'"\')\n  }\n  return name.toLowerCase()\n}\n\nfunction normalizeValue(value) {\n  if (typeof value !== \'string\') {\n    value = String(value)\n  }\n  return value\n}\n\n// Build a destructive iterator for the value list\nfunction iteratorFor(items) {\n  var iterator = {\n    next: function() {\n      var value = items.shift()\n      return {done: value === undefined, value: value}\n    }\n  }\n\n  if (support.iterable) {\n    iterator[Symbol.iterator] = function() {\n      return iterator\n    }\n  }\n\n  return iterator\n}\n\nfunction Headers(headers) {\n  this.map = {}\n\n  if (headers instanceof Headers) {\n    headers.forEach(function(value, name) {\n      this.append(name, value)\n    }, this)\n  } else if (Array.isArray(headers)) {\n    headers.forEach(function(header) {\n      this.append(header[0], header[1])\n    }, this)\n  } else if (headers) {\n    Object.getOwnPropertyNames(headers).forEach(function(name) {\n      this.append(name, headers[name])\n    }, this)\n  }\n}\n\nHeaders.prototype.append = function(name, value) {\n  name = normalizeName(name)\n  value = normalizeValue(value)\n  var oldValue = this.map[name]\n  this.map[name] = oldValue ? oldValue + \', \' + value : value\n}\n\nHeaders.prototype[\'delete\'] = function(name) {\n  delete this.map[normalizeName(name)]\n}\n\nHeaders.prototype.get = function(name) {\n  name = normalizeName(name)\n  return this.has(name) ? this.map[name] : null\n}\n\nHeaders.prototype.has = function(name) {\n  return this.map.hasOwnProperty(normalizeName(name))\n}\n\nHeaders.prototype.set = function(name, value) {\n  this.map[normalizeName(name)] = normalizeValue(value)\n}\n\nHeaders.prototype.forEach = function(callback, thisArg) {\n  for (var name in this.map) {\n    if (this.map.hasOwnProperty(name)) {\n      callback.call(thisArg, this.map[name], name, this)\n    }\n  }\n}\n\nHeaders.prototype.keys = function() {\n  var items = []\n  this.forEach(function(value, name) {\n    items.push(name)\n  })\n  return iteratorFor(items)\n}\n\nHeaders.prototype.values = function() {\n  var items = []\n  this.forEach(function(value) {\n    items.push(value)\n  })\n  return iteratorFor(items)\n}\n\nHeaders.prototype.entries = function() {\n  var items = []\n  this.forEach(function(value, name) {\n    items.push([name, value])\n  })\n  return iteratorFor(items)\n}\n\nif (support.iterable) {\n  Headers.prototype[Symbol.iterator] = Headers.prototype.entries\n}\n\nfunction consumed(body) {\n  if (body.bodyUsed) {\n    return Promise.reject(new TypeError(\'Already read\'))\n  }\n  body.bodyUsed = true\n}\n\nfunction fileReaderReady(reader) {\n  return new Promise(function(resolve, reject) {\n    reader.onload = function() {\n      resolve(reader.result)\n    }\n    reader.onerror = function() {\n      reject(reader.error)\n    }\n  })\n}\n\nfunction readBlobAsArrayBuffer(blob) {\n  var reader = new FileReader()\n  var promise = fileReaderReady(reader)\n  reader.readAsArrayBuffer(blob)\n  return promise\n}\n\nfunction readBlobAsText(blob) {\n  var reader = new FileReader()\n  var promise = fileReaderReady(reader)\n  reader.readAsText(blob)\n  return promise\n}\n\nfunction readArrayBufferAsText(buf) {\n  var view = new Uint8Array(buf)\n  var chars = new Array(view.length)\n\n  for (var i = 0; i < view.length; i++) {\n    chars[i] = String.fromCharCode(view[i])\n  }\n  return chars.join(\'\')\n}\n\nfunction bufferClone(buf) {\n  if (buf.slice) {\n    return buf.slice(0)\n  } else {\n    var view = new Uint8Array(buf.byteLength)\n    view.set(new Uint8Array(buf))\n    return view.buffer\n  }\n}\n\nfunction Body() {\n  this.bodyUsed = false\n\n  this._initBody = function(body) {\n    /*\n      fetch-mock wraps the Response object in an ES6 Proxy to\n      provide useful test harness features such as flush. However, on\n      ES5 browsers without fetch or Proxy support pollyfills must be used;\n      the proxy-pollyfill is unable to proxy an attribute unless it exists\n      on the object before the Proxy is created. This change ensures\n      Response.bodyUsed exists on the instance, while maintaining the\n      semantic of setting Request.bodyUsed in the constructor before\n      _initBody is called.\n    */\n    this.bodyUsed = this.bodyUsed\n    this._bodyInit = body\n    if (!body) {\n      this._bodyText = \'\'\n    } else if (typeof body === \'string\') {\n      this._bodyText = body\n    } else if (support.blob && Blob.prototype.isPrototypeOf(body)) {\n      this._bodyBlob = body\n    } else if (support.formData && FormData.prototype.isPrototypeOf(body)) {\n      this._bodyFormData = body\n    } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {\n      this._bodyText = body.toString()\n    } else if (support.arrayBuffer && support.blob && isDataView(body)) {\n      this._bodyArrayBuffer = bufferClone(body.buffer)\n      // IE 10-11 can\'t handle a DataView body.\n      this._bodyInit = new Blob([this._bodyArrayBuffer])\n    } else if (support.arrayBuffer && (ArrayBuffer.prototype.isPrototypeOf(body) || isArrayBufferView(body))) {\n      this._bodyArrayBuffer = bufferClone(body)\n    } else {\n      this._bodyText = body = Object.prototype.toString.call(body)\n    }\n\n    if (!this.headers.get(\'content-type\')) {\n      if (typeof body === \'string\') {\n        this.headers.set(\'content-type\', \'text/plain;charset=UTF-8\')\n      } else if (this._bodyBlob && this._bodyBlob.type) {\n        this.headers.set(\'content-type\', this._bodyBlob.type)\n      } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {\n        this.headers.set(\'content-type\', \'application/x-www-form-urlencoded;charset=UTF-8\')\n      }\n    }\n  }\n\n  if (support.blob) {\n    this.blob = function() {\n      var rejected = consumed(this)\n      if (rejected) {\n        return rejected\n      }\n\n      if (this._bodyBlob) {\n        return Promise.resolve(this._bodyBlob)\n      } else if (this._bodyArrayBuffer) {\n        return Promise.resolve(new Blob([this._bodyArrayBuffer]))\n      } else if (this._bodyFormData) {\n        throw new Error(\'could not read FormData body as blob\')\n      } else {\n        return Promise.resolve(new Blob([this._bodyText]))\n      }\n    }\n\n    this.arrayBuffer = function() {\n      if (this._bodyArrayBuffer) {\n        var isConsumed = consumed(this)\n        if (isConsumed) {\n          return isConsumed\n        }\n        if (ArrayBuffer.isView(this._bodyArrayBuffer)) {\n          return Promise.resolve(\n            this._bodyArrayBuffer.buffer.slice(\n              this._bodyArrayBuffer.byteOffset,\n              this._bodyArrayBuffer.byteOffset + this._bodyArrayBuffer.byteLength\n            )\n          )\n        } else {\n          return Promise.resolve(this._bodyArrayBuffer)\n        }\n      } else {\n        return this.blob().then(readBlobAsArrayBuffer)\n      }\n    }\n  }\n\n  this.text = function() {\n    var rejected = consumed(this)\n    if (rejected) {\n      return rejected\n    }\n\n    if (this._bodyBlob) {\n      return readBlobAsText(this._bodyBlob)\n    } else if (this._bodyArrayBuffer) {\n      return Promise.resolve(readArrayBufferAsText(this._bodyArrayBuffer))\n    } else if (this._bodyFormData) {\n      throw new Error(\'could not read FormData body as text\')\n    } else {\n      return Promise.resolve(this._bodyText)\n    }\n  }\n\n  if (support.formData) {\n    this.formData = function() {\n      return this.text().then(decode)\n    }\n  }\n\n  this.json = function() {\n    return this.text().then(JSON.parse)\n  }\n\n  return this\n}\n\n// HTTP methods whose capitalization should be normalized\nvar methods = [\'DELETE\', \'GET\', \'HEAD\', \'OPTIONS\', \'POST\', \'PUT\']\n\nfunction normalizeMethod(method) {\n  var upcased = method.toUpperCase()\n  return methods.indexOf(upcased) > -1 ? upcased : method\n}\n\nfunction Request(input, options) {\n  if (!(this instanceof Request)) {\n    throw new TypeError(\'Please use the "new" operator, this DOM object constructor cannot be called as a function.\')\n  }\n\n  options = options || {}\n  var body = options.body\n\n  if (input instanceof Request) {\n    if (input.bodyUsed) {\n      throw new TypeError(\'Already read\')\n    }\n    this.url = input.url\n    this.credentials = input.credentials\n    if (!options.headers) {\n      this.headers = new Headers(input.headers)\n    }\n    this.method = input.method\n    this.mode = input.mode\n    this.signal = input.signal\n    if (!body && input._bodyInit != null) {\n      body = input._bodyInit\n      input.bodyUsed = true\n    }\n  } else {\n    this.url = String(input)\n  }\n\n  this.credentials = options.credentials || this.credentials || \'same-origin\'\n  if (options.headers || !this.headers) {\n    this.headers = new Headers(options.headers)\n  }\n  this.method = normalizeMethod(options.method || this.method || \'GET\')\n  this.mode = options.mode || this.mode || null\n  this.signal = options.signal || this.signal\n  this.referrer = null\n\n  if ((this.method === \'GET\' || this.method === \'HEAD\') && body) {\n    throw new TypeError(\'Body not allowed for GET or HEAD requests\')\n  }\n  this._initBody(body)\n\n  if (this.method === \'GET\' || this.method === \'HEAD\') {\n    if (options.cache === \'no-store\' || options.cache === \'no-cache\') {\n      // Search for a \'_\' parameter in the query string\n      var reParamSearch = /([?&])_=[^&]*/\n      if (reParamSearch.test(this.url)) {\n        // If it already exists then set the value with the current time\n        this.url = this.url.replace(reParamSearch, \'$1_=\' + new Date().getTime())\n      } else {\n        // Otherwise add a new \'_\' parameter to the end with the current time\n        var reQueryString = /\\?/\n        this.url += (reQueryString.test(this.url) ? \'&\' : \'?\') + \'_=\' + new Date().getTime()\n      }\n    }\n  }\n}\n\nRequest.prototype.clone = function() {\n  return new Request(this, {body: this._bodyInit})\n}\n\nfunction decode(body) {\n  var form = new FormData()\n  body\n    .trim()\n    .split(\'&\')\n    .forEach(function(bytes) {\n      if (bytes) {\n        var split = bytes.split(\'=\')\n        var name = split.shift().replace(/\\+/g, \' \')\n        var value = split.join(\'=\').replace(/\\+/g, \' \')\n        form.append(decodeURIComponent(name), decodeURIComponent(value))\n      }\n    })\n  return form\n}\n\nfunction parseHeaders(rawHeaders) {\n  var headers = new Headers()\n  // Replace instances of \\r\\n and \\n followed by at least one space or horizontal tab with a space\n  // https://tools.ietf.org/html/rfc7230#section-3.2\n  var preProcessedHeaders = rawHeaders.replace(/\\r?\\n[\\t ]+/g, \' \')\n  // Avoiding split via regex to work around a common IE11 bug with the core-js 3.6.0 regex polyfill\n  // https://github.com/github/fetch/issues/748\n  // https://github.com/zloirock/core-js/issues/751\n  preProcessedHeaders\n    .split(\'\\r\')\n    .map(function(header) {\n      return header.indexOf(\'\\n\') === 0 ? header.substr(1, header.length) : header\n    })\n    .forEach(function(line) {\n      var parts = line.split(\':\')\n      var key = parts.shift().trim()\n      if (key) {\n        var value = parts.join(\':\').trim()\n        headers.append(key, value)\n      }\n    })\n  return headers\n}\n\nBody.call(Request.prototype)\n\nfunction Response(bodyInit, options) {\n  if (!(this instanceof Response)) {\n    throw new TypeError(\'Please use the "new" operator, this DOM object constructor cannot be called as a function.\')\n  }\n  if (!options) {\n    options = {}\n  }\n\n  this.type = \'default\'\n  this.status = options.status === undefined ? 200 : options.status\n  this.ok = this.status >= 200 && this.status < 300\n  this.statusText = options.statusText === undefined ? \'\' : \'\' + options.statusText\n  this.headers = new Headers(options.headers)\n  this.url = options.url || \'\'\n  this._initBody(bodyInit)\n}\n\nBody.call(Response.prototype)\n\nResponse.prototype.clone = function() {\n  return new Response(this._bodyInit, {\n    status: this.status,\n    statusText: this.statusText,\n    headers: new Headers(this.headers),\n    url: this.url\n  })\n}\n\nResponse.error = function() {\n  var response = new Response(null, {status: 0, statusText: \'\'})\n  response.type = \'error\'\n  return response\n}\n\nvar redirectStatuses = [301, 302, 303, 307, 308]\n\nResponse.redirect = function(url, status) {\n  if (redirectStatuses.indexOf(status) === -1) {\n    throw new RangeError(\'Invalid status code\')\n  }\n\n  return new Response(null, {status: status, headers: {location: url}})\n}\n\nvar DOMException = global.DOMException\ntry {\n  new DOMException()\n} catch (err) {\n  DOMException = function(message, name) {\n    this.message = message\n    this.name = name\n    var error = Error(message)\n    this.stack = error.stack\n  }\n  DOMException.prototype = Object.create(Error.prototype)\n  DOMException.prototype.constructor = DOMException\n}\n\nfunction fetch_fetch(input, init) {\n  return new Promise(function(resolve, reject) {\n    var request = new Request(input, init)\n\n    if (request.signal && request.signal.aborted) {\n      return reject(new DOMException(\'Aborted\', \'AbortError\'))\n    }\n\n    var xhr = new XMLHttpRequest()\n\n    function abortXhr() {\n      xhr.abort()\n    }\n\n    xhr.onload = function() {\n      var options = {\n        status: xhr.status,\n        statusText: xhr.statusText,\n        headers: parseHeaders(xhr.getAllResponseHeaders() || \'\')\n      }\n      options.url = \'responseURL\' in xhr ? xhr.responseURL : options.headers.get(\'X-Request-URL\')\n      var body = \'response\' in xhr ? xhr.response : xhr.responseText\n      setTimeout(function() {\n        resolve(new Response(body, options))\n      }, 0)\n    }\n\n    xhr.onerror = function() {\n      setTimeout(function() {\n        reject(new TypeError(\'Network request failed\'))\n      }, 0)\n    }\n\n    xhr.ontimeout = function() {\n      setTimeout(function() {\n        reject(new TypeError(\'Network request failed\'))\n      }, 0)\n    }\n\n    xhr.onabort = function() {\n      setTimeout(function() {\n        reject(new DOMException(\'Aborted\', \'AbortError\'))\n      }, 0)\n    }\n\n    function fixUrl(url) {\n      try {\n        return url === \'\' && global.location.href ? global.location.href : url\n      } catch (e) {\n        return url\n      }\n    }\n\n    xhr.open(request.method, fixUrl(request.url), true)\n\n    if (request.credentials === \'include\') {\n      xhr.withCredentials = true\n    } else if (request.credentials === \'omit\') {\n      xhr.withCredentials = false\n    }\n\n    if (\'responseType\' in xhr) {\n      if (support.blob) {\n        xhr.responseType = \'blob\'\n      } else if (\n        support.arrayBuffer &&\n        request.headers.get(\'Content-Type\') &&\n        request.headers.get(\'Content-Type\').indexOf(\'application/octet-stream\') !== -1\n      ) {\n        xhr.responseType = \'arraybuffer\'\n      }\n    }\n\n    if (init && typeof init.headers === \'object\' && !(init.headers instanceof Headers)) {\n      Object.getOwnPropertyNames(init.headers).forEach(function(name) {\n        xhr.setRequestHeader(name, normalizeValue(init.headers[name]))\n      })\n    } else {\n      request.headers.forEach(function(value, name) {\n        xhr.setRequestHeader(name, value)\n      })\n    }\n\n    if (request.signal) {\n      request.signal.addEventListener(\'abort\', abortXhr)\n\n      xhr.onreadystatechange = function() {\n        // DONE (success or failure)\n        if (xhr.readyState === 4) {\n          request.signal.removeEventListener(\'abort\', abortXhr)\n        }\n      }\n    }\n\n    xhr.send(typeof request._bodyInit === \'undefined\' ? null : request._bodyInit)\n  })\n}\n\nfetch_fetch.polyfill = true\n\nif (!global.fetch) {\n  global.fetch = fetch_fetch\n  global.Headers = Headers\n  global.Request = Request\n  global.Response = Response\n}\n\n;// CONCATENATED MODULE: ./src/constants/numbers.ts\nvar MAX_DECIMALS = 6;\nvar DEFAULT_BLEND_STEPS = 5;\n\n;// CONCATENATED MODULE: ./src/constants/enums.ts\nvar ColorModel;\n(function (ColorModel) {\n    ColorModel["HEX"] = "HEX";\n    ColorModel["RGB"] = "RGB";\n    ColorModel["HSL"] = "HSL";\n    ColorModel["CMYK"] = "CMYK";\n})(ColorModel || (ColorModel = {}));\nvar Harmony;\n(function (Harmony) {\n    Harmony["ANALOGOUS"] = "ANALOGOUS";\n    Harmony["COMPLEMENTARY"] = "COMPLEMENTARY";\n    Harmony["SPLIT_COMPLEMENTARY"] = "SPLIT_COMPLEMENTARY";\n    Harmony["TRIADIC"] = "TRIADIC";\n    Harmony["TETRADIC"] = "TETRADIC";\n    Harmony["SQUARE"] = "SQUARE";\n})(Harmony || (Harmony = {}));\nvar Mix;\n(function (Mix) {\n    Mix["ADDITIVE"] = "ADDITIVE";\n    Mix["SUBTRACTIVE"] = "SUBTRACTIVE";\n})(Mix || (Mix = {}));\nvar ColorKeywords;\n(function (ColorKeywords) {\n    ColorKeywords["black"] = "#000000";\n    ColorKeywords["silver"] = "#C0C0C0";\n    ColorKeywords["gray"] = "#808080";\n    ColorKeywords["white"] = "#FFFFFF";\n    ColorKeywords["maroon"] = "#800000";\n    ColorKeywords["red"] = "#FF0000";\n    ColorKeywords["purple"] = "#800080";\n    ColorKeywords["fuchsia"] = "#FF00FF";\n    ColorKeywords["green"] = "#008000";\n    ColorKeywords["lime"] = "#00FF00";\n    ColorKeywords["olive"] = "#808000";\n    ColorKeywords["yellow"] = "#FFFF00";\n    ColorKeywords["navy"] = "#000080";\n    ColorKeywords["blue"] = "#0000FF";\n    ColorKeywords["teal"] = "#008080";\n    ColorKeywords["aqua"] = "#00FFFF";\n    ColorKeywords["orange"] = "#FFA500";\n    ColorKeywords["aliceblue"] = "#F0F8FF";\n    ColorKeywords["antiquewhite"] = "#FAEBD7";\n    ColorKeywords["aquamarine"] = "#7FFFD4";\n    ColorKeywords["azure"] = "#F0FFFF";\n    ColorKeywords["beige"] = "#F5F5DC";\n    ColorKeywords["bisque"] = "#FFE4C4";\n    ColorKeywords["blanchedalmond"] = "#FFEBCD";\n    ColorKeywords["blueviolet"] = "#8A2BE2";\n    ColorKeywords["brown"] = "#A52A2A";\n    ColorKeywords["burlywood"] = "#DEB887";\n    ColorKeywords["cadetblue"] = "#5F9EA0";\n    ColorKeywords["chartreuse"] = "#7FFF00";\n    ColorKeywords["chocolate"] = "#D2691E";\n    ColorKeywords["coral"] = "#FF7F50";\n    ColorKeywords["cornflowerblue"] = "#6495ED";\n    ColorKeywords["cornsilk"] = "#FFF8DC";\n    ColorKeywords["crimson"] = "#DC143C";\n    ColorKeywords["cyan"] = "#00FFFF";\n    ColorKeywords["darkblue"] = "#00008B";\n    ColorKeywords["darkcyan"] = "#008B8B";\n    ColorKeywords["darkgoldenrod"] = "#B8860B";\n    ColorKeywords["darkgray"] = "#A9A9A9";\n    ColorKeywords["darkgreen"] = "#006400";\n    ColorKeywords["darkgrey"] = "#A9A9A9";\n    ColorKeywords["darkkhaki"] = "#BDB76B";\n    ColorKeywords["darkmagenta"] = "#8B008B";\n    ColorKeywords["darkolivegreen"] = "#556B2F";\n    ColorKeywords["darkorange"] = "#FF8C00";\n    ColorKeywords["darkorchid"] = "#9932CC";\n    ColorKeywords["darkred"] = "#8B0000";\n    ColorKeywords["darksalmon"] = "#E9967A";\n    ColorKeywords["darkseagreen"] = "#8FBC8F";\n    ColorKeywords["darkslateblue"] = "#483D8B";\n    ColorKeywords["darkslategray"] = "#2F4F4F";\n    ColorKeywords["darkslategrey"] = "#2F4F4F";\n    ColorKeywords["darkturquoise"] = "#00CED1";\n    ColorKeywords["darkviolet"] = "#9400D3";\n    ColorKeywords["deeppink"] = "#FF1493";\n    ColorKeywords["deepskyblue"] = "#00BFFF";\n    ColorKeywords["dimgray"] = "#696969";\n    ColorKeywords["dimgrey"] = "#696969";\n    ColorKeywords["dodgerblue"] = "#1E90FF";\n    ColorKeywords["firebrick"] = "#B22222";\n    ColorKeywords["floralwhite"] = "#FFFAF0";\n    ColorKeywords["forestgreen"] = "#228B22";\n    ColorKeywords["gainsboro"] = "#DCDCDC";\n    ColorKeywords["ghostwhite"] = "#F8F8FF";\n    ColorKeywords["gold"] = "#FFD700";\n    ColorKeywords["goldenrod"] = "#DAA520";\n    ColorKeywords["greenyellow"] = "#ADFF2F";\n    ColorKeywords["grey"] = "#808080";\n    ColorKeywords["honeydew"] = "#F0FFF0";\n    ColorKeywords["hotpink"] = "#FF69B4";\n    ColorKeywords["indianred"] = "#CD5C5C";\n    ColorKeywords["indigo"] = "#4B0082";\n    ColorKeywords["ivory"] = "#FFFFF0";\n    ColorKeywords["khaki"] = "#F0E68C";\n    ColorKeywords["lavender"] = "#E6E6FA";\n    ColorKeywords["lavenderblush"] = "#FFF0F5";\n    ColorKeywords["lawngreen"] = "#7CFC00";\n    ColorKeywords["lemonchiffon"] = "#FFFACD";\n    ColorKeywords["lightblue"] = "#ADD8E6";\n    ColorKeywords["lightcoral"] = "#F08080";\n    ColorKeywords["lightcyan"] = "#E0FFFF";\n    ColorKeywords["lightgoldenrodyellow"] = "#FAFAD2";\n    ColorKeywords["lightgray"] = "#D3D3D3";\n    ColorKeywords["lightgreen"] = "#90EE90";\n    ColorKeywords["lightgrey"] = "#D3D3D3";\n    ColorKeywords["lightpink"] = "#FFB6C1";\n    ColorKeywords["lightsalmon"] = "#FFA07A";\n    ColorKeywords["lightseagreen"] = "#20B2AA";\n    ColorKeywords["lightskyblue"] = "#87CEFA";\n    ColorKeywords["lightslategray"] = "#778899";\n    ColorKeywords["lightslategrey"] = "#778899";\n    ColorKeywords["lightsteelblue"] = "#B0C4DE";\n    ColorKeywords["lightyellow"] = "#FFFFE0";\n    ColorKeywords["limegreen"] = "#32CD32";\n    ColorKeywords["linen"] = "#FAF0E6";\n    ColorKeywords["magenta"] = "#FF00FF";\n    ColorKeywords["mediumaquamarine"] = "#66CDAA";\n    ColorKeywords["mediumblue"] = "#0000CD";\n    ColorKeywords["mediumorchid"] = "#BA55D3";\n    ColorKeywords["mediumpurple"] = "#9370DB";\n    ColorKeywords["mediumseagreen"] = "#3CB371";\n    ColorKeywords["mediumslateblue"] = "#7B68EE";\n    ColorKeywords["mediumspringgreen"] = "#00FA9A";\n    ColorKeywords["mediumturquoise"] = "#48D1CC";\n    ColorKeywords["mediumvioletred"] = "#C71585";\n    ColorKeywords["midnightblue"] = "#191970";\n    ColorKeywords["mintcream"] = "#F5FFFA";\n    ColorKeywords["mistyrose"] = "#FFE4E1";\n    ColorKeywords["moccasin"] = "#FFE4B5";\n    ColorKeywords["navajowhite"] = "#FFDEAD";\n    ColorKeywords["oldlace"] = "#FDF5E6";\n    ColorKeywords["olivedrab"] = "#6B8E23";\n    ColorKeywords["orangered"] = "#FF4500";\n    ColorKeywords["orchid"] = "#DA70D6";\n    ColorKeywords["palegoldenrod"] = "#EEE8AA";\n    ColorKeywords["palegreen"] = "#98FB98";\n    ColorKeywords["paleturquoise"] = "#AFEEEE";\n    ColorKeywords["palevioletred"] = "#DB7093";\n    ColorKeywords["papayawhip"] = "#FFEFD5";\n    ColorKeywords["peachpuff"] = "#FFDAB9";\n    ColorKeywords["peru"] = "#CD853F";\n    ColorKeywords["pink"] = "#FFC0CB";\n    ColorKeywords["plum"] = "#DDA0DD";\n    ColorKeywords["powderblue"] = "#B0E0E6";\n    ColorKeywords["rosybrown"] = "#BC8F8F";\n    ColorKeywords["royalblue"] = "#4169E1";\n    ColorKeywords["saddlebrown"] = "#8B4513";\n    ColorKeywords["salmon"] = "#FA8072";\n    ColorKeywords["sandybrown"] = "#F4A460";\n    ColorKeywords["seagreen"] = "#2E8B57";\n    ColorKeywords["seashell"] = "#FFF5EE";\n    ColorKeywords["sienna"] = "#A0522D";\n    ColorKeywords["skyblue"] = "#87CEEB";\n    ColorKeywords["slateblue"] = "#6A5ACD";\n    ColorKeywords["slategray"] = "#708090";\n    ColorKeywords["slategrey"] = "#708090";\n    ColorKeywords["snow"] = "#FFFAFA";\n    ColorKeywords["springgreen"] = "#00FF7F";\n    ColorKeywords["steelblue"] = "#4682B4";\n    ColorKeywords["tan"] = "#D2B48C";\n    ColorKeywords["thistle"] = "#D8BFD8";\n    ColorKeywords["tomato"] = "#FF6347";\n    ColorKeywords["turquoise"] = "#40E0D0";\n    ColorKeywords["violet"] = "#EE82EE";\n    ColorKeywords["wheat"] = "#F5DEB3";\n    ColorKeywords["whitesmoke"] = "#F5F5F5";\n    ColorKeywords["yellowgreen"] = "#9ACD32";\n    ColorKeywords["rebeccapurple"] = "#663399";\n})(ColorKeywords || (ColorKeywords = {}));\nvar COLOR_KEYS = Object.keys(ColorKeywords);\nvar COLOR_PROPS = {\n    HEX: [\'r\', \'g\', \'b\', \'a\'],\n    RGB: [\'r\', \'g\', \'b\', \'a\'],\n    HSL: [\'h\', \'s\', \'l\', \'a\'],\n    CMYK: [\'c\', \'m\', \'y\', \'k\', \'a\']\n};\nvar VALID_COLOR_OBJECTS = {\n    BGR: ColorModel.RGB,\n    ABGR: ColorModel.RGB,\n    HLS: ColorModel.HSL,\n    AHLS: ColorModel.HSL,\n    CKMY: ColorModel.CMYK,\n    ACKMY: ColorModel.CMYK\n};\nvar TypeOf;\n(function (TypeOf) {\n    TypeOf["NUMBER"] = "number";\n    TypeOf["BOOLEAN"] = "boolean";\n})(TypeOf || (TypeOf = {}));\n\n;// CONCATENATED MODULE: ./src/constants/regexps.ts\nvar _a;\n\nvar COLORREGS = (_a = {},\n    _a[ColorModel.HEX] = /^#(?:([a-f\\d])([a-f\\d])([a-f\\d])([a-f\\d])?|([a-f\\d]{2})([a-f\\d]{2})([a-f\\d]{2})([a-f\\d]{2})?)$/i,\n    _a[ColorModel.RGB] = /^rgba?\\s*\\(\\s*(?:((?:\\d*\\.)?\\d+%?)\\s*,\\s*((?:\\d*\\.)?\\d+%?)\\s*,\\s*((?:\\d*\\.)?\\d+%?)(?:\\s*,\\s*((?:\\d*\\.)?\\d+))?|((?:\\d*\\.)?\\d+%?)\\s*((?:\\d*\\.)?\\d+%?)\\s*((?:\\d*\\.)?\\d+%?)(?:\\s*\\/\\s*((?:\\d*\\.)?\\d+%?))?)\\s*\\)$/,\n    _a[ColorModel.HSL] = /^hsla?\\s*\\(\\s*(?:(-?(?:\\d*\\.)?\\d+(?:deg|grad|rad|turn)?)\\s*,\\s*((?:\\d*\\.)?\\d+)%\\s*,\\s*((?:\\d*\\.)?\\d+)%(?:\\s*,\\s*((?:\\d*\\.)?\\d+))?|(-?(?:\\d*\\.)?\\d+(?:deg|grad|rad|turn)?)\\s*((?:\\d*\\.)?\\d+)%\\s*((?:\\d*\\.)?\\d+)%(?:\\s*\\/\\s*((?:\\d*\\.)?\\d+%?))?)\\s*\\)$/,\n    _a[ColorModel.CMYK] = /^(?:device-cmyk|cmyk)\\s*\\(\\s*(?:((?:\\d*\\.)?\\d+%?)\\s*,\\s*((?:\\d*\\.)?\\d+%?)\\s*,\\s*((?:\\d*\\.)?\\d+%?)\\s*,\\s*((?:\\d*\\.)?\\d+%?)(?:\\s*,\\s*((?:\\d*\\.)?\\d+))?|((?:\\d*\\.)?\\d+%?)\\s*((?:\\d*\\.)?\\d+%?)\\s*((?:\\d*\\.)?\\d+%?)\\s*((?:\\d*\\.)?\\d+%?)(?:\\s*\\/\\s*((?:\\d*\\.)?\\d+%?))?)\\s*\\)$/,\n    _a);\nvar HSL_HUE = /^(-?(?:\\d*\\.)?\\d+)((?:deg|grad|rad|turn)?)$/;\nvar PCENT = /^(\\d+(?:\\.\\d+)?|\\.\\d+)%$/;\nvar HEX = /^0x([a-f\\d]{1,2})$/i;\nvar TEMPLATE_VAR = /\\{(\\d+)\\}/g;\n\n;// CONCATENATED MODULE: ./src/constants/errors.ts\nvar ERRORS = {\n    NOT_ACCEPTED_STRING_INPUT: \'The provided string color doesn\\\'t have a correct format\',\n    NOT_ACCEPTED_OBJECT_INPUT: \'The provided color object doesn\\\'t have the proper keys or format\'\n};\n\n;// CONCATENATED MODULE: ./src/@types/index.ts\nvar AnglesUnitEnum;\n(function (AnglesUnitEnum) {\n    AnglesUnitEnum["NONE"] = "none";\n    AnglesUnitEnum["DEGREES"] = "deg";\n    AnglesUnitEnum["GRADIANS"] = "grad";\n    AnglesUnitEnum["RADIANS"] = "rad";\n    AnglesUnitEnum["TURNS"] = "turn";\n})(AnglesUnitEnum || (AnglesUnitEnum = {}));\n\n;// CONCATENATED MODULE: ./src/constants/options.ts\n\n\nvar DEFAULT_OPTIONS = {\n    decimals: MAX_DECIMALS,\n    legacyCSS: false,\n    spacesAfterCommas: false,\n    anglesUnit: AnglesUnitEnum.NONE\n};\n\n;// CONCATENATED MODULE: ./src/constants/index.ts\n\n\n\n\n\n\n;// CONCATENATED MODULE: ./src/helpers/index.ts\nvar __spreadArray = (undefined && undefined.__spreadArray) || function (to, from, pack) {\n    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\n        if (ar || !(i in from)) {\n            if (!ar) ar = Array.prototype.slice.call(from, 0, i);\n            ar[i] = from[i];\n        }\n    }\n    return to.concat(ar || Array.prototype.slice.call(from));\n};\n\n\nvar hasProp = function (obj, prop) { return Object.prototype.hasOwnProperty.call(obj, prop); };\nvar percentNumber = function (percent) {\n    return +"".concat(percent).replace(PCENT, \'$1\');\n};\nvar percent = function (percent) { return PCENT.test("".concat(percent))\n    ? percentNumber(percent)\n    : Math.min(+percent, 100); };\nvar getDEC = function (hex) {\n    if (hex.length === 1) {\n        hex += hex;\n    }\n    return parseInt(hex, 16);\n};\nvar getHEX = function (number) {\n    var hex = round(number, 0).toString(16).toUpperCase();\n    if (hex.length === 1) {\n        return "0x0".concat(hex);\n    }\n    return "0x".concat(hex);\n};\nvar toHEX = function (h) {\n    var hex = round(h, 0).toString(16).toUpperCase();\n    if (hex.length === 1) {\n        hex = "0".concat(hex);\n    }\n    return hex;\n};\nvar getBase255Number = function (color, alpha) {\n    if (alpha === void 0) { alpha = false; }\n    if (!alpha && PCENT.test(color)) {\n        return Math.min(255 * percentNumber(color) / 100, 255);\n    }\n    if (HEX.test(color)) {\n        if (color.length === 3) {\n            color += color.slice(-1);\n        }\n        return alpha\n            ? round(color) / 255\n            : round(color);\n    }\n    return Math.min(+color, alpha ? 1 : 255);\n};\nvar getCMYKNumber = function (color) { return Math.min(PCENT.test(color) ? percentNumber(color) / 100 : +color, 1); };\nvar getOrderedArrayString = function (keys) { return __spreadArray([], keys, true).sort().join(\'\').toUpperCase(); };\nvar round = function (value, decimals) {\n    if (decimals === void 0) { decimals = MAX_DECIMALS; }\n    var exp = Math.pow(10, decimals);\n    return Math.round(+value * exp) / exp;\n};\nvar minmax = function (n, min, max) { return Math.max(min, Math.min(n, max)); };\nvar degrees = function (radian) { return radian * 180 / Math.PI; };\nvar radians = function (degrees) { return degrees * Math.PI / 180; };\nvar pi2 = 360;\nvar normalizeHue = function (hue) {\n    if (typeof hue === \'string\') {\n        var matches = hue.match(HSL_HUE);\n        var value = +matches[1];\n        var units = matches[2];\n        switch (units) {\n            case AnglesUnitEnum.RADIANS:\n                hue = round(degrees(value));\n                break;\n            case AnglesUnitEnum.TURNS:\n                hue = round(value * pi2);\n                break;\n            case AnglesUnitEnum.GRADIANS:\n                hue = round(9 / 10 * value);\n                break;\n            case AnglesUnitEnum.DEGREES:\n            default:\n                hue = value;\n        }\n    }\n    if (hue > 360 || hue < 0) {\n        hue -= Math.floor(hue / pi2) * pi2;\n    }\n    return hue;\n};\nvar translateDegrees = function (degrees, units) {\n    var hue;\n    switch (units) {\n        case AnglesUnitEnum.RADIANS:\n            hue = round(radians(degrees));\n            break;\n        case AnglesUnitEnum.TURNS:\n            hue = round(degrees / pi2);\n            break;\n        case AnglesUnitEnum.GRADIANS:\n            hue = round(10 / 9 * degrees);\n            break;\n        case AnglesUnitEnum.DEGREES:\n        case AnglesUnitEnum.NONE:\n        default:\n            hue = degrees;\n    }\n    return hue;\n};\nvar getTranslatedHue = function (degrees, anglesUnit, decimals) {\n    return round(translateDegrees(degrees, anglesUnit), decimals);\n};\nvar getOptionsFromColorInput = function (options) {\n    var colors = [];\n    for (var _i = 1; _i < arguments.length; _i++) {\n        colors[_i - 1] = arguments[_i];\n    }\n    var cssColors = colors.filter(function (color) { return typeof color === \'string\'; });\n    var hslColors = cssColors\n        .filter(function (color) { return COLORREGS.HSL.test(color); })\n        .map(function (color) {\n        var hslMatch = color.match(COLORREGS.HSL);\n        var angle = hslMatch[1] || hslMatch[5];\n        var unit = angle.match(HSL_HUE)[2];\n        return unit === \'\'\n            ? AnglesUnitEnum.NONE\n            : unit;\n    });\n    var matchOptions = {\n        legacyCSS: 0,\n        spacesAfterCommas: 0,\n        anglesUnit: 0\n    };\n    cssColors.forEach(function (color) {\n        if (color.includes(\',\')) {\n            matchOptions.legacyCSS++;\n            var commasWithNextCharacter = color.match(/,( +|\\d+)/g);\n            if (new Set(commasWithNextCharacter).size === 1 &&\n                / +/.test(commasWithNextCharacter[0].slice(1))) {\n                matchOptions.spacesAfterCommas++;\n            }\n        }\n    });\n    return {\n        decimals: typeof options.decimals === TypeOf.NUMBER\n            ? options.decimals\n            : DEFAULT_OPTIONS.decimals,\n        legacyCSS: typeof options.legacyCSS === TypeOf.BOOLEAN\n            ? options.legacyCSS\n            : Boolean(cssColors.length &&\n                matchOptions.legacyCSS === cssColors.length) || DEFAULT_OPTIONS.legacyCSS,\n        spacesAfterCommas: typeof options.spacesAfterCommas === TypeOf.BOOLEAN\n            ? options.spacesAfterCommas\n            : Boolean(cssColors.length &&\n                matchOptions.spacesAfterCommas === cssColors.length) || DEFAULT_OPTIONS.spacesAfterCommas,\n        anglesUnit: options.anglesUnit\n            ? options.anglesUnit\n            : (new Set(hslColors).size === 1\n                ? hslColors[0]\n                : DEFAULT_OPTIONS.anglesUnit)\n    };\n};\n\n;// CONCATENATED MODULE: ./src/color/translators.ts\n\nvar hueToRGB = function (t1, t2, hue) {\n    if (hue < 0) {\n        hue += 6;\n    }\n    if (hue >= 6) {\n        hue -= 6;\n    }\n    if (hue < 1) {\n        return round(((t2 - t1) * hue + t1) * 255);\n    }\n    else if (hue < 3) {\n        return round(t2 * 255);\n    }\n    else if (hue < 4) {\n        return round(((t2 - t1) * (4 - hue) + t1) * 255);\n    }\n    else {\n        return round(t1 * 255);\n    }\n};\nvar hslToRGB = function (h, s, l) {\n    h /= 60;\n    s /= 100;\n    l /= 100;\n    var t2 = (l <= .5)\n        ? l * (s + 1)\n        : l + s - (l * s);\n    var t1 = l * 2 - t2;\n    var r = hueToRGB(t1, t2, h + 2);\n    var g = hueToRGB(t1, t2, h);\n    var b = hueToRGB(t1, t2, h - 2);\n    return { r: r, g: g, b: b };\n};\nvar cmykToRGB = function (c, m, y, k) {\n    k = 1 - k;\n    var r = round(255 * (1 - c) * k);\n    var g = round(255 * (1 - m) * k);\n    var b = round(255 * (1 - y) * k);\n    return { r: r, g: g, b: b };\n};\nvar rgbToCMYK = function (r, g, b) {\n    r /= 255;\n    g /= 255;\n    b /= 255;\n    var k = 1 - Math.max(r, g, b);\n    var k1 = 1 - k;\n    var c = k1 && (k1 - r) / k1;\n    var m = k1 && (k1 - g) / k1;\n    var y = k1 && (k1 - b) / k1;\n    return {\n        c: round(c * 100),\n        m: round(m * 100),\n        y: round(y * 100),\n        k: round(k * 100)\n    };\n};\nvar rgbToHSL = function (r, g, b, a) {\n    if (a === void 0) { a = 1; }\n    r /= 255;\n    g /= 255;\n    b /= 255;\n    a = Math.min(a, 1);\n    var max = Math.max(r, g, b);\n    var min = Math.min(r, g, b);\n    var d = max - min;\n    var h = 0;\n    var s = 0;\n    var l = (max + min) / 2;\n    if (d !== 0) {\n        switch (max) {\n            case r:\n                h = ((g - b) / d) % 6;\n                break;\n            case g:\n                h = (b - r) / d + 2;\n                break;\n            case b:\n                h = (r - g) / d + 4;\n                break;\n        }\n        h = round(h * 60);\n        if (h < 0) {\n            h += 360;\n        }\n        s = d / (1 - Math.abs(2 * l - 1));\n    }\n    return {\n        h: h,\n        s: round(s * 100),\n        l: round(l * 100),\n        a: a\n    };\n};\nvar rgbToRYB = function (r, g, b) {\n    var Iw = Math.min(r, g, b);\n    var Ib = Math.min(255 - r, 255 - g, 255 - b);\n    var rRGB = r - Iw;\n    var gRGB = g - Iw;\n    var bRGB = b - Iw;\n    var minRG = Math.min(rRGB, gRGB);\n    var rRYB = rRGB - minRG;\n    var yRYB = (gRGB + minRG) / 2;\n    var bRYB = (bRGB + gRGB - minRG) / 2;\n    var n = Math.max(rRYB, yRYB, bRYB) / Math.max(rRGB, gRGB, bRGB);\n    var N = isNaN(n) || n === Infinity || n <= 0 ? 1 : n;\n    return {\n        r: rRYB / N + Ib,\n        y: yRYB / N + Ib,\n        b: bRYB / N + Ib\n    };\n};\nvar rybToRGB = function (r, y, b) {\n    var Iw = Math.min(r, y, b);\n    var Ib = Math.min(255 - r, 255 - y, 255 - b);\n    var rRYB = r - Iw;\n    var yRYB = y - Iw;\n    var bRYB = b - Iw;\n    var minYB = Math.min(yRYB, bRYB);\n    var rRGB = rRYB + yRYB - minYB;\n    var gRGB = yRYB + minYB;\n    var bRGB = 2 * (bRYB - minYB);\n    var n = Math.max(rRGB, gRGB, bRGB) / Math.max(rRYB, yRYB, bRYB);\n    var N = isNaN(n) || n === Infinity || n <= 0 ? 1 : n;\n    return {\n        r: rRGB / N + Ib,\n        g: gRGB / N + Ib,\n        b: bRGB / N + Ib\n    };\n};\nvar hueRYB = function (hue, toRYB) {\n    if (hue < 0)\n        hue += 360;\n    if (hue > 360)\n        hue -= 360;\n    if (hue === 360 || hue === 0)\n        return hue;\n    var map1 = [\n        [0, 120],\n        [120, 180],\n        [180, 240],\n        [240, 360]\n    ];\n    var map2 = [\n        [0, 60],\n        [60, 120],\n        [120, 240],\n        [240, 360]\n    ];\n    var from = toRYB ? map1 : map2;\n    var to = toRYB ? map2 : map1;\n    var a = 0;\n    var b = 0;\n    var c = 0;\n    var d = 0;\n    from.find(function (arr, index) {\n        if (hue >= arr[0] && hue < arr[1]) {\n            a = arr[0];\n            b = arr[1];\n            c = to[index][0];\n            d = to[index][1];\n            return true;\n        }\n        return false;\n    });\n    return c + (hue - a) * ((d - c) / (b - a));\n};\n\n;// CONCATENATED MODULE: ./src/color/css.ts\nvar css_a;\n\n\n\nvar getComma = function (withSpace) { return withSpace\n    ? \', \'\n    : \',\'; };\nvar prepareColorForCss = function (color, isHex) {\n    if (isHex === void 0) { isHex = false; }\n    var props = getOrderedArrayString(Object.keys(color));\n    var model = VALID_COLOR_OBJECTS[props];\n    var keys = COLOR_PROPS[model];\n    return keys.reduce(function (result, key) {\n        var value = color[key];\n        if (typeof value !== \'undefined\') {\n            if (isHex) {\n                result.push(toHEX(round(value, 0)));\n            }\n            else {\n                result.push(value);\n            }\n        }\n        return result;\n    }, []);\n};\nvar getResultFromTemplate = function (template, vars) {\n    return template.replace(TEMPLATE_VAR, function (__match, indexStr) {\n        var index = +indexStr - 1;\n        return "".concat(vars[index]);\n    });\n};\nvar CSS = (css_a = {},\n    css_a[ColorModel.HEX] = function (color) {\n        var values = prepareColorForCss(color, true);\n        var template = values.length === 4\n            ? \'#{1}{2}{3}{4}\'\n            : \'#{1}{2}{3}\';\n        return getResultFromTemplate(template, values);\n    },\n    css_a[ColorModel.RGB] = function (color, options) {\n        var legacyCSS = options.legacyCSS, spacesAfterCommas = options.spacesAfterCommas;\n        var comma = getComma(spacesAfterCommas);\n        var values = prepareColorForCss(color);\n        var template = legacyCSS\n            ? (values.length === 4\n                ? "rgba({1}".concat(comma, "{2}").concat(comma, "{3}").concat(comma, "{4})")\n                : "rgb({1}".concat(comma, "{2}").concat(comma, "{3})"))\n            : (values.length === 4\n                ? \'rgb({1} {2} {3} / {4})\'\n                : \'rgb({1} {2} {3})\');\n        return getResultFromTemplate(template, values);\n    },\n    css_a[ColorModel.HSL] = function (color, options) {\n        var legacyCSS = options.legacyCSS, spacesAfterCommas = options.spacesAfterCommas, anglesUnit = options.anglesUnit;\n        var comma = getComma(spacesAfterCommas);\n        var values = prepareColorForCss(color);\n        var units = anglesUnit === AnglesUnitEnum.NONE\n            ? \'\'\n            : anglesUnit;\n        var template = legacyCSS\n            ? (values.length === 4\n                ? "hsla({1}".concat(units).concat(comma, "{2}%").concat(comma, "{3}%").concat(comma, "{4})")\n                : "hsl({1}".concat(units).concat(comma, "{2}%").concat(comma, "{3}%)"))\n            : (values.length === 4\n                ? "hsl({1}".concat(units, " {2}% {3}% / {4})")\n                : "hsl({1}".concat(units, " {2}% {3}%)"));\n        return getResultFromTemplate(template, values);\n    },\n    css_a[ColorModel.CMYK] = function (color, options) {\n        var legacyCSS = options.legacyCSS, spacesAfterCommas = options.spacesAfterCommas;\n        var comma = getComma(spacesAfterCommas);\n        var values = prepareColorForCss(color);\n        var template = legacyCSS\n            ? (values.length === 5\n                ? "device-cmyk({1}%".concat(comma, "{2}%").concat(comma, "{3}%").concat(comma, "{4}%").concat(comma, "{5})")\n                : "device-cmyk({1}%".concat(comma, "{2}%").concat(comma, "{3}%").concat(comma, "{4}%)"))\n            : (values.length === 5\n                ? \'device-cmyk({1}% {2}% {3}% {4}% / {5})\'\n                : \'device-cmyk({1}% {2}% {3}% {4}%)\');\n        return getResultFromTemplate(template, values);\n    },\n    css_a);\n\n;// CONCATENATED MODULE: ./src/color/utils.ts\nvar __assign = (undefined && undefined.__assign) || function () {\n    __assign = Object.assign || function(t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n                t[p] = s[p];\n        }\n        return t;\n    };\n    return __assign.apply(this, arguments);\n};\nvar utils_spreadArray = (undefined && undefined.__spreadArray) || function (to, from, pack) {\n    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\n        if (ar || !(i in from)) {\n            if (!ar) ar = Array.prototype.slice.call(from, 0, i);\n            ar[i] = from[i];\n        }\n    }\n    return to.concat(ar || Array.prototype.slice.call(from));\n};\nvar utils_a, _b, _c, _d, _e;\n\n\n\n\n\nvar normalizeAlpha = function (alpha) {\n    if (typeof alpha === \'string\') {\n        if (PCENT.test(alpha)) {\n            alpha = percentNumber(alpha) / 100;\n        }\n        else {\n            alpha = +alpha;\n        }\n    }\n    return (isNaN(+alpha) || alpha > 1) ? 1 : round(alpha);\n};\nvar harmony = function (color, angles, mode) {\n    return angles.reduce(function (arr, num) {\n        return (utils_spreadArray(utils_spreadArray([], arr, true), [\n            __assign(__assign({}, color), { h: mode === Mix.ADDITIVE\n                    ? normalizeHue(color.h + num)\n                    : normalizeHue(hueRYB(hueRYB(color.h, false) + num, true)) })\n        ], false));\n    }, [__assign({}, color)]);\n};\nvar analogous = function (color, mode) { return harmony(color, [30, -30], mode); };\nvar complementary = function (color, mode) { return harmony(color, [180], mode); };\nvar splitComplementary = function (color, mode) { return harmony(color, [150, -150], mode); };\nvar triadic = function (color, mode) { return harmony(color, [120, -120], mode); };\nvar tetradic = function (color, mode) { return harmony(color, [60, -120, 180], mode); };\nvar square = function (color, mode) { return harmony(color, [90, -90, 180], mode); };\nvar getColorModelFromString = function (color) {\n    var model;\n    Object.keys(ColorModel).some(function (p) {\n        var reg = COLORREGS[p];\n        if (reg.test(color)) {\n            model = p;\n            return true;\n        }\n    });\n    if (!model &&\n        !!~COLOR_KEYS.indexOf(color)) {\n        model = ColorModel.HEX;\n    }\n    if (!model) {\n        throw new Error(ERRORS.NOT_ACCEPTED_STRING_INPUT);\n    }\n    return model;\n};\nvar getColorModelFromObject = function (color) {\n    var model;\n    var invalid = false;\n    var props = getOrderedArrayString(Object.keys(color));\n    if (VALID_COLOR_OBJECTS[props]) {\n        model = VALID_COLOR_OBJECTS[props];\n    }\n    if (model && model === ColorModel.RGB) {\n        var hasInvalidHex = Object.entries(color).some(function (item) {\n            return !HEX.test("".concat(item[1]));\n        });\n        var hasInvalidRegb = Object.entries(color).some(function (item) {\n            return !(PCENT.test("".concat(item[1])) ||\n                (!HEX.test("".concat(item[1])) &&\n                    !isNaN(+item[1]) &&\n                    +item[1] <= 255));\n        });\n        if (hasInvalidHex && hasInvalidRegb) {\n            invalid = true;\n        }\n        if (!hasInvalidHex) {\n            model = ColorModel.HEX;\n        }\n    }\n    if (!model || invalid) {\n        throw new Error(ERRORS.NOT_ACCEPTED_OBJECT_INPUT);\n    }\n    return model;\n};\nvar getColorModel = function (color) { return typeof color === \'string\'\n    ? getColorModelFromString(color)\n    : getColorModelFromObject(color); };\nvar getRGBObjectFromString = (utils_a = {},\n    utils_a[ColorModel.HEX] = function (color) {\n        var colorStr = !~COLOR_KEYS.indexOf(color)\n            ? color\n            : ColorKeywords[color];\n        var match = colorStr.match(COLORREGS.HEX);\n        var object = {\n            r: getDEC(match[1] || match[5]),\n            g: getDEC(match[2] || match[6]),\n            b: getDEC(match[3] || match[7])\n        };\n        var a = match[4] || match[8];\n        if (a !== undefined) {\n            object.a = getDEC(a) / 255;\n        }\n        return object;\n    },\n    utils_a[ColorModel.RGB] = function (color) {\n        var match = color.match(COLORREGS.RGB);\n        var r = getBase255Number(match[1] || match[5]);\n        var g = getBase255Number(match[2] || match[6]);\n        var b = getBase255Number(match[3] || match[7]);\n        var a = match[4] || match[8];\n        var object = {\n            r: Math.min(r, 255),\n            g: Math.min(g, 255),\n            b: Math.min(b, 255)\n        };\n        if (a !== undefined) {\n            object.a = normalizeAlpha(a);\n        }\n        return object;\n    },\n    utils_a[ColorModel.HSL] = function (color) {\n        var match = color.match(COLORREGS.HSL);\n        var h = normalizeHue(match[1] || match[5]);\n        var s = percent(match[2] || match[6]);\n        var l = percent(match[3] || match[7]);\n        var a = match[4] || match[8];\n        var rgb = hslToRGB(h, s, l);\n        if (a !== undefined) {\n            rgb.a = normalizeAlpha(a);\n        }\n        return rgb;\n    },\n    utils_a[ColorModel.CMYK] = function (color) {\n        var match = color.match(COLORREGS.CMYK);\n        var c = getCMYKNumber(match[1] || match[6]);\n        var m = getCMYKNumber(match[2] || match[7]);\n        var y = getCMYKNumber(match[3] || match[8]);\n        var k = getCMYKNumber(match[4] || match[9]);\n        var a = match[5] || match[10];\n        var rgb = cmykToRGB(c, m, y, k);\n        if (a !== undefined) {\n            rgb.a = normalizeAlpha(a);\n        }\n        return rgb;\n    },\n    utils_a);\nvar getRGBObjectFromObject = (_b = {},\n    _b[ColorModel.HEX] = function (color) {\n        var object = {\n            r: getBase255Number("".concat(color.r)),\n            g: getBase255Number("".concat(color.g)),\n            b: getBase255Number("".concat(color.b))\n        };\n        if (hasProp(color, \'a\')) {\n            object.a = Math.min(getBase255Number("".concat(color.a), true), 1);\n        }\n        return object;\n    },\n    _b[ColorModel.RGB] = function (color) {\n        return this.HEX(color);\n    },\n    _b[ColorModel.HSL] = function (color) {\n        var s = percent("".concat(color.s));\n        var l = percent("".concat(color.l));\n        var rgb = hslToRGB(normalizeHue(color.h), s, l);\n        if (hasProp(color, \'a\')) {\n            rgb.a = normalizeAlpha(color.a);\n        }\n        return rgb;\n    },\n    _b[ColorModel.CMYK] = function (color) {\n        var c = getCMYKNumber("".concat(color.c));\n        var m = getCMYKNumber("".concat(color.m));\n        var y = getCMYKNumber("".concat(color.y));\n        var k = getCMYKNumber("".concat(color.k));\n        var rgb = cmykToRGB(c, m, y, k);\n        if (hasProp(color, \'a\')) {\n            rgb.a = normalizeAlpha(color.a);\n        }\n        return rgb;\n    },\n    _b);\nvar getRGBObject = function (color, model) {\n    if (model === void 0) { model = getColorModel(color); }\n    return typeof color === \'string\'\n        ? getRGBObjectFromString[model](color)\n        : getRGBObjectFromObject[model](color);\n};\nvar translateColor = (_c = {},\n    _c[ColorModel.HEX] = function (color) {\n        return {\n            r: getHEX(color.r),\n            g: getHEX(color.g),\n            b: getHEX(color.b)\n        };\n    },\n    _c.HEXA = function (color) {\n        var rgb = translateColor.HEX(color);\n        rgb.a = hasProp(color, \'a\')\n            ? getHEX(color.a * 255)\n            : \'0xFF\';\n        return rgb;\n    },\n    _c[ColorModel.RGB] = function (color, options) {\n        if (hasProp(color, \'a\')) {\n            delete color.a;\n        }\n        return roundRGBObject(color, options);\n    },\n    _c.RGBA = function (color, options) {\n        color.a = hasProp(color, \'a\')\n            ? round(color.a)\n            : 1;\n        return roundRGBObject(color, options);\n    },\n    _c[ColorModel.HSL] = function (color, options) {\n        var hsl = rgbToHSL(color.r, color.g, color.b);\n        delete hsl.a;\n        return roundHSLObject(hsl, options);\n    },\n    _c.HSLA = function (color, options) {\n        var decimals = options.decimals;\n        var hsl = translateColor.HSL(color, options);\n        hsl.a = hasProp(color, \'a\')\n            ? round(color.a, decimals)\n            : 1;\n        return hsl;\n    },\n    _c[ColorModel.CMYK] = function (color, options) {\n        return roundCMYKObject(rgbToCMYK(color.r, color.g, color.b), options);\n    },\n    _c.CMYKA = function (color, options) {\n        var decimals = options.decimals;\n        var cmyk = translateColor.CMYK(color, options);\n        cmyk.a = hasProp(color, \'a\')\n            ? round(color.a, decimals)\n            : 1;\n        return cmyk;\n    },\n    _c);\nvar blend = function (from, to, steps) {\n    var div = steps - 1;\n    var diffR = (to.r - from.r) / div;\n    var diffG = (to.g - from.g) / div;\n    var diffB = (to.b - from.b) / div;\n    var fromA = normalizeAlpha(from.a);\n    var toA = normalizeAlpha(to.a);\n    var diffA = (toA - fromA) / div;\n    return Array(steps).fill(null).map(function (__n, i) {\n        if (i === 0) {\n            return from;\n        }\n        if (i === div) {\n            return to;\n        }\n        return {\n            r: round(from.r + diffR * i),\n            g: round(from.g + diffG * i),\n            b: round(from.b + diffB * i),\n            a: round(fromA + diffA * i)\n        };\n    });\n};\nvar getColorMixture = function (color, steps, shades, options) {\n    var model = getColorModel(color);\n    var isCSS = typeof color === \'string\';\n    var rgb = getRGBObject(color, model);\n    var hasAlpha = ((typeof color === \'string\' && hasProp(rgb, \'a\')) ||\n        (typeof color !== \'string\' && hasProp(color, \'a\')));\n    var hsl = rgbToHSL(rgb.r, rgb.g, rgb.b, rgb.a);\n    if (!hasAlpha)\n        delete hsl.a;\n    var increment = shades\n        ? hsl.l / (steps + 1)\n        : (100 - hsl.l) / (steps + 1);\n    var hslMap = Array(steps).fill(null).map(function (__n, i) { return (__assign(__assign({}, hsl), { l: hsl.l + increment * (i + 1) * (1 - +shades * 2) })); });\n    switch (model) {\n        case ColorModel.HEX:\n        default:\n            return hslMap.map(function (hslColor) {\n                var rgbColor = hslToRGB(hslColor.h, hslColor.s, hslColor.l);\n                if (hasAlpha)\n                    rgbColor.a = hslColor.a;\n                return isCSS\n                    ? hasAlpha\n                        ? CSS.HEX(roundRGBObject(__assign(__assign({}, rgbColor), { a: round(rgbColor.a * 255) }), options))\n                        : CSS.HEX(roundRGBObject(rgbColor, options))\n                    : hasAlpha\n                        ? translateColor.HEXA(rgbColor)\n                        : translateColor.HEX(rgbColor);\n            });\n        case ColorModel.RGB:\n            return hslMap.map(function (hslColor) {\n                var rgbColor = hslToRGB(hslColor.h, hslColor.s, hslColor.l);\n                if (hasAlpha)\n                    rgbColor.a = hslColor.a;\n                return isCSS\n                    ? CSS.RGB(roundRGBObject(rgbColor, options), options)\n                    : hasAlpha\n                        ? translateColor.RGBA(rgbColor, options)\n                        : translateColor.RGB(rgbColor, options);\n            });\n        case ColorModel.HSL:\n            return hslMap.map(function (hslColor) {\n                return isCSS\n                    ? CSS.HSL(roundHSLObject(hslColor, options), options)\n                    : hasAlpha\n                        ? translateColor.HSLA(__assign(__assign({}, hslToRGB(hslColor.h, hslColor.s, hslColor.l)), { a: hslColor.a }), options)\n                        : translateColor.HSL(hslToRGB(hslColor.h, hslColor.s, hslColor.l), options);\n            });\n    }\n};\nvar colorHarmony = (_d = {\n        buildHarmony: function (color, harmonyFunction, mode, options) {\n            var model = getColorModel(color);\n            var rgb = getRGBObject(color, model);\n            var hsl = rgbToHSL(rgb.r, rgb.g, rgb.b, rgb.a);\n            var hasAlpha = ((typeof color === \'string\' && hasProp(rgb, \'a\')) ||\n                (typeof color !== \'string\' && hasProp(color, \'a\')));\n            var isCSS = typeof color === \'string\';\n            switch (model) {\n                case ColorModel.HEX:\n                default:\n                    return hasAlpha\n                        ? this.HEXA(roundHSLObject(hsl, null), harmonyFunction, mode, isCSS)\n                        : this.HEX(roundHSLObject(hsl, null), harmonyFunction, mode, isCSS);\n                case ColorModel.HSL:\n                    return hasAlpha\n                        ? this.HSLA(hsl, harmonyFunction, mode, isCSS, options)\n                        : this.HSL(hsl, harmonyFunction, mode, isCSS, options);\n                case ColorModel.RGB:\n                    return hasAlpha\n                        ? this.RGBA(hsl, harmonyFunction, mode, isCSS, options)\n                        : this.RGB(hsl, harmonyFunction, mode, isCSS, options);\n            }\n        }\n    },\n    _d[ColorModel.HEX] = function (color, harmonyFunction, mode, css) {\n        var array = harmonyFunction(color, mode);\n        return array.map(function (c) { return (css\n            ? CSS.HEX(hslToRGB(c.h, c.s, c.l))\n            : translateColor.HEX(hslToRGB(c.h, c.s, c.l))); });\n    },\n    _d.HEXA = function (color, harmonyFunction, mode, css) {\n        var array = harmonyFunction(color, mode);\n        return array.map(function (c) { return (css\n            ? CSS.HEX(__assign(__assign({}, hslToRGB(c.h, c.s, c.l)), { a: normalizeAlpha(c.a) * 255 }))\n            : translateColor.HEXA(__assign(__assign({}, hslToRGB(c.h, c.s, c.l)), { a: normalizeAlpha(c.a) }))); });\n    },\n    _d[ColorModel.RGB] = function (color, harmonyFunction, mode, css, options) {\n        var array = harmonyFunction(color, mode);\n        return array.map(function (c) { return (css\n            ? CSS.RGB(roundRGBObject(hslToRGB(c.h, c.s, c.l), options), options)\n            : translateColor.RGB(hslToRGB(c.h, c.s, c.l), options)); });\n    },\n    _d.RGBA = function (color, harmonyFunction, mode, css, options) {\n        var array = harmonyFunction(color, mode);\n        return array.map(function (c) { return (css\n            ? CSS.RGB(roundRGBObject(__assign(__assign({}, hslToRGB(c.h, c.s, c.l)), { a: normalizeAlpha(c.a) }), options), options)\n            : translateColor.RGBA(__assign(__assign({}, hslToRGB(c.h, c.s, c.l)), { a: normalizeAlpha(c.a) }), options)); });\n    },\n    _d[ColorModel.HSL] = function (color, harmonyFunction, mode, css, options) {\n        var array = harmonyFunction(color, mode);\n        return array.map(function (c) { return (css\n            ? CSS.HSL(roundHSLObject({\n                h: c.h,\n                s: c.s,\n                l: c.l\n            }, options), options)\n            : translateColor.HSL(hslToRGB(c.h, c.s, c.l), options)); });\n    },\n    _d.HSLA = function (color, harmonyFunction, mode, css, options) {\n        var array = harmonyFunction(color, mode);\n        return array.map(function (c) { return (css\n            ? CSS.HSL(roundHSLObject(__assign(__assign({}, c), { a: normalizeAlpha(c.a) }), options), options)\n            : translateColor.HSLA(__assign(__assign({}, hslToRGB(c.h, c.s, c.l)), { a: normalizeAlpha(c.a) }), options)); });\n    },\n    _d);\nvar colorMixer = (_e = {\n        mix: function (colors, mode) {\n            var rgbMap = colors.map(function (color) {\n                var model = getColorModel(color);\n                return getRGBObject(color, model);\n            });\n            var rybMap = mode === Mix.SUBTRACTIVE\n                ? rgbMap.map(function (color) {\n                    var ryb = rgbToRYB(color.r, color.g, color.b);\n                    if (hasProp(color, \'a\')) {\n                        ryb.a = color.a;\n                    }\n                    return ryb;\n                })\n                : null;\n            function createMix(items) {\n                var initial = mode === Mix.ADDITIVE\n                    ? { r: 0, g: 0, b: 0, a: 0 }\n                    : { r: 0, y: 0, b: 0, a: 0 };\n                return items.reduce(function (mix, color) {\n                    var colorA = hasProp(color, \'a\') ? color.a : 1;\n                    var common = {\n                        r: Math.min(mix.r + color.r * colorA, 255),\n                        b: Math.min(mix.b + color.b * colorA, 255),\n                        a: 1 - (1 - colorA) * (1 - mix.a)\n                    };\n                    var mixGY = \'g\' in mix\n                        ? mix.g\n                        : mix.y;\n                    var colorGY = \'g\' in color\n                        ? color.g\n                        : color.y;\n                    return __assign(__assign({}, common), (mode === Mix.ADDITIVE\n                        ? { g: Math.min(mixGY + colorGY * colorA, 255) }\n                        : { y: Math.min(mixGY + colorGY * colorA, 255) }));\n                }, initial);\n            }\n            var mix;\n            if (mode === Mix.ADDITIVE) {\n                mix = createMix(rgbMap);\n            }\n            else {\n                var ryb = createMix(rybMap);\n                mix = rybToRGB(ryb.r, ryb.y, ryb.b);\n                mix.a = ryb.a;\n            }\n            return {\n                r: round(mix.r),\n                g: round(mix.g),\n                b: round(mix.b),\n                a: minmax(mix.a, 0, 1)\n            };\n        }\n    },\n    _e[ColorModel.HEX] = function (colors, mode, css) {\n        var mix = this.mix(colors, mode);\n        delete mix.a;\n        return (css\n            ? CSS.HEX(mix)\n            : translateColor.HEX(mix));\n    },\n    _e.HEXA = function (colors, mode, css) {\n        var mix = this.mix(colors, mode);\n        mix.a = css\n            ? normalizeAlpha(mix.a) * 255\n            : normalizeAlpha(mix.a);\n        return (css\n            ? CSS.HEX(mix)\n            : translateColor.HEXA(mix));\n    },\n    _e[ColorModel.RGB] = function (colors, mode, css, options) {\n        var mix = this.mix(colors, mode);\n        delete mix.a;\n        return (css\n            ? CSS.RGB(mix, options)\n            : translateColor.RGB(mix, options));\n    },\n    _e.RGBA = function (colors, mode, css, options) {\n        var mix = this.mix(colors, mode);\n        return (css\n            ? CSS.RGB(mix, options)\n            : translateColor.RGBA(mix, options));\n    },\n    _e[ColorModel.HSL] = function (colors, mode, css, options) {\n        var mix = this.mix(colors, mode);\n        var hsl = rgbToHSL(mix.r, mix.g, mix.b);\n        delete mix.a;\n        delete hsl.a;\n        return (css\n            ? CSS.HSL(hsl, options)\n            : translateColor.HSL(mix, options));\n    },\n    _e.HSLA = function (colors, mode, css, options) {\n        var mix = this.mix(colors, mode);\n        var hsl = rgbToHSL(mix.r, mix.g, mix.b, mix.a);\n        return (css\n            ? CSS.HSL(hsl, options)\n            : translateColor.HSLA(mix, options));\n    },\n    _e);\nvar roundRGBObject = function (color, options) {\n    var decimals = options.decimals;\n    return __assign({ r: round(color.r, decimals), g: round(color.g, decimals), b: round(color.b, decimals) }, (hasProp(color, \'a\')\n        ? {\n            a: round(color.a, decimals)\n        }\n        : {}));\n};\nvar roundHSLObject = function (color, options) {\n    var decimals = options\n        ? options.decimals\n        : 0;\n    var anglesUnits = options\n        ? options.anglesUnit\n        : AnglesUnitEnum.NONE;\n    return __assign({ h: getTranslatedHue(color.h, anglesUnits, decimals), s: round(color.s, decimals), l: round(color.l, decimals) }, (hasProp(color, \'a\')\n        ? {\n            a: round(color.a, decimals)\n        }\n        : {}));\n};\nvar roundCMYKObject = function (color, options) {\n    var decimals = options.decimals;\n    return {\n        c: round(color.c, decimals),\n        m: round(color.m, decimals),\n        y: round(color.y, decimals),\n        k: round(color.k, decimals)\n    };\n};\n\n;// CONCATENATED MODULE: ./src/index.ts\nvar src_assign = (undefined && undefined.__assign) || function () {\n    src_assign = Object.assign || function(t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n                t[p] = s[p];\n        }\n        return t;\n    };\n    return src_assign.apply(this, arguments);\n};\nvar src_spreadArray = (undefined && undefined.__spreadArray) || function (to, from, pack) {\n    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\n        if (ar || !(i in from)) {\n            if (!ar) ar = Array.prototype.slice.call(from, 0, i);\n            ar[i] = from[i];\n        }\n    }\n    return to.concat(ar || Array.prototype.slice.call(from));\n};\n\n\n\n\n\nvar getColorReturn = function (color, model, options, translateFunction) {\n    var optionsFromInput = getOptionsFromColorInput(options, color);\n    var rgbObject = getRGBObject(color, model);\n    return translateFunction(rgbObject, optionsFromInput);\n};\nvar getBlendReturn = function (from, to, steps, options, translateFunction) {\n    var optionsFromInput = getOptionsFromColorInput(options, from, to);\n    if (steps < 1)\n        steps = DEFAULT_BLEND_STEPS;\n    var fromRGBObject = getRGBObject(from);\n    var toRGBObject = getRGBObject(to);\n    var blendArray = blend(fromRGBObject, toRGBObject, steps);\n    return blendArray.map(function (color) {\n        return translateFunction(color, optionsFromInput);\n    });\n};\nvar getHarmonyReturn = function (harmony, color, mode, options) {\n    var _a;\n    return (_a = {},\n        _a[Harmony.ANALOGOUS] = colorHarmony.buildHarmony(color, analogous, mode, options),\n        _a[Harmony.COMPLEMENTARY] = colorHarmony.buildHarmony(color, complementary, mode, options),\n        _a[Harmony.SPLIT_COMPLEMENTARY] = colorHarmony.buildHarmony(color, splitComplementary, mode, options),\n        _a[Harmony.TRIADIC] = colorHarmony.buildHarmony(color, triadic, mode, options),\n        _a[Harmony.TETRADIC] = colorHarmony.buildHarmony(color, tetradic, mode, options),\n        _a[Harmony.SQUARE] = colorHarmony.buildHarmony(color, square, mode, options),\n        _a)[harmony];\n};\nvar ColorTranslator = (function () {\n    function ColorTranslator(color, options) {\n        if (options === void 0) { options = {}; }\n        this._options = getOptionsFromColorInput(options, color);\n        this.rgb = getRGBObject(color);\n        this.updateHSL();\n        this.updateCMYK();\n    }\n    ColorTranslator.prototype.updateRGB = function () {\n        this.rgb = src_assign(src_assign({}, hslToRGB(this.hsl.h, this.hsl.s, this.hsl.l)), { a: this.hsl.a });\n    };\n    ColorTranslator.prototype.updateRGBFromCMYK = function () {\n        this.rgb = src_assign(src_assign({}, cmykToRGB(this.cmyk.c, this.cmyk.m, this.cmyk.y, this.cmyk.k)), { a: this.rgb.a });\n    };\n    ColorTranslator.prototype.updateHSL = function () {\n        this.hsl = rgbToHSL(this.rgb.r, this.rgb.g, this.rgb.b, this.rgb.a);\n    };\n    ColorTranslator.prototype.updateCMYK = function () {\n        this.cmyk = rgbToCMYK(this.rgb.r, this.rgb.g, this.rgb.b);\n    };\n    ColorTranslator.prototype.updateRGBAndCMYK = function () {\n        this.updateRGB();\n        this.updateCMYK();\n        return this;\n    };\n    ColorTranslator.prototype.updateHSLAndCMYK = function () {\n        this.updateHSL();\n        this.updateCMYK();\n        return this;\n    };\n    ColorTranslator.prototype.updateRGBAndHSL = function () {\n        this.updateRGBFromCMYK();\n        this.updateHSL();\n        return this;\n    };\n    ColorTranslator.prototype.setOptions = function (options) {\n        if (options === void 0) { options = {}; }\n        this._options = src_assign(src_assign({}, this._options), options);\n        return this;\n    };\n    ColorTranslator.prototype.setH = function (h) {\n        this.hsl.h = normalizeHue(h);\n        return this.updateRGBAndCMYK();\n    };\n    ColorTranslator.prototype.setS = function (s) {\n        this.hsl.s = minmax(s, 0, 100);\n        return this.updateRGBAndCMYK();\n    };\n    ColorTranslator.prototype.setL = function (l) {\n        this.hsl.l = minmax(l, 0, 100);\n        return this.updateRGBAndCMYK();\n    };\n    ColorTranslator.prototype.setR = function (r) {\n        this.rgb.r = minmax(r, 0, 255);\n        return this.updateHSLAndCMYK();\n    };\n    ColorTranslator.prototype.setG = function (g) {\n        this.rgb.g = minmax(g, 0, 255);\n        return this.updateHSLAndCMYK();\n    };\n    ColorTranslator.prototype.setB = function (b) {\n        this.rgb.b = minmax(b, 0, 255);\n        return this.updateHSLAndCMYK();\n    };\n    ColorTranslator.prototype.setA = function (a) {\n        this.hsl.a = this.rgb.a = minmax(a, 0, 1);\n        return this;\n    };\n    ColorTranslator.prototype.setC = function (c) {\n        this.cmyk.c = minmax(c, 0, 100);\n        return this.updateRGBAndHSL();\n    };\n    ColorTranslator.prototype.setM = function (m) {\n        this.cmyk.m = minmax(m, 0, 100);\n        return this.updateRGBAndHSL();\n    };\n    ColorTranslator.prototype.setY = function (y) {\n        this.cmyk.y = minmax(y, 0, 100);\n        return this.updateRGBAndHSL();\n    };\n    ColorTranslator.prototype.setK = function (k) {\n        this.cmyk.k = minmax(k, 0, 100);\n        return this.updateRGBAndHSL();\n    };\n    Object.defineProperty(ColorTranslator.prototype, "options", {\n        get: function () {\n            return this._options;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(ColorTranslator.prototype, "H", {\n        get: function () {\n            return round(this.hsl.h, this.options.decimals);\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(ColorTranslator.prototype, "S", {\n        get: function () {\n            return round(this.hsl.s, this.options.decimals);\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(ColorTranslator.prototype, "L", {\n        get: function () {\n            return round(this.hsl.l, this.options.decimals);\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(ColorTranslator.prototype, "R", {\n        get: function () {\n            return round(this.rgb.r, this.options.decimals);\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(ColorTranslator.prototype, "G", {\n        get: function () {\n            return round(this.rgb.g, this.options.decimals);\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(ColorTranslator.prototype, "B", {\n        get: function () {\n            return round(this.rgb.b, this.options.decimals);\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(ColorTranslator.prototype, "A", {\n        get: function () {\n            return round(this.hsl.a, this.options.decimals);\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(ColorTranslator.prototype, "C", {\n        get: function () {\n            return round(this.cmyk.c, this.options.decimals);\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(ColorTranslator.prototype, "M", {\n        get: function () {\n            return round(this.cmyk.m, this.options.decimals);\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(ColorTranslator.prototype, "Y", {\n        get: function () {\n            return round(this.cmyk.y, this.options.decimals);\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(ColorTranslator.prototype, "K", {\n        get: function () {\n            return round(this.cmyk.k, this.options.decimals);\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(ColorTranslator.prototype, "HEXObject", {\n        get: function () {\n            return translateColor.HEX(this.rgb);\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(ColorTranslator.prototype, "HEXAObject", {\n        get: function () {\n            return translateColor.HEXA(this.rgb);\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(ColorTranslator.prototype, "RGBObject", {\n        get: function () {\n            return {\n                r: this.R,\n                g: this.G,\n                b: this.B\n            };\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(ColorTranslator.prototype, "RGBAObject", {\n        get: function () {\n            return src_assign(src_assign({}, this.RGBObject), { a: this.A });\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(ColorTranslator.prototype, "HSLObject", {\n        get: function () {\n            return {\n                h: this.H,\n                s: this.S,\n                l: this.L\n            };\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(ColorTranslator.prototype, "HSLAObject", {\n        get: function () {\n            return src_assign(src_assign({}, this.HSLObject), { a: this.A });\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(ColorTranslator.prototype, "CMYKObject", {\n        get: function () {\n            return {\n                c: this.C,\n                m: this.M,\n                y: this.Y,\n                k: this.K\n            };\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(ColorTranslator.prototype, "CMYKAObject", {\n        get: function () {\n            return src_assign(src_assign({}, this.CMYKObject), { a: this.A });\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(ColorTranslator.prototype, "HEX", {\n        get: function () {\n            return CSS.HEX({\n                r: this.R,\n                g: this.G,\n                b: this.B\n            });\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(ColorTranslator.prototype, "HEXA", {\n        get: function () {\n            return CSS.HEX({\n                r: this.R,\n                g: this.G,\n                b: this.B,\n                a: this.A * 255\n            });\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(ColorTranslator.prototype, "RGB", {\n        get: function () {\n            return CSS.RGB({\n                r: this.R,\n                g: this.G,\n                b: this.B\n            }, this.options);\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(ColorTranslator.prototype, "RGBA", {\n        get: function () {\n            return CSS.RGB({\n                r: this.R,\n                g: this.G,\n                b: this.B,\n                a: this.A\n            }, this.options);\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(ColorTranslator.prototype, "HSL", {\n        get: function () {\n            return CSS.HSL({\n                h: getTranslatedHue(this.hsl.h, this.options.anglesUnit, this.options.decimals),\n                s: this.S,\n                l: this.L\n            }, this.options);\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(ColorTranslator.prototype, "HSLA", {\n        get: function () {\n            return CSS.HSL({\n                h: getTranslatedHue(this.hsl.h, this.options.anglesUnit, this.options.decimals),\n                s: this.S,\n                l: this.L,\n                a: this.A\n            }, this.options);\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(ColorTranslator.prototype, "CMYK", {\n        get: function () {\n            return CSS.CMYK({\n                c: this.C,\n                m: this.M,\n                y: this.Y,\n                k: this.K\n            }, this.options);\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(ColorTranslator.prototype, "CMYKA", {\n        get: function () {\n            return CSS.CMYK({\n                c: this.C,\n                m: this.M,\n                y: this.Y,\n                k: this.K,\n                a: this.A\n            }, this.options);\n        },\n        enumerable: false,\n        configurable: true\n    });\n    ColorTranslator.toHEXObject = function (color) {\n        var model = getColorModel(color);\n        return getColorReturn(color, model, { decimals: 0 }, translateColor.HEX);\n    };\n    ColorTranslator.toHEX = function (color) {\n        return CSS.HEX(ColorTranslator.toHEXObject(color));\n    };\n    ColorTranslator.toHEXAObject = function (color) {\n        var model = getColorModel(color);\n        return getColorReturn(color, model, { decimals: 0 }, translateColor.HEXA);\n    };\n    ColorTranslator.toHEXA = function (color) {\n        return CSS.HEX(ColorTranslator.toHEXAObject(color));\n    };\n    ColorTranslator.toRGBObject = function (color, options) {\n        if (options === void 0) { options = {}; }\n        var model = getColorModel(color);\n        return getColorReturn(color, model, options, translateColor.RGB);\n    };\n    ColorTranslator.toRGB = function (color, options) {\n        if (options === void 0) { options = {}; }\n        return CSS.RGB(ColorTranslator.toRGBObject(color, options), getOptionsFromColorInput(options, color));\n    };\n    ColorTranslator.toRGBAObject = function (color, options) {\n        if (options === void 0) { options = {}; }\n        var model = getColorModel(color);\n        return getColorReturn(color, model, options, translateColor.RGBA);\n    };\n    ColorTranslator.toRGBA = function (color, options) {\n        if (options === void 0) { options = {}; }\n        return CSS.RGB(ColorTranslator.toRGBAObject(color, options), getOptionsFromColorInput(options, color));\n    };\n    ColorTranslator.toHSLObject = function (color, options) {\n        if (options === void 0) { options = {}; }\n        var model = getColorModel(color);\n        return getColorReturn(color, model, options, translateColor.HSL);\n    };\n    ColorTranslator.toHSL = function (color, options) {\n        if (options === void 0) { options = {}; }\n        return CSS.HSL(ColorTranslator.toHSLObject(color, options), getOptionsFromColorInput(options, color));\n    };\n    ColorTranslator.toHSLAObject = function (color, options) {\n        if (options === void 0) { options = {}; }\n        var model = getColorModel(color);\n        return getColorReturn(color, model, options, translateColor.HSLA);\n    };\n    ColorTranslator.toHSLA = function (color, options) {\n        if (options === void 0) { options = {}; }\n        return CSS.HSL(ColorTranslator.toHSLAObject(color, options), getOptionsFromColorInput(options, color));\n    };\n    ColorTranslator.toCMYKObject = function (color, options) {\n        if (options === void 0) { options = {}; }\n        var model = getColorModel(color);\n        return getColorReturn(color, model, options, translateColor.CMYK);\n    };\n    ColorTranslator.toCMYK = function (color, options) {\n        if (options === void 0) { options = {}; }\n        return CSS.CMYK(ColorTranslator.toCMYKObject(color, options), getOptionsFromColorInput(options, color));\n    };\n    ColorTranslator.toCMYKAObject = function (color, options) {\n        if (options === void 0) { options = {}; }\n        var model = getColorModel(color);\n        return getColorReturn(color, model, options, translateColor.CMYKA);\n    };\n    ColorTranslator.toCMYKA = function (color, options) {\n        if (options === void 0) { options = {}; }\n        return CSS.CMYK(ColorTranslator.toCMYKAObject(color, options), getOptionsFromColorInput(options, color));\n    };\n    ColorTranslator.getBlendHEXObject = function (from, to, steps) {\n        if (steps === void 0) { steps = DEFAULT_BLEND_STEPS; }\n        return getBlendReturn(from, to, steps, { decimals: 0 }, translateColor.HEX);\n    };\n    ColorTranslator.getBlendHEX = function (from, to, steps) {\n        if (steps === void 0) { steps = DEFAULT_BLEND_STEPS; }\n        return ColorTranslator.getBlendHEXObject(from, to, steps)\n            .map(function (color) { return CSS.HEX(color); });\n    };\n    ColorTranslator.getBlendHEXAObject = function (from, to, steps) {\n        if (steps === void 0) { steps = DEFAULT_BLEND_STEPS; }\n        return getBlendReturn(from, to, steps, { decimals: 0 }, translateColor.HEXA);\n    };\n    ColorTranslator.getBlendHEXA = function (from, to, steps) {\n        if (steps === void 0) { steps = DEFAULT_BLEND_STEPS; }\n        return ColorTranslator.getBlendHEXAObject(from, to, steps)\n            .map(function (color) { return CSS.HEX(color); });\n    };\n    ColorTranslator.getBlendRGBObject = function (from, to, steps, options) {\n        if (steps === void 0) { steps = DEFAULT_BLEND_STEPS; }\n        if (options === void 0) { options = {}; }\n        return getBlendReturn(from, to, steps, options, translateColor.RGB);\n    };\n    ColorTranslator.getBlendRGB = function (from, to, steps, options) {\n        if (steps === void 0) { steps = DEFAULT_BLEND_STEPS; }\n        if (options === void 0) { options = {}; }\n        return ColorTranslator.getBlendRGBObject(from, to, steps, options)\n            .map(function (color) {\n            return CSS.RGB(color, getOptionsFromColorInput(options, from, to));\n        });\n    };\n    ColorTranslator.getBlendRGBAObject = function (from, to, steps, options) {\n        if (steps === void 0) { steps = DEFAULT_BLEND_STEPS; }\n        if (options === void 0) { options = {}; }\n        return getBlendReturn(from, to, steps, options, translateColor.RGBA);\n    };\n    ColorTranslator.getBlendRGBA = function (from, to, steps, options) {\n        if (steps === void 0) { steps = DEFAULT_BLEND_STEPS; }\n        if (options === void 0) { options = {}; }\n        return ColorTranslator.getBlendRGBAObject(from, to, steps, options)\n            .map(function (color) {\n            return CSS.RGB(color, getOptionsFromColorInput(options, from, to));\n        });\n    };\n    ColorTranslator.getBlendHSLObject = function (from, to, steps, options) {\n        if (steps === void 0) { steps = DEFAULT_BLEND_STEPS; }\n        if (options === void 0) { options = {}; }\n        return getBlendReturn(from, to, steps, options, translateColor.HSL);\n    };\n    ColorTranslator.getBlendHSL = function (from, to, steps, options) {\n        if (steps === void 0) { steps = DEFAULT_BLEND_STEPS; }\n        if (options === void 0) { options = {}; }\n        return ColorTranslator.getBlendHSLObject(from, to, steps, options)\n            .map(function (color) {\n            return CSS.HSL(color, getOptionsFromColorInput(options, from, to));\n        });\n    };\n    ColorTranslator.getBlendHSLAObject = function (from, to, steps, options) {\n        if (steps === void 0) { steps = DEFAULT_BLEND_STEPS; }\n        if (options === void 0) { options = {}; }\n        return getBlendReturn(from, to, steps, options, translateColor.HSLA);\n    };\n    ColorTranslator.getBlendHSLA = function (from, to, steps, options) {\n        if (steps === void 0) { steps = DEFAULT_BLEND_STEPS; }\n        if (options === void 0) { options = {}; }\n        return ColorTranslator.getBlendHSLAObject(from, to, steps, options)\n            .map(function (color) {\n            return CSS.HSL(color, getOptionsFromColorInput(options, from, to));\n        });\n    };\n    ColorTranslator.getMixHEXObject = function (colors, mode) {\n        if (mode === void 0) { mode = Mix.ADDITIVE; }\n        return colorMixer.HEX(colors, mode, false);\n    };\n    ColorTranslator.getMixHEX = function (colors, mode) {\n        if (mode === void 0) { mode = Mix.ADDITIVE; }\n        return colorMixer.HEX(colors, mode, true);\n    };\n    ColorTranslator.getMixHEXAObject = function (colors, mode) {\n        if (mode === void 0) { mode = Mix.ADDITIVE; }\n        return colorMixer.HEXA(colors, mode, false);\n    };\n    ColorTranslator.getMixHEXA = function (colors, mode) {\n        if (mode === void 0) { mode = Mix.ADDITIVE; }\n        return colorMixer.HEXA(colors, mode, true);\n    };\n    ColorTranslator.getMixRGBObject = function (colors, mode, options) {\n        if (mode === void 0) { mode = Mix.ADDITIVE; }\n        if (options === void 0) { options = {}; }\n        return colorMixer.RGB(colors, mode, false, getOptionsFromColorInput.apply(void 0, src_spreadArray([options], colors, false)));\n    };\n    ColorTranslator.getMixRGB = function (colors, mode, options) {\n        if (mode === void 0) { mode = Mix.ADDITIVE; }\n        if (options === void 0) { options = {}; }\n        return colorMixer.RGB(colors, mode, true, getOptionsFromColorInput.apply(void 0, src_spreadArray([options], colors, false)));\n    };\n    ColorTranslator.getMixRGBAObject = function (colors, mode, options) {\n        if (mode === void 0) { mode = Mix.ADDITIVE; }\n        if (options === void 0) { options = {}; }\n        return colorMixer.RGBA(colors, mode, false, getOptionsFromColorInput.apply(void 0, src_spreadArray([options], colors, false)));\n    };\n    ColorTranslator.getMixRGBA = function (colors, mode, options) {\n        if (mode === void 0) { mode = Mix.ADDITIVE; }\n        if (options === void 0) { options = {}; }\n        return colorMixer.RGBA(colors, mode, true, getOptionsFromColorInput.apply(void 0, src_spreadArray([options], colors, false)));\n    };\n    ColorTranslator.getMixHSLObject = function (colors, mode, options) {\n        if (mode === void 0) { mode = Mix.ADDITIVE; }\n        if (options === void 0) { options = {}; }\n        return colorMixer.HSL(colors, mode, false, getOptionsFromColorInput.apply(void 0, src_spreadArray([options], colors, false)));\n    };\n    ColorTranslator.getMixHSL = function (colors, mode, options) {\n        if (mode === void 0) { mode = Mix.ADDITIVE; }\n        if (options === void 0) { options = {}; }\n        return colorMixer.HSL(colors, mode, true, getOptionsFromColorInput.apply(void 0, src_spreadArray([options], colors, false)));\n    };\n    ColorTranslator.getMixHSLAObject = function (colors, mode, options) {\n        if (mode === void 0) { mode = Mix.ADDITIVE; }\n        if (options === void 0) { options = {}; }\n        return colorMixer.HSLA(colors, mode, false, getOptionsFromColorInput.apply(void 0, src_spreadArray([options], colors, false)));\n    };\n    ColorTranslator.getMixHSLA = function (colors, mode, options) {\n        if (mode === void 0) { mode = Mix.ADDITIVE; }\n        if (options === void 0) { options = {}; }\n        return colorMixer.HSLA(colors, mode, true, getOptionsFromColorInput.apply(void 0, src_spreadArray([options], colors, false)));\n    };\n    ColorTranslator.getShades = function (color, shades, options) {\n        if (options === void 0) { options = {}; }\n        return getColorMixture(color, shades, true, getOptionsFromColorInput(options, color));\n    };\n    ColorTranslator.getTints = function (color, tints, options) {\n        if (options === void 0) { options = {}; }\n        return getColorMixture(color, tints, false, getOptionsFromColorInput(options, color));\n    };\n    ColorTranslator.getHarmony = function (color, harmony, mode, options) {\n        if (harmony === void 0) { harmony = Harmony.COMPLEMENTARY; }\n        if (mode === void 0) { mode = Mix.ADDITIVE; }\n        if (options === void 0) { options = {}; }\n        return getHarmonyReturn(harmony, color, mode, getOptionsFromColorInput(options, color));\n    };\n    return ColorTranslator;\n}());\n\n\n\n;// CONCATENATED MODULE: ./src/@demo/demo1/index.js\n\n\n/* harmony default export */ const demo1 = ((ColorTranslator) => {\n\n    const container = document.createElement(\'div\');\n    const color = new ColorTranslator(\'hsl(180,100%,50%)\', { decimals: 0 });\n\n    for (let row = 0; row < 10; row++) {\n\n        for (let col = 0; col < 10; col++) {\n\n            color\n                .setS(row * 10)\n                .setL(col * 5 + 30);\n\n            const box = document.createElement(\'div\');\n\n            box.classList.add(\'box\');\n            box.style.background = color.HEX;\n\n            box.innerText =\n                `R:${color.R}\n                 G:${color.G}\n                 B:${color.B}`;\n            container.appendChild(box);\n\n        }\n    }\n\n    return container;\n\n});\n;// CONCATENATED MODULE: ./src/@demo/demo2/index.js\n\n\n/* harmony default export */ const demo2 = ((ColorTranslator) => {\n\n    const container = document.createElement(\'div\');\n    const color = new ColorTranslator({ r: 255, g: 0, b: 0 });\n    const hue = [0, 30, 60, 120, 240, 280, 320, 0];\n    let rainbow;\n\n    for (let r = 0; r < hue.length; r++) {\n\n        color.setH(hue[r]);\n\n        const bow = document.createElement(\'div\');\n\n        bow.classList.add(\'rainbow\');\n        bow.style.background = color.HEX;\n\n        if (rainbow) {\n            rainbow.appendChild(bow);\n        } else {\n            container.appendChild(bow);\n        }\n\n        rainbow = bow;\n    }\n\n    rainbow.style.background = \'#333\';\n\n    return container;\n\n});\n;// CONCATENATED MODULE: ./src/@demo/demo3/index.js\n\n\n/* harmony default export */ const demo3 = ((ColorTranslator) => {\n\n    const container = document.createElement(\'div\');\n    const hsl = { h: 0, s: \'90%\', l: \'50%\' };\n    const hue = [undefined, 55, 30, 0, 290, 220, 130];\n    const total = hue.length;\n\n    for (let row = 0; row < total; row++) {\n\n        for (let col = 0; col < total; col++) {\n\n            let index = total - row + col;\n            if (index >= total) {\n                index -= total;\n            }\n            hsl.h = hue[index];\n            const rgb = hue[index] === undefined\n                ? \'#FFF\'\n                : ColorTranslator.toHEX(hsl);\n            const box = document.createElement(\'div\');\n\n            box.classList.add(\'flag\');\n            box.style.background = rgb;\n\n            container.appendChild(box);\n\n        }\n    }\n\n    return container;\n\n});\n;// CONCATENATED MODULE: ./src/@demo/demo4/index.js\n\n\n/* harmony default export */ const demo4 = ((ColorTranslator) => {\n\n    const container = document.createElement(\'div\');\n    const colors = [\n        \'red\',\n        \'lime\',\n        \'blue\',\n        \'aqua\',\n        \'yellow\',\n        \'fuchsia\'\n    ];\n    const total = colors.length;\n\n    for (let row = 0; row < total; row++) {\n\n        const hsl = ColorTranslator.toHSLObject(colors[row], { decimals: 0 });\n        const step = hsl.s / (total - 1);\n\n        for (let col = 0; col < total; col++) {\n\n            const rgb = ColorTranslator.toHEX(hsl, { decimals: 0 });\n            const cmyk = ColorTranslator.toCMYKObject(hsl, { decimals: 0 });\n\n            const box = document.createElement(\'div\');\n            box.classList.add(\'box\');\n            box.style.background = rgb;\n            box.innerText = `C:${cmyk.c}\n                             M:${cmyk.m}\n                             Y:${cmyk.y}\n                             K:${cmyk.k}`;\n\n            container.appendChild(box);\n\n            hsl.s -= step;\n\n        }\n    }\n\n    return container;\n\n});\n;// CONCATENATED MODULE: ./src/@demo/demo5/index.js\n\n\n/* harmony default export */ const demo5 = ((ColorTranslator) => {\n\n    const container = document.createElement(\'div\');\n    const rows = 11;\n    const mult = 3;\n\n    for (let i = 0; i < rows; i++) {\n\n        const blends = ColorTranslator.getBlendHEX(\'#FF0000\', \'#FFFF00\', mult + i * mult);\n\n        blends.forEach((blend, index) => {\n            const box = document.createElement(\'div\');\n            box.classList.add(\'box\', `file${i}`);\n            box.style.background = blend;\n            box.innerText = index + 1;\n            container.appendChild(box);\n        });\n\n    }\n\n    return container;\n\n});\n;// CONCATENATED MODULE: ./src/@demo/demo6/index.js\n\n\n/* harmony default export */ const demo6 = ((ColorTranslator) => {\n\n    const container = document.createElement(\'div\');\n\n    const colors = [\'#F00\', \'#FF8000\', \'#FF0\', \'#0F0\', \'#00F\', \'#AA00FF\', \'#FF00AA\'];\n\n    const createBox = (color, type) => {\n        const box = document.createElement(\'div\');\n        box.classList.add(\'box\');\n        box.style.backgroundColor = color;\n        if (type) box.dataset.type = type;\n        container.appendChild(box);\n    };\n\n    colors.forEach((color) => {\n        const shades = ColorTranslator.getShades(color, 3).reverse();\n        const tints = ColorTranslator.getTints(color, 3);\n        shades.forEach((shade) => createBox(shade, \'shade\'));\n        createBox(color);\n        tints.forEach((tint) => createBox(tint, \'tint\'));\n    });\n\n    return container;\n\n});\n;// CONCATENATED MODULE: ./src/@demo/demo7/index.js\n\n\n\n/* harmony default export */ const demo7 = ((ColorTranslator) => {\n\n    const container = document.createElement(\'div\');\n\n    const mixes = [\n        \'#FF0000\',\n        \'#00FF00\',\n        \'#0000FF\',\n        [1, 3],\n        [1, 2],\n        [2, 3],\n        [1, 2, 3]\n    ];\n\n    const fillPlanes = () => {\n        const planes = container.querySelectorAll(\'#planes path\');\n        planes.forEach((plane, index) => {\n            let color = \'#CCCCCC\';\n            if (typeof mixes[index] === \'string\') {\n                color = mixes[index];\n            } else if(mixes[index]) {\n                const colors = mixes[index].map((i) => mixes[i - 1]);\n                color = mixes[index] = ColorTranslator.getMixHEX(colors);\n            }\n            plane.setAttribute(\'fill\', color);\n        });\n    };\n\n    fetch(\'images/color-mixes.svg\')\n        .then(result => result.text())\n        .then((svgCode) => {\n            container.innerHTML = svgCode;\n            fillPlanes();\n        });\n\n    return container;\n\n});\n;// CONCATENATED MODULE: ./src/@demo/demo8/index.js\n\n\n/* harmony default export */ const demo8 = ((ColorTranslator, { Mix }) => {\n\n    const container = document.createElement(\'div\');\n\n    const mixes = [\n        \'#FF0000\',\n        \'#FFFF00\',\n        \'#0000FF\',\n        [1, 3],\n        [1, 2],\n        [2, 3],\n        [1, 2, 3]\n    ];\n\n    const fillPlanes = () => {\n        const planes = container.querySelectorAll(\'#planes path\');\n        planes.forEach((plane, index) => {\n            let color = \'#CCCCCC\';\n            if (typeof mixes[index] === \'string\') {\n                color = mixes[index];\n            } else if(mixes[index]) {\n                const colors = mixes[index].map((i) => mixes[i - 1]);\n                color = mixes[index] = ColorTranslator.getMixHEX(colors, Mix.SUBTRACTIVE);\n            }\n            plane.setAttribute(\'fill\', color);\n        });\n    };\n\n    fetch(\'images/color-mixes.svg\')\n        .then(result => result.text())\n        .then((svgCode) => {\n            container.innerHTML = svgCode;\n            fillPlanes();\n        });\n\n    return container;\n\n});\n;// CONCATENATED MODULE: ./src/@demo/demo9/index.js\n\n\n/* harmony default export */ const demo9 = ((ColorTranslator, { Harmony }) => {\n\n    const container = document.createElement(\'div\');\n\n    const harmonies = [\n        { label: \'Complementary\',       value: Harmony.COMPLEMENTARY },\n        { label: \'Split Complementary\', value: Harmony.SPLIT_COMPLEMENTARY },\n        { label: \'Analogous\',           value: Harmony.ANALOGOUS },\n        { label: \'Triadic\',             value: Harmony.TRIADIC },\n        { label: \'Tetradic\',            value: Harmony.TETRADIC },\n        { label: \'Square\',              value: Harmony.SQUARE }\n    ];\n\n    const baseColor = \'#F00\';\n\n    const createElement = (className, parent) => {\n        const div = document.createElement(\'div\');\n        div.classList.add(className);\n        parent.appendChild(div);\n        return div;\n    };\n\n    const createHarmony = (item) => {\n\n        const wrapper = createElement(\'wrapper\', container);\n        const wheel = createElement(\'wheel\', wrapper);\n        const harmony = createElement(\'harmony\', wrapper);\n        createElement(\'label\', wrapper).innerText = item.label;\n\n        fetch(\'images/wheel-additive.svg\')\n            .then(result => result.text())\n            .then((svgCode) => {\n                const harmonyColors = ColorTranslator.getHarmony(baseColor, item.value);\n                const selector = \'path\' + harmonyColors.map((color) => `:not([fill="${color}"])`).join(\'\');\n                wheel.innerHTML = svgCode;\n                harmonyColors.forEach((hex) => createElement(\'box\', harmony).style.background = hex);\n                wheel.querySelectorAll(selector).forEach((path) => path.setAttribute(\'fill-opacity\', \'0.25\'));\n            });\n\n    };\n\n    harmonies.forEach((item) => createHarmony(item));\n\n    return container;\n\n});\n;// CONCATENATED MODULE: ./src/@demo/demo10/index.js\n\n\n/* harmony default export */ const demo10 = ((ColorTranslator, { Harmony, Mix }) => {\n\n    const container = document.createElement(\'div\');\n\n    const harmonies = [\n        { label: \'Complementary\',       value: Harmony.COMPLEMENTARY },\n        { label: \'Split Complementary\', value: Harmony.SPLIT_COMPLEMENTARY },\n        { label: \'Analogous\',           value: Harmony.ANALOGOUS },\n        { label: \'Triadic\',             value: Harmony.TRIADIC },\n        { label: \'Tetradic\',            value: Harmony.TETRADIC },\n        { label: \'Square\',              value: Harmony.SQUARE }\n    ];\n\n    const baseColor = \'#F00\';\n\n    const createElement = (className, parent) => {\n        const div = document.createElement(\'div\');\n        div.classList.add(className);\n        parent.appendChild(div);\n        return div;\n    };\n\n    const createHarmony = (item) => {\n\n        const wrapper = createElement(\'wrapper\', container);\n        const wheel = createElement(\'wheel\', wrapper);\n        const harmony = createElement(\'harmony\', wrapper);\n        createElement(\'label\', wrapper).innerText = item.label;\n\n        fetch(\'images/wheel-subtractive.svg\')\n            .then(result => result.text())\n            .then((svgCode) => {\n                const harmonyColors = ColorTranslator.getHarmony(baseColor, item.value, Mix.SUBTRACTIVE);\n                const selector = \'path\' + harmonyColors.map((color) => `:not([fill="${color}"])`).join(\'\');\n                wheel.innerHTML = svgCode;\n                harmonyColors.forEach((hex) => createElement(\'box\', harmony).style.background = hex);\n                wheel.querySelectorAll(selector).forEach((path) => path.setAttribute(\'fill-opacity\', \'0.25\'));\n            });\n\n    };\n\n    harmonies.forEach((item) => createHarmony(item));\n\n    return container;\n\n});\n;// CONCATENATED MODULE: ./src/@demo/demo.js\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nconst functioToString = (fn) => {\n    const article = document.createElement(\'article\');\n    const pre = document.createElement(\'pre\');\n    article.classList.add(\'function-container\');\n    pre.classList.add(\'prettyprint\');\n    article.appendChild(pre);\n    pre.innerHTML = fn.toString().replace(\'(ColorTranslator)\', \'()\');\n    return article;\n};\n\nconst demos = new Map([\n    [\'demo1\', demo1],\n    [\'demo2\', demo2],\n    [\'demo3\', demo3],\n    [\'demo4\', demo4],\n    [\'demo5\', demo5],\n    [\'demo6\', demo6],\n    [\'demo7\', demo7],\n    [\'demo8\', demo8],\n    [\'demo9\', demo9],\n    [\'demo10\', demo10],\n]);\n\ndocument.addEventListener(\'DOMContentLoaded\', () => {\n    demos.forEach((module, div) => {\n        const demo = document.getElementById(div);\n        const container = document.createElement(\'div\');\n        const wrapper = document.createElement(\'div\');\n\n        container.classList.add(\'demo-container\');\n        wrapper.classList.add(\'demo-wrapper\');\n\n        wrapper.appendChild(module(ColorTranslator, { Harmony: Harmony, Mix: Mix }));\n        container.appendChild(wrapper);\n        demo.appendChild(container);\n        demo.appendChild(functioToString(module));\n    });\n});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiOTQyLmpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFTztBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxJQUFJO0FBQ0o7QUFDQTtBQUNBLEtBQUs7QUFDTCxJQUFJO0FBQ0o7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsa0JBQWtCLGlCQUFpQjtBQUNuQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBO0FBQ0EscURBQXFEO0FBQ3JELFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUiw0RUFBNEU7QUFDNUU7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsNEJBQTRCLHFCQUFxQjtBQUNqRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTs7QUFFTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBLHFDQUFxQywwQkFBMEI7QUFDL0Q7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDZCQUE2QiwwQkFBMEIsZUFBZTtBQUN0RTs7QUFFTztBQUNQO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVPLFNBQVMsV0FBSztBQUNyQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7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Oi8vY29sb3J0cmFuc2xhdG9yLy4vbm9kZV9tb2R1bGVzL3doYXR3Zy1mZXRjaC9mZXRjaC5qcz82ZDkzIiwid2VicGFjazovL2NvbG9ydHJhbnNsYXRvci8uL3NyYy9jb25zdGFudHMvbnVtYmVycy50cz9kNTU5Iiwid2VicGFjazovL2NvbG9ydHJhbnNsYXRvci8uL3NyYy9jb25zdGFudHMvZW51bXMudHM/ZjVjYSIsIndlYnBhY2s6Ly9jb2xvcnRyYW5zbGF0b3IvLi9zcmMvY29uc3RhbnRzL3JlZ2V4cHMudHM/Y2ZmOCIsIndlYnBhY2s6Ly9jb2xvcnRyYW5zbGF0b3IvLi9zcmMvY29uc3RhbnRzL2Vycm9ycy50cz83YTRkIiwid2VicGFjazovL2NvbG9ydHJhbnNsYXRvci8uL3NyYy9AdHlwZXMvaW5kZXgudHM/M2RjYSIsIndlYnBhY2s6Ly9jb2xvcnRyYW5zbGF0b3IvLi9zcmMvY29uc3RhbnRzL29wdGlvbnMudHM/NWEzNSIsIndlYnBhY2s6Ly9jb2xvcnRyYW5zbGF0b3IvLi9zcmMvY29uc3RhbnRzL2luZGV4LnRzPzcwMmEiLCJ3ZWJwYWNrOi8vY29sb3J0cmFuc2xhdG9yLy4vc3JjL2hlbHBlcnMvaW5kZXgudHM/NzhhMSIsIndlYnBhY2s6Ly9jb2xvcnRyYW5zbGF0b3IvLi9zcmMvY29sb3IvdHJhbnNsYXRvcnMudHM/OWY3MCIsIndlYnBhY2s6Ly9jb2xvcnRyYW5zbGF0b3IvLi9zcmMvY29sb3IvY3NzLnRzPzZiMTIiLCJ3ZWJwYWNrOi8vY29sb3J0cmFuc2xhdG9yLy4vc3JjL2NvbG9yL3V0aWxzLnRzPzY5ZjMiLCJ3ZWJwYWNrOi8vY29sb3J0cmFuc2xhdG9yLy4vc3JjL2luZGV4LnRzP2U5NGUiLCJ3ZWJwYWNrOi8vY29sb3J0cmFuc2xhdG9yLy4vc3JjL0BkZW1vL2RlbW8xL2luZGV4LmpzPzM5NjUiLCJ3ZWJwYWNrOi8vY29sb3J0cmFuc2xhdG9yLy4vc3JjL0BkZW1vL2RlbW8yL2luZGV4LmpzP2Q4ZGMiLCJ3ZWJwYWNrOi8vY29sb3J0cmFuc2xhdG9yLy4vc3JjL0BkZW1vL2RlbW8zL2luZGV4LmpzP2QzODYiLCJ3ZWJwYWNrOi8vY29sb3J0cmFuc2xhdG9yLy4vc3JjL0BkZW1vL2RlbW80L2luZGV4LmpzPzYxOWYiLCJ3ZWJwYWNrOi8vY29sb3J0cmFuc2xhdG9yLy4vc3JjL0BkZW1vL2RlbW81L2luZGV4LmpzP2Q4Y2MiLCJ3ZWJwYWNrOi8vY29sb3J0cmFuc2xhdG9yLy4vc3JjL0BkZW1vL2RlbW82L2luZGV4LmpzPzNhMzIiLCJ3ZWJwYWNrOi8vY29sb3J0cmFuc2xhdG9yLy4vc3JjL0BkZW1vL2RlbW83L2luZGV4LmpzPzgzNDMiLCJ3ZWJwYWNrOi8vY29sb3J0cmFuc2xhdG9yLy4vc3JjL0BkZW1vL2RlbW84L2luZGV4LmpzPzc3MjUiLCJ3ZWJwYWNrOi8vY29sb3J0cmFuc2xhdG9yLy4vc3JjL0BkZW1vL2RlbW85L2luZGV4LmpzPzg1MzIiLCJ3ZWJwYWNrOi8vY29sb3J0cmFuc2xhdG9yLy4vc3JjL0BkZW1vL2RlbW8xMC9pbmRleC5qcz80ZjY3Iiwid2VicGFjazovL2NvbG9ydHJhbnNsYXRvci8uL3NyYy9AZGVtby9kZW1vLmpzPzliN2QiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIGdsb2JhbCA9XG4gICh0eXBlb2YgZ2xvYmFsVGhpcyAhPT0gJ3VuZGVmaW5lZCcgJiYgZ2xvYmFsVGhpcykgfHxcbiAgKHR5cGVvZiBzZWxmICE9PSAndW5kZWZpbmVkJyAmJiBzZWxmKSB8fFxuICAodHlwZW9mIGdsb2JhbCAhPT0gJ3VuZGVmaW5lZCcgJiYgZ2xvYmFsKVxuXG52YXIgc3VwcG9ydCA9IHtcbiAgc2VhcmNoUGFyYW1zOiAnVVJMU2VhcmNoUGFyYW1zJyBpbiBnbG9iYWwsXG4gIGl0ZXJhYmxlOiAnU3ltYm9sJyBpbiBnbG9iYWwgJiYgJ2l0ZXJhdG9yJyBpbiBTeW1ib2wsXG4gIGJsb2I6XG4gICAgJ0ZpbGVSZWFkZXInIGluIGdsb2JhbCAmJlxuICAgICdCbG9iJyBpbiBnbG9iYWwgJiZcbiAgICAoZnVuY3Rpb24oKSB7XG4gICAgICB0cnkge1xuICAgICAgICBuZXcgQmxvYigpXG4gICAgICAgIHJldHVybiB0cnVlXG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgfVxuICAgIH0pKCksXG4gIGZvcm1EYXRhOiAnRm9ybURhdGEnIGluIGdsb2JhbCxcbiAgYXJyYXlCdWZmZXI6ICdBcnJheUJ1ZmZlcicgaW4gZ2xvYmFsXG59XG5cbmZ1bmN0aW9uIGlzRGF0YVZpZXcob2JqKSB7XG4gIHJldHVybiBvYmogJiYgRGF0YVZpZXcucHJvdG90eXBlLmlzUHJvdG90eXBlT2Yob2JqKVxufVxuXG5pZiAoc3VwcG9ydC5hcnJheUJ1ZmZlcikge1xuICB2YXIgdmlld0NsYXNzZXMgPSBbXG4gICAgJ1tvYmplY3QgSW50OEFycmF5XScsXG4gICAgJ1tvYmplY3QgVWludDhBcnJheV0nLFxuICAgICdbb2JqZWN0IFVpbnQ4Q2xhbXBlZEFycmF5XScsXG4gICAgJ1tvYmplY3QgSW50MTZBcnJheV0nLFxuICAgICdbb2JqZWN0IFVpbnQxNkFycmF5XScsXG4gICAgJ1tvYmplY3QgSW50MzJBcnJheV0nLFxuICAgICdbb2JqZWN0IFVpbnQzMkFycmF5XScsXG4gICAgJ1tvYmplY3QgRmxvYXQzMkFycmF5XScsXG4gICAgJ1tvYmplY3QgRmxvYXQ2NEFycmF5XSdcbiAgXVxuXG4gIHZhciBpc0FycmF5QnVmZmVyVmlldyA9XG4gICAgQXJyYXlCdWZmZXIuaXNWaWV3IHx8XG4gICAgZnVuY3Rpb24ob2JqKSB7XG4gICAgICByZXR1cm4gb2JqICYmIHZpZXdDbGFzc2VzLmluZGV4T2YoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG9iaikpID4gLTFcbiAgICB9XG59XG5cbmZ1bmN0aW9uIG5vcm1hbGl6ZU5hbWUobmFtZSkge1xuICBpZiAodHlwZW9mIG5hbWUgIT09ICdzdHJpbmcnKSB7XG4gICAgbmFtZSA9IFN0cmluZyhuYW1lKVxuICB9XG4gIGlmICgvW15hLXowLTlcXC0jJCUmJyorLl5fYHx+IV0vaS50ZXN0KG5hbWUpIHx8IG5hbWUgPT09ICcnKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignSW52YWxpZCBjaGFyYWN0ZXIgaW4gaGVhZGVyIGZpZWxkIG5hbWU6IFwiJyArIG5hbWUgKyAnXCInKVxuICB9XG4gIHJldHVybiBuYW1lLnRvTG93ZXJDYXNlKClcbn1cblxuZnVuY3Rpb24gbm9ybWFsaXplVmFsdWUodmFsdWUpIHtcbiAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ3N0cmluZycpIHtcbiAgICB2YWx1ZSA9IFN0cmluZyh2YWx1ZSlcbiAgfVxuICByZXR1cm4gdmFsdWVcbn1cblxuLy8gQnVpbGQgYSBkZXN0cnVjdGl2ZSBpdGVyYXRvciBmb3IgdGhlIHZhbHVlIGxpc3RcbmZ1bmN0aW9uIGl0ZXJhdG9yRm9yKGl0ZW1zKSB7XG4gIHZhciBpdGVyYXRvciA9IHtcbiAgICBuZXh0OiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciB2YWx1ZSA9IGl0ZW1zLnNoaWZ0KClcbiAgICAgIHJldHVybiB7ZG9uZTogdmFsdWUgPT09IHVuZGVmaW5lZCwgdmFsdWU6IHZhbHVlfVxuICAgIH1cbiAgfVxuXG4gIGlmIChzdXBwb3J0Lml0ZXJhYmxlKSB7XG4gICAgaXRlcmF0b3JbU3ltYm9sLml0ZXJhdG9yXSA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIGl0ZXJhdG9yXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGl0ZXJhdG9yXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBIZWFkZXJzKGhlYWRlcnMpIHtcbiAgdGhpcy5tYXAgPSB7fVxuXG4gIGlmIChoZWFkZXJzIGluc3RhbmNlb2YgSGVhZGVycykge1xuICAgIGhlYWRlcnMuZm9yRWFjaChmdW5jdGlvbih2YWx1ZSwgbmFtZSkge1xuICAgICAgdGhpcy5hcHBlbmQobmFtZSwgdmFsdWUpXG4gICAgfSwgdGhpcylcbiAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KGhlYWRlcnMpKSB7XG4gICAgaGVhZGVycy5mb3JFYWNoKGZ1bmN0aW9uKGhlYWRlcikge1xuICAgICAgdGhpcy5hcHBlbmQoaGVhZGVyWzBdLCBoZWFkZXJbMV0pXG4gICAgfSwgdGhpcylcbiAgfSBlbHNlIGlmIChoZWFkZXJzKSB7XG4gICAgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoaGVhZGVycykuZm9yRWFjaChmdW5jdGlvbihuYW1lKSB7XG4gICAgICB0aGlzLmFwcGVuZChuYW1lLCBoZWFkZXJzW25hbWVdKVxuICAgIH0sIHRoaXMpXG4gIH1cbn1cblxuSGVhZGVycy5wcm90b3R5cGUuYXBwZW5kID0gZnVuY3Rpb24obmFtZSwgdmFsdWUpIHtcbiAgbmFtZSA9IG5vcm1hbGl6ZU5hbWUobmFtZSlcbiAgdmFsdWUgPSBub3JtYWxpemVWYWx1ZSh2YWx1ZSlcbiAgdmFyIG9sZFZhbHVlID0gdGhpcy5tYXBbbmFtZV1cbiAgdGhpcy5tYXBbbmFtZV0gPSBvbGRWYWx1ZSA/IG9sZFZhbHVlICsgJywgJyArIHZhbHVlIDogdmFsdWVcbn1cblxuSGVhZGVycy5wcm90b3R5cGVbJ2RlbGV0ZSddID0gZnVuY3Rpb24obmFtZSkge1xuICBkZWxldGUgdGhpcy5tYXBbbm9ybWFsaXplTmFtZShuYW1lKV1cbn1cblxuSGVhZGVycy5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24obmFtZSkge1xuICBuYW1lID0gbm9ybWFsaXplTmFtZShuYW1lKVxuICByZXR1cm4gdGhpcy5oYXMobmFtZSkgPyB0aGlzLm1hcFtuYW1lXSA6IG51bGxcbn1cblxuSGVhZGVycy5wcm90b3R5cGUuaGFzID0gZnVuY3Rpb24obmFtZSkge1xuICByZXR1cm4gdGhpcy5tYXAuaGFzT3duUHJvcGVydHkobm9ybWFsaXplTmFtZShuYW1lKSlcbn1cblxuSGVhZGVycy5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24obmFtZSwgdmFsdWUpIHtcbiAgdGhpcy5tYXBbbm9ybWFsaXplTmFtZShuYW1lKV0gPSBub3JtYWxpemVWYWx1ZSh2YWx1ZSlcbn1cblxuSGVhZGVycy5wcm90b3R5cGUuZm9yRWFjaCA9IGZ1bmN0aW9uKGNhbGxiYWNrLCB0aGlzQXJnKSB7XG4gIGZvciAodmFyIG5hbWUgaW4gdGhpcy5tYXApIHtcbiAgICBpZiAodGhpcy5tYXAuaGFzT3duUHJvcGVydHkobmFtZSkpIHtcbiAgICAgIGNhbGxiYWNrLmNhbGwodGhpc0FyZywgdGhpcy5tYXBbbmFtZV0sIG5hbWUsIHRoaXMpXG4gICAgfVxuICB9XG59XG5cbkhlYWRlcnMucHJvdG90eXBlLmtleXMgPSBmdW5jdGlvbigpIHtcbiAgdmFyIGl0ZW1zID0gW11cbiAgdGhpcy5mb3JFYWNoKGZ1bmN0aW9uKHZhbHVlLCBuYW1lKSB7XG4gICAgaXRlbXMucHVzaChuYW1lKVxuICB9KVxuICByZXR1cm4gaXRlcmF0b3JGb3IoaXRlbXMpXG59XG5cbkhlYWRlcnMucHJvdG90eXBlLnZhbHVlcyA9IGZ1bmN0aW9uKCkge1xuICB2YXIgaXRlbXMgPSBbXVxuICB0aGlzLmZvckVhY2goZnVuY3Rpb24odmFsdWUpIHtcbiAgICBpdGVtcy5wdXNoKHZhbHVlKVxuICB9KVxuICByZXR1cm4gaXRlcmF0b3JGb3IoaXRlbXMpXG59XG5cbkhlYWRlcnMucHJvdG90eXBlLmVudHJpZXMgPSBmdW5jdGlvbigpIHtcbiAgdmFyIGl0ZW1zID0gW11cbiAgdGhpcy5mb3JFYWNoKGZ1bmN0aW9uKHZhbHVlLCBuYW1lKSB7XG4gICAgaXRlbXMucHVzaChbbmFtZSwgdmFsdWVdKVxuICB9KVxuICByZXR1cm4gaXRlcmF0b3JGb3IoaXRlbXMpXG59XG5cbmlmIChzdXBwb3J0Lml0ZXJhYmxlKSB7XG4gIEhlYWRlcnMucHJvdG90eXBlW1N5bWJvbC5pdGVyYXRvcl0gPSBIZWFkZXJzLnByb3RvdHlwZS5lbnRyaWVzXG59XG5cbmZ1bmN0aW9uIGNvbnN1bWVkKGJvZHkpIHtcbiAgaWYgKGJvZHkuYm9keVVzZWQpIHtcbiAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IFR5cGVFcnJvcignQWxyZWFkeSByZWFkJykpXG4gIH1cbiAgYm9keS5ib2R5VXNlZCA9IHRydWVcbn1cblxuZnVuY3Rpb24gZmlsZVJlYWRlclJlYWR5KHJlYWRlcikge1xuICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgcmVhZGVyLm9ubG9hZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmVzb2x2ZShyZWFkZXIucmVzdWx0KVxuICAgIH1cbiAgICByZWFkZXIub25lcnJvciA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmVqZWN0KHJlYWRlci5lcnJvcilcbiAgICB9XG4gIH0pXG59XG5cbmZ1bmN0aW9uIHJlYWRCbG9iQXNBcnJheUJ1ZmZlcihibG9iKSB7XG4gIHZhciByZWFkZXIgPSBuZXcgRmlsZVJlYWRlcigpXG4gIHZhciBwcm9taXNlID0gZmlsZVJlYWRlclJlYWR5KHJlYWRlcilcbiAgcmVhZGVyLnJlYWRBc0FycmF5QnVmZmVyKGJsb2IpXG4gIHJldHVybiBwcm9taXNlXG59XG5cbmZ1bmN0aW9uIHJlYWRCbG9iQXNUZXh0KGJsb2IpIHtcbiAgdmFyIHJlYWRlciA9IG5ldyBGaWxlUmVhZGVyKClcbiAgdmFyIHByb21pc2UgPSBmaWxlUmVhZGVyUmVhZHkocmVhZGVyKVxuICByZWFkZXIucmVhZEFzVGV4dChibG9iKVxuICByZXR1cm4gcHJvbWlzZVxufVxuXG5mdW5jdGlvbiByZWFkQXJyYXlCdWZmZXJBc1RleHQoYnVmKSB7XG4gIHZhciB2aWV3ID0gbmV3IFVpbnQ4QXJyYXkoYnVmKVxuICB2YXIgY2hhcnMgPSBuZXcgQXJyYXkodmlldy5sZW5ndGgpXG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB2aWV3Lmxlbmd0aDsgaSsrKSB7XG4gICAgY2hhcnNbaV0gPSBTdHJpbmcuZnJvbUNoYXJDb2RlKHZpZXdbaV0pXG4gIH1cbiAgcmV0dXJuIGNoYXJzLmpvaW4oJycpXG59XG5cbmZ1bmN0aW9uIGJ1ZmZlckNsb25lKGJ1Zikge1xuICBpZiAoYnVmLnNsaWNlKSB7XG4gICAgcmV0dXJuIGJ1Zi5zbGljZSgwKVxuICB9IGVsc2Uge1xuICAgIHZhciB2aWV3ID0gbmV3IFVpbnQ4QXJyYXkoYnVmLmJ5dGVMZW5ndGgpXG4gICAgdmlldy5zZXQobmV3IFVpbnQ4QXJyYXkoYnVmKSlcbiAgICByZXR1cm4gdmlldy5idWZmZXJcbiAgfVxufVxuXG5mdW5jdGlvbiBCb2R5KCkge1xuICB0aGlzLmJvZHlVc2VkID0gZmFsc2VcblxuICB0aGlzLl9pbml0Qm9keSA9IGZ1bmN0aW9uKGJvZHkpIHtcbiAgICAvKlxuICAgICAgZmV0Y2gtbW9jayB3cmFwcyB0aGUgUmVzcG9uc2Ugb2JqZWN0IGluIGFuIEVTNiBQcm94eSB0b1xuICAgICAgcHJvdmlkZSB1c2VmdWwgdGVzdCBoYXJuZXNzIGZlYXR1cmVzIHN1Y2ggYXMgZmx1c2guIEhvd2V2ZXIsIG9uXG4gICAgICBFUzUgYnJvd3NlcnMgd2l0aG91dCBmZXRjaCBvciBQcm94eSBzdXBwb3J0IHBvbGx5ZmlsbHMgbXVzdCBiZSB1c2VkO1xuICAgICAgdGhlIHByb3h5LXBvbGx5ZmlsbCBpcyB1bmFibGUgdG8gcHJveHkgYW4gYXR0cmlidXRlIHVubGVzcyBpdCBleGlzdHNcbiAgICAgIG9uIHRoZSBvYmplY3QgYmVmb3JlIHRoZSBQcm94eSBpcyBjcmVhdGVkLiBUaGlzIGNoYW5nZSBlbnN1cmVzXG4gICAgICBSZXNwb25zZS5ib2R5VXNlZCBleGlzdHMgb24gdGhlIGluc3RhbmNlLCB3aGlsZSBtYWludGFpbmluZyB0aGVcbiAgICAgIHNlbWFudGljIG9mIHNldHRpbmcgUmVxdWVzdC5ib2R5VXNlZCBpbiB0aGUgY29uc3RydWN0b3IgYmVmb3JlXG4gICAgICBfaW5pdEJvZHkgaXMgY2FsbGVkLlxuICAgICovXG4gICAgdGhpcy5ib2R5VXNlZCA9IHRoaXMuYm9keVVzZWRcbiAgICB0aGlzLl9ib2R5SW5pdCA9IGJvZHlcbiAgICBpZiAoIWJvZHkpIHtcbiAgICAgIHRoaXMuX2JvZHlUZXh0ID0gJydcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBib2R5ID09PSAnc3RyaW5nJykge1xuICAgICAgdGhpcy5fYm9keVRleHQgPSBib2R5XG4gICAgfSBlbHNlIGlmIChzdXBwb3J0LmJsb2IgJiYgQmxvYi5wcm90b3R5cGUuaXNQcm90b3R5cGVPZihib2R5KSkge1xuICAgICAgdGhpcy5fYm9keUJsb2IgPSBib2R5XG4gICAgfSBlbHNlIGlmIChzdXBwb3J0LmZvcm1EYXRhICYmIEZvcm1EYXRhLnByb3RvdHlwZS5pc1Byb3RvdHlwZU9mKGJvZHkpKSB7XG4gICAgICB0aGlzLl9ib2R5Rm9ybURhdGEgPSBib2R5XG4gICAgfSBlbHNlIGlmIChzdXBwb3J0LnNlYXJjaFBhcmFtcyAmJiBVUkxTZWFyY2hQYXJhbXMucHJvdG90eXBlLmlzUHJvdG90eXBlT2YoYm9keSkpIHtcbiAgICAgIHRoaXMuX2JvZHlUZXh0ID0gYm9keS50b1N0cmluZygpXG4gICAgfSBlbHNlIGlmIChzdXBwb3J0LmFycmF5QnVmZmVyICYmIHN1cHBvcnQuYmxvYiAmJiBpc0RhdGFWaWV3KGJvZHkpKSB7XG4gICAgICB0aGlzLl9ib2R5QXJyYXlCdWZmZXIgPSBidWZmZXJDbG9uZShib2R5LmJ1ZmZlcilcbiAgICAgIC8vIElFIDEwLTExIGNhbid0IGhhbmRsZSBhIERhdGFWaWV3IGJvZHkuXG4gICAgICB0aGlzLl9ib2R5SW5pdCA9IG5ldyBCbG9iKFt0aGlzLl9ib2R5QXJyYXlCdWZmZXJdKVxuICAgIH0gZWxzZSBpZiAoc3VwcG9ydC5hcnJheUJ1ZmZlciAmJiAoQXJyYXlCdWZmZXIucHJvdG90eXBlLmlzUHJvdG90eXBlT2YoYm9keSkgfHwgaXNBcnJheUJ1ZmZlclZpZXcoYm9keSkpKSB7XG4gICAgICB0aGlzLl9ib2R5QXJyYXlCdWZmZXIgPSBidWZmZXJDbG9uZShib2R5KVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9ib2R5VGV4dCA9IGJvZHkgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoYm9keSlcbiAgICB9XG5cbiAgICBpZiAoIXRoaXMuaGVhZGVycy5nZXQoJ2NvbnRlbnQtdHlwZScpKSB7XG4gICAgICBpZiAodHlwZW9mIGJvZHkgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHRoaXMuaGVhZGVycy5zZXQoJ2NvbnRlbnQtdHlwZScsICd0ZXh0L3BsYWluO2NoYXJzZXQ9VVRGLTgnKVxuICAgICAgfSBlbHNlIGlmICh0aGlzLl9ib2R5QmxvYiAmJiB0aGlzLl9ib2R5QmxvYi50eXBlKSB7XG4gICAgICAgIHRoaXMuaGVhZGVycy5zZXQoJ2NvbnRlbnQtdHlwZScsIHRoaXMuX2JvZHlCbG9iLnR5cGUpXG4gICAgICB9IGVsc2UgaWYgKHN1cHBvcnQuc2VhcmNoUGFyYW1zICYmIFVSTFNlYXJjaFBhcmFtcy5wcm90b3R5cGUuaXNQcm90b3R5cGVPZihib2R5KSkge1xuICAgICAgICB0aGlzLmhlYWRlcnMuc2V0KCdjb250ZW50LXR5cGUnLCAnYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkO2NoYXJzZXQ9VVRGLTgnKVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGlmIChzdXBwb3J0LmJsb2IpIHtcbiAgICB0aGlzLmJsb2IgPSBmdW5jdGlvbigpIHtcbiAgICAgIHZhciByZWplY3RlZCA9IGNvbnN1bWVkKHRoaXMpXG4gICAgICBpZiAocmVqZWN0ZWQpIHtcbiAgICAgICAgcmV0dXJuIHJlamVjdGVkXG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLl9ib2R5QmxvYikge1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHRoaXMuX2JvZHlCbG9iKVxuICAgICAgfSBlbHNlIGlmICh0aGlzLl9ib2R5QXJyYXlCdWZmZXIpIHtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShuZXcgQmxvYihbdGhpcy5fYm9keUFycmF5QnVmZmVyXSkpXG4gICAgICB9IGVsc2UgaWYgKHRoaXMuX2JvZHlGb3JtRGF0YSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2NvdWxkIG5vdCByZWFkIEZvcm1EYXRhIGJvZHkgYXMgYmxvYicpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKG5ldyBCbG9iKFt0aGlzLl9ib2R5VGV4dF0pKVxuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMuYXJyYXlCdWZmZXIgPSBmdW5jdGlvbigpIHtcbiAgICAgIGlmICh0aGlzLl9ib2R5QXJyYXlCdWZmZXIpIHtcbiAgICAgICAgdmFyIGlzQ29uc3VtZWQgPSBjb25zdW1lZCh0aGlzKVxuICAgICAgICBpZiAoaXNDb25zdW1lZCkge1xuICAgICAgICAgIHJldHVybiBpc0NvbnN1bWVkXG4gICAgICAgIH1cbiAgICAgICAgaWYgKEFycmF5QnVmZmVyLmlzVmlldyh0aGlzLl9ib2R5QXJyYXlCdWZmZXIpKSB7XG4gICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShcbiAgICAgICAgICAgIHRoaXMuX2JvZHlBcnJheUJ1ZmZlci5idWZmZXIuc2xpY2UoXG4gICAgICAgICAgICAgIHRoaXMuX2JvZHlBcnJheUJ1ZmZlci5ieXRlT2Zmc2V0LFxuICAgICAgICAgICAgICB0aGlzLl9ib2R5QXJyYXlCdWZmZXIuYnl0ZU9mZnNldCArIHRoaXMuX2JvZHlBcnJheUJ1ZmZlci5ieXRlTGVuZ3RoXG4gICAgICAgICAgICApXG4gICAgICAgICAgKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUodGhpcy5fYm9keUFycmF5QnVmZmVyKVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gdGhpcy5ibG9iKCkudGhlbihyZWFkQmxvYkFzQXJyYXlCdWZmZXIpXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgdGhpcy50ZXh0ID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHJlamVjdGVkID0gY29uc3VtZWQodGhpcylcbiAgICBpZiAocmVqZWN0ZWQpIHtcbiAgICAgIHJldHVybiByZWplY3RlZFxuICAgIH1cblxuICAgIGlmICh0aGlzLl9ib2R5QmxvYikge1xuICAgICAgcmV0dXJuIHJlYWRCbG9iQXNUZXh0KHRoaXMuX2JvZHlCbG9iKVxuICAgIH0gZWxzZSBpZiAodGhpcy5fYm9keUFycmF5QnVmZmVyKSB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHJlYWRBcnJheUJ1ZmZlckFzVGV4dCh0aGlzLl9ib2R5QXJyYXlCdWZmZXIpKVxuICAgIH0gZWxzZSBpZiAodGhpcy5fYm9keUZvcm1EYXRhKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2NvdWxkIG5vdCByZWFkIEZvcm1EYXRhIGJvZHkgYXMgdGV4dCcpXG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUodGhpcy5fYm9keVRleHQpXG4gICAgfVxuICB9XG5cbiAgaWYgKHN1cHBvcnQuZm9ybURhdGEpIHtcbiAgICB0aGlzLmZvcm1EYXRhID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy50ZXh0KCkudGhlbihkZWNvZGUpXG4gICAgfVxuICB9XG5cbiAgdGhpcy5qc29uID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMudGV4dCgpLnRoZW4oSlNPTi5wYXJzZSlcbiAgfVxuXG4gIHJldHVybiB0aGlzXG59XG5cbi8vIEhUVFAgbWV0aG9kcyB3aG9zZSBjYXBpdGFsaXphdGlvbiBzaG91bGQgYmUgbm9ybWFsaXplZFxudmFyIG1ldGhvZHMgPSBbJ0RFTEVURScsICdHRVQnLCAnSEVBRCcsICdPUFRJT05TJywgJ1BPU1QnLCAnUFVUJ11cblxuZnVuY3Rpb24gbm9ybWFsaXplTWV0aG9kKG1ldGhvZCkge1xuICB2YXIgdXBjYXNlZCA9IG1ldGhvZC50b1VwcGVyQ2FzZSgpXG4gIHJldHVybiBtZXRob2RzLmluZGV4T2YodXBjYXNlZCkgPiAtMSA/IHVwY2FzZWQgOiBtZXRob2Rcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIFJlcXVlc3QoaW5wdXQsIG9wdGlvbnMpIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFJlcXVlc3QpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignUGxlYXNlIHVzZSB0aGUgXCJuZXdcIiBvcGVyYXRvciwgdGhpcyBET00gb2JqZWN0IGNvbnN0cnVjdG9yIGNhbm5vdCBiZSBjYWxsZWQgYXMgYSBmdW5jdGlvbi4nKVxuICB9XG5cbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge31cbiAgdmFyIGJvZHkgPSBvcHRpb25zLmJvZHlcblxuICBpZiAoaW5wdXQgaW5zdGFuY2VvZiBSZXF1ZXN0KSB7XG4gICAgaWYgKGlucHV0LmJvZHlVc2VkKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBbHJlYWR5IHJlYWQnKVxuICAgIH1cbiAgICB0aGlzLnVybCA9IGlucHV0LnVybFxuICAgIHRoaXMuY3JlZGVudGlhbHMgPSBpbnB1dC5jcmVkZW50aWFsc1xuICAgIGlmICghb3B0aW9ucy5oZWFkZXJzKSB7XG4gICAgICB0aGlzLmhlYWRlcnMgPSBuZXcgSGVhZGVycyhpbnB1dC5oZWFkZXJzKVxuICAgIH1cbiAgICB0aGlzLm1ldGhvZCA9IGlucHV0Lm1ldGhvZFxuICAgIHRoaXMubW9kZSA9IGlucHV0Lm1vZGVcbiAgICB0aGlzLnNpZ25hbCA9IGlucHV0LnNpZ25hbFxuICAgIGlmICghYm9keSAmJiBpbnB1dC5fYm9keUluaXQgIT0gbnVsbCkge1xuICAgICAgYm9keSA9IGlucHV0Ll9ib2R5SW5pdFxuICAgICAgaW5wdXQuYm9keVVzZWQgPSB0cnVlXG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHRoaXMudXJsID0gU3RyaW5nKGlucHV0KVxuICB9XG5cbiAgdGhpcy5jcmVkZW50aWFscyA9IG9wdGlvbnMuY3JlZGVudGlhbHMgfHwgdGhpcy5jcmVkZW50aWFscyB8fCAnc2FtZS1vcmlnaW4nXG4gIGlmIChvcHRpb25zLmhlYWRlcnMgfHwgIXRoaXMuaGVhZGVycykge1xuICAgIHRoaXMuaGVhZGVycyA9IG5ldyBIZWFkZXJzKG9wdGlvbnMuaGVhZGVycylcbiAgfVxuICB0aGlzLm1ldGhvZCA9IG5vcm1hbGl6ZU1ldGhvZChvcHRpb25zLm1ldGhvZCB8fCB0aGlzLm1ldGhvZCB8fCAnR0VUJylcbiAgdGhpcy5tb2RlID0gb3B0aW9ucy5tb2RlIHx8IHRoaXMubW9kZSB8fCBudWxsXG4gIHRoaXMuc2lnbmFsID0gb3B0aW9ucy5zaWduYWwgfHwgdGhpcy5zaWduYWxcbiAgdGhpcy5yZWZlcnJlciA9IG51bGxcblxuICBpZiAoKHRoaXMubWV0aG9kID09PSAnR0VUJyB8fCB0aGlzLm1ldGhvZCA9PT0gJ0hFQUQnKSAmJiBib2R5KSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQm9keSBub3QgYWxsb3dlZCBmb3IgR0VUIG9yIEhFQUQgcmVxdWVzdHMnKVxuICB9XG4gIHRoaXMuX2luaXRCb2R5KGJvZHkpXG5cbiAgaWYgKHRoaXMubWV0aG9kID09PSAnR0VUJyB8fCB0aGlzLm1ldGhvZCA9PT0gJ0hFQUQnKSB7XG4gICAgaWYgKG9wdGlvbnMuY2FjaGUgPT09ICduby1zdG9yZScgfHwgb3B0aW9ucy5jYWNoZSA9PT0gJ25vLWNhY2hlJykge1xuICAgICAgLy8gU2VhcmNoIGZvciBhICdfJyBwYXJhbWV0ZXIgaW4gdGhlIHF1ZXJ5IHN0cmluZ1xuICAgICAgdmFyIHJlUGFyYW1TZWFyY2ggPSAvKFs/Jl0pXz1bXiZdKi9cbiAgICAgIGlmIChyZVBhcmFtU2VhcmNoLnRlc3QodGhpcy51cmwpKSB7XG4gICAgICAgIC8vIElmIGl0IGFscmVhZHkgZXhpc3RzIHRoZW4gc2V0IHRoZSB2YWx1ZSB3aXRoIHRoZSBjdXJyZW50IHRpbWVcbiAgICAgICAgdGhpcy51cmwgPSB0aGlzLnVybC5yZXBsYWNlKHJlUGFyYW1TZWFyY2gsICckMV89JyArIG5ldyBEYXRlKCkuZ2V0VGltZSgpKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gT3RoZXJ3aXNlIGFkZCBhIG5ldyAnXycgcGFyYW1ldGVyIHRvIHRoZSBlbmQgd2l0aCB0aGUgY3VycmVudCB0aW1lXG4gICAgICAgIHZhciByZVF1ZXJ5U3RyaW5nID0gL1xcPy9cbiAgICAgICAgdGhpcy51cmwgKz0gKHJlUXVlcnlTdHJpbmcudGVzdCh0aGlzLnVybCkgPyAnJicgOiAnPycpICsgJ189JyArIG5ldyBEYXRlKCkuZ2V0VGltZSgpXG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cblJlcXVlc3QucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiBuZXcgUmVxdWVzdCh0aGlzLCB7Ym9keTogdGhpcy5fYm9keUluaXR9KVxufVxuXG5mdW5jdGlvbiBkZWNvZGUoYm9keSkge1xuICB2YXIgZm9ybSA9IG5ldyBGb3JtRGF0YSgpXG4gIGJvZHlcbiAgICAudHJpbSgpXG4gICAgLnNwbGl0KCcmJylcbiAgICAuZm9yRWFjaChmdW5jdGlvbihieXRlcykge1xuICAgICAgaWYgKGJ5dGVzKSB7XG4gICAgICAgIHZhciBzcGxpdCA9IGJ5dGVzLnNwbGl0KCc9JylcbiAgICAgICAgdmFyIG5hbWUgPSBzcGxpdC5zaGlmdCgpLnJlcGxhY2UoL1xcKy9nLCAnICcpXG4gICAgICAgIHZhciB2YWx1ZSA9IHNwbGl0LmpvaW4oJz0nKS5yZXBsYWNlKC9cXCsvZywgJyAnKVxuICAgICAgICBmb3JtLmFwcGVuZChkZWNvZGVVUklDb21wb25lbnQobmFtZSksIGRlY29kZVVSSUNvbXBvbmVudCh2YWx1ZSkpXG4gICAgICB9XG4gICAgfSlcbiAgcmV0dXJuIGZvcm1cbn1cblxuZnVuY3Rpb24gcGFyc2VIZWFkZXJzKHJhd0hlYWRlcnMpIHtcbiAgdmFyIGhlYWRlcnMgPSBuZXcgSGVhZGVycygpXG4gIC8vIFJlcGxhY2UgaW5zdGFuY2VzIG9mIFxcclxcbiBhbmQgXFxuIGZvbGxvd2VkIGJ5IGF0IGxlYXN0IG9uZSBzcGFjZSBvciBob3Jpem9udGFsIHRhYiB3aXRoIGEgc3BhY2VcbiAgLy8gaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzcyMzAjc2VjdGlvbi0zLjJcbiAgdmFyIHByZVByb2Nlc3NlZEhlYWRlcnMgPSByYXdIZWFkZXJzLnJlcGxhY2UoL1xccj9cXG5bXFx0IF0rL2csICcgJylcbiAgLy8gQXZvaWRpbmcgc3BsaXQgdmlhIHJlZ2V4IHRvIHdvcmsgYXJvdW5kIGEgY29tbW9uIElFMTEgYnVnIHdpdGggdGhlIGNvcmUtanMgMy42LjAgcmVnZXggcG9seWZpbGxcbiAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2dpdGh1Yi9mZXRjaC9pc3N1ZXMvNzQ4XG4gIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS96bG9pcm9jay9jb3JlLWpzL2lzc3Vlcy83NTFcbiAgcHJlUHJvY2Vzc2VkSGVhZGVyc1xuICAgIC5zcGxpdCgnXFxyJylcbiAgICAubWFwKGZ1bmN0aW9uKGhlYWRlcikge1xuICAgICAgcmV0dXJuIGhlYWRlci5pbmRleE9mKCdcXG4nKSA9PT0gMCA/IGhlYWRlci5zdWJzdHIoMSwgaGVhZGVyLmxlbmd0aCkgOiBoZWFkZXJcbiAgICB9KVxuICAgIC5mb3JFYWNoKGZ1bmN0aW9uKGxpbmUpIHtcbiAgICAgIHZhciBwYXJ0cyA9IGxpbmUuc3BsaXQoJzonKVxuICAgICAgdmFyIGtleSA9IHBhcnRzLnNoaWZ0KCkudHJpbSgpXG4gICAgICBpZiAoa2V5KSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IHBhcnRzLmpvaW4oJzonKS50cmltKClcbiAgICAgICAgaGVhZGVycy5hcHBlbmQoa2V5LCB2YWx1ZSlcbiAgICAgIH1cbiAgICB9KVxuICByZXR1cm4gaGVhZGVyc1xufVxuXG5Cb2R5LmNhbGwoUmVxdWVzdC5wcm90b3R5cGUpXG5cbmV4cG9ydCBmdW5jdGlvbiBSZXNwb25zZShib2R5SW5pdCwgb3B0aW9ucykge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgUmVzcG9uc2UpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignUGxlYXNlIHVzZSB0aGUgXCJuZXdcIiBvcGVyYXRvciwgdGhpcyBET00gb2JqZWN0IGNvbnN0cnVjdG9yIGNhbm5vdCBiZSBjYWxsZWQgYXMgYSBmdW5jdGlvbi4nKVxuICB9XG4gIGlmICghb3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSB7fVxuICB9XG5cbiAgdGhpcy50eXBlID0gJ2RlZmF1bHQnXG4gIHRoaXMuc3RhdHVzID0gb3B0aW9ucy5zdGF0dXMgPT09IHVuZGVmaW5lZCA/IDIwMCA6IG9wdGlvbnMuc3RhdHVzXG4gIHRoaXMub2sgPSB0aGlzLnN0YXR1cyA+PSAyMDAgJiYgdGhpcy5zdGF0dXMgPCAzMDBcbiAgdGhpcy5zdGF0dXNUZXh0ID0gb3B0aW9ucy5zdGF0dXNUZXh0ID09PSB1bmRlZmluZWQgPyAnJyA6ICcnICsgb3B0aW9ucy5zdGF0dXNUZXh0XG4gIHRoaXMuaGVhZGVycyA9IG5ldyBIZWFkZXJzKG9wdGlvbnMuaGVhZGVycylcbiAgdGhpcy51cmwgPSBvcHRpb25zLnVybCB8fCAnJ1xuICB0aGlzLl9pbml0Qm9keShib2R5SW5pdClcbn1cblxuQm9keS5jYWxsKFJlc3BvbnNlLnByb3RvdHlwZSlcblxuUmVzcG9uc2UucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiBuZXcgUmVzcG9uc2UodGhpcy5fYm9keUluaXQsIHtcbiAgICBzdGF0dXM6IHRoaXMuc3RhdHVzLFxuICAgIHN0YXR1c1RleHQ6IHRoaXMuc3RhdHVzVGV4dCxcbiAgICBoZWFkZXJzOiBuZXcgSGVhZGVycyh0aGlzLmhlYWRlcnMpLFxuICAgIHVybDogdGhpcy51cmxcbiAgfSlcbn1cblxuUmVzcG9uc2UuZXJyb3IgPSBmdW5jdGlvbigpIHtcbiAgdmFyIHJlc3BvbnNlID0gbmV3IFJlc3BvbnNlKG51bGwsIHtzdGF0dXM6IDAsIHN0YXR1c1RleHQ6ICcnfSlcbiAgcmVzcG9uc2UudHlwZSA9ICdlcnJvcidcbiAgcmV0dXJuIHJlc3BvbnNlXG59XG5cbnZhciByZWRpcmVjdFN0YXR1c2VzID0gWzMwMSwgMzAyLCAzMDMsIDMwNywgMzA4XVxuXG5SZXNwb25zZS5yZWRpcmVjdCA9IGZ1bmN0aW9uKHVybCwgc3RhdHVzKSB7XG4gIGlmIChyZWRpcmVjdFN0YXR1c2VzLmluZGV4T2Yoc3RhdHVzKSA9PT0gLTEpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignSW52YWxpZCBzdGF0dXMgY29kZScpXG4gIH1cblxuICByZXR1cm4gbmV3IFJlc3BvbnNlKG51bGwsIHtzdGF0dXM6IHN0YXR1cywgaGVhZGVyczoge2xvY2F0aW9uOiB1cmx9fSlcbn1cblxuZXhwb3J0IHZhciBET01FeGNlcHRpb24gPSBnbG9iYWwuRE9NRXhjZXB0aW9uXG50cnkge1xuICBuZXcgRE9NRXhjZXB0aW9uKClcbn0gY2F0Y2ggKGVycikge1xuICBET01FeGNlcHRpb24gPSBmdW5jdGlvbihtZXNzYWdlLCBuYW1lKSB7XG4gICAgdGhpcy5tZXNzYWdlID0gbWVzc2FnZVxuICAgIHRoaXMubmFtZSA9IG5hbWVcbiAgICB2YXIgZXJyb3IgPSBFcnJvcihtZXNzYWdlKVxuICAgIHRoaXMuc3RhY2sgPSBlcnJvci5zdGFja1xuICB9XG4gIERPTUV4Y2VwdGlvbi5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEVycm9yLnByb3RvdHlwZSlcbiAgRE9NRXhjZXB0aW9uLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IERPTUV4Y2VwdGlvblxufVxuXG5leHBvcnQgZnVuY3Rpb24gZmV0Y2goaW5wdXQsIGluaXQpIHtcbiAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkge1xuICAgIHZhciByZXF1ZXN0ID0gbmV3IFJlcXVlc3QoaW5wdXQsIGluaXQpXG5cbiAgICBpZiAocmVxdWVzdC5zaWduYWwgJiYgcmVxdWVzdC5zaWduYWwuYWJvcnRlZCkge1xuICAgICAgcmV0dXJuIHJlamVjdChuZXcgRE9NRXhjZXB0aW9uKCdBYm9ydGVkJywgJ0Fib3J0RXJyb3InKSlcbiAgICB9XG5cbiAgICB2YXIgeGhyID0gbmV3IFhNTEh0dHBSZXF1ZXN0KClcblxuICAgIGZ1bmN0aW9uIGFib3J0WGhyKCkge1xuICAgICAgeGhyLmFib3J0KClcbiAgICB9XG5cbiAgICB4aHIub25sb2FkID0gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgb3B0aW9ucyA9IHtcbiAgICAgICAgc3RhdHVzOiB4aHIuc3RhdHVzLFxuICAgICAgICBzdGF0dXNUZXh0OiB4aHIuc3RhdHVzVGV4dCxcbiAgICAgICAgaGVhZGVyczogcGFyc2VIZWFkZXJzKHhoci5nZXRBbGxSZXNwb25zZUhlYWRlcnMoKSB8fCAnJylcbiAgICAgIH1cbiAgICAgIG9wdGlvbnMudXJsID0gJ3Jlc3BvbnNlVVJMJyBpbiB4aHIgPyB4aHIucmVzcG9uc2VVUkwgOiBvcHRpb25zLmhlYWRlcnMuZ2V0KCdYLVJlcXVlc3QtVVJMJylcbiAgICAgIHZhciBib2R5ID0gJ3Jlc3BvbnNlJyBpbiB4aHIgPyB4aHIucmVzcG9uc2UgOiB4aHIucmVzcG9uc2VUZXh0XG4gICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICByZXNvbHZlKG5ldyBSZXNwb25zZShib2R5LCBvcHRpb25zKSlcbiAgICAgIH0sIDApXG4gICAgfVxuXG4gICAgeGhyLm9uZXJyb3IgPSBmdW5jdGlvbigpIHtcbiAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgIHJlamVjdChuZXcgVHlwZUVycm9yKCdOZXR3b3JrIHJlcXVlc3QgZmFpbGVkJykpXG4gICAgICB9LCAwKVxuICAgIH1cblxuICAgIHhoci5vbnRpbWVvdXQgPSBmdW5jdGlvbigpIHtcbiAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgIHJlamVjdChuZXcgVHlwZUVycm9yKCdOZXR3b3JrIHJlcXVlc3QgZmFpbGVkJykpXG4gICAgICB9LCAwKVxuICAgIH1cblxuICAgIHhoci5vbmFib3J0ID0gZnVuY3Rpb24oKSB7XG4gICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICByZWplY3QobmV3IERPTUV4Y2VwdGlvbignQWJvcnRlZCcsICdBYm9ydEVycm9yJykpXG4gICAgICB9LCAwKVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGZpeFVybCh1cmwpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHJldHVybiB1cmwgPT09ICcnICYmIGdsb2JhbC5sb2NhdGlvbi5ocmVmID8gZ2xvYmFsLmxvY2F0aW9uLmhyZWYgOiB1cmxcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgcmV0dXJuIHVybFxuICAgICAgfVxuICAgIH1cblxuICAgIHhoci5vcGVuKHJlcXVlc3QubWV0aG9kLCBmaXhVcmwocmVxdWVzdC51cmwpLCB0cnVlKVxuXG4gICAgaWYgKHJlcXVlc3QuY3JlZGVudGlhbHMgPT09ICdpbmNsdWRlJykge1xuICAgICAgeGhyLndpdGhDcmVkZW50aWFscyA9IHRydWVcbiAgICB9IGVsc2UgaWYgKHJlcXVlc3QuY3JlZGVudGlhbHMgPT09ICdvbWl0Jykge1xuICAgICAgeGhyLndpdGhDcmVkZW50aWFscyA9IGZhbHNlXG4gICAgfVxuXG4gICAgaWYgKCdyZXNwb25zZVR5cGUnIGluIHhocikge1xuICAgICAgaWYgKHN1cHBvcnQuYmxvYikge1xuICAgICAgICB4aHIucmVzcG9uc2VUeXBlID0gJ2Jsb2InXG4gICAgICB9IGVsc2UgaWYgKFxuICAgICAgICBzdXBwb3J0LmFycmF5QnVmZmVyICYmXG4gICAgICAgIHJlcXVlc3QuaGVhZGVycy5nZXQoJ0NvbnRlbnQtVHlwZScpICYmXG4gICAgICAgIHJlcXVlc3QuaGVhZGVycy5nZXQoJ0NvbnRlbnQtVHlwZScpLmluZGV4T2YoJ2FwcGxpY2F0aW9uL29jdGV0LXN0cmVhbScpICE9PSAtMVxuICAgICAgKSB7XG4gICAgICAgIHhoci5yZXNwb25zZVR5cGUgPSAnYXJyYXlidWZmZXInXG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGluaXQgJiYgdHlwZW9mIGluaXQuaGVhZGVycyA9PT0gJ29iamVjdCcgJiYgIShpbml0LmhlYWRlcnMgaW5zdGFuY2VvZiBIZWFkZXJzKSkge1xuICAgICAgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoaW5pdC5oZWFkZXJzKS5mb3JFYWNoKGZ1bmN0aW9uKG5hbWUpIHtcbiAgICAgICAgeGhyLnNldFJlcXVlc3RIZWFkZXIobmFtZSwgbm9ybWFsaXplVmFsdWUoaW5pdC5oZWFkZXJzW25hbWVdKSlcbiAgICAgIH0pXG4gICAgfSBlbHNlIHtcbiAgICAgIHJlcXVlc3QuaGVhZGVycy5mb3JFYWNoKGZ1bmN0aW9uKHZhbHVlLCBuYW1lKSB7XG4gICAgICAgIHhoci5zZXRSZXF1ZXN0SGVhZGVyKG5hbWUsIHZhbHVlKVxuICAgICAgfSlcbiAgICB9XG5cbiAgICBpZiAocmVxdWVzdC5zaWduYWwpIHtcbiAgICAgIHJlcXVlc3Quc2lnbmFsLmFkZEV2ZW50TGlzdGVuZXIoJ2Fib3J0JywgYWJvcnRYaHIpXG5cbiAgICAgIHhoci5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgLy8gRE9ORSAoc3VjY2VzcyBvciBmYWlsdXJlKVxuICAgICAgICBpZiAoeGhyLnJlYWR5U3RhdGUgPT09IDQpIHtcbiAgICAgICAgICByZXF1ZXN0LnNpZ25hbC5yZW1vdmVFdmVudExpc3RlbmVyKCdhYm9ydCcsIGFib3J0WGhyKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgeGhyLnNlbmQodHlwZW9mIHJlcXVlc3QuX2JvZHlJbml0ID09PSAndW5kZWZpbmVkJyA/IG51bGwgOiByZXF1ZXN0Ll9ib2R5SW5pdClcbiAgfSlcbn1cblxuZmV0Y2gucG9seWZpbGwgPSB0cnVlXG5cbmlmICghZ2xvYmFsLmZldGNoKSB7XG4gIGdsb2JhbC5mZXRjaCA9IGZldGNoXG4gIGdsb2JhbC5IZWFkZXJzID0gSGVhZGVyc1xuICBnbG9iYWwuUmVxdWVzdCA9IFJlcXVlc3RcbiAgZ2xvYmFsLlJlc3BvbnNlID0gUmVzcG9uc2Vcbn1cbiIsImV4cG9ydCB2YXIgTUFYX0RFQ0lNQUxTID0gNjtcbmV4cG9ydCB2YXIgREVGQVVMVF9CTEVORF9TVEVQUyA9IDU7XG4iLCJleHBvcnQgdmFyIENvbG9yTW9kZWw7XG4oZnVuY3Rpb24gKENvbG9yTW9kZWwpIHtcbiAgICBDb2xvck1vZGVsW1wiSEVYXCJdID0gXCJIRVhcIjtcbiAgICBDb2xvck1vZGVsW1wiUkdCXCJdID0gXCJSR0JcIjtcbiAgICBDb2xvck1vZGVsW1wiSFNMXCJdID0gXCJIU0xcIjtcbiAgICBDb2xvck1vZGVsW1wiQ01ZS1wiXSA9IFwiQ01ZS1wiO1xufSkoQ29sb3JNb2RlbCB8fCAoQ29sb3JNb2RlbCA9IHt9KSk7XG5leHBvcnQgdmFyIEhhcm1vbnk7XG4oZnVuY3Rpb24gKEhhcm1vbnkpIHtcbiAgICBIYXJtb255W1wiQU5BTE9HT1VTXCJdID0gXCJBTkFMT0dPVVNcIjtcbiAgICBIYXJtb255W1wiQ09NUExFTUVOVEFSWVwiXSA9IFwiQ09NUExFTUVOVEFSWVwiO1xuICAgIEhhcm1vbnlbXCJTUExJVF9DT01QTEVNRU5UQVJZXCJdID0gXCJTUExJVF9DT01QTEVNRU5UQVJZXCI7XG4gICAgSGFybW9ueVtcIlRSSUFESUNcIl0gPSBcIlRSSUFESUNcIjtcbiAgICBIYXJtb255W1wiVEVUUkFESUNcIl0gPSBcIlRFVFJBRElDXCI7XG4gICAgSGFybW9ueVtcIlNRVUFSRVwiXSA9IFwiU1FVQVJFXCI7XG59KShIYXJtb255IHx8IChIYXJtb255ID0ge30pKTtcbmV4cG9ydCB2YXIgTWl4O1xuKGZ1bmN0aW9uIChNaXgpIHtcbiAgICBNaXhbXCJBRERJVElWRVwiXSA9IFwiQURESVRJVkVcIjtcbiAgICBNaXhbXCJTVUJUUkFDVElWRVwiXSA9IFwiU1VCVFJBQ1RJVkVcIjtcbn0pKE1peCB8fCAoTWl4ID0ge30pKTtcbmV4cG9ydCB2YXIgQ29sb3JLZXl3b3JkcztcbihmdW5jdGlvbiAoQ29sb3JLZXl3b3Jkcykge1xuICAgIENvbG9yS2V5d29yZHNbXCJibGFja1wiXSA9IFwiIzAwMDAwMFwiO1xuICAgIENvbG9yS2V5d29yZHNbXCJzaWx2ZXJcIl0gPSBcIiNDMEMwQzBcIjtcbiAgICBDb2xvcktleXdvcmRzW1wiZ3JheVwiXSA9IFwiIzgwODA4MFwiO1xuICAgIENvbG9yS2V5d29yZHNbXCJ3aGl0ZVwiXSA9IFwiI0ZGRkZGRlwiO1xuICAgIENvbG9yS2V5d29yZHNbXCJtYXJvb25cIl0gPSBcIiM4MDAwMDBcIjtcbiAgICBDb2xvcktleXdvcmRzW1wicmVkXCJdID0gXCIjRkYwMDAwXCI7XG4gICAgQ29sb3JLZXl3b3Jkc1tcInB1cnBsZVwiXSA9IFwiIzgwMDA4MFwiO1xuICAgIENvbG9yS2V5d29yZHNbXCJmdWNoc2lhXCJdID0gXCIjRkYwMEZGXCI7XG4gICAgQ29sb3JLZXl3b3Jkc1tcImdyZWVuXCJdID0gXCIjMDA4MDAwXCI7XG4gICAgQ29sb3JLZXl3b3Jkc1tcImxpbWVcIl0gPSBcIiMwMEZGMDBcIjtcbiAgICBDb2xvcktleXdvcmRzW1wib2xpdmVcIl0gPSBcIiM4MDgwMDBcIjtcbiAgICBDb2xvcktleXdvcmRzW1wieWVsbG93XCJdID0gXCIjRkZGRjAwXCI7XG4gICAgQ29sb3JLZXl3b3Jkc1tcIm5hdnlcIl0gPSBcIiMwMDAwODBcIjtcbiAgICBDb2xvcktleXdvcmRzW1wiYmx1ZVwiXSA9IFwiIzAwMDBGRlwiO1xuICAgIENvbG9yS2V5d29yZHNbXCJ0ZWFsXCJdID0gXCIjMDA4MDgwXCI7XG4gICAgQ29sb3JLZXl3b3Jkc1tcImFxdWFcIl0gPSBcIiMwMEZGRkZcIjtcbiAgICBDb2xvcktleXdvcmRzW1wib3JhbmdlXCJdID0gXCIjRkZBNTAwXCI7XG4gICAgQ29sb3JLZXl3b3Jkc1tcImFsaWNlYmx1ZVwiXSA9IFwiI0YwRjhGRlwiO1xuICAgIENvbG9yS2V5d29yZHNbXCJhbnRpcXVld2hpdGVcIl0gPSBcIiNGQUVCRDdcIjtcbiAgICBDb2xvcktleXdvcmRzW1wiYXF1YW1hcmluZVwiXSA9IFwiIzdGRkZENFwiO1xuICAgIENvbG9yS2V5d29yZHNbXCJhenVyZVwiXSA9IFwiI0YwRkZGRlwiO1xuICAgIENvbG9yS2V5d29yZHNbXCJiZWlnZVwiXSA9IFwiI0Y1RjVEQ1wiO1xuICAgIENvbG9yS2V5d29yZHNbXCJiaXNxdWVcIl0gPSBcIiNGRkU0QzRcIjtcbiAgICBDb2xvcktleXdvcmRzW1wiYmxhbmNoZWRhbG1vbmRcIl0gPSBcIiNGRkVCQ0RcIjtcbiAgICBDb2xvcktleXdvcmRzW1wiYmx1ZXZpb2xldFwiXSA9IFwiIzhBMkJFMlwiO1xuICAgIENvbG9yS2V5d29yZHNbXCJicm93blwiXSA9IFwiI0E1MkEyQVwiO1xuICAgIENvbG9yS2V5d29yZHNbXCJidXJseXdvb2RcIl0gPSBcIiNERUI4ODdcIjtcbiAgICBDb2xvcktleXdvcmRzW1wiY2FkZXRibHVlXCJdID0gXCIjNUY5RUEwXCI7XG4gICAgQ29sb3JLZXl3b3Jkc1tcImNoYXJ0cmV1c2VcIl0gPSBcIiM3RkZGMDBcIjtcbiAgICBDb2xvcktleXdvcmRzW1wiY2hvY29sYXRlXCJdID0gXCIjRDI2OTFFXCI7XG4gICAgQ29sb3JLZXl3b3Jkc1tcImNvcmFsXCJdID0gXCIjRkY3RjUwXCI7XG4gICAgQ29sb3JLZXl3b3Jkc1tcImNvcm5mbG93ZXJibHVlXCJdID0gXCIjNjQ5NUVEXCI7XG4gICAgQ29sb3JLZXl3b3Jkc1tcImNvcm5zaWxrXCJdID0gXCIjRkZGOERDXCI7XG4gICAgQ29sb3JLZXl3b3Jkc1tcImNyaW1zb25cIl0gPSBcIiNEQzE0M0NcIjtcbiAgICBDb2xvcktleXdvcmRzW1wiY3lhblwiXSA9IFwiIzAwRkZGRlwiO1xuICAgIENvbG9yS2V5d29yZHNbXCJkYXJrYmx1ZVwiXSA9IFwiIzAwMDA4QlwiO1xuICAgIENvbG9yS2V5d29yZHNbXCJkYXJrY3lhblwiXSA9IFwiIzAwOEI4QlwiO1xuICAgIENvbG9yS2V5d29yZHNbXCJkYXJrZ29sZGVucm9kXCJdID0gXCIjQjg4NjBCXCI7XG4gICAgQ29sb3JLZXl3b3Jkc1tcImRhcmtncmF5XCJdID0gXCIjQTlBOUE5XCI7XG4gICAgQ29sb3JLZXl3b3Jkc1tcImRhcmtncmVlblwiXSA9IFwiIzAwNjQwMFwiO1xuICAgIENvbG9yS2V5d29yZHNbXCJkYXJrZ3JleVwiXSA9IFwiI0E5QTlBOVwiO1xuICAgIENvbG9yS2V5d29yZHNbXCJkYXJra2hha2lcIl0gPSBcIiNCREI3NkJcIjtcbiAgICBDb2xvcktleXdvcmRzW1wiZGFya21hZ2VudGFcIl0gPSBcIiM4QjAwOEJcIjtcbiAgICBDb2xvcktleXdvcmRzW1wiZGFya29saXZlZ3JlZW5cIl0gPSBcIiM1NTZCMkZcIjtcbiAgICBDb2xvcktleXdvcmRzW1wiZGFya29yYW5nZVwiXSA9IFwiI0ZGOEMwMFwiO1xuICAgIENvbG9yS2V5d29yZHNbXCJkYXJrb3JjaGlkXCJdID0gXCIjOTkzMkNDXCI7XG4gICAgQ29sb3JLZXl3b3Jkc1tcImRhcmtyZWRcIl0gPSBcIiM4QjAwMDBcIjtcbiAgICBDb2xvcktleXdvcmRzW1wiZGFya3NhbG1vblwiXSA9IFwiI0U5OTY3QVwiO1xuICAgIENvbG9yS2V5d29yZHNbXCJkYXJrc2VhZ3JlZW5cIl0gPSBcIiM4RkJDOEZcIjtcbiAgICBDb2xvcktleXdvcmRzW1wiZGFya3NsYXRlYmx1ZVwiXSA9IFwiIzQ4M0Q4QlwiO1xuICAgIENvbG9yS2V5d29yZHNbXCJkYXJrc2xhdGVncmF5XCJdID0gXCIjMkY0RjRGXCI7XG4gICAgQ29sb3JLZXl3b3Jkc1tcImRhcmtzbGF0ZWdyZXlcIl0gPSBcIiMyRjRGNEZcIjtcbiAgICBDb2xvcktleXdvcmRzW1wiZGFya3R1cnF1b2lzZVwiXSA9IFwiIzAwQ0VEMVwiO1xuICAgIENvbG9yS2V5d29yZHNbXCJkYXJrdmlvbGV0XCJdID0gXCIjOTQwMEQzXCI7XG4gICAgQ29sb3JLZXl3b3Jkc1tcImRlZXBwaW5rXCJdID0gXCIjRkYxNDkzXCI7XG4gICAgQ29sb3JLZXl3b3Jkc1tcImRlZXBza3libHVlXCJdID0gXCIjMDBCRkZGXCI7XG4gICAgQ29sb3JLZXl3b3Jkc1tcImRpbWdyYXlcIl0gPSBcIiM2OTY5NjlcIjtcbiAgICBDb2xvcktleXdvcmRzW1wiZGltZ3JleVwiXSA9IFwiIzY5Njk2OVwiO1xuICAgIENvbG9yS2V5d29yZHNbXCJkb2RnZXJibHVlXCJdID0gXCIjMUU5MEZGXCI7XG4gICAgQ29sb3JLZXl3b3Jkc1tcImZpcmVicmlja1wiXSA9IFwiI0IyMjIyMlwiO1xuICAgIENvbG9yS2V5d29yZHNbXCJmbG9yYWx3aGl0ZVwiXSA9IFwiI0ZGRkFGMFwiO1xuICAgIENvbG9yS2V5d29yZHNbXCJmb3Jlc3RncmVlblwiXSA9IFwiIzIyOEIyMlwiO1xuICAgIENvbG9yS2V5d29yZHNbXCJnYWluc2Jvcm9cIl0gPSBcIiNEQ0RDRENcIjtcbiAgICBDb2xvcktleXdvcmRzW1wiZ2hvc3R3aGl0ZVwiXSA9IFwiI0Y4RjhGRlwiO1xuICAgIENvbG9yS2V5d29yZHNbXCJnb2xkXCJdID0gXCIjRkZENzAwXCI7XG4gICAgQ29sb3JLZXl3b3Jkc1tcImdvbGRlbnJvZFwiXSA9IFwiI0RBQTUyMFwiO1xuICAgIENvbG9yS2V5d29yZHNbXCJncmVlbnllbGxvd1wiXSA9IFwiI0FERkYyRlwiO1xuICAgIENvbG9yS2V5d29yZHNbXCJncmV5XCJdID0gXCIjODA4MDgwXCI7XG4gICAgQ29sb3JLZXl3b3Jkc1tcImhvbmV5ZGV3XCJdID0gXCIjRjBGRkYwXCI7XG4gICAgQ29sb3JLZXl3b3Jkc1tcImhvdHBpbmtcIl0gPSBcIiNGRjY5QjRcIjtcbiAgICBDb2xvcktleXdvcmRzW1wiaW5kaWFucmVkXCJdID0gXCIjQ0Q1QzVDXCI7XG4gICAgQ29sb3JLZXl3b3Jkc1tcImluZGlnb1wiXSA9IFwiIzRCMDA4MlwiO1xuICAgIENvbG9yS2V5d29yZHNbXCJpdm9yeVwiXSA9IFwiI0ZGRkZGMFwiO1xuICAgIENvbG9yS2V5d29yZHNbXCJraGFraVwiXSA9IFwiI0YwRTY4Q1wiO1xuICAgIENvbG9yS2V5d29yZHNbXCJsYXZlbmRlclwiXSA9IFwiI0U2RTZGQVwiO1xuICAgIENvbG9yS2V5d29yZHNbXCJsYXZlbmRlcmJsdXNoXCJdID0gXCIjRkZGMEY1XCI7XG4gICAgQ29sb3JLZXl3b3Jkc1tcImxhd25ncmVlblwiXSA9IFwiIzdDRkMwMFwiO1xuICAgIENvbG9yS2V5d29yZHNbXCJsZW1vbmNoaWZmb25cIl0gPSBcIiNGRkZBQ0RcIjtcbiAgICBDb2xvcktleXdvcmRzW1wibGlnaHRibHVlXCJdID0gXCIjQUREOEU2XCI7XG4gICAgQ29sb3JLZXl3b3Jkc1tcImxpZ2h0Y29yYWxcIl0gPSBcIiNGMDgwODBcIjtcbiAgICBDb2xvcktleXdvcmRzW1wibGlnaHRjeWFuXCJdID0gXCIjRTBGRkZGXCI7XG4gICAgQ29sb3JLZXl3b3Jkc1tcImxpZ2h0Z29sZGVucm9keWVsbG93XCJdID0gXCIjRkFGQUQyXCI7XG4gICAgQ29sb3JLZXl3b3Jkc1tcImxpZ2h0Z3JheVwiXSA9IFwiI0QzRDNEM1wiO1xuICAgIENvbG9yS2V5d29yZHNbXCJsaWdodGdyZWVuXCJdID0gXCIjOTBFRTkwXCI7XG4gICAgQ29sb3JLZXl3b3Jkc1tcImxpZ2h0Z3JleVwiXSA9IFwiI0QzRDNEM1wiO1xuICAgIENvbG9yS2V5d29yZHNbXCJsaWdodHBpbmtcIl0gPSBcIiNGRkI2QzFcIjtcbiAgICBDb2xvcktleXdvcmRzW1wibGlnaHRzYWxtb25cIl0gPSBcIiNGRkEwN0FcIjtcbiAgICBDb2xvcktleXdvcmRzW1wibGlnaHRzZWFncmVlblwiXSA9IFwiIzIwQjJBQVwiO1xuICAgIENvbG9yS2V5d29yZHNbXCJsaWdodHNreWJsdWVcIl0gPSBcIiM4N0NFRkFcIjtcbiAgICBDb2xvcktleXdvcmRzW1wibGlnaHRzbGF0ZWdyYXlcIl0gPSBcIiM3Nzg4OTlcIjtcbiAgICBDb2xvcktleXdvcmRzW1wibGlnaHRzbGF0ZWdyZXlcIl0gPSBcIiM3Nzg4OTlcIjtcbiAgICBDb2xvcktleXdvcmRzW1wibGlnaHRzdGVlbGJsdWVcIl0gPSBcIiNCMEM0REVcIjtcbiAgICBDb2xvcktleXdvcmRzW1wibGlnaHR5ZWxsb3dcIl0gPSBcIiNGRkZGRTBcIjtcbiAgICBDb2xvcktleXdvcmRzW1wibGltZWdyZWVuXCJdID0gXCIjMzJDRDMyXCI7XG4gICAgQ29sb3JLZXl3b3Jkc1tcImxpbmVuXCJdID0gXCIjRkFGMEU2XCI7XG4gICAgQ29sb3JLZXl3b3Jkc1tcIm1hZ2VudGFcIl0gPSBcIiNGRjAwRkZcIjtcbiAgICBDb2xvcktleXdvcmRzW1wibWVkaXVtYXF1YW1hcmluZVwiXSA9IFwiIzY2Q0RBQVwiO1xuICAgIENvbG9yS2V5d29yZHNbXCJtZWRpdW1ibHVlXCJdID0gXCIjMDAwMENEXCI7XG4gICAgQ29sb3JLZXl3b3Jkc1tcIm1lZGl1bW9yY2hpZFwiXSA9IFwiI0JBNTVEM1wiO1xuICAgIENvbG9yS2V5d29yZHNbXCJtZWRpdW1wdXJwbGVcIl0gPSBcIiM5MzcwREJcIjtcbiAgICBDb2xvcktleXdvcmRzW1wibWVkaXVtc2VhZ3JlZW5cIl0gPSBcIiMzQ0IzNzFcIjtcbiAgICBDb2xvcktleXdvcmRzW1wibWVkaXVtc2xhdGVibHVlXCJdID0gXCIjN0I2OEVFXCI7XG4gICAgQ29sb3JLZXl3b3Jkc1tcIm1lZGl1bXNwcmluZ2dyZWVuXCJdID0gXCIjMDBGQTlBXCI7XG4gICAgQ29sb3JLZXl3b3Jkc1tcIm1lZGl1bXR1cnF1b2lzZVwiXSA9IFwiIzQ4RDFDQ1wiO1xuICAgIENvbG9yS2V5d29yZHNbXCJtZWRpdW12aW9sZXRyZWRcIl0gPSBcIiNDNzE1ODVcIjtcbiAgICBDb2xvcktleXdvcmRzW1wibWlkbmlnaHRibHVlXCJdID0gXCIjMTkxOTcwXCI7XG4gICAgQ29sb3JLZXl3b3Jkc1tcIm1pbnRjcmVhbVwiXSA9IFwiI0Y1RkZGQVwiO1xuICAgIENvbG9yS2V5d29yZHNbXCJtaXN0eXJvc2VcIl0gPSBcIiNGRkU0RTFcIjtcbiAgICBDb2xvcktleXdvcmRzW1wibW9jY2FzaW5cIl0gPSBcIiNGRkU0QjVcIjtcbiAgICBDb2xvcktleXdvcmRzW1wibmF2YWpvd2hpdGVcIl0gPSBcIiNGRkRFQURcIjtcbiAgICBDb2xvcktleXdvcmRzW1wib2xkbGFjZVwiXSA9IFwiI0ZERjVFNlwiO1xuICAgIENvbG9yS2V5d29yZHNbXCJvbGl2ZWRyYWJcIl0gPSBcIiM2QjhFMjNcIjtcbiAgICBDb2xvcktleXdvcmRzW1wib3JhbmdlcmVkXCJdID0gXCIjRkY0NTAwXCI7XG4gICAgQ29sb3JLZXl3b3Jkc1tcIm9yY2hpZFwiXSA9IFwiI0RBNzBENlwiO1xuICAgIENvbG9yS2V5d29yZHNbXCJwYWxlZ29sZGVucm9kXCJdID0gXCIjRUVFOEFBXCI7XG4gICAgQ29sb3JLZXl3b3Jkc1tcInBhbGVncmVlblwiXSA9IFwiIzk4RkI5OFwiO1xuICAgIENvbG9yS2V5d29yZHNbXCJwYWxldHVycXVvaXNlXCJdID0gXCIjQUZFRUVFXCI7XG4gICAgQ29sb3JLZXl3b3Jkc1tcInBhbGV2aW9sZXRyZWRcIl0gPSBcIiNEQjcwOTNcIjtcbiAgICBDb2xvcktleXdvcmRzW1wicGFwYXlhd2hpcFwiXSA9IFwiI0ZGRUZENVwiO1xuICAgIENvbG9yS2V5d29yZHNbXCJwZWFjaHB1ZmZcIl0gPSBcIiNGRkRBQjlcIjtcbiAgICBDb2xvcktleXdvcmRzW1wicGVydVwiXSA9IFwiI0NEODUzRlwiO1xuICAgIENvbG9yS2V5d29yZHNbXCJwaW5rXCJdID0gXCIjRkZDMENCXCI7XG4gICAgQ29sb3JLZXl3b3Jkc1tcInBsdW1cIl0gPSBcIiNEREEwRERcIjtcbiAgICBDb2xvcktleXdvcmRzW1wicG93ZGVyYmx1ZVwiXSA9IFwiI0IwRTBFNlwiO1xuICAgIENvbG9yS2V5d29yZHNbXCJyb3N5YnJvd25cIl0gPSBcIiNCQzhGOEZcIjtcbiAgICBDb2xvcktleXdvcmRzW1wicm95YWxibHVlXCJdID0gXCIjNDE2OUUxXCI7XG4gICAgQ29sb3JLZXl3b3Jkc1tcInNhZGRsZWJyb3duXCJdID0gXCIjOEI0NTEzXCI7XG4gICAgQ29sb3JLZXl3b3Jkc1tcInNhbG1vblwiXSA9IFwiI0ZBODA3MlwiO1xuICAgIENvbG9yS2V5d29yZHNbXCJzYW5keWJyb3duXCJdID0gXCIjRjRBNDYwXCI7XG4gICAgQ29sb3JLZXl3b3Jkc1tcInNlYWdyZWVuXCJdID0gXCIjMkU4QjU3XCI7XG4gICAgQ29sb3JLZXl3b3Jkc1tcInNlYXNoZWxsXCJdID0gXCIjRkZGNUVFXCI7XG4gICAgQ29sb3JLZXl3b3Jkc1tcInNpZW5uYVwiXSA9IFwiI0EwNTIyRFwiO1xuICAgIENvbG9yS2V5d29yZHNbXCJza3libHVlXCJdID0gXCIjODdDRUVCXCI7XG4gICAgQ29sb3JLZXl3b3Jkc1tcInNsYXRlYmx1ZVwiXSA9IFwiIzZBNUFDRFwiO1xuICAgIENvbG9yS2V5d29yZHNbXCJzbGF0ZWdyYXlcIl0gPSBcIiM3MDgwOTBcIjtcbiAgICBDb2xvcktleXdvcmRzW1wic2xhdGVncmV5XCJdID0gXCIjNzA4MDkwXCI7XG4gICAgQ29sb3JLZXl3b3Jkc1tcInNub3dcIl0gPSBcIiNGRkZBRkFcIjtcbiAgICBDb2xvcktleXdvcmRzW1wic3ByaW5nZ3JlZW5cIl0gPSBcIiMwMEZGN0ZcIjtcbiAgICBDb2xvcktleXdvcmRzW1wic3RlZWxibHVlXCJdID0gXCIjNDY4MkI0XCI7XG4gICAgQ29sb3JLZXl3b3Jkc1tcInRhblwiXSA9IFwiI0QyQjQ4Q1wiO1xuICAgIENvbG9yS2V5d29yZHNbXCJ0aGlzdGxlXCJdID0gXCIjRDhCRkQ4XCI7XG4gICAgQ29sb3JLZXl3b3Jkc1tcInRvbWF0b1wiXSA9IFwiI0ZGNjM0N1wiO1xuICAgIENvbG9yS2V5d29yZHNbXCJ0dXJxdW9pc2VcIl0gPSBcIiM0MEUwRDBcIjtcbiAgICBDb2xvcktleXdvcmRzW1widmlvbGV0XCJdID0gXCIjRUU4MkVFXCI7XG4gICAgQ29sb3JLZXl3b3Jkc1tcIndoZWF0XCJdID0gXCIjRjVERUIzXCI7XG4gICAgQ29sb3JLZXl3b3Jkc1tcIndoaXRlc21va2VcIl0gPSBcIiNGNUY1RjVcIjtcbiAgICBDb2xvcktleXdvcmRzW1wieWVsbG93Z3JlZW5cIl0gPSBcIiM5QUNEMzJcIjtcbiAgICBDb2xvcktleXdvcmRzW1wicmViZWNjYXB1cnBsZVwiXSA9IFwiIzY2MzM5OVwiO1xufSkoQ29sb3JLZXl3b3JkcyB8fCAoQ29sb3JLZXl3b3JkcyA9IHt9KSk7XG5leHBvcnQgdmFyIENPTE9SX0tFWVMgPSBPYmplY3Qua2V5cyhDb2xvcktleXdvcmRzKTtcbmV4cG9ydCB2YXIgQ09MT1JfUFJPUFMgPSB7XG4gICAgSEVYOiBbJ3InLCAnZycsICdiJywgJ2EnXSxcbiAgICBSR0I6IFsncicsICdnJywgJ2InLCAnYSddLFxuICAgIEhTTDogWydoJywgJ3MnLCAnbCcsICdhJ10sXG4gICAgQ01ZSzogWydjJywgJ20nLCAneScsICdrJywgJ2EnXVxufTtcbmV4cG9ydCB2YXIgVkFMSURfQ09MT1JfT0JKRUNUUyA9IHtcbiAgICBCR1I6IENvbG9yTW9kZWwuUkdCLFxuICAgIEFCR1I6IENvbG9yTW9kZWwuUkdCLFxuICAgIEhMUzogQ29sb3JNb2RlbC5IU0wsXG4gICAgQUhMUzogQ29sb3JNb2RlbC5IU0wsXG4gICAgQ0tNWTogQ29sb3JNb2RlbC5DTVlLLFxuICAgIEFDS01ZOiBDb2xvck1vZGVsLkNNWUtcbn07XG5leHBvcnQgdmFyIFR5cGVPZjtcbihmdW5jdGlvbiAoVHlwZU9mKSB7XG4gICAgVHlwZU9mW1wiTlVNQkVSXCJdID0gXCJudW1iZXJcIjtcbiAgICBUeXBlT2ZbXCJCT09MRUFOXCJdID0gXCJib29sZWFuXCI7XG59KShUeXBlT2YgfHwgKFR5cGVPZiA9IHt9KSk7XG4iLCJ2YXIgX2E7XG5pbXBvcnQgeyBDb2xvck1vZGVsIH0gZnJvbSAnLi9lbnVtcyc7XG5leHBvcnQgdmFyIENPTE9SUkVHUyA9IChfYSA9IHt9LFxuICAgIF9hW0NvbG9yTW9kZWwuSEVYXSA9IC9eIyg/OihbYS1mXFxkXSkoW2EtZlxcZF0pKFthLWZcXGRdKShbYS1mXFxkXSk/fChbYS1mXFxkXXsyfSkoW2EtZlxcZF17Mn0pKFthLWZcXGRdezJ9KShbYS1mXFxkXXsyfSk/KSQvaSxcbiAgICBfYVtDb2xvck1vZGVsLlJHQl0gPSAvXnJnYmE/XFxzKlxcKFxccyooPzooKD86XFxkKlxcLik/XFxkKyU/KVxccyosXFxzKigoPzpcXGQqXFwuKT9cXGQrJT8pXFxzKixcXHMqKCg/OlxcZCpcXC4pP1xcZCslPykoPzpcXHMqLFxccyooKD86XFxkKlxcLik/XFxkKykpP3woKD86XFxkKlxcLik/XFxkKyU/KVxccyooKD86XFxkKlxcLik/XFxkKyU/KVxccyooKD86XFxkKlxcLik/XFxkKyU/KSg/OlxccypcXC9cXHMqKCg/OlxcZCpcXC4pP1xcZCslPykpPylcXHMqXFwpJC8sXG4gICAgX2FbQ29sb3JNb2RlbC5IU0xdID0gL15oc2xhP1xccypcXChcXHMqKD86KC0/KD86XFxkKlxcLik/XFxkKyg/OmRlZ3xncmFkfHJhZHx0dXJuKT8pXFxzKixcXHMqKCg/OlxcZCpcXC4pP1xcZCspJVxccyosXFxzKigoPzpcXGQqXFwuKT9cXGQrKSUoPzpcXHMqLFxccyooKD86XFxkKlxcLik/XFxkKykpP3woLT8oPzpcXGQqXFwuKT9cXGQrKD86ZGVnfGdyYWR8cmFkfHR1cm4pPylcXHMqKCg/OlxcZCpcXC4pP1xcZCspJVxccyooKD86XFxkKlxcLik/XFxkKyklKD86XFxzKlxcL1xccyooKD86XFxkKlxcLik/XFxkKyU/KSk/KVxccypcXCkkLyxcbiAgICBfYVtDb2xvck1vZGVsLkNNWUtdID0gL14oPzpkZXZpY2UtY215a3xjbXlrKVxccypcXChcXHMqKD86KCg/OlxcZCpcXC4pP1xcZCslPylcXHMqLFxccyooKD86XFxkKlxcLik/XFxkKyU/KVxccyosXFxzKigoPzpcXGQqXFwuKT9cXGQrJT8pXFxzKixcXHMqKCg/OlxcZCpcXC4pP1xcZCslPykoPzpcXHMqLFxccyooKD86XFxkKlxcLik/XFxkKykpP3woKD86XFxkKlxcLik/XFxkKyU/KVxccyooKD86XFxkKlxcLik/XFxkKyU/KVxccyooKD86XFxkKlxcLik/XFxkKyU/KVxccyooKD86XFxkKlxcLik/XFxkKyU/KSg/OlxccypcXC9cXHMqKCg/OlxcZCpcXC4pP1xcZCslPykpPylcXHMqXFwpJC8sXG4gICAgX2EpO1xuZXhwb3J0IHZhciBIU0xfSFVFID0gL14oLT8oPzpcXGQqXFwuKT9cXGQrKSgoPzpkZWd8Z3JhZHxyYWR8dHVybik/KSQvO1xuZXhwb3J0IHZhciBQQ0VOVCA9IC9eKFxcZCsoPzpcXC5cXGQrKT98XFwuXFxkKyklJC87XG5leHBvcnQgdmFyIEhFWCA9IC9eMHgoW2EtZlxcZF17MSwyfSkkL2k7XG5leHBvcnQgdmFyIFRFTVBMQVRFX1ZBUiA9IC9cXHsoXFxkKylcXH0vZztcbiIsImV4cG9ydCB2YXIgRVJST1JTID0ge1xuICAgIE5PVF9BQ0NFUFRFRF9TVFJJTkdfSU5QVVQ6ICdUaGUgcHJvdmlkZWQgc3RyaW5nIGNvbG9yIGRvZXNuXFwndCBoYXZlIGEgY29ycmVjdCBmb3JtYXQnLFxuICAgIE5PVF9BQ0NFUFRFRF9PQkpFQ1RfSU5QVVQ6ICdUaGUgcHJvdmlkZWQgY29sb3Igb2JqZWN0IGRvZXNuXFwndCBoYXZlIHRoZSBwcm9wZXIga2V5cyBvciBmb3JtYXQnXG59O1xuIiwiZXhwb3J0IHZhciBBbmdsZXNVbml0RW51bTtcbihmdW5jdGlvbiAoQW5nbGVzVW5pdEVudW0pIHtcbiAgICBBbmdsZXNVbml0RW51bVtcIk5PTkVcIl0gPSBcIm5vbmVcIjtcbiAgICBBbmdsZXNVbml0RW51bVtcIkRFR1JFRVNcIl0gPSBcImRlZ1wiO1xuICAgIEFuZ2xlc1VuaXRFbnVtW1wiR1JBRElBTlNcIl0gPSBcImdyYWRcIjtcbiAgICBBbmdsZXNVbml0RW51bVtcIlJBRElBTlNcIl0gPSBcInJhZFwiO1xuICAgIEFuZ2xlc1VuaXRFbnVtW1wiVFVSTlNcIl0gPSBcInR1cm5cIjtcbn0pKEFuZ2xlc1VuaXRFbnVtIHx8IChBbmdsZXNVbml0RW51bSA9IHt9KSk7XG4iLCJpbXBvcnQgeyBBbmdsZXNVbml0RW51bSB9IGZyb20gJ0B0eXBlcyc7XG5pbXBvcnQgeyBNQVhfREVDSU1BTFMgfSBmcm9tICcuL251bWJlcnMnO1xuZXhwb3J0IHZhciBERUZBVUxUX09QVElPTlMgPSB7XG4gICAgZGVjaW1hbHM6IE1BWF9ERUNJTUFMUyxcbiAgICBsZWdhY3lDU1M6IGZhbHNlLFxuICAgIHNwYWNlc0FmdGVyQ29tbWFzOiBmYWxzZSxcbiAgICBhbmdsZXNVbml0OiBBbmdsZXNVbml0RW51bS5OT05FXG59O1xuIiwiZXhwb3J0ICogZnJvbSAnLi9udW1iZXJzJztcbmV4cG9ydCAqIGZyb20gJy4vZW51bXMnO1xuZXhwb3J0ICogZnJvbSAnLi9yZWdleHBzJztcbmV4cG9ydCAqIGZyb20gJy4vZXJyb3JzJztcbmV4cG9ydCAqIGZyb20gJy4vb3B0aW9ucyc7XG4iLCJ2YXIgX19zcHJlYWRBcnJheSA9ICh0aGlzICYmIHRoaXMuX19zcHJlYWRBcnJheSkgfHwgZnVuY3Rpb24gKHRvLCBmcm9tLCBwYWNrKSB7XG4gICAgaWYgKHBhY2sgfHwgYXJndW1lbnRzLmxlbmd0aCA9PT0gMikgZm9yICh2YXIgaSA9IDAsIGwgPSBmcm9tLmxlbmd0aCwgYXI7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgaWYgKGFyIHx8ICEoaSBpbiBmcm9tKSkge1xuICAgICAgICAgICAgaWYgKCFhcikgYXIgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChmcm9tLCAwLCBpKTtcbiAgICAgICAgICAgIGFyW2ldID0gZnJvbVtpXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdG8uY29uY2F0KGFyIHx8IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGZyb20pKTtcbn07XG5pbXBvcnQgeyBBbmdsZXNVbml0RW51bSB9IGZyb20gJ0B0eXBlcyc7XG5pbXBvcnQgeyBQQ0VOVCwgSEVYLCBNQVhfREVDSU1BTFMsIERFRkFVTFRfT1BUSU9OUywgQ09MT1JSRUdTLCBIU0xfSFVFLCBUeXBlT2YgfSBmcm9tICcjY29uc3RhbnRzJztcbmV4cG9ydCB2YXIgaGFzUHJvcCA9IGZ1bmN0aW9uIChvYmosIHByb3ApIHsgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIHByb3ApOyB9O1xuZXhwb3J0IHZhciBwZXJjZW50TnVtYmVyID0gZnVuY3Rpb24gKHBlcmNlbnQpIHtcbiAgICByZXR1cm4gK1wiXCIuY29uY2F0KHBlcmNlbnQpLnJlcGxhY2UoUENFTlQsICckMScpO1xufTtcbmV4cG9ydCB2YXIgcGVyY2VudCA9IGZ1bmN0aW9uIChwZXJjZW50KSB7IHJldHVybiBQQ0VOVC50ZXN0KFwiXCIuY29uY2F0KHBlcmNlbnQpKVxuICAgID8gcGVyY2VudE51bWJlcihwZXJjZW50KVxuICAgIDogTWF0aC5taW4oK3BlcmNlbnQsIDEwMCk7IH07XG5leHBvcnQgdmFyIGdldERFQyA9IGZ1bmN0aW9uIChoZXgpIHtcbiAgICBpZiAoaGV4Lmxlbmd0aCA9PT0gMSkge1xuICAgICAgICBoZXggKz0gaGV4O1xuICAgIH1cbiAgICByZXR1cm4gcGFyc2VJbnQoaGV4LCAxNik7XG59O1xuZXhwb3J0IHZhciBnZXRIRVggPSBmdW5jdGlvbiAobnVtYmVyKSB7XG4gICAgdmFyIGhleCA9IHJvdW5kKG51bWJlciwgMCkudG9TdHJpbmcoMTYpLnRvVXBwZXJDYXNlKCk7XG4gICAgaWYgKGhleC5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgcmV0dXJuIFwiMHgwXCIuY29uY2F0KGhleCk7XG4gICAgfVxuICAgIHJldHVybiBcIjB4XCIuY29uY2F0KGhleCk7XG59O1xuZXhwb3J0IHZhciB0b0hFWCA9IGZ1bmN0aW9uIChoKSB7XG4gICAgdmFyIGhleCA9IHJvdW5kKGgsIDApLnRvU3RyaW5nKDE2KS50b1VwcGVyQ2FzZSgpO1xuICAgIGlmIChoZXgubGVuZ3RoID09PSAxKSB7XG4gICAgICAgIGhleCA9IFwiMFwiLmNvbmNhdChoZXgpO1xuICAgIH1cbiAgICByZXR1cm4gaGV4O1xufTtcbmV4cG9ydCB2YXIgZ2V0QmFzZTI1NU51bWJlciA9IGZ1bmN0aW9uIChjb2xvciwgYWxwaGEpIHtcbiAgICBpZiAoYWxwaGEgPT09IHZvaWQgMCkgeyBhbHBoYSA9IGZhbHNlOyB9XG4gICAgaWYgKCFhbHBoYSAmJiBQQ0VOVC50ZXN0KGNvbG9yKSkge1xuICAgICAgICByZXR1cm4gTWF0aC5taW4oMjU1ICogcGVyY2VudE51bWJlcihjb2xvcikgLyAxMDAsIDI1NSk7XG4gICAgfVxuICAgIGlmIChIRVgudGVzdChjb2xvcikpIHtcbiAgICAgICAgaWYgKGNvbG9yLmxlbmd0aCA9PT0gMykge1xuICAgICAgICAgICAgY29sb3IgKz0gY29sb3Iuc2xpY2UoLTEpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhbHBoYVxuICAgICAgICAgICAgPyByb3VuZChjb2xvcikgLyAyNTVcbiAgICAgICAgICAgIDogcm91bmQoY29sb3IpO1xuICAgIH1cbiAgICByZXR1cm4gTWF0aC5taW4oK2NvbG9yLCBhbHBoYSA/IDEgOiAyNTUpO1xufTtcbmV4cG9ydCB2YXIgZ2V0Q01ZS051bWJlciA9IGZ1bmN0aW9uIChjb2xvcikgeyByZXR1cm4gTWF0aC5taW4oUENFTlQudGVzdChjb2xvcikgPyBwZXJjZW50TnVtYmVyKGNvbG9yKSAvIDEwMCA6ICtjb2xvciwgMSk7IH07XG5leHBvcnQgdmFyIGdldE9yZGVyZWRBcnJheVN0cmluZyA9IGZ1bmN0aW9uIChrZXlzKSB7IHJldHVybiBfX3NwcmVhZEFycmF5KFtdLCBrZXlzLCB0cnVlKS5zb3J0KCkuam9pbignJykudG9VcHBlckNhc2UoKTsgfTtcbmV4cG9ydCB2YXIgcm91bmQgPSBmdW5jdGlvbiAodmFsdWUsIGRlY2ltYWxzKSB7XG4gICAgaWYgKGRlY2ltYWxzID09PSB2b2lkIDApIHsgZGVjaW1hbHMgPSBNQVhfREVDSU1BTFM7IH1cbiAgICB2YXIgZXhwID0gTWF0aC5wb3coMTAsIGRlY2ltYWxzKTtcbiAgICByZXR1cm4gTWF0aC5yb3VuZCgrdmFsdWUgKiBleHApIC8gZXhwO1xufTtcbmV4cG9ydCB2YXIgbWlubWF4ID0gZnVuY3Rpb24gKG4sIG1pbiwgbWF4KSB7IHJldHVybiBNYXRoLm1heChtaW4sIE1hdGgubWluKG4sIG1heCkpOyB9O1xuZXhwb3J0IHZhciBkZWdyZWVzID0gZnVuY3Rpb24gKHJhZGlhbikgeyByZXR1cm4gcmFkaWFuICogMTgwIC8gTWF0aC5QSTsgfTtcbmV4cG9ydCB2YXIgcmFkaWFucyA9IGZ1bmN0aW9uIChkZWdyZWVzKSB7IHJldHVybiBkZWdyZWVzICogTWF0aC5QSSAvIDE4MDsgfTtcbnZhciBwaTIgPSAzNjA7XG5leHBvcnQgdmFyIG5vcm1hbGl6ZUh1ZSA9IGZ1bmN0aW9uIChodWUpIHtcbiAgICBpZiAodHlwZW9mIGh1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgdmFyIG1hdGNoZXMgPSBodWUubWF0Y2goSFNMX0hVRSk7XG4gICAgICAgIHZhciB2YWx1ZSA9ICttYXRjaGVzWzFdO1xuICAgICAgICB2YXIgdW5pdHMgPSBtYXRjaGVzWzJdO1xuICAgICAgICBzd2l0Y2ggKHVuaXRzKSB7XG4gICAgICAgICAgICBjYXNlIEFuZ2xlc1VuaXRFbnVtLlJBRElBTlM6XG4gICAgICAgICAgICAgICAgaHVlID0gcm91bmQoZGVncmVlcyh2YWx1ZSkpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBBbmdsZXNVbml0RW51bS5UVVJOUzpcbiAgICAgICAgICAgICAgICBodWUgPSByb3VuZCh2YWx1ZSAqIHBpMik7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIEFuZ2xlc1VuaXRFbnVtLkdSQURJQU5TOlxuICAgICAgICAgICAgICAgIGh1ZSA9IHJvdW5kKDkgLyAxMCAqIHZhbHVlKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgQW5nbGVzVW5pdEVudW0uREVHUkVFUzpcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgaHVlID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKGh1ZSA+IDM2MCB8fCBodWUgPCAwKSB7XG4gICAgICAgIGh1ZSAtPSBNYXRoLmZsb29yKGh1ZSAvIHBpMikgKiBwaTI7XG4gICAgfVxuICAgIHJldHVybiBodWU7XG59O1xuZXhwb3J0IHZhciB0cmFuc2xhdGVEZWdyZWVzID0gZnVuY3Rpb24gKGRlZ3JlZXMsIHVuaXRzKSB7XG4gICAgdmFyIGh1ZTtcbiAgICBzd2l0Y2ggKHVuaXRzKSB7XG4gICAgICAgIGNhc2UgQW5nbGVzVW5pdEVudW0uUkFESUFOUzpcbiAgICAgICAgICAgIGh1ZSA9IHJvdW5kKHJhZGlhbnMoZGVncmVlcykpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgQW5nbGVzVW5pdEVudW0uVFVSTlM6XG4gICAgICAgICAgICBodWUgPSByb3VuZChkZWdyZWVzIC8gcGkyKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIEFuZ2xlc1VuaXRFbnVtLkdSQURJQU5TOlxuICAgICAgICAgICAgaHVlID0gcm91bmQoMTAgLyA5ICogZGVncmVlcyk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBBbmdsZXNVbml0RW51bS5ERUdSRUVTOlxuICAgICAgICBjYXNlIEFuZ2xlc1VuaXRFbnVtLk5PTkU6XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICBodWUgPSBkZWdyZWVzO1xuICAgIH1cbiAgICByZXR1cm4gaHVlO1xufTtcbmV4cG9ydCB2YXIgZ2V0VHJhbnNsYXRlZEh1ZSA9IGZ1bmN0aW9uIChkZWdyZWVzLCBhbmdsZXNVbml0LCBkZWNpbWFscykge1xuICAgIHJldHVybiByb3VuZCh0cmFuc2xhdGVEZWdyZWVzKGRlZ3JlZXMsIGFuZ2xlc1VuaXQpLCBkZWNpbWFscyk7XG59O1xuZXhwb3J0IHZhciBnZXRPcHRpb25zRnJvbUNvbG9ySW5wdXQgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgIHZhciBjb2xvcnMgPSBbXTtcbiAgICBmb3IgKHZhciBfaSA9IDE7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgICBjb2xvcnNbX2kgLSAxXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgfVxuICAgIHZhciBjc3NDb2xvcnMgPSBjb2xvcnMuZmlsdGVyKGZ1bmN0aW9uIChjb2xvcikgeyByZXR1cm4gdHlwZW9mIGNvbG9yID09PSAnc3RyaW5nJzsgfSk7XG4gICAgdmFyIGhzbENvbG9ycyA9IGNzc0NvbG9yc1xuICAgICAgICAuZmlsdGVyKGZ1bmN0aW9uIChjb2xvcikgeyByZXR1cm4gQ09MT1JSRUdTLkhTTC50ZXN0KGNvbG9yKTsgfSlcbiAgICAgICAgLm1hcChmdW5jdGlvbiAoY29sb3IpIHtcbiAgICAgICAgdmFyIGhzbE1hdGNoID0gY29sb3IubWF0Y2goQ09MT1JSRUdTLkhTTCk7XG4gICAgICAgIHZhciBhbmdsZSA9IGhzbE1hdGNoWzFdIHx8IGhzbE1hdGNoWzVdO1xuICAgICAgICB2YXIgdW5pdCA9IGFuZ2xlLm1hdGNoKEhTTF9IVUUpWzJdO1xuICAgICAgICByZXR1cm4gdW5pdCA9PT0gJydcbiAgICAgICAgICAgID8gQW5nbGVzVW5pdEVudW0uTk9ORVxuICAgICAgICAgICAgOiB1bml0O1xuICAgIH0pO1xuICAgIHZhciBtYXRjaE9wdGlvbnMgPSB7XG4gICAgICAgIGxlZ2FjeUNTUzogMCxcbiAgICAgICAgc3BhY2VzQWZ0ZXJDb21tYXM6IDAsXG4gICAgICAgIGFuZ2xlc1VuaXQ6IDBcbiAgICB9O1xuICAgIGNzc0NvbG9ycy5mb3JFYWNoKGZ1bmN0aW9uIChjb2xvcikge1xuICAgICAgICBpZiAoY29sb3IuaW5jbHVkZXMoJywnKSkge1xuICAgICAgICAgICAgbWF0Y2hPcHRpb25zLmxlZ2FjeUNTUysrO1xuICAgICAgICAgICAgdmFyIGNvbW1hc1dpdGhOZXh0Q2hhcmFjdGVyID0gY29sb3IubWF0Y2goLywoICt8XFxkKykvZyk7XG4gICAgICAgICAgICBpZiAobmV3IFNldChjb21tYXNXaXRoTmV4dENoYXJhY3Rlcikuc2l6ZSA9PT0gMSAmJlxuICAgICAgICAgICAgICAgIC8gKy8udGVzdChjb21tYXNXaXRoTmV4dENoYXJhY3RlclswXS5zbGljZSgxKSkpIHtcbiAgICAgICAgICAgICAgICBtYXRjaE9wdGlvbnMuc3BhY2VzQWZ0ZXJDb21tYXMrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiB7XG4gICAgICAgIGRlY2ltYWxzOiB0eXBlb2Ygb3B0aW9ucy5kZWNpbWFscyA9PT0gVHlwZU9mLk5VTUJFUlxuICAgICAgICAgICAgPyBvcHRpb25zLmRlY2ltYWxzXG4gICAgICAgICAgICA6IERFRkFVTFRfT1BUSU9OUy5kZWNpbWFscyxcbiAgICAgICAgbGVnYWN5Q1NTOiB0eXBlb2Ygb3B0aW9ucy5sZWdhY3lDU1MgPT09IFR5cGVPZi5CT09MRUFOXG4gICAgICAgICAgICA/IG9wdGlvbnMubGVnYWN5Q1NTXG4gICAgICAgICAgICA6IEJvb2xlYW4oY3NzQ29sb3JzLmxlbmd0aCAmJlxuICAgICAgICAgICAgICAgIG1hdGNoT3B0aW9ucy5sZWdhY3lDU1MgPT09IGNzc0NvbG9ycy5sZW5ndGgpIHx8IERFRkFVTFRfT1BUSU9OUy5sZWdhY3lDU1MsXG4gICAgICAgIHNwYWNlc0FmdGVyQ29tbWFzOiB0eXBlb2Ygb3B0aW9ucy5zcGFjZXNBZnRlckNvbW1hcyA9PT0gVHlwZU9mLkJPT0xFQU5cbiAgICAgICAgICAgID8gb3B0aW9ucy5zcGFjZXNBZnRlckNvbW1hc1xuICAgICAgICAgICAgOiBCb29sZWFuKGNzc0NvbG9ycy5sZW5ndGggJiZcbiAgICAgICAgICAgICAgICBtYXRjaE9wdGlvbnMuc3BhY2VzQWZ0ZXJDb21tYXMgPT09IGNzc0NvbG9ycy5sZW5ndGgpIHx8IERFRkFVTFRfT1BUSU9OUy5zcGFjZXNBZnRlckNvbW1hcyxcbiAgICAgICAgYW5nbGVzVW5pdDogb3B0aW9ucy5hbmdsZXNVbml0XG4gICAgICAgICAgICA/IG9wdGlvbnMuYW5nbGVzVW5pdFxuICAgICAgICAgICAgOiAobmV3IFNldChoc2xDb2xvcnMpLnNpemUgPT09IDFcbiAgICAgICAgICAgICAgICA/IGhzbENvbG9yc1swXVxuICAgICAgICAgICAgICAgIDogREVGQVVMVF9PUFRJT05TLmFuZ2xlc1VuaXQpXG4gICAgfTtcbn07XG4iLCJpbXBvcnQgeyByb3VuZCB9IGZyb20gJyNoZWxwZXJzJztcbmV4cG9ydCB2YXIgaHVlVG9SR0IgPSBmdW5jdGlvbiAodDEsIHQyLCBodWUpIHtcbiAgICBpZiAoaHVlIDwgMCkge1xuICAgICAgICBodWUgKz0gNjtcbiAgICB9XG4gICAgaWYgKGh1ZSA+PSA2KSB7XG4gICAgICAgIGh1ZSAtPSA2O1xuICAgIH1cbiAgICBpZiAoaHVlIDwgMSkge1xuICAgICAgICByZXR1cm4gcm91bmQoKCh0MiAtIHQxKSAqIGh1ZSArIHQxKSAqIDI1NSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGh1ZSA8IDMpIHtcbiAgICAgICAgcmV0dXJuIHJvdW5kKHQyICogMjU1KTtcbiAgICB9XG4gICAgZWxzZSBpZiAoaHVlIDwgNCkge1xuICAgICAgICByZXR1cm4gcm91bmQoKCh0MiAtIHQxKSAqICg0IC0gaHVlKSArIHQxKSAqIDI1NSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gcm91bmQodDEgKiAyNTUpO1xuICAgIH1cbn07XG5leHBvcnQgdmFyIGhzbFRvUkdCID0gZnVuY3Rpb24gKGgsIHMsIGwpIHtcbiAgICBoIC89IDYwO1xuICAgIHMgLz0gMTAwO1xuICAgIGwgLz0gMTAwO1xuICAgIHZhciB0MiA9IChsIDw9IC41KVxuICAgICAgICA/IGwgKiAocyArIDEpXG4gICAgICAgIDogbCArIHMgLSAobCAqIHMpO1xuICAgIHZhciB0MSA9IGwgKiAyIC0gdDI7XG4gICAgdmFyIHIgPSBodWVUb1JHQih0MSwgdDIsIGggKyAyKTtcbiAgICB2YXIgZyA9IGh1ZVRvUkdCKHQxLCB0MiwgaCk7XG4gICAgdmFyIGIgPSBodWVUb1JHQih0MSwgdDIsIGggLSAyKTtcbiAgICByZXR1cm4geyByOiByLCBnOiBnLCBiOiBiIH07XG59O1xuZXhwb3J0IHZhciBjbXlrVG9SR0IgPSBmdW5jdGlvbiAoYywgbSwgeSwgaykge1xuICAgIGsgPSAxIC0gaztcbiAgICB2YXIgciA9IHJvdW5kKDI1NSAqICgxIC0gYykgKiBrKTtcbiAgICB2YXIgZyA9IHJvdW5kKDI1NSAqICgxIC0gbSkgKiBrKTtcbiAgICB2YXIgYiA9IHJvdW5kKDI1NSAqICgxIC0geSkgKiBrKTtcbiAgICByZXR1cm4geyByOiByLCBnOiBnLCBiOiBiIH07XG59O1xuZXhwb3J0IHZhciByZ2JUb0NNWUsgPSBmdW5jdGlvbiAociwgZywgYikge1xuICAgIHIgLz0gMjU1O1xuICAgIGcgLz0gMjU1O1xuICAgIGIgLz0gMjU1O1xuICAgIHZhciBrID0gMSAtIE1hdGgubWF4KHIsIGcsIGIpO1xuICAgIHZhciBrMSA9IDEgLSBrO1xuICAgIHZhciBjID0gazEgJiYgKGsxIC0gcikgLyBrMTtcbiAgICB2YXIgbSA9IGsxICYmIChrMSAtIGcpIC8gazE7XG4gICAgdmFyIHkgPSBrMSAmJiAoazEgLSBiKSAvIGsxO1xuICAgIHJldHVybiB7XG4gICAgICAgIGM6IHJvdW5kKGMgKiAxMDApLFxuICAgICAgICBtOiByb3VuZChtICogMTAwKSxcbiAgICAgICAgeTogcm91bmQoeSAqIDEwMCksXG4gICAgICAgIGs6IHJvdW5kKGsgKiAxMDApXG4gICAgfTtcbn07XG5leHBvcnQgdmFyIHJnYlRvSFNMID0gZnVuY3Rpb24gKHIsIGcsIGIsIGEpIHtcbiAgICBpZiAoYSA9PT0gdm9pZCAwKSB7IGEgPSAxOyB9XG4gICAgciAvPSAyNTU7XG4gICAgZyAvPSAyNTU7XG4gICAgYiAvPSAyNTU7XG4gICAgYSA9IE1hdGgubWluKGEsIDEpO1xuICAgIHZhciBtYXggPSBNYXRoLm1heChyLCBnLCBiKTtcbiAgICB2YXIgbWluID0gTWF0aC5taW4ociwgZywgYik7XG4gICAgdmFyIGQgPSBtYXggLSBtaW47XG4gICAgdmFyIGggPSAwO1xuICAgIHZhciBzID0gMDtcbiAgICB2YXIgbCA9IChtYXggKyBtaW4pIC8gMjtcbiAgICBpZiAoZCAhPT0gMCkge1xuICAgICAgICBzd2l0Y2ggKG1heCkge1xuICAgICAgICAgICAgY2FzZSByOlxuICAgICAgICAgICAgICAgIGggPSAoKGcgLSBiKSAvIGQpICUgNjtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgZzpcbiAgICAgICAgICAgICAgICBoID0gKGIgLSByKSAvIGQgKyAyO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBiOlxuICAgICAgICAgICAgICAgIGggPSAociAtIGcpIC8gZCArIDQ7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgaCA9IHJvdW5kKGggKiA2MCk7XG4gICAgICAgIGlmIChoIDwgMCkge1xuICAgICAgICAgICAgaCArPSAzNjA7XG4gICAgICAgIH1cbiAgICAgICAgcyA9IGQgLyAoMSAtIE1hdGguYWJzKDIgKiBsIC0gMSkpO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICBoOiBoLFxuICAgICAgICBzOiByb3VuZChzICogMTAwKSxcbiAgICAgICAgbDogcm91bmQobCAqIDEwMCksXG4gICAgICAgIGE6IGFcbiAgICB9O1xufTtcbmV4cG9ydCB2YXIgcmdiVG9SWUIgPSBmdW5jdGlvbiAociwgZywgYikge1xuICAgIHZhciBJdyA9IE1hdGgubWluKHIsIGcsIGIpO1xuICAgIHZhciBJYiA9IE1hdGgubWluKDI1NSAtIHIsIDI1NSAtIGcsIDI1NSAtIGIpO1xuICAgIHZhciByUkdCID0gciAtIEl3O1xuICAgIHZhciBnUkdCID0gZyAtIEl3O1xuICAgIHZhciBiUkdCID0gYiAtIEl3O1xuICAgIHZhciBtaW5SRyA9IE1hdGgubWluKHJSR0IsIGdSR0IpO1xuICAgIHZhciByUllCID0gclJHQiAtIG1pblJHO1xuICAgIHZhciB5UllCID0gKGdSR0IgKyBtaW5SRykgLyAyO1xuICAgIHZhciBiUllCID0gKGJSR0IgKyBnUkdCIC0gbWluUkcpIC8gMjtcbiAgICB2YXIgbiA9IE1hdGgubWF4KHJSWUIsIHlSWUIsIGJSWUIpIC8gTWF0aC5tYXgoclJHQiwgZ1JHQiwgYlJHQik7XG4gICAgdmFyIE4gPSBpc05hTihuKSB8fCBuID09PSBJbmZpbml0eSB8fCBuIDw9IDAgPyAxIDogbjtcbiAgICByZXR1cm4ge1xuICAgICAgICByOiByUllCIC8gTiArIEliLFxuICAgICAgICB5OiB5UllCIC8gTiArIEliLFxuICAgICAgICBiOiBiUllCIC8gTiArIEliXG4gICAgfTtcbn07XG5leHBvcnQgdmFyIHJ5YlRvUkdCID0gZnVuY3Rpb24gKHIsIHksIGIpIHtcbiAgICB2YXIgSXcgPSBNYXRoLm1pbihyLCB5LCBiKTtcbiAgICB2YXIgSWIgPSBNYXRoLm1pbigyNTUgLSByLCAyNTUgLSB5LCAyNTUgLSBiKTtcbiAgICB2YXIgclJZQiA9IHIgLSBJdztcbiAgICB2YXIgeVJZQiA9IHkgLSBJdztcbiAgICB2YXIgYlJZQiA9IGIgLSBJdztcbiAgICB2YXIgbWluWUIgPSBNYXRoLm1pbih5UllCLCBiUllCKTtcbiAgICB2YXIgclJHQiA9IHJSWUIgKyB5UllCIC0gbWluWUI7XG4gICAgdmFyIGdSR0IgPSB5UllCICsgbWluWUI7XG4gICAgdmFyIGJSR0IgPSAyICogKGJSWUIgLSBtaW5ZQik7XG4gICAgdmFyIG4gPSBNYXRoLm1heChyUkdCLCBnUkdCLCBiUkdCKSAvIE1hdGgubWF4KHJSWUIsIHlSWUIsIGJSWUIpO1xuICAgIHZhciBOID0gaXNOYU4obikgfHwgbiA9PT0gSW5maW5pdHkgfHwgbiA8PSAwID8gMSA6IG47XG4gICAgcmV0dXJuIHtcbiAgICAgICAgcjogclJHQiAvIE4gKyBJYixcbiAgICAgICAgZzogZ1JHQiAvIE4gKyBJYixcbiAgICAgICAgYjogYlJHQiAvIE4gKyBJYlxuICAgIH07XG59O1xuZXhwb3J0IHZhciBodWVSWUIgPSBmdW5jdGlvbiAoaHVlLCB0b1JZQikge1xuICAgIGlmIChodWUgPCAwKVxuICAgICAgICBodWUgKz0gMzYwO1xuICAgIGlmIChodWUgPiAzNjApXG4gICAgICAgIGh1ZSAtPSAzNjA7XG4gICAgaWYgKGh1ZSA9PT0gMzYwIHx8IGh1ZSA9PT0gMClcbiAgICAgICAgcmV0dXJuIGh1ZTtcbiAgICB2YXIgbWFwMSA9IFtcbiAgICAgICAgWzAsIDEyMF0sXG4gICAgICAgIFsxMjAsIDE4MF0sXG4gICAgICAgIFsxODAsIDI0MF0sXG4gICAgICAgIFsyNDAsIDM2MF1cbiAgICBdO1xuICAgIHZhciBtYXAyID0gW1xuICAgICAgICBbMCwgNjBdLFxuICAgICAgICBbNjAsIDEyMF0sXG4gICAgICAgIFsxMjAsIDI0MF0sXG4gICAgICAgIFsyNDAsIDM2MF1cbiAgICBdO1xuICAgIHZhciBmcm9tID0gdG9SWUIgPyBtYXAxIDogbWFwMjtcbiAgICB2YXIgdG8gPSB0b1JZQiA/IG1hcDIgOiBtYXAxO1xuICAgIHZhciBhID0gMDtcbiAgICB2YXIgYiA9IDA7XG4gICAgdmFyIGMgPSAwO1xuICAgIHZhciBkID0gMDtcbiAgICBmcm9tLmZpbmQoZnVuY3Rpb24gKGFyciwgaW5kZXgpIHtcbiAgICAgICAgaWYgKGh1ZSA+PSBhcnJbMF0gJiYgaHVlIDwgYXJyWzFdKSB7XG4gICAgICAgICAgICBhID0gYXJyWzBdO1xuICAgICAgICAgICAgYiA9IGFyclsxXTtcbiAgICAgICAgICAgIGMgPSB0b1tpbmRleF1bMF07XG4gICAgICAgICAgICBkID0gdG9baW5kZXhdWzFdO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0pO1xuICAgIHJldHVybiBjICsgKGh1ZSAtIGEpICogKChkIC0gYykgLyAoYiAtIGEpKTtcbn07XG4iLCJ2YXIgX2E7XG5pbXBvcnQgeyBBbmdsZXNVbml0RW51bSB9IGZyb20gJ0B0eXBlcyc7XG5pbXBvcnQgeyBDb2xvck1vZGVsLCBURU1QTEFURV9WQVIsIENPTE9SX1BST1BTLCBWQUxJRF9DT0xPUl9PQkpFQ1RTIH0gZnJvbSAnI2NvbnN0YW50cyc7XG5pbXBvcnQgeyB0b0hFWCwgcm91bmQsIGdldE9yZGVyZWRBcnJheVN0cmluZyB9IGZyb20gJyNoZWxwZXJzJztcbnZhciBnZXRDb21tYSA9IGZ1bmN0aW9uICh3aXRoU3BhY2UpIHsgcmV0dXJuIHdpdGhTcGFjZVxuICAgID8gJywgJ1xuICAgIDogJywnOyB9O1xudmFyIHByZXBhcmVDb2xvckZvckNzcyA9IGZ1bmN0aW9uIChjb2xvciwgaXNIZXgpIHtcbiAgICBpZiAoaXNIZXggPT09IHZvaWQgMCkgeyBpc0hleCA9IGZhbHNlOyB9XG4gICAgdmFyIHByb3BzID0gZ2V0T3JkZXJlZEFycmF5U3RyaW5nKE9iamVjdC5rZXlzKGNvbG9yKSk7XG4gICAgdmFyIG1vZGVsID0gVkFMSURfQ09MT1JfT0JKRUNUU1twcm9wc107XG4gICAgdmFyIGtleXMgPSBDT0xPUl9QUk9QU1ttb2RlbF07XG4gICAgcmV0dXJuIGtleXMucmVkdWNlKGZ1bmN0aW9uIChyZXN1bHQsIGtleSkge1xuICAgICAgICB2YXIgdmFsdWUgPSBjb2xvcltrZXldO1xuICAgICAgICBpZiAodHlwZW9mIHZhbHVlICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgaWYgKGlzSGV4KSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2godG9IRVgocm91bmQodmFsdWUsIDApKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaCh2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9LCBbXSk7XG59O1xudmFyIGdldFJlc3VsdEZyb21UZW1wbGF0ZSA9IGZ1bmN0aW9uICh0ZW1wbGF0ZSwgdmFycykge1xuICAgIHJldHVybiB0ZW1wbGF0ZS5yZXBsYWNlKFRFTVBMQVRFX1ZBUiwgZnVuY3Rpb24gKF9fbWF0Y2gsIGluZGV4U3RyKSB7XG4gICAgICAgIHZhciBpbmRleCA9ICtpbmRleFN0ciAtIDE7XG4gICAgICAgIHJldHVybiBcIlwiLmNvbmNhdCh2YXJzW2luZGV4XSk7XG4gICAgfSk7XG59O1xuZXhwb3J0IHZhciBDU1MgPSAoX2EgPSB7fSxcbiAgICBfYVtDb2xvck1vZGVsLkhFWF0gPSBmdW5jdGlvbiAoY29sb3IpIHtcbiAgICAgICAgdmFyIHZhbHVlcyA9IHByZXBhcmVDb2xvckZvckNzcyhjb2xvciwgdHJ1ZSk7XG4gICAgICAgIHZhciB0ZW1wbGF0ZSA9IHZhbHVlcy5sZW5ndGggPT09IDRcbiAgICAgICAgICAgID8gJyN7MX17Mn17M317NH0nXG4gICAgICAgICAgICA6ICcjezF9ezJ9ezN9JztcbiAgICAgICAgcmV0dXJuIGdldFJlc3VsdEZyb21UZW1wbGF0ZSh0ZW1wbGF0ZSwgdmFsdWVzKTtcbiAgICB9LFxuICAgIF9hW0NvbG9yTW9kZWwuUkdCXSA9IGZ1bmN0aW9uIChjb2xvciwgb3B0aW9ucykge1xuICAgICAgICB2YXIgbGVnYWN5Q1NTID0gb3B0aW9ucy5sZWdhY3lDU1MsIHNwYWNlc0FmdGVyQ29tbWFzID0gb3B0aW9ucy5zcGFjZXNBZnRlckNvbW1hcztcbiAgICAgICAgdmFyIGNvbW1hID0gZ2V0Q29tbWEoc3BhY2VzQWZ0ZXJDb21tYXMpO1xuICAgICAgICB2YXIgdmFsdWVzID0gcHJlcGFyZUNvbG9yRm9yQ3NzKGNvbG9yKTtcbiAgICAgICAgdmFyIHRlbXBsYXRlID0gbGVnYWN5Q1NTXG4gICAgICAgICAgICA/ICh2YWx1ZXMubGVuZ3RoID09PSA0XG4gICAgICAgICAgICAgICAgPyBcInJnYmEoezF9XCIuY29uY2F0KGNvbW1hLCBcInsyfVwiKS5jb25jYXQoY29tbWEsIFwiezN9XCIpLmNvbmNhdChjb21tYSwgXCJ7NH0pXCIpXG4gICAgICAgICAgICAgICAgOiBcInJnYih7MX1cIi5jb25jYXQoY29tbWEsIFwiezJ9XCIpLmNvbmNhdChjb21tYSwgXCJ7M30pXCIpKVxuICAgICAgICAgICAgOiAodmFsdWVzLmxlbmd0aCA9PT0gNFxuICAgICAgICAgICAgICAgID8gJ3JnYih7MX0gezJ9IHszfSAvIHs0fSknXG4gICAgICAgICAgICAgICAgOiAncmdiKHsxfSB7Mn0gezN9KScpO1xuICAgICAgICByZXR1cm4gZ2V0UmVzdWx0RnJvbVRlbXBsYXRlKHRlbXBsYXRlLCB2YWx1ZXMpO1xuICAgIH0sXG4gICAgX2FbQ29sb3JNb2RlbC5IU0xdID0gZnVuY3Rpb24gKGNvbG9yLCBvcHRpb25zKSB7XG4gICAgICAgIHZhciBsZWdhY3lDU1MgPSBvcHRpb25zLmxlZ2FjeUNTUywgc3BhY2VzQWZ0ZXJDb21tYXMgPSBvcHRpb25zLnNwYWNlc0FmdGVyQ29tbWFzLCBhbmdsZXNVbml0ID0gb3B0aW9ucy5hbmdsZXNVbml0O1xuICAgICAgICB2YXIgY29tbWEgPSBnZXRDb21tYShzcGFjZXNBZnRlckNvbW1hcyk7XG4gICAgICAgIHZhciB2YWx1ZXMgPSBwcmVwYXJlQ29sb3JGb3JDc3MoY29sb3IpO1xuICAgICAgICB2YXIgdW5pdHMgPSBhbmdsZXNVbml0ID09PSBBbmdsZXNVbml0RW51bS5OT05FXG4gICAgICAgICAgICA/ICcnXG4gICAgICAgICAgICA6IGFuZ2xlc1VuaXQ7XG4gICAgICAgIHZhciB0ZW1wbGF0ZSA9IGxlZ2FjeUNTU1xuICAgICAgICAgICAgPyAodmFsdWVzLmxlbmd0aCA9PT0gNFxuICAgICAgICAgICAgICAgID8gXCJoc2xhKHsxfVwiLmNvbmNhdCh1bml0cykuY29uY2F0KGNvbW1hLCBcInsyfSVcIikuY29uY2F0KGNvbW1hLCBcInszfSVcIikuY29uY2F0KGNvbW1hLCBcIns0fSlcIilcbiAgICAgICAgICAgICAgICA6IFwiaHNsKHsxfVwiLmNvbmNhdCh1bml0cykuY29uY2F0KGNvbW1hLCBcInsyfSVcIikuY29uY2F0KGNvbW1hLCBcInszfSUpXCIpKVxuICAgICAgICAgICAgOiAodmFsdWVzLmxlbmd0aCA9PT0gNFxuICAgICAgICAgICAgICAgID8gXCJoc2woezF9XCIuY29uY2F0KHVuaXRzLCBcIiB7Mn0lIHszfSUgLyB7NH0pXCIpXG4gICAgICAgICAgICAgICAgOiBcImhzbCh7MX1cIi5jb25jYXQodW5pdHMsIFwiIHsyfSUgezN9JSlcIikpO1xuICAgICAgICByZXR1cm4gZ2V0UmVzdWx0RnJvbVRlbXBsYXRlKHRlbXBsYXRlLCB2YWx1ZXMpO1xuICAgIH0sXG4gICAgX2FbQ29sb3JNb2RlbC5DTVlLXSA9IGZ1bmN0aW9uIChjb2xvciwgb3B0aW9ucykge1xuICAgICAgICB2YXIgbGVnYWN5Q1NTID0gb3B0aW9ucy5sZWdhY3lDU1MsIHNwYWNlc0FmdGVyQ29tbWFzID0gb3B0aW9ucy5zcGFjZXNBZnRlckNvbW1hcztcbiAgICAgICAgdmFyIGNvbW1hID0gZ2V0Q29tbWEoc3BhY2VzQWZ0ZXJDb21tYXMpO1xuICAgICAgICB2YXIgdmFsdWVzID0gcHJlcGFyZUNvbG9yRm9yQ3NzKGNvbG9yKTtcbiAgICAgICAgdmFyIHRlbXBsYXRlID0gbGVnYWN5Q1NTXG4gICAgICAgICAgICA/ICh2YWx1ZXMubGVuZ3RoID09PSA1XG4gICAgICAgICAgICAgICAgPyBcImRldmljZS1jbXlrKHsxfSVcIi5jb25jYXQoY29tbWEsIFwiezJ9JVwiKS5jb25jYXQoY29tbWEsIFwiezN9JVwiKS5jb25jYXQoY29tbWEsIFwiezR9JVwiKS5jb25jYXQoY29tbWEsIFwiezV9KVwiKVxuICAgICAgICAgICAgICAgIDogXCJkZXZpY2UtY215ayh7MX0lXCIuY29uY2F0KGNvbW1hLCBcInsyfSVcIikuY29uY2F0KGNvbW1hLCBcInszfSVcIikuY29uY2F0KGNvbW1hLCBcIns0fSUpXCIpKVxuICAgICAgICAgICAgOiAodmFsdWVzLmxlbmd0aCA9PT0gNVxuICAgICAgICAgICAgICAgID8gJ2RldmljZS1jbXlrKHsxfSUgezJ9JSB7M30lIHs0fSUgLyB7NX0pJ1xuICAgICAgICAgICAgICAgIDogJ2RldmljZS1jbXlrKHsxfSUgezJ9JSB7M30lIHs0fSUpJyk7XG4gICAgICAgIHJldHVybiBnZXRSZXN1bHRGcm9tVGVtcGxhdGUodGVtcGxhdGUsIHZhbHVlcyk7XG4gICAgfSxcbiAgICBfYSk7XG4iLCJ2YXIgX19hc3NpZ24gPSAodGhpcyAmJiB0aGlzLl9fYXNzaWduKSB8fCBmdW5jdGlvbiAoKSB7XG4gICAgX19hc3NpZ24gPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uKHQpIHtcbiAgICAgICAgZm9yICh2YXIgcywgaSA9IDEsIG4gPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgICAgICBzID0gYXJndW1lbnRzW2ldO1xuICAgICAgICAgICAgZm9yICh2YXIgcCBpbiBzKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHMsIHApKVxuICAgICAgICAgICAgICAgIHRbcF0gPSBzW3BdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0O1xuICAgIH07XG4gICAgcmV0dXJuIF9fYXNzaWduLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59O1xudmFyIF9fc3ByZWFkQXJyYXkgPSAodGhpcyAmJiB0aGlzLl9fc3ByZWFkQXJyYXkpIHx8IGZ1bmN0aW9uICh0bywgZnJvbSwgcGFjaykge1xuICAgIGlmIChwYWNrIHx8IGFyZ3VtZW50cy5sZW5ndGggPT09IDIpIGZvciAodmFyIGkgPSAwLCBsID0gZnJvbS5sZW5ndGgsIGFyOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIGlmIChhciB8fCAhKGkgaW4gZnJvbSkpIHtcbiAgICAgICAgICAgIGlmICghYXIpIGFyID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoZnJvbSwgMCwgaSk7XG4gICAgICAgICAgICBhcltpXSA9IGZyb21baV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRvLmNvbmNhdChhciB8fCBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChmcm9tKSk7XG59O1xudmFyIF9hLCBfYiwgX2MsIF9kLCBfZTtcbmltcG9ydCB7IEFuZ2xlc1VuaXRFbnVtIH0gZnJvbSAnQHR5cGVzJztcbmltcG9ydCB7IEhFWCwgUENFTlQsIENvbG9yTW9kZWwsIE1peCwgQ29sb3JLZXl3b3JkcywgQ09MT1JSRUdTLCBDT0xPUl9LRVlTLCBFUlJPUlMsIFZBTElEX0NPTE9SX09CSkVDVFMgfSBmcm9tICcjY29uc3RhbnRzJztcbmltcG9ydCB7IGdldE9yZGVyZWRBcnJheVN0cmluZywgZ2V0REVDLCBnZXRIRVgsIGdldEJhc2UyNTVOdW1iZXIsIGdldENNWUtOdW1iZXIsIGhhc1Byb3AsIHBlcmNlbnQsIHBlcmNlbnROdW1iZXIsIHJvdW5kLCBtaW5tYXgsIG5vcm1hbGl6ZUh1ZSwgZ2V0VHJhbnNsYXRlZEh1ZSB9IGZyb20gJyNoZWxwZXJzJztcbmltcG9ydCB7IHJnYlRvSFNMLCBoc2xUb1JHQiwgY215a1RvUkdCLCByZ2JUb0NNWUssIHJnYlRvUllCLCByeWJUb1JHQiwgaHVlUllCIH0gZnJvbSAnI2NvbG9yL3RyYW5zbGF0b3JzJztcbmltcG9ydCB7IENTUyB9IGZyb20gJyNjb2xvci9jc3MnO1xuZXhwb3J0IHZhciBub3JtYWxpemVBbHBoYSA9IGZ1bmN0aW9uIChhbHBoYSkge1xuICAgIGlmICh0eXBlb2YgYWxwaGEgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIGlmIChQQ0VOVC50ZXN0KGFscGhhKSkge1xuICAgICAgICAgICAgYWxwaGEgPSBwZXJjZW50TnVtYmVyKGFscGhhKSAvIDEwMDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGFscGhhID0gK2FscGhhO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiAoaXNOYU4oK2FscGhhKSB8fCBhbHBoYSA+IDEpID8gMSA6IHJvdW5kKGFscGhhKTtcbn07XG52YXIgaGFybW9ueSA9IGZ1bmN0aW9uIChjb2xvciwgYW5nbGVzLCBtb2RlKSB7XG4gICAgcmV0dXJuIGFuZ2xlcy5yZWR1Y2UoZnVuY3Rpb24gKGFyciwgbnVtKSB7XG4gICAgICAgIHJldHVybiAoX19zcHJlYWRBcnJheShfX3NwcmVhZEFycmF5KFtdLCBhcnIsIHRydWUpLCBbXG4gICAgICAgICAgICBfX2Fzc2lnbihfX2Fzc2lnbih7fSwgY29sb3IpLCB7IGg6IG1vZGUgPT09IE1peC5BRERJVElWRVxuICAgICAgICAgICAgICAgICAgICA/IG5vcm1hbGl6ZUh1ZShjb2xvci5oICsgbnVtKVxuICAgICAgICAgICAgICAgICAgICA6IG5vcm1hbGl6ZUh1ZShodWVSWUIoaHVlUllCKGNvbG9yLmgsIGZhbHNlKSArIG51bSwgdHJ1ZSkpIH0pXG4gICAgICAgIF0sIGZhbHNlKSk7XG4gICAgfSwgW19fYXNzaWduKHt9LCBjb2xvcildKTtcbn07XG5leHBvcnQgdmFyIGFuYWxvZ291cyA9IGZ1bmN0aW9uIChjb2xvciwgbW9kZSkgeyByZXR1cm4gaGFybW9ueShjb2xvciwgWzMwLCAtMzBdLCBtb2RlKTsgfTtcbmV4cG9ydCB2YXIgY29tcGxlbWVudGFyeSA9IGZ1bmN0aW9uIChjb2xvciwgbW9kZSkgeyByZXR1cm4gaGFybW9ueShjb2xvciwgWzE4MF0sIG1vZGUpOyB9O1xuZXhwb3J0IHZhciBzcGxpdENvbXBsZW1lbnRhcnkgPSBmdW5jdGlvbiAoY29sb3IsIG1vZGUpIHsgcmV0dXJuIGhhcm1vbnkoY29sb3IsIFsxNTAsIC0xNTBdLCBtb2RlKTsgfTtcbmV4cG9ydCB2YXIgdHJpYWRpYyA9IGZ1bmN0aW9uIChjb2xvciwgbW9kZSkgeyByZXR1cm4gaGFybW9ueShjb2xvciwgWzEyMCwgLTEyMF0sIG1vZGUpOyB9O1xuZXhwb3J0IHZhciB0ZXRyYWRpYyA9IGZ1bmN0aW9uIChjb2xvciwgbW9kZSkgeyByZXR1cm4gaGFybW9ueShjb2xvciwgWzYwLCAtMTIwLCAxODBdLCBtb2RlKTsgfTtcbmV4cG9ydCB2YXIgc3F1YXJlID0gZnVuY3Rpb24gKGNvbG9yLCBtb2RlKSB7IHJldHVybiBoYXJtb255KGNvbG9yLCBbOTAsIC05MCwgMTgwXSwgbW9kZSk7IH07XG52YXIgZ2V0Q29sb3JNb2RlbEZyb21TdHJpbmcgPSBmdW5jdGlvbiAoY29sb3IpIHtcbiAgICB2YXIgbW9kZWw7XG4gICAgT2JqZWN0LmtleXMoQ29sb3JNb2RlbCkuc29tZShmdW5jdGlvbiAocCkge1xuICAgICAgICB2YXIgcmVnID0gQ09MT1JSRUdTW3BdO1xuICAgICAgICBpZiAocmVnLnRlc3QoY29sb3IpKSB7XG4gICAgICAgICAgICBtb2RlbCA9IHA7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIGlmICghbW9kZWwgJiZcbiAgICAgICAgISF+Q09MT1JfS0VZUy5pbmRleE9mKGNvbG9yKSkge1xuICAgICAgICBtb2RlbCA9IENvbG9yTW9kZWwuSEVYO1xuICAgIH1cbiAgICBpZiAoIW1vZGVsKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihFUlJPUlMuTk9UX0FDQ0VQVEVEX1NUUklOR19JTlBVVCk7XG4gICAgfVxuICAgIHJldHVybiBtb2RlbDtcbn07XG52YXIgZ2V0Q29sb3JNb2RlbEZyb21PYmplY3QgPSBmdW5jdGlvbiAoY29sb3IpIHtcbiAgICB2YXIgbW9kZWw7XG4gICAgdmFyIGludmFsaWQgPSBmYWxzZTtcbiAgICB2YXIgcHJvcHMgPSBnZXRPcmRlcmVkQXJyYXlTdHJpbmcoT2JqZWN0LmtleXMoY29sb3IpKTtcbiAgICBpZiAoVkFMSURfQ09MT1JfT0JKRUNUU1twcm9wc10pIHtcbiAgICAgICAgbW9kZWwgPSBWQUxJRF9DT0xPUl9PQkpFQ1RTW3Byb3BzXTtcbiAgICB9XG4gICAgaWYgKG1vZGVsICYmIG1vZGVsID09PSBDb2xvck1vZGVsLlJHQikge1xuICAgICAgICB2YXIgaGFzSW52YWxpZEhleCA9IE9iamVjdC5lbnRyaWVzKGNvbG9yKS5zb21lKGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICAgICAgICByZXR1cm4gIUhFWC50ZXN0KFwiXCIuY29uY2F0KGl0ZW1bMV0pKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHZhciBoYXNJbnZhbGlkUmVnYiA9IE9iamVjdC5lbnRyaWVzKGNvbG9yKS5zb21lKGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICAgICAgICByZXR1cm4gIShQQ0VOVC50ZXN0KFwiXCIuY29uY2F0KGl0ZW1bMV0pKSB8fFxuICAgICAgICAgICAgICAgICghSEVYLnRlc3QoXCJcIi5jb25jYXQoaXRlbVsxXSkpICYmXG4gICAgICAgICAgICAgICAgICAgICFpc05hTigraXRlbVsxXSkgJiZcbiAgICAgICAgICAgICAgICAgICAgK2l0ZW1bMV0gPD0gMjU1KSk7XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoaGFzSW52YWxpZEhleCAmJiBoYXNJbnZhbGlkUmVnYikge1xuICAgICAgICAgICAgaW52YWxpZCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFoYXNJbnZhbGlkSGV4KSB7XG4gICAgICAgICAgICBtb2RlbCA9IENvbG9yTW9kZWwuSEVYO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmICghbW9kZWwgfHwgaW52YWxpZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoRVJST1JTLk5PVF9BQ0NFUFRFRF9PQkpFQ1RfSU5QVVQpO1xuICAgIH1cbiAgICByZXR1cm4gbW9kZWw7XG59O1xuZXhwb3J0IHZhciBnZXRDb2xvck1vZGVsID0gZnVuY3Rpb24gKGNvbG9yKSB7IHJldHVybiB0eXBlb2YgY29sb3IgPT09ICdzdHJpbmcnXG4gICAgPyBnZXRDb2xvck1vZGVsRnJvbVN0cmluZyhjb2xvcilcbiAgICA6IGdldENvbG9yTW9kZWxGcm9tT2JqZWN0KGNvbG9yKTsgfTtcbmV4cG9ydCB2YXIgZ2V0UkdCT2JqZWN0RnJvbVN0cmluZyA9IChfYSA9IHt9LFxuICAgIF9hW0NvbG9yTW9kZWwuSEVYXSA9IGZ1bmN0aW9uIChjb2xvcikge1xuICAgICAgICB2YXIgY29sb3JTdHIgPSAhfkNPTE9SX0tFWVMuaW5kZXhPZihjb2xvcilcbiAgICAgICAgICAgID8gY29sb3JcbiAgICAgICAgICAgIDogQ29sb3JLZXl3b3Jkc1tjb2xvcl07XG4gICAgICAgIHZhciBtYXRjaCA9IGNvbG9yU3RyLm1hdGNoKENPTE9SUkVHUy5IRVgpO1xuICAgICAgICB2YXIgb2JqZWN0ID0ge1xuICAgICAgICAgICAgcjogZ2V0REVDKG1hdGNoWzFdIHx8IG1hdGNoWzVdKSxcbiAgICAgICAgICAgIGc6IGdldERFQyhtYXRjaFsyXSB8fCBtYXRjaFs2XSksXG4gICAgICAgICAgICBiOiBnZXRERUMobWF0Y2hbM10gfHwgbWF0Y2hbN10pXG4gICAgICAgIH07XG4gICAgICAgIHZhciBhID0gbWF0Y2hbNF0gfHwgbWF0Y2hbOF07XG4gICAgICAgIGlmIChhICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIG9iamVjdC5hID0gZ2V0REVDKGEpIC8gMjU1O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvYmplY3Q7XG4gICAgfSxcbiAgICBfYVtDb2xvck1vZGVsLlJHQl0gPSBmdW5jdGlvbiAoY29sb3IpIHtcbiAgICAgICAgdmFyIG1hdGNoID0gY29sb3IubWF0Y2goQ09MT1JSRUdTLlJHQik7XG4gICAgICAgIHZhciByID0gZ2V0QmFzZTI1NU51bWJlcihtYXRjaFsxXSB8fCBtYXRjaFs1XSk7XG4gICAgICAgIHZhciBnID0gZ2V0QmFzZTI1NU51bWJlcihtYXRjaFsyXSB8fCBtYXRjaFs2XSk7XG4gICAgICAgIHZhciBiID0gZ2V0QmFzZTI1NU51bWJlcihtYXRjaFszXSB8fCBtYXRjaFs3XSk7XG4gICAgICAgIHZhciBhID0gbWF0Y2hbNF0gfHwgbWF0Y2hbOF07XG4gICAgICAgIHZhciBvYmplY3QgPSB7XG4gICAgICAgICAgICByOiBNYXRoLm1pbihyLCAyNTUpLFxuICAgICAgICAgICAgZzogTWF0aC5taW4oZywgMjU1KSxcbiAgICAgICAgICAgIGI6IE1hdGgubWluKGIsIDI1NSlcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKGEgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgb2JqZWN0LmEgPSBub3JtYWxpemVBbHBoYShhKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb2JqZWN0O1xuICAgIH0sXG4gICAgX2FbQ29sb3JNb2RlbC5IU0xdID0gZnVuY3Rpb24gKGNvbG9yKSB7XG4gICAgICAgIHZhciBtYXRjaCA9IGNvbG9yLm1hdGNoKENPTE9SUkVHUy5IU0wpO1xuICAgICAgICB2YXIgaCA9IG5vcm1hbGl6ZUh1ZShtYXRjaFsxXSB8fCBtYXRjaFs1XSk7XG4gICAgICAgIHZhciBzID0gcGVyY2VudChtYXRjaFsyXSB8fCBtYXRjaFs2XSk7XG4gICAgICAgIHZhciBsID0gcGVyY2VudChtYXRjaFszXSB8fCBtYXRjaFs3XSk7XG4gICAgICAgIHZhciBhID0gbWF0Y2hbNF0gfHwgbWF0Y2hbOF07XG4gICAgICAgIHZhciByZ2IgPSBoc2xUb1JHQihoLCBzLCBsKTtcbiAgICAgICAgaWYgKGEgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmdiLmEgPSBub3JtYWxpemVBbHBoYShhKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmdiO1xuICAgIH0sXG4gICAgX2FbQ29sb3JNb2RlbC5DTVlLXSA9IGZ1bmN0aW9uIChjb2xvcikge1xuICAgICAgICB2YXIgbWF0Y2ggPSBjb2xvci5tYXRjaChDT0xPUlJFR1MuQ01ZSyk7XG4gICAgICAgIHZhciBjID0gZ2V0Q01ZS051bWJlcihtYXRjaFsxXSB8fCBtYXRjaFs2XSk7XG4gICAgICAgIHZhciBtID0gZ2V0Q01ZS051bWJlcihtYXRjaFsyXSB8fCBtYXRjaFs3XSk7XG4gICAgICAgIHZhciB5ID0gZ2V0Q01ZS051bWJlcihtYXRjaFszXSB8fCBtYXRjaFs4XSk7XG4gICAgICAgIHZhciBrID0gZ2V0Q01ZS051bWJlcihtYXRjaFs0XSB8fCBtYXRjaFs5XSk7XG4gICAgICAgIHZhciBhID0gbWF0Y2hbNV0gfHwgbWF0Y2hbMTBdO1xuICAgICAgICB2YXIgcmdiID0gY215a1RvUkdCKGMsIG0sIHksIGspO1xuICAgICAgICBpZiAoYSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZ2IuYSA9IG5vcm1hbGl6ZUFscGhhKGEpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZ2I7XG4gICAgfSxcbiAgICBfYSk7XG5leHBvcnQgdmFyIGdldFJHQk9iamVjdEZyb21PYmplY3QgPSAoX2IgPSB7fSxcbiAgICBfYltDb2xvck1vZGVsLkhFWF0gPSBmdW5jdGlvbiAoY29sb3IpIHtcbiAgICAgICAgdmFyIG9iamVjdCA9IHtcbiAgICAgICAgICAgIHI6IGdldEJhc2UyNTVOdW1iZXIoXCJcIi5jb25jYXQoY29sb3IucikpLFxuICAgICAgICAgICAgZzogZ2V0QmFzZTI1NU51bWJlcihcIlwiLmNvbmNhdChjb2xvci5nKSksXG4gICAgICAgICAgICBiOiBnZXRCYXNlMjU1TnVtYmVyKFwiXCIuY29uY2F0KGNvbG9yLmIpKVxuICAgICAgICB9O1xuICAgICAgICBpZiAoaGFzUHJvcChjb2xvciwgJ2EnKSkge1xuICAgICAgICAgICAgb2JqZWN0LmEgPSBNYXRoLm1pbihnZXRCYXNlMjU1TnVtYmVyKFwiXCIuY29uY2F0KGNvbG9yLmEpLCB0cnVlKSwgMSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG9iamVjdDtcbiAgICB9LFxuICAgIF9iW0NvbG9yTW9kZWwuUkdCXSA9IGZ1bmN0aW9uIChjb2xvcikge1xuICAgICAgICByZXR1cm4gdGhpcy5IRVgoY29sb3IpO1xuICAgIH0sXG4gICAgX2JbQ29sb3JNb2RlbC5IU0xdID0gZnVuY3Rpb24gKGNvbG9yKSB7XG4gICAgICAgIHZhciBzID0gcGVyY2VudChcIlwiLmNvbmNhdChjb2xvci5zKSk7XG4gICAgICAgIHZhciBsID0gcGVyY2VudChcIlwiLmNvbmNhdChjb2xvci5sKSk7XG4gICAgICAgIHZhciByZ2IgPSBoc2xUb1JHQihub3JtYWxpemVIdWUoY29sb3IuaCksIHMsIGwpO1xuICAgICAgICBpZiAoaGFzUHJvcChjb2xvciwgJ2EnKSkge1xuICAgICAgICAgICAgcmdiLmEgPSBub3JtYWxpemVBbHBoYShjb2xvci5hKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmdiO1xuICAgIH0sXG4gICAgX2JbQ29sb3JNb2RlbC5DTVlLXSA9IGZ1bmN0aW9uIChjb2xvcikge1xuICAgICAgICB2YXIgYyA9IGdldENNWUtOdW1iZXIoXCJcIi5jb25jYXQoY29sb3IuYykpO1xuICAgICAgICB2YXIgbSA9IGdldENNWUtOdW1iZXIoXCJcIi5jb25jYXQoY29sb3IubSkpO1xuICAgICAgICB2YXIgeSA9IGdldENNWUtOdW1iZXIoXCJcIi5jb25jYXQoY29sb3IueSkpO1xuICAgICAgICB2YXIgayA9IGdldENNWUtOdW1iZXIoXCJcIi5jb25jYXQoY29sb3IuaykpO1xuICAgICAgICB2YXIgcmdiID0gY215a1RvUkdCKGMsIG0sIHksIGspO1xuICAgICAgICBpZiAoaGFzUHJvcChjb2xvciwgJ2EnKSkge1xuICAgICAgICAgICAgcmdiLmEgPSBub3JtYWxpemVBbHBoYShjb2xvci5hKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmdiO1xuICAgIH0sXG4gICAgX2IpO1xuZXhwb3J0IHZhciBnZXRSR0JPYmplY3QgPSBmdW5jdGlvbiAoY29sb3IsIG1vZGVsKSB7XG4gICAgaWYgKG1vZGVsID09PSB2b2lkIDApIHsgbW9kZWwgPSBnZXRDb2xvck1vZGVsKGNvbG9yKTsgfVxuICAgIHJldHVybiB0eXBlb2YgY29sb3IgPT09ICdzdHJpbmcnXG4gICAgICAgID8gZ2V0UkdCT2JqZWN0RnJvbVN0cmluZ1ttb2RlbF0oY29sb3IpXG4gICAgICAgIDogZ2V0UkdCT2JqZWN0RnJvbU9iamVjdFttb2RlbF0oY29sb3IpO1xufTtcbmV4cG9ydCB2YXIgdHJhbnNsYXRlQ29sb3IgPSAoX2MgPSB7fSxcbiAgICBfY1tDb2xvck1vZGVsLkhFWF0gPSBmdW5jdGlvbiAoY29sb3IpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHI6IGdldEhFWChjb2xvci5yKSxcbiAgICAgICAgICAgIGc6IGdldEhFWChjb2xvci5nKSxcbiAgICAgICAgICAgIGI6IGdldEhFWChjb2xvci5iKVxuICAgICAgICB9O1xuICAgIH0sXG4gICAgX2MuSEVYQSA9IGZ1bmN0aW9uIChjb2xvcikge1xuICAgICAgICB2YXIgcmdiID0gdHJhbnNsYXRlQ29sb3IuSEVYKGNvbG9yKTtcbiAgICAgICAgcmdiLmEgPSBoYXNQcm9wKGNvbG9yLCAnYScpXG4gICAgICAgICAgICA/IGdldEhFWChjb2xvci5hICogMjU1KVxuICAgICAgICAgICAgOiAnMHhGRic7XG4gICAgICAgIHJldHVybiByZ2I7XG4gICAgfSxcbiAgICBfY1tDb2xvck1vZGVsLlJHQl0gPSBmdW5jdGlvbiAoY29sb3IsIG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKGhhc1Byb3AoY29sb3IsICdhJykpIHtcbiAgICAgICAgICAgIGRlbGV0ZSBjb2xvci5hO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByb3VuZFJHQk9iamVjdChjb2xvciwgb3B0aW9ucyk7XG4gICAgfSxcbiAgICBfYy5SR0JBID0gZnVuY3Rpb24gKGNvbG9yLCBvcHRpb25zKSB7XG4gICAgICAgIGNvbG9yLmEgPSBoYXNQcm9wKGNvbG9yLCAnYScpXG4gICAgICAgICAgICA/IHJvdW5kKGNvbG9yLmEpXG4gICAgICAgICAgICA6IDE7XG4gICAgICAgIHJldHVybiByb3VuZFJHQk9iamVjdChjb2xvciwgb3B0aW9ucyk7XG4gICAgfSxcbiAgICBfY1tDb2xvck1vZGVsLkhTTF0gPSBmdW5jdGlvbiAoY29sb3IsIG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIGhzbCA9IHJnYlRvSFNMKGNvbG9yLnIsIGNvbG9yLmcsIGNvbG9yLmIpO1xuICAgICAgICBkZWxldGUgaHNsLmE7XG4gICAgICAgIHJldHVybiByb3VuZEhTTE9iamVjdChoc2wsIG9wdGlvbnMpO1xuICAgIH0sXG4gICAgX2MuSFNMQSA9IGZ1bmN0aW9uIChjb2xvciwgb3B0aW9ucykge1xuICAgICAgICB2YXIgZGVjaW1hbHMgPSBvcHRpb25zLmRlY2ltYWxzO1xuICAgICAgICB2YXIgaHNsID0gdHJhbnNsYXRlQ29sb3IuSFNMKGNvbG9yLCBvcHRpb25zKTtcbiAgICAgICAgaHNsLmEgPSBoYXNQcm9wKGNvbG9yLCAnYScpXG4gICAgICAgICAgICA/IHJvdW5kKGNvbG9yLmEsIGRlY2ltYWxzKVxuICAgICAgICAgICAgOiAxO1xuICAgICAgICByZXR1cm4gaHNsO1xuICAgIH0sXG4gICAgX2NbQ29sb3JNb2RlbC5DTVlLXSA9IGZ1bmN0aW9uIChjb2xvciwgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gcm91bmRDTVlLT2JqZWN0KHJnYlRvQ01ZSyhjb2xvci5yLCBjb2xvci5nLCBjb2xvci5iKSwgb3B0aW9ucyk7XG4gICAgfSxcbiAgICBfYy5DTVlLQSA9IGZ1bmN0aW9uIChjb2xvciwgb3B0aW9ucykge1xuICAgICAgICB2YXIgZGVjaW1hbHMgPSBvcHRpb25zLmRlY2ltYWxzO1xuICAgICAgICB2YXIgY215ayA9IHRyYW5zbGF0ZUNvbG9yLkNNWUsoY29sb3IsIG9wdGlvbnMpO1xuICAgICAgICBjbXlrLmEgPSBoYXNQcm9wKGNvbG9yLCAnYScpXG4gICAgICAgICAgICA/IHJvdW5kKGNvbG9yLmEsIGRlY2ltYWxzKVxuICAgICAgICAgICAgOiAxO1xuICAgICAgICByZXR1cm4gY215aztcbiAgICB9LFxuICAgIF9jKTtcbmV4cG9ydCB2YXIgYmxlbmQgPSBmdW5jdGlvbiAoZnJvbSwgdG8sIHN0ZXBzKSB7XG4gICAgdmFyIGRpdiA9IHN0ZXBzIC0gMTtcbiAgICB2YXIgZGlmZlIgPSAodG8uciAtIGZyb20ucikgLyBkaXY7XG4gICAgdmFyIGRpZmZHID0gKHRvLmcgLSBmcm9tLmcpIC8gZGl2O1xuICAgIHZhciBkaWZmQiA9ICh0by5iIC0gZnJvbS5iKSAvIGRpdjtcbiAgICB2YXIgZnJvbUEgPSBub3JtYWxpemVBbHBoYShmcm9tLmEpO1xuICAgIHZhciB0b0EgPSBub3JtYWxpemVBbHBoYSh0by5hKTtcbiAgICB2YXIgZGlmZkEgPSAodG9BIC0gZnJvbUEpIC8gZGl2O1xuICAgIHJldHVybiBBcnJheShzdGVwcykuZmlsbChudWxsKS5tYXAoZnVuY3Rpb24gKF9fbiwgaSkge1xuICAgICAgICBpZiAoaSA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIGZyb207XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGkgPT09IGRpdikge1xuICAgICAgICAgICAgcmV0dXJuIHRvO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICByOiByb3VuZChmcm9tLnIgKyBkaWZmUiAqIGkpLFxuICAgICAgICAgICAgZzogcm91bmQoZnJvbS5nICsgZGlmZkcgKiBpKSxcbiAgICAgICAgICAgIGI6IHJvdW5kKGZyb20uYiArIGRpZmZCICogaSksXG4gICAgICAgICAgICBhOiByb3VuZChmcm9tQSArIGRpZmZBICogaSlcbiAgICAgICAgfTtcbiAgICB9KTtcbn07XG5leHBvcnQgdmFyIGdldENvbG9yTWl4dHVyZSA9IGZ1bmN0aW9uIChjb2xvciwgc3RlcHMsIHNoYWRlcywgb3B0aW9ucykge1xuICAgIHZhciBtb2RlbCA9IGdldENvbG9yTW9kZWwoY29sb3IpO1xuICAgIHZhciBpc0NTUyA9IHR5cGVvZiBjb2xvciA9PT0gJ3N0cmluZyc7XG4gICAgdmFyIHJnYiA9IGdldFJHQk9iamVjdChjb2xvciwgbW9kZWwpO1xuICAgIHZhciBoYXNBbHBoYSA9ICgodHlwZW9mIGNvbG9yID09PSAnc3RyaW5nJyAmJiBoYXNQcm9wKHJnYiwgJ2EnKSkgfHxcbiAgICAgICAgKHR5cGVvZiBjb2xvciAhPT0gJ3N0cmluZycgJiYgaGFzUHJvcChjb2xvciwgJ2EnKSkpO1xuICAgIHZhciBoc2wgPSByZ2JUb0hTTChyZ2IuciwgcmdiLmcsIHJnYi5iLCByZ2IuYSk7XG4gICAgaWYgKCFoYXNBbHBoYSlcbiAgICAgICAgZGVsZXRlIGhzbC5hO1xuICAgIHZhciBpbmNyZW1lbnQgPSBzaGFkZXNcbiAgICAgICAgPyBoc2wubCAvIChzdGVwcyArIDEpXG4gICAgICAgIDogKDEwMCAtIGhzbC5sKSAvIChzdGVwcyArIDEpO1xuICAgIHZhciBoc2xNYXAgPSBBcnJheShzdGVwcykuZmlsbChudWxsKS5tYXAoZnVuY3Rpb24gKF9fbiwgaSkgeyByZXR1cm4gKF9fYXNzaWduKF9fYXNzaWduKHt9LCBoc2wpLCB7IGw6IGhzbC5sICsgaW5jcmVtZW50ICogKGkgKyAxKSAqICgxIC0gK3NoYWRlcyAqIDIpIH0pKTsgfSk7XG4gICAgc3dpdGNoIChtb2RlbCkge1xuICAgICAgICBjYXNlIENvbG9yTW9kZWwuSEVYOlxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcmV0dXJuIGhzbE1hcC5tYXAoZnVuY3Rpb24gKGhzbENvbG9yKSB7XG4gICAgICAgICAgICAgICAgdmFyIHJnYkNvbG9yID0gaHNsVG9SR0IoaHNsQ29sb3IuaCwgaHNsQ29sb3IucywgaHNsQ29sb3IubCk7XG4gICAgICAgICAgICAgICAgaWYgKGhhc0FscGhhKVxuICAgICAgICAgICAgICAgICAgICByZ2JDb2xvci5hID0gaHNsQ29sb3IuYTtcbiAgICAgICAgICAgICAgICByZXR1cm4gaXNDU1NcbiAgICAgICAgICAgICAgICAgICAgPyBoYXNBbHBoYVxuICAgICAgICAgICAgICAgICAgICAgICAgPyBDU1MuSEVYKHJvdW5kUkdCT2JqZWN0KF9fYXNzaWduKF9fYXNzaWduKHt9LCByZ2JDb2xvciksIHsgYTogcm91bmQocmdiQ29sb3IuYSAqIDI1NSkgfSksIG9wdGlvbnMpKVxuICAgICAgICAgICAgICAgICAgICAgICAgOiBDU1MuSEVYKHJvdW5kUkdCT2JqZWN0KHJnYkNvbG9yLCBvcHRpb25zKSlcbiAgICAgICAgICAgICAgICAgICAgOiBoYXNBbHBoYVxuICAgICAgICAgICAgICAgICAgICAgICAgPyB0cmFuc2xhdGVDb2xvci5IRVhBKHJnYkNvbG9yKVxuICAgICAgICAgICAgICAgICAgICAgICAgOiB0cmFuc2xhdGVDb2xvci5IRVgocmdiQ29sb3IpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIGNhc2UgQ29sb3JNb2RlbC5SR0I6XG4gICAgICAgICAgICByZXR1cm4gaHNsTWFwLm1hcChmdW5jdGlvbiAoaHNsQ29sb3IpIHtcbiAgICAgICAgICAgICAgICB2YXIgcmdiQ29sb3IgPSBoc2xUb1JHQihoc2xDb2xvci5oLCBoc2xDb2xvci5zLCBoc2xDb2xvci5sKTtcbiAgICAgICAgICAgICAgICBpZiAoaGFzQWxwaGEpXG4gICAgICAgICAgICAgICAgICAgIHJnYkNvbG9yLmEgPSBoc2xDb2xvci5hO1xuICAgICAgICAgICAgICAgIHJldHVybiBpc0NTU1xuICAgICAgICAgICAgICAgICAgICA/IENTUy5SR0Iocm91bmRSR0JPYmplY3QocmdiQ29sb3IsIG9wdGlvbnMpLCBvcHRpb25zKVxuICAgICAgICAgICAgICAgICAgICA6IGhhc0FscGhhXG4gICAgICAgICAgICAgICAgICAgICAgICA/IHRyYW5zbGF0ZUNvbG9yLlJHQkEocmdiQ29sb3IsIG9wdGlvbnMpXG4gICAgICAgICAgICAgICAgICAgICAgICA6IHRyYW5zbGF0ZUNvbG9yLlJHQihyZ2JDb2xvciwgb3B0aW9ucyk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgY2FzZSBDb2xvck1vZGVsLkhTTDpcbiAgICAgICAgICAgIHJldHVybiBoc2xNYXAubWFwKGZ1bmN0aW9uIChoc2xDb2xvcikge1xuICAgICAgICAgICAgICAgIHJldHVybiBpc0NTU1xuICAgICAgICAgICAgICAgICAgICA/IENTUy5IU0wocm91bmRIU0xPYmplY3QoaHNsQ29sb3IsIG9wdGlvbnMpLCBvcHRpb25zKVxuICAgICAgICAgICAgICAgICAgICA6IGhhc0FscGhhXG4gICAgICAgICAgICAgICAgICAgICAgICA/IHRyYW5zbGF0ZUNvbG9yLkhTTEEoX19hc3NpZ24oX19hc3NpZ24oe30sIGhzbFRvUkdCKGhzbENvbG9yLmgsIGhzbENvbG9yLnMsIGhzbENvbG9yLmwpKSwgeyBhOiBoc2xDb2xvci5hIH0pLCBvcHRpb25zKVxuICAgICAgICAgICAgICAgICAgICAgICAgOiB0cmFuc2xhdGVDb2xvci5IU0woaHNsVG9SR0IoaHNsQ29sb3IuaCwgaHNsQ29sb3IucywgaHNsQ29sb3IubCksIG9wdGlvbnMpO1xuICAgICAgICAgICAgfSk7XG4gICAgfVxufTtcbmV4cG9ydCB2YXIgY29sb3JIYXJtb255ID0gKF9kID0ge1xuICAgICAgICBidWlsZEhhcm1vbnk6IGZ1bmN0aW9uIChjb2xvciwgaGFybW9ueUZ1bmN0aW9uLCBtb2RlLCBvcHRpb25zKSB7XG4gICAgICAgICAgICB2YXIgbW9kZWwgPSBnZXRDb2xvck1vZGVsKGNvbG9yKTtcbiAgICAgICAgICAgIHZhciByZ2IgPSBnZXRSR0JPYmplY3QoY29sb3IsIG1vZGVsKTtcbiAgICAgICAgICAgIHZhciBoc2wgPSByZ2JUb0hTTChyZ2IuciwgcmdiLmcsIHJnYi5iLCByZ2IuYSk7XG4gICAgICAgICAgICB2YXIgaGFzQWxwaGEgPSAoKHR5cGVvZiBjb2xvciA9PT0gJ3N0cmluZycgJiYgaGFzUHJvcChyZ2IsICdhJykpIHx8XG4gICAgICAgICAgICAgICAgKHR5cGVvZiBjb2xvciAhPT0gJ3N0cmluZycgJiYgaGFzUHJvcChjb2xvciwgJ2EnKSkpO1xuICAgICAgICAgICAgdmFyIGlzQ1NTID0gdHlwZW9mIGNvbG9yID09PSAnc3RyaW5nJztcbiAgICAgICAgICAgIHN3aXRjaCAobW9kZWwpIHtcbiAgICAgICAgICAgICAgICBjYXNlIENvbG9yTW9kZWwuSEVYOlxuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBoYXNBbHBoYVxuICAgICAgICAgICAgICAgICAgICAgICAgPyB0aGlzLkhFWEEocm91bmRIU0xPYmplY3QoaHNsLCBudWxsKSwgaGFybW9ueUZ1bmN0aW9uLCBtb2RlLCBpc0NTUylcbiAgICAgICAgICAgICAgICAgICAgICAgIDogdGhpcy5IRVgocm91bmRIU0xPYmplY3QoaHNsLCBudWxsKSwgaGFybW9ueUZ1bmN0aW9uLCBtb2RlLCBpc0NTUyk7XG4gICAgICAgICAgICAgICAgY2FzZSBDb2xvck1vZGVsLkhTTDpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGhhc0FscGhhXG4gICAgICAgICAgICAgICAgICAgICAgICA/IHRoaXMuSFNMQShoc2wsIGhhcm1vbnlGdW5jdGlvbiwgbW9kZSwgaXNDU1MsIG9wdGlvbnMpXG4gICAgICAgICAgICAgICAgICAgICAgICA6IHRoaXMuSFNMKGhzbCwgaGFybW9ueUZ1bmN0aW9uLCBtb2RlLCBpc0NTUywgb3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgY2FzZSBDb2xvck1vZGVsLlJHQjpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGhhc0FscGhhXG4gICAgICAgICAgICAgICAgICAgICAgICA/IHRoaXMuUkdCQShoc2wsIGhhcm1vbnlGdW5jdGlvbiwgbW9kZSwgaXNDU1MsIG9wdGlvbnMpXG4gICAgICAgICAgICAgICAgICAgICAgICA6IHRoaXMuUkdCKGhzbCwgaGFybW9ueUZ1bmN0aW9uLCBtb2RlLCBpc0NTUywgb3B0aW9ucyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LFxuICAgIF9kW0NvbG9yTW9kZWwuSEVYXSA9IGZ1bmN0aW9uIChjb2xvciwgaGFybW9ueUZ1bmN0aW9uLCBtb2RlLCBjc3MpIHtcbiAgICAgICAgdmFyIGFycmF5ID0gaGFybW9ueUZ1bmN0aW9uKGNvbG9yLCBtb2RlKTtcbiAgICAgICAgcmV0dXJuIGFycmF5Lm1hcChmdW5jdGlvbiAoYykgeyByZXR1cm4gKGNzc1xuICAgICAgICAgICAgPyBDU1MuSEVYKGhzbFRvUkdCKGMuaCwgYy5zLCBjLmwpKVxuICAgICAgICAgICAgOiB0cmFuc2xhdGVDb2xvci5IRVgoaHNsVG9SR0IoYy5oLCBjLnMsIGMubCkpKTsgfSk7XG4gICAgfSxcbiAgICBfZC5IRVhBID0gZnVuY3Rpb24gKGNvbG9yLCBoYXJtb255RnVuY3Rpb24sIG1vZGUsIGNzcykge1xuICAgICAgICB2YXIgYXJyYXkgPSBoYXJtb255RnVuY3Rpb24oY29sb3IsIG1vZGUpO1xuICAgICAgICByZXR1cm4gYXJyYXkubWFwKGZ1bmN0aW9uIChjKSB7IHJldHVybiAoY3NzXG4gICAgICAgICAgICA/IENTUy5IRVgoX19hc3NpZ24oX19hc3NpZ24oe30sIGhzbFRvUkdCKGMuaCwgYy5zLCBjLmwpKSwgeyBhOiBub3JtYWxpemVBbHBoYShjLmEpICogMjU1IH0pKVxuICAgICAgICAgICAgOiB0cmFuc2xhdGVDb2xvci5IRVhBKF9fYXNzaWduKF9fYXNzaWduKHt9LCBoc2xUb1JHQihjLmgsIGMucywgYy5sKSksIHsgYTogbm9ybWFsaXplQWxwaGEoYy5hKSB9KSkpOyB9KTtcbiAgICB9LFxuICAgIF9kW0NvbG9yTW9kZWwuUkdCXSA9IGZ1bmN0aW9uIChjb2xvciwgaGFybW9ueUZ1bmN0aW9uLCBtb2RlLCBjc3MsIG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIGFycmF5ID0gaGFybW9ueUZ1bmN0aW9uKGNvbG9yLCBtb2RlKTtcbiAgICAgICAgcmV0dXJuIGFycmF5Lm1hcChmdW5jdGlvbiAoYykgeyByZXR1cm4gKGNzc1xuICAgICAgICAgICAgPyBDU1MuUkdCKHJvdW5kUkdCT2JqZWN0KGhzbFRvUkdCKGMuaCwgYy5zLCBjLmwpLCBvcHRpb25zKSwgb3B0aW9ucylcbiAgICAgICAgICAgIDogdHJhbnNsYXRlQ29sb3IuUkdCKGhzbFRvUkdCKGMuaCwgYy5zLCBjLmwpLCBvcHRpb25zKSk7IH0pO1xuICAgIH0sXG4gICAgX2QuUkdCQSA9IGZ1bmN0aW9uIChjb2xvciwgaGFybW9ueUZ1bmN0aW9uLCBtb2RlLCBjc3MsIG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIGFycmF5ID0gaGFybW9ueUZ1bmN0aW9uKGNvbG9yLCBtb2RlKTtcbiAgICAgICAgcmV0dXJuIGFycmF5Lm1hcChmdW5jdGlvbiAoYykgeyByZXR1cm4gKGNzc1xuICAgICAgICAgICAgPyBDU1MuUkdCKHJvdW5kUkdCT2JqZWN0KF9fYXNzaWduKF9fYXNzaWduKHt9LCBoc2xUb1JHQihjLmgsIGMucywgYy5sKSksIHsgYTogbm9ybWFsaXplQWxwaGEoYy5hKSB9KSwgb3B0aW9ucyksIG9wdGlvbnMpXG4gICAgICAgICAgICA6IHRyYW5zbGF0ZUNvbG9yLlJHQkEoX19hc3NpZ24oX19hc3NpZ24oe30sIGhzbFRvUkdCKGMuaCwgYy5zLCBjLmwpKSwgeyBhOiBub3JtYWxpemVBbHBoYShjLmEpIH0pLCBvcHRpb25zKSk7IH0pO1xuICAgIH0sXG4gICAgX2RbQ29sb3JNb2RlbC5IU0xdID0gZnVuY3Rpb24gKGNvbG9yLCBoYXJtb255RnVuY3Rpb24sIG1vZGUsIGNzcywgb3B0aW9ucykge1xuICAgICAgICB2YXIgYXJyYXkgPSBoYXJtb255RnVuY3Rpb24oY29sb3IsIG1vZGUpO1xuICAgICAgICByZXR1cm4gYXJyYXkubWFwKGZ1bmN0aW9uIChjKSB7IHJldHVybiAoY3NzXG4gICAgICAgICAgICA/IENTUy5IU0wocm91bmRIU0xPYmplY3Qoe1xuICAgICAgICAgICAgICAgIGg6IGMuaCxcbiAgICAgICAgICAgICAgICBzOiBjLnMsXG4gICAgICAgICAgICAgICAgbDogYy5sXG4gICAgICAgICAgICB9LCBvcHRpb25zKSwgb3B0aW9ucylcbiAgICAgICAgICAgIDogdHJhbnNsYXRlQ29sb3IuSFNMKGhzbFRvUkdCKGMuaCwgYy5zLCBjLmwpLCBvcHRpb25zKSk7IH0pO1xuICAgIH0sXG4gICAgX2QuSFNMQSA9IGZ1bmN0aW9uIChjb2xvciwgaGFybW9ueUZ1bmN0aW9uLCBtb2RlLCBjc3MsIG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIGFycmF5ID0gaGFybW9ueUZ1bmN0aW9uKGNvbG9yLCBtb2RlKTtcbiAgICAgICAgcmV0dXJuIGFycmF5Lm1hcChmdW5jdGlvbiAoYykgeyByZXR1cm4gKGNzc1xuICAgICAgICAgICAgPyBDU1MuSFNMKHJvdW5kSFNMT2JqZWN0KF9fYXNzaWduKF9fYXNzaWduKHt9LCBjKSwgeyBhOiBub3JtYWxpemVBbHBoYShjLmEpIH0pLCBvcHRpb25zKSwgb3B0aW9ucylcbiAgICAgICAgICAgIDogdHJhbnNsYXRlQ29sb3IuSFNMQShfX2Fzc2lnbihfX2Fzc2lnbih7fSwgaHNsVG9SR0IoYy5oLCBjLnMsIGMubCkpLCB7IGE6IG5vcm1hbGl6ZUFscGhhKGMuYSkgfSksIG9wdGlvbnMpKTsgfSk7XG4gICAgfSxcbiAgICBfZCk7XG5leHBvcnQgdmFyIGNvbG9yTWl4ZXIgPSAoX2UgPSB7XG4gICAgICAgIG1peDogZnVuY3Rpb24gKGNvbG9ycywgbW9kZSkge1xuICAgICAgICAgICAgdmFyIHJnYk1hcCA9IGNvbG9ycy5tYXAoZnVuY3Rpb24gKGNvbG9yKSB7XG4gICAgICAgICAgICAgICAgdmFyIG1vZGVsID0gZ2V0Q29sb3JNb2RlbChjb2xvcik7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGdldFJHQk9iamVjdChjb2xvciwgbW9kZWwpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB2YXIgcnliTWFwID0gbW9kZSA9PT0gTWl4LlNVQlRSQUNUSVZFXG4gICAgICAgICAgICAgICAgPyByZ2JNYXAubWFwKGZ1bmN0aW9uIChjb2xvcikge1xuICAgICAgICAgICAgICAgICAgICB2YXIgcnliID0gcmdiVG9SWUIoY29sb3IuciwgY29sb3IuZywgY29sb3IuYik7XG4gICAgICAgICAgICAgICAgICAgIGlmIChoYXNQcm9wKGNvbG9yLCAnYScpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByeWIuYSA9IGNvbG9yLmE7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJ5YjtcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIDogbnVsbDtcbiAgICAgICAgICAgIGZ1bmN0aW9uIGNyZWF0ZU1peChpdGVtcykge1xuICAgICAgICAgICAgICAgIHZhciBpbml0aWFsID0gbW9kZSA9PT0gTWl4LkFERElUSVZFXG4gICAgICAgICAgICAgICAgICAgID8geyByOiAwLCBnOiAwLCBiOiAwLCBhOiAwIH1cbiAgICAgICAgICAgICAgICAgICAgOiB7IHI6IDAsIHk6IDAsIGI6IDAsIGE6IDAgfTtcbiAgICAgICAgICAgICAgICByZXR1cm4gaXRlbXMucmVkdWNlKGZ1bmN0aW9uIChtaXgsIGNvbG9yKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBjb2xvckEgPSBoYXNQcm9wKGNvbG9yLCAnYScpID8gY29sb3IuYSA6IDE7XG4gICAgICAgICAgICAgICAgICAgIHZhciBjb21tb24gPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByOiBNYXRoLm1pbihtaXguciArIGNvbG9yLnIgKiBjb2xvckEsIDI1NSksXG4gICAgICAgICAgICAgICAgICAgICAgICBiOiBNYXRoLm1pbihtaXguYiArIGNvbG9yLmIgKiBjb2xvckEsIDI1NSksXG4gICAgICAgICAgICAgICAgICAgICAgICBhOiAxIC0gKDEgLSBjb2xvckEpICogKDEgLSBtaXguYSlcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG1peEdZID0gJ2cnIGluIG1peFxuICAgICAgICAgICAgICAgICAgICAgICAgPyBtaXguZ1xuICAgICAgICAgICAgICAgICAgICAgICAgOiBtaXgueTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNvbG9yR1kgPSAnZycgaW4gY29sb3JcbiAgICAgICAgICAgICAgICAgICAgICAgID8gY29sb3IuZ1xuICAgICAgICAgICAgICAgICAgICAgICAgOiBjb2xvci55O1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gX19hc3NpZ24oX19hc3NpZ24oe30sIGNvbW1vbiksIChtb2RlID09PSBNaXguQURESVRJVkVcbiAgICAgICAgICAgICAgICAgICAgICAgID8geyBnOiBNYXRoLm1pbihtaXhHWSArIGNvbG9yR1kgKiBjb2xvckEsIDI1NSkgfVxuICAgICAgICAgICAgICAgICAgICAgICAgOiB7IHk6IE1hdGgubWluKG1peEdZICsgY29sb3JHWSAqIGNvbG9yQSwgMjU1KSB9KSk7XG4gICAgICAgICAgICAgICAgfSwgaW5pdGlhbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgbWl4O1xuICAgICAgICAgICAgaWYgKG1vZGUgPT09IE1peC5BRERJVElWRSkge1xuICAgICAgICAgICAgICAgIG1peCA9IGNyZWF0ZU1peChyZ2JNYXApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFyIHJ5YiA9IGNyZWF0ZU1peChyeWJNYXApO1xuICAgICAgICAgICAgICAgIG1peCA9IHJ5YlRvUkdCKHJ5Yi5yLCByeWIueSwgcnliLmIpO1xuICAgICAgICAgICAgICAgIG1peC5hID0gcnliLmE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHI6IHJvdW5kKG1peC5yKSxcbiAgICAgICAgICAgICAgICBnOiByb3VuZChtaXguZyksXG4gICAgICAgICAgICAgICAgYjogcm91bmQobWl4LmIpLFxuICAgICAgICAgICAgICAgIGE6IG1pbm1heChtaXguYSwgMCwgMSlcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9LFxuICAgIF9lW0NvbG9yTW9kZWwuSEVYXSA9IGZ1bmN0aW9uIChjb2xvcnMsIG1vZGUsIGNzcykge1xuICAgICAgICB2YXIgbWl4ID0gdGhpcy5taXgoY29sb3JzLCBtb2RlKTtcbiAgICAgICAgZGVsZXRlIG1peC5hO1xuICAgICAgICByZXR1cm4gKGNzc1xuICAgICAgICAgICAgPyBDU1MuSEVYKG1peClcbiAgICAgICAgICAgIDogdHJhbnNsYXRlQ29sb3IuSEVYKG1peCkpO1xuICAgIH0sXG4gICAgX2UuSEVYQSA9IGZ1bmN0aW9uIChjb2xvcnMsIG1vZGUsIGNzcykge1xuICAgICAgICB2YXIgbWl4ID0gdGhpcy5taXgoY29sb3JzLCBtb2RlKTtcbiAgICAgICAgbWl4LmEgPSBjc3NcbiAgICAgICAgICAgID8gbm9ybWFsaXplQWxwaGEobWl4LmEpICogMjU1XG4gICAgICAgICAgICA6IG5vcm1hbGl6ZUFscGhhKG1peC5hKTtcbiAgICAgICAgcmV0dXJuIChjc3NcbiAgICAgICAgICAgID8gQ1NTLkhFWChtaXgpXG4gICAgICAgICAgICA6IHRyYW5zbGF0ZUNvbG9yLkhFWEEobWl4KSk7XG4gICAgfSxcbiAgICBfZVtDb2xvck1vZGVsLlJHQl0gPSBmdW5jdGlvbiAoY29sb3JzLCBtb2RlLCBjc3MsIG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIG1peCA9IHRoaXMubWl4KGNvbG9ycywgbW9kZSk7XG4gICAgICAgIGRlbGV0ZSBtaXguYTtcbiAgICAgICAgcmV0dXJuIChjc3NcbiAgICAgICAgICAgID8gQ1NTLlJHQihtaXgsIG9wdGlvbnMpXG4gICAgICAgICAgICA6IHRyYW5zbGF0ZUNvbG9yLlJHQihtaXgsIG9wdGlvbnMpKTtcbiAgICB9LFxuICAgIF9lLlJHQkEgPSBmdW5jdGlvbiAoY29sb3JzLCBtb2RlLCBjc3MsIG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIG1peCA9IHRoaXMubWl4KGNvbG9ycywgbW9kZSk7XG4gICAgICAgIHJldHVybiAoY3NzXG4gICAgICAgICAgICA/IENTUy5SR0IobWl4LCBvcHRpb25zKVxuICAgICAgICAgICAgOiB0cmFuc2xhdGVDb2xvci5SR0JBKG1peCwgb3B0aW9ucykpO1xuICAgIH0sXG4gICAgX2VbQ29sb3JNb2RlbC5IU0xdID0gZnVuY3Rpb24gKGNvbG9ycywgbW9kZSwgY3NzLCBvcHRpb25zKSB7XG4gICAgICAgIHZhciBtaXggPSB0aGlzLm1peChjb2xvcnMsIG1vZGUpO1xuICAgICAgICB2YXIgaHNsID0gcmdiVG9IU0wobWl4LnIsIG1peC5nLCBtaXguYik7XG4gICAgICAgIGRlbGV0ZSBtaXguYTtcbiAgICAgICAgZGVsZXRlIGhzbC5hO1xuICAgICAgICByZXR1cm4gKGNzc1xuICAgICAgICAgICAgPyBDU1MuSFNMKGhzbCwgb3B0aW9ucylcbiAgICAgICAgICAgIDogdHJhbnNsYXRlQ29sb3IuSFNMKG1peCwgb3B0aW9ucykpO1xuICAgIH0sXG4gICAgX2UuSFNMQSA9IGZ1bmN0aW9uIChjb2xvcnMsIG1vZGUsIGNzcywgb3B0aW9ucykge1xuICAgICAgICB2YXIgbWl4ID0gdGhpcy5taXgoY29sb3JzLCBtb2RlKTtcbiAgICAgICAgdmFyIGhzbCA9IHJnYlRvSFNMKG1peC5yLCBtaXguZywgbWl4LmIsIG1peC5hKTtcbiAgICAgICAgcmV0dXJuIChjc3NcbiAgICAgICAgICAgID8gQ1NTLkhTTChoc2wsIG9wdGlvbnMpXG4gICAgICAgICAgICA6IHRyYW5zbGF0ZUNvbG9yLkhTTEEobWl4LCBvcHRpb25zKSk7XG4gICAgfSxcbiAgICBfZSk7XG5leHBvcnQgdmFyIHJvdW5kUkdCT2JqZWN0ID0gZnVuY3Rpb24gKGNvbG9yLCBvcHRpb25zKSB7XG4gICAgdmFyIGRlY2ltYWxzID0gb3B0aW9ucy5kZWNpbWFscztcbiAgICByZXR1cm4gX19hc3NpZ24oeyByOiByb3VuZChjb2xvci5yLCBkZWNpbWFscyksIGc6IHJvdW5kKGNvbG9yLmcsIGRlY2ltYWxzKSwgYjogcm91bmQoY29sb3IuYiwgZGVjaW1hbHMpIH0sIChoYXNQcm9wKGNvbG9yLCAnYScpXG4gICAgICAgID8ge1xuICAgICAgICAgICAgYTogcm91bmQoY29sb3IuYSwgZGVjaW1hbHMpXG4gICAgICAgIH1cbiAgICAgICAgOiB7fSkpO1xufTtcbmV4cG9ydCB2YXIgcm91bmRIU0xPYmplY3QgPSBmdW5jdGlvbiAoY29sb3IsIG9wdGlvbnMpIHtcbiAgICB2YXIgZGVjaW1hbHMgPSBvcHRpb25zXG4gICAgICAgID8gb3B0aW9ucy5kZWNpbWFsc1xuICAgICAgICA6IDA7XG4gICAgdmFyIGFuZ2xlc1VuaXRzID0gb3B0aW9uc1xuICAgICAgICA/IG9wdGlvbnMuYW5nbGVzVW5pdFxuICAgICAgICA6IEFuZ2xlc1VuaXRFbnVtLk5PTkU7XG4gICAgcmV0dXJuIF9fYXNzaWduKHsgaDogZ2V0VHJhbnNsYXRlZEh1ZShjb2xvci5oLCBhbmdsZXNVbml0cywgZGVjaW1hbHMpLCBzOiByb3VuZChjb2xvci5zLCBkZWNpbWFscyksIGw6IHJvdW5kKGNvbG9yLmwsIGRlY2ltYWxzKSB9LCAoaGFzUHJvcChjb2xvciwgJ2EnKVxuICAgICAgICA/IHtcbiAgICAgICAgICAgIGE6IHJvdW5kKGNvbG9yLmEsIGRlY2ltYWxzKVxuICAgICAgICB9XG4gICAgICAgIDoge30pKTtcbn07XG5leHBvcnQgdmFyIHJvdW5kQ01ZS09iamVjdCA9IGZ1bmN0aW9uIChjb2xvciwgb3B0aW9ucykge1xuICAgIHZhciBkZWNpbWFscyA9IG9wdGlvbnMuZGVjaW1hbHM7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgYzogcm91bmQoY29sb3IuYywgZGVjaW1hbHMpLFxuICAgICAgICBtOiByb3VuZChjb2xvci5tLCBkZWNpbWFscyksXG4gICAgICAgIHk6IHJvdW5kKGNvbG9yLnksIGRlY2ltYWxzKSxcbiAgICAgICAgazogcm91bmQoY29sb3IuaywgZGVjaW1hbHMpXG4gICAgfTtcbn07XG4iLCJ2YXIgX19hc3NpZ24gPSAodGhpcyAmJiB0aGlzLl9fYXNzaWduKSB8fCBmdW5jdGlvbiAoKSB7XG4gICAgX19hc3NpZ24gPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uKHQpIHtcbiAgICAgICAgZm9yICh2YXIgcywgaSA9IDEsIG4gPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgICAgICBzID0gYXJndW1lbnRzW2ldO1xuICAgICAgICAgICAgZm9yICh2YXIgcCBpbiBzKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHMsIHApKVxuICAgICAgICAgICAgICAgIHRbcF0gPSBzW3BdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0O1xuICAgIH07XG4gICAgcmV0dXJuIF9fYXNzaWduLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59O1xudmFyIF9fc3ByZWFkQXJyYXkgPSAodGhpcyAmJiB0aGlzLl9fc3ByZWFkQXJyYXkpIHx8IGZ1bmN0aW9uICh0bywgZnJvbSwgcGFjaykge1xuICAgIGlmIChwYWNrIHx8IGFyZ3VtZW50cy5sZW5ndGggPT09IDIpIGZvciAodmFyIGkgPSAwLCBsID0gZnJvbS5sZW5ndGgsIGFyOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIGlmIChhciB8fCAhKGkgaW4gZnJvbSkpIHtcbiAgICAgICAgICAgIGlmICghYXIpIGFyID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoZnJvbSwgMCwgaSk7XG4gICAgICAgICAgICBhcltpXSA9IGZyb21baV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRvLmNvbmNhdChhciB8fCBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChmcm9tKSk7XG59O1xuaW1wb3J0IHsgSGFybW9ueSwgTWl4LCBERUZBVUxUX0JMRU5EX1NURVBTIH0gZnJvbSAnI2NvbnN0YW50cyc7XG5pbXBvcnQgeyByZ2JUb0hTTCwgaHNsVG9SR0IsIHJnYlRvQ01ZSywgY215a1RvUkdCIH0gZnJvbSAnI2NvbG9yL3RyYW5zbGF0b3JzJztcbmltcG9ydCAqIGFzIHV0aWxzIGZyb20gJyNjb2xvci91dGlscyc7XG5pbXBvcnQgeyBDU1MgfSBmcm9tICcjY29sb3IvY3NzJztcbmltcG9ydCB7IHJvdW5kLCBtaW5tYXgsIGdldE9wdGlvbnNGcm9tQ29sb3JJbnB1dCwgbm9ybWFsaXplSHVlLCBnZXRUcmFuc2xhdGVkSHVlIH0gZnJvbSAnI2hlbHBlcnMnO1xudmFyIGdldENvbG9yUmV0dXJuID0gZnVuY3Rpb24gKGNvbG9yLCBtb2RlbCwgb3B0aW9ucywgdHJhbnNsYXRlRnVuY3Rpb24pIHtcbiAgICB2YXIgb3B0aW9uc0Zyb21JbnB1dCA9IGdldE9wdGlvbnNGcm9tQ29sb3JJbnB1dChvcHRpb25zLCBjb2xvcik7XG4gICAgdmFyIHJnYk9iamVjdCA9IHV0aWxzLmdldFJHQk9iamVjdChjb2xvciwgbW9kZWwpO1xuICAgIHJldHVybiB0cmFuc2xhdGVGdW5jdGlvbihyZ2JPYmplY3QsIG9wdGlvbnNGcm9tSW5wdXQpO1xufTtcbnZhciBnZXRCbGVuZFJldHVybiA9IGZ1bmN0aW9uIChmcm9tLCB0bywgc3RlcHMsIG9wdGlvbnMsIHRyYW5zbGF0ZUZ1bmN0aW9uKSB7XG4gICAgdmFyIG9wdGlvbnNGcm9tSW5wdXQgPSBnZXRPcHRpb25zRnJvbUNvbG9ySW5wdXQob3B0aW9ucywgZnJvbSwgdG8pO1xuICAgIGlmIChzdGVwcyA8IDEpXG4gICAgICAgIHN0ZXBzID0gREVGQVVMVF9CTEVORF9TVEVQUztcbiAgICB2YXIgZnJvbVJHQk9iamVjdCA9IHV0aWxzLmdldFJHQk9iamVjdChmcm9tKTtcbiAgICB2YXIgdG9SR0JPYmplY3QgPSB1dGlscy5nZXRSR0JPYmplY3QodG8pO1xuICAgIHZhciBibGVuZEFycmF5ID0gdXRpbHMuYmxlbmQoZnJvbVJHQk9iamVjdCwgdG9SR0JPYmplY3QsIHN0ZXBzKTtcbiAgICByZXR1cm4gYmxlbmRBcnJheS5tYXAoZnVuY3Rpb24gKGNvbG9yKSB7XG4gICAgICAgIHJldHVybiB0cmFuc2xhdGVGdW5jdGlvbihjb2xvciwgb3B0aW9uc0Zyb21JbnB1dCk7XG4gICAgfSk7XG59O1xudmFyIGdldEhhcm1vbnlSZXR1cm4gPSBmdW5jdGlvbiAoaGFybW9ueSwgY29sb3IsIG1vZGUsIG9wdGlvbnMpIHtcbiAgICB2YXIgX2E7XG4gICAgcmV0dXJuIChfYSA9IHt9LFxuICAgICAgICBfYVtIYXJtb255LkFOQUxPR09VU10gPSB1dGlscy5jb2xvckhhcm1vbnkuYnVpbGRIYXJtb255KGNvbG9yLCB1dGlscy5hbmFsb2dvdXMsIG1vZGUsIG9wdGlvbnMpLFxuICAgICAgICBfYVtIYXJtb255LkNPTVBMRU1FTlRBUlldID0gdXRpbHMuY29sb3JIYXJtb255LmJ1aWxkSGFybW9ueShjb2xvciwgdXRpbHMuY29tcGxlbWVudGFyeSwgbW9kZSwgb3B0aW9ucyksXG4gICAgICAgIF9hW0hhcm1vbnkuU1BMSVRfQ09NUExFTUVOVEFSWV0gPSB1dGlscy5jb2xvckhhcm1vbnkuYnVpbGRIYXJtb255KGNvbG9yLCB1dGlscy5zcGxpdENvbXBsZW1lbnRhcnksIG1vZGUsIG9wdGlvbnMpLFxuICAgICAgICBfYVtIYXJtb255LlRSSUFESUNdID0gdXRpbHMuY29sb3JIYXJtb255LmJ1aWxkSGFybW9ueShjb2xvciwgdXRpbHMudHJpYWRpYywgbW9kZSwgb3B0aW9ucyksXG4gICAgICAgIF9hW0hhcm1vbnkuVEVUUkFESUNdID0gdXRpbHMuY29sb3JIYXJtb255LmJ1aWxkSGFybW9ueShjb2xvciwgdXRpbHMudGV0cmFkaWMsIG1vZGUsIG9wdGlvbnMpLFxuICAgICAgICBfYVtIYXJtb255LlNRVUFSRV0gPSB1dGlscy5jb2xvckhhcm1vbnkuYnVpbGRIYXJtb255KGNvbG9yLCB1dGlscy5zcXVhcmUsIG1vZGUsIG9wdGlvbnMpLFxuICAgICAgICBfYSlbaGFybW9ueV07XG59O1xudmFyIENvbG9yVHJhbnNsYXRvciA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gQ29sb3JUcmFuc2xhdG9yKGNvbG9yLCBvcHRpb25zKSB7XG4gICAgICAgIGlmIChvcHRpb25zID09PSB2b2lkIDApIHsgb3B0aW9ucyA9IHt9OyB9XG4gICAgICAgIHRoaXMuX29wdGlvbnMgPSBnZXRPcHRpb25zRnJvbUNvbG9ySW5wdXQob3B0aW9ucywgY29sb3IpO1xuICAgICAgICB0aGlzLnJnYiA9IHV0aWxzLmdldFJHQk9iamVjdChjb2xvcik7XG4gICAgICAgIHRoaXMudXBkYXRlSFNMKCk7XG4gICAgICAgIHRoaXMudXBkYXRlQ01ZSygpO1xuICAgIH1cbiAgICBDb2xvclRyYW5zbGF0b3IucHJvdG90eXBlLnVwZGF0ZVJHQiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5yZ2IgPSBfX2Fzc2lnbihfX2Fzc2lnbih7fSwgaHNsVG9SR0IodGhpcy5oc2wuaCwgdGhpcy5oc2wucywgdGhpcy5oc2wubCkpLCB7IGE6IHRoaXMuaHNsLmEgfSk7XG4gICAgfTtcbiAgICBDb2xvclRyYW5zbGF0b3IucHJvdG90eXBlLnVwZGF0ZVJHQkZyb21DTVlLID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLnJnYiA9IF9fYXNzaWduKF9fYXNzaWduKHt9LCBjbXlrVG9SR0IodGhpcy5jbXlrLmMsIHRoaXMuY215ay5tLCB0aGlzLmNteWsueSwgdGhpcy5jbXlrLmspKSwgeyBhOiB0aGlzLnJnYi5hIH0pO1xuICAgIH07XG4gICAgQ29sb3JUcmFuc2xhdG9yLnByb3RvdHlwZS51cGRhdGVIU0wgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuaHNsID0gcmdiVG9IU0wodGhpcy5yZ2IuciwgdGhpcy5yZ2IuZywgdGhpcy5yZ2IuYiwgdGhpcy5yZ2IuYSk7XG4gICAgfTtcbiAgICBDb2xvclRyYW5zbGF0b3IucHJvdG90eXBlLnVwZGF0ZUNNWUsgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuY215ayA9IHJnYlRvQ01ZSyh0aGlzLnJnYi5yLCB0aGlzLnJnYi5nLCB0aGlzLnJnYi5iKTtcbiAgICB9O1xuICAgIENvbG9yVHJhbnNsYXRvci5wcm90b3R5cGUudXBkYXRlUkdCQW5kQ01ZSyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy51cGRhdGVSR0IoKTtcbiAgICAgICAgdGhpcy51cGRhdGVDTVlLKCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgQ29sb3JUcmFuc2xhdG9yLnByb3RvdHlwZS51cGRhdGVIU0xBbmRDTVlLID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLnVwZGF0ZUhTTCgpO1xuICAgICAgICB0aGlzLnVwZGF0ZUNNWUsoKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICBDb2xvclRyYW5zbGF0b3IucHJvdG90eXBlLnVwZGF0ZVJHQkFuZEhTTCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy51cGRhdGVSR0JGcm9tQ01ZSygpO1xuICAgICAgICB0aGlzLnVwZGF0ZUhTTCgpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIENvbG9yVHJhbnNsYXRvci5wcm90b3R5cGUuc2V0T3B0aW9ucyA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICAgIGlmIChvcHRpb25zID09PSB2b2lkIDApIHsgb3B0aW9ucyA9IHt9OyB9XG4gICAgICAgIHRoaXMuX29wdGlvbnMgPSBfX2Fzc2lnbihfX2Fzc2lnbih7fSwgdGhpcy5fb3B0aW9ucyksIG9wdGlvbnMpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIENvbG9yVHJhbnNsYXRvci5wcm90b3R5cGUuc2V0SCA9IGZ1bmN0aW9uIChoKSB7XG4gICAgICAgIHRoaXMuaHNsLmggPSBub3JtYWxpemVIdWUoaCk7XG4gICAgICAgIHJldHVybiB0aGlzLnVwZGF0ZVJHQkFuZENNWUsoKTtcbiAgICB9O1xuICAgIENvbG9yVHJhbnNsYXRvci5wcm90b3R5cGUuc2V0UyA9IGZ1bmN0aW9uIChzKSB7XG4gICAgICAgIHRoaXMuaHNsLnMgPSBtaW5tYXgocywgMCwgMTAwKTtcbiAgICAgICAgcmV0dXJuIHRoaXMudXBkYXRlUkdCQW5kQ01ZSygpO1xuICAgIH07XG4gICAgQ29sb3JUcmFuc2xhdG9yLnByb3RvdHlwZS5zZXRMID0gZnVuY3Rpb24gKGwpIHtcbiAgICAgICAgdGhpcy5oc2wubCA9IG1pbm1heChsLCAwLCAxMDApO1xuICAgICAgICByZXR1cm4gdGhpcy51cGRhdGVSR0JBbmRDTVlLKCk7XG4gICAgfTtcbiAgICBDb2xvclRyYW5zbGF0b3IucHJvdG90eXBlLnNldFIgPSBmdW5jdGlvbiAocikge1xuICAgICAgICB0aGlzLnJnYi5yID0gbWlubWF4KHIsIDAsIDI1NSk7XG4gICAgICAgIHJldHVybiB0aGlzLnVwZGF0ZUhTTEFuZENNWUsoKTtcbiAgICB9O1xuICAgIENvbG9yVHJhbnNsYXRvci5wcm90b3R5cGUuc2V0RyA9IGZ1bmN0aW9uIChnKSB7XG4gICAgICAgIHRoaXMucmdiLmcgPSBtaW5tYXgoZywgMCwgMjU1KTtcbiAgICAgICAgcmV0dXJuIHRoaXMudXBkYXRlSFNMQW5kQ01ZSygpO1xuICAgIH07XG4gICAgQ29sb3JUcmFuc2xhdG9yLnByb3RvdHlwZS5zZXRCID0gZnVuY3Rpb24gKGIpIHtcbiAgICAgICAgdGhpcy5yZ2IuYiA9IG1pbm1heChiLCAwLCAyNTUpO1xuICAgICAgICByZXR1cm4gdGhpcy51cGRhdGVIU0xBbmRDTVlLKCk7XG4gICAgfTtcbiAgICBDb2xvclRyYW5zbGF0b3IucHJvdG90eXBlLnNldEEgPSBmdW5jdGlvbiAoYSkge1xuICAgICAgICB0aGlzLmhzbC5hID0gdGhpcy5yZ2IuYSA9IG1pbm1heChhLCAwLCAxKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICBDb2xvclRyYW5zbGF0b3IucHJvdG90eXBlLnNldEMgPSBmdW5jdGlvbiAoYykge1xuICAgICAgICB0aGlzLmNteWsuYyA9IG1pbm1heChjLCAwLCAxMDApO1xuICAgICAgICByZXR1cm4gdGhpcy51cGRhdGVSR0JBbmRIU0woKTtcbiAgICB9O1xuICAgIENvbG9yVHJhbnNsYXRvci5wcm90b3R5cGUuc2V0TSA9IGZ1bmN0aW9uIChtKSB7XG4gICAgICAgIHRoaXMuY215ay5tID0gbWlubWF4KG0sIDAsIDEwMCk7XG4gICAgICAgIHJldHVybiB0aGlzLnVwZGF0ZVJHQkFuZEhTTCgpO1xuICAgIH07XG4gICAgQ29sb3JUcmFuc2xhdG9yLnByb3RvdHlwZS5zZXRZID0gZnVuY3Rpb24gKHkpIHtcbiAgICAgICAgdGhpcy5jbXlrLnkgPSBtaW5tYXgoeSwgMCwgMTAwKTtcbiAgICAgICAgcmV0dXJuIHRoaXMudXBkYXRlUkdCQW5kSFNMKCk7XG4gICAgfTtcbiAgICBDb2xvclRyYW5zbGF0b3IucHJvdG90eXBlLnNldEsgPSBmdW5jdGlvbiAoaykge1xuICAgICAgICB0aGlzLmNteWsuayA9IG1pbm1heChrLCAwLCAxMDApO1xuICAgICAgICByZXR1cm4gdGhpcy51cGRhdGVSR0JBbmRIU0woKTtcbiAgICB9O1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDb2xvclRyYW5zbGF0b3IucHJvdG90eXBlLCBcIm9wdGlvbnNcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9vcHRpb25zO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KENvbG9yVHJhbnNsYXRvci5wcm90b3R5cGUsIFwiSFwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHJvdW5kKHRoaXMuaHNsLmgsIHRoaXMub3B0aW9ucy5kZWNpbWFscyk7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQ29sb3JUcmFuc2xhdG9yLnByb3RvdHlwZSwgXCJTXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gcm91bmQodGhpcy5oc2wucywgdGhpcy5vcHRpb25zLmRlY2ltYWxzKTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDb2xvclRyYW5zbGF0b3IucHJvdG90eXBlLCBcIkxcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiByb3VuZCh0aGlzLmhzbC5sLCB0aGlzLm9wdGlvbnMuZGVjaW1hbHMpO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KENvbG9yVHJhbnNsYXRvci5wcm90b3R5cGUsIFwiUlwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHJvdW5kKHRoaXMucmdiLnIsIHRoaXMub3B0aW9ucy5kZWNpbWFscyk7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQ29sb3JUcmFuc2xhdG9yLnByb3RvdHlwZSwgXCJHXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gcm91bmQodGhpcy5yZ2IuZywgdGhpcy5vcHRpb25zLmRlY2ltYWxzKTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDb2xvclRyYW5zbGF0b3IucHJvdG90eXBlLCBcIkJcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiByb3VuZCh0aGlzLnJnYi5iLCB0aGlzLm9wdGlvbnMuZGVjaW1hbHMpO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KENvbG9yVHJhbnNsYXRvci5wcm90b3R5cGUsIFwiQVwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHJvdW5kKHRoaXMuaHNsLmEsIHRoaXMub3B0aW9ucy5kZWNpbWFscyk7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQ29sb3JUcmFuc2xhdG9yLnByb3RvdHlwZSwgXCJDXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gcm91bmQodGhpcy5jbXlrLmMsIHRoaXMub3B0aW9ucy5kZWNpbWFscyk7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQ29sb3JUcmFuc2xhdG9yLnByb3RvdHlwZSwgXCJNXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gcm91bmQodGhpcy5jbXlrLm0sIHRoaXMub3B0aW9ucy5kZWNpbWFscyk7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQ29sb3JUcmFuc2xhdG9yLnByb3RvdHlwZSwgXCJZXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gcm91bmQodGhpcy5jbXlrLnksIHRoaXMub3B0aW9ucy5kZWNpbWFscyk7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQ29sb3JUcmFuc2xhdG9yLnByb3RvdHlwZSwgXCJLXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gcm91bmQodGhpcy5jbXlrLmssIHRoaXMub3B0aW9ucy5kZWNpbWFscyk7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQ29sb3JUcmFuc2xhdG9yLnByb3RvdHlwZSwgXCJIRVhPYmplY3RcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB1dGlscy50cmFuc2xhdGVDb2xvci5IRVgodGhpcy5yZ2IpO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KENvbG9yVHJhbnNsYXRvci5wcm90b3R5cGUsIFwiSEVYQU9iamVjdFwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHV0aWxzLnRyYW5zbGF0ZUNvbG9yLkhFWEEodGhpcy5yZ2IpO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KENvbG9yVHJhbnNsYXRvci5wcm90b3R5cGUsIFwiUkdCT2JqZWN0XCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHI6IHRoaXMuUixcbiAgICAgICAgICAgICAgICBnOiB0aGlzLkcsXG4gICAgICAgICAgICAgICAgYjogdGhpcy5CXG4gICAgICAgICAgICB9O1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KENvbG9yVHJhbnNsYXRvci5wcm90b3R5cGUsIFwiUkdCQU9iamVjdFwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIF9fYXNzaWduKF9fYXNzaWduKHt9LCB0aGlzLlJHQk9iamVjdCksIHsgYTogdGhpcy5BIH0pO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KENvbG9yVHJhbnNsYXRvci5wcm90b3R5cGUsIFwiSFNMT2JqZWN0XCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGg6IHRoaXMuSCxcbiAgICAgICAgICAgICAgICBzOiB0aGlzLlMsXG4gICAgICAgICAgICAgICAgbDogdGhpcy5MXG4gICAgICAgICAgICB9O1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KENvbG9yVHJhbnNsYXRvci5wcm90b3R5cGUsIFwiSFNMQU9iamVjdFwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIF9fYXNzaWduKF9fYXNzaWduKHt9LCB0aGlzLkhTTE9iamVjdCksIHsgYTogdGhpcy5BIH0pO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KENvbG9yVHJhbnNsYXRvci5wcm90b3R5cGUsIFwiQ01ZS09iamVjdFwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBjOiB0aGlzLkMsXG4gICAgICAgICAgICAgICAgbTogdGhpcy5NLFxuICAgICAgICAgICAgICAgIHk6IHRoaXMuWSxcbiAgICAgICAgICAgICAgICBrOiB0aGlzLktcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQ29sb3JUcmFuc2xhdG9yLnByb3RvdHlwZSwgXCJDTVlLQU9iamVjdFwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIF9fYXNzaWduKF9fYXNzaWduKHt9LCB0aGlzLkNNWUtPYmplY3QpLCB7IGE6IHRoaXMuQSB9KTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDb2xvclRyYW5zbGF0b3IucHJvdG90eXBlLCBcIkhFWFwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIENTUy5IRVgoe1xuICAgICAgICAgICAgICAgIHI6IHRoaXMuUixcbiAgICAgICAgICAgICAgICBnOiB0aGlzLkcsXG4gICAgICAgICAgICAgICAgYjogdGhpcy5CXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDb2xvclRyYW5zbGF0b3IucHJvdG90eXBlLCBcIkhFWEFcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBDU1MuSEVYKHtcbiAgICAgICAgICAgICAgICByOiB0aGlzLlIsXG4gICAgICAgICAgICAgICAgZzogdGhpcy5HLFxuICAgICAgICAgICAgICAgIGI6IHRoaXMuQixcbiAgICAgICAgICAgICAgICBhOiB0aGlzLkEgKiAyNTVcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KENvbG9yVHJhbnNsYXRvci5wcm90b3R5cGUsIFwiUkdCXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gQ1NTLlJHQih7XG4gICAgICAgICAgICAgICAgcjogdGhpcy5SLFxuICAgICAgICAgICAgICAgIGc6IHRoaXMuRyxcbiAgICAgICAgICAgICAgICBiOiB0aGlzLkJcbiAgICAgICAgICAgIH0sIHRoaXMub3B0aW9ucyk7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQ29sb3JUcmFuc2xhdG9yLnByb3RvdHlwZSwgXCJSR0JBXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gQ1NTLlJHQih7XG4gICAgICAgICAgICAgICAgcjogdGhpcy5SLFxuICAgICAgICAgICAgICAgIGc6IHRoaXMuRyxcbiAgICAgICAgICAgICAgICBiOiB0aGlzLkIsXG4gICAgICAgICAgICAgICAgYTogdGhpcy5BXG4gICAgICAgICAgICB9LCB0aGlzLm9wdGlvbnMpO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KENvbG9yVHJhbnNsYXRvci5wcm90b3R5cGUsIFwiSFNMXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gQ1NTLkhTTCh7XG4gICAgICAgICAgICAgICAgaDogZ2V0VHJhbnNsYXRlZEh1ZSh0aGlzLmhzbC5oLCB0aGlzLm9wdGlvbnMuYW5nbGVzVW5pdCwgdGhpcy5vcHRpb25zLmRlY2ltYWxzKSxcbiAgICAgICAgICAgICAgICBzOiB0aGlzLlMsXG4gICAgICAgICAgICAgICAgbDogdGhpcy5MXG4gICAgICAgICAgICB9LCB0aGlzLm9wdGlvbnMpO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KENvbG9yVHJhbnNsYXRvci5wcm90b3R5cGUsIFwiSFNMQVwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIENTUy5IU0woe1xuICAgICAgICAgICAgICAgIGg6IGdldFRyYW5zbGF0ZWRIdWUodGhpcy5oc2wuaCwgdGhpcy5vcHRpb25zLmFuZ2xlc1VuaXQsIHRoaXMub3B0aW9ucy5kZWNpbWFscyksXG4gICAgICAgICAgICAgICAgczogdGhpcy5TLFxuICAgICAgICAgICAgICAgIGw6IHRoaXMuTCxcbiAgICAgICAgICAgICAgICBhOiB0aGlzLkFcbiAgICAgICAgICAgIH0sIHRoaXMub3B0aW9ucyk7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQ29sb3JUcmFuc2xhdG9yLnByb3RvdHlwZSwgXCJDTVlLXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gQ1NTLkNNWUsoe1xuICAgICAgICAgICAgICAgIGM6IHRoaXMuQyxcbiAgICAgICAgICAgICAgICBtOiB0aGlzLk0sXG4gICAgICAgICAgICAgICAgeTogdGhpcy5ZLFxuICAgICAgICAgICAgICAgIGs6IHRoaXMuS1xuICAgICAgICAgICAgfSwgdGhpcy5vcHRpb25zKTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDb2xvclRyYW5zbGF0b3IucHJvdG90eXBlLCBcIkNNWUtBXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gQ1NTLkNNWUsoe1xuICAgICAgICAgICAgICAgIGM6IHRoaXMuQyxcbiAgICAgICAgICAgICAgICBtOiB0aGlzLk0sXG4gICAgICAgICAgICAgICAgeTogdGhpcy5ZLFxuICAgICAgICAgICAgICAgIGs6IHRoaXMuSyxcbiAgICAgICAgICAgICAgICBhOiB0aGlzLkFcbiAgICAgICAgICAgIH0sIHRoaXMub3B0aW9ucyk7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBDb2xvclRyYW5zbGF0b3IudG9IRVhPYmplY3QgPSBmdW5jdGlvbiAoY29sb3IpIHtcbiAgICAgICAgdmFyIG1vZGVsID0gdXRpbHMuZ2V0Q29sb3JNb2RlbChjb2xvcik7XG4gICAgICAgIHJldHVybiBnZXRDb2xvclJldHVybihjb2xvciwgbW9kZWwsIHsgZGVjaW1hbHM6IDAgfSwgdXRpbHMudHJhbnNsYXRlQ29sb3IuSEVYKTtcbiAgICB9O1xuICAgIENvbG9yVHJhbnNsYXRvci50b0hFWCA9IGZ1bmN0aW9uIChjb2xvcikge1xuICAgICAgICByZXR1cm4gQ1NTLkhFWChDb2xvclRyYW5zbGF0b3IudG9IRVhPYmplY3QoY29sb3IpKTtcbiAgICB9O1xuICAgIENvbG9yVHJhbnNsYXRvci50b0hFWEFPYmplY3QgPSBmdW5jdGlvbiAoY29sb3IpIHtcbiAgICAgICAgdmFyIG1vZGVsID0gdXRpbHMuZ2V0Q29sb3JNb2RlbChjb2xvcik7XG4gICAgICAgIHJldHVybiBnZXRDb2xvclJldHVybihjb2xvciwgbW9kZWwsIHsgZGVjaW1hbHM6IDAgfSwgdXRpbHMudHJhbnNsYXRlQ29sb3IuSEVYQSk7XG4gICAgfTtcbiAgICBDb2xvclRyYW5zbGF0b3IudG9IRVhBID0gZnVuY3Rpb24gKGNvbG9yKSB7XG4gICAgICAgIHJldHVybiBDU1MuSEVYKENvbG9yVHJhbnNsYXRvci50b0hFWEFPYmplY3QoY29sb3IpKTtcbiAgICB9O1xuICAgIENvbG9yVHJhbnNsYXRvci50b1JHQk9iamVjdCA9IGZ1bmN0aW9uIChjb2xvciwgb3B0aW9ucykge1xuICAgICAgICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7IG9wdGlvbnMgPSB7fTsgfVxuICAgICAgICB2YXIgbW9kZWwgPSB1dGlscy5nZXRDb2xvck1vZGVsKGNvbG9yKTtcbiAgICAgICAgcmV0dXJuIGdldENvbG9yUmV0dXJuKGNvbG9yLCBtb2RlbCwgb3B0aW9ucywgdXRpbHMudHJhbnNsYXRlQ29sb3IuUkdCKTtcbiAgICB9O1xuICAgIENvbG9yVHJhbnNsYXRvci50b1JHQiA9IGZ1bmN0aW9uIChjb2xvciwgb3B0aW9ucykge1xuICAgICAgICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7IG9wdGlvbnMgPSB7fTsgfVxuICAgICAgICByZXR1cm4gQ1NTLlJHQihDb2xvclRyYW5zbGF0b3IudG9SR0JPYmplY3QoY29sb3IsIG9wdGlvbnMpLCBnZXRPcHRpb25zRnJvbUNvbG9ySW5wdXQob3B0aW9ucywgY29sb3IpKTtcbiAgICB9O1xuICAgIENvbG9yVHJhbnNsYXRvci50b1JHQkFPYmplY3QgPSBmdW5jdGlvbiAoY29sb3IsIG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkgeyBvcHRpb25zID0ge307IH1cbiAgICAgICAgdmFyIG1vZGVsID0gdXRpbHMuZ2V0Q29sb3JNb2RlbChjb2xvcik7XG4gICAgICAgIHJldHVybiBnZXRDb2xvclJldHVybihjb2xvciwgbW9kZWwsIG9wdGlvbnMsIHV0aWxzLnRyYW5zbGF0ZUNvbG9yLlJHQkEpO1xuICAgIH07XG4gICAgQ29sb3JUcmFuc2xhdG9yLnRvUkdCQSA9IGZ1bmN0aW9uIChjb2xvciwgb3B0aW9ucykge1xuICAgICAgICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7IG9wdGlvbnMgPSB7fTsgfVxuICAgICAgICByZXR1cm4gQ1NTLlJHQihDb2xvclRyYW5zbGF0b3IudG9SR0JBT2JqZWN0KGNvbG9yLCBvcHRpb25zKSwgZ2V0T3B0aW9uc0Zyb21Db2xvcklucHV0KG9wdGlvbnMsIGNvbG9yKSk7XG4gICAgfTtcbiAgICBDb2xvclRyYW5zbGF0b3IudG9IU0xPYmplY3QgPSBmdW5jdGlvbiAoY29sb3IsIG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkgeyBvcHRpb25zID0ge307IH1cbiAgICAgICAgdmFyIG1vZGVsID0gdXRpbHMuZ2V0Q29sb3JNb2RlbChjb2xvcik7XG4gICAgICAgIHJldHVybiBnZXRDb2xvclJldHVybihjb2xvciwgbW9kZWwsIG9wdGlvbnMsIHV0aWxzLnRyYW5zbGF0ZUNvbG9yLkhTTCk7XG4gICAgfTtcbiAgICBDb2xvclRyYW5zbGF0b3IudG9IU0wgPSBmdW5jdGlvbiAoY29sb3IsIG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkgeyBvcHRpb25zID0ge307IH1cbiAgICAgICAgcmV0dXJuIENTUy5IU0woQ29sb3JUcmFuc2xhdG9yLnRvSFNMT2JqZWN0KGNvbG9yLCBvcHRpb25zKSwgZ2V0T3B0aW9uc0Zyb21Db2xvcklucHV0KG9wdGlvbnMsIGNvbG9yKSk7XG4gICAgfTtcbiAgICBDb2xvclRyYW5zbGF0b3IudG9IU0xBT2JqZWN0ID0gZnVuY3Rpb24gKGNvbG9yLCBvcHRpb25zKSB7XG4gICAgICAgIGlmIChvcHRpb25zID09PSB2b2lkIDApIHsgb3B0aW9ucyA9IHt9OyB9XG4gICAgICAgIHZhciBtb2RlbCA9IHV0aWxzLmdldENvbG9yTW9kZWwoY29sb3IpO1xuICAgICAgICByZXR1cm4gZ2V0Q29sb3JSZXR1cm4oY29sb3IsIG1vZGVsLCBvcHRpb25zLCB1dGlscy50cmFuc2xhdGVDb2xvci5IU0xBKTtcbiAgICB9O1xuICAgIENvbG9yVHJhbnNsYXRvci50b0hTTEEgPSBmdW5jdGlvbiAoY29sb3IsIG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkgeyBvcHRpb25zID0ge307IH1cbiAgICAgICAgcmV0dXJuIENTUy5IU0woQ29sb3JUcmFuc2xhdG9yLnRvSFNMQU9iamVjdChjb2xvciwgb3B0aW9ucyksIGdldE9wdGlvbnNGcm9tQ29sb3JJbnB1dChvcHRpb25zLCBjb2xvcikpO1xuICAgIH07XG4gICAgQ29sb3JUcmFuc2xhdG9yLnRvQ01ZS09iamVjdCA9IGZ1bmN0aW9uIChjb2xvciwgb3B0aW9ucykge1xuICAgICAgICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7IG9wdGlvbnMgPSB7fTsgfVxuICAgICAgICB2YXIgbW9kZWwgPSB1dGlscy5nZXRDb2xvck1vZGVsKGNvbG9yKTtcbiAgICAgICAgcmV0dXJuIGdldENvbG9yUmV0dXJuKGNvbG9yLCBtb2RlbCwgb3B0aW9ucywgdXRpbHMudHJhbnNsYXRlQ29sb3IuQ01ZSyk7XG4gICAgfTtcbiAgICBDb2xvclRyYW5zbGF0b3IudG9DTVlLID0gZnVuY3Rpb24gKGNvbG9yLCBvcHRpb25zKSB7XG4gICAgICAgIGlmIChvcHRpb25zID09PSB2b2lkIDApIHsgb3B0aW9ucyA9IHt9OyB9XG4gICAgICAgIHJldHVybiBDU1MuQ01ZSyhDb2xvclRyYW5zbGF0b3IudG9DTVlLT2JqZWN0KGNvbG9yLCBvcHRpb25zKSwgZ2V0T3B0aW9uc0Zyb21Db2xvcklucHV0KG9wdGlvbnMsIGNvbG9yKSk7XG4gICAgfTtcbiAgICBDb2xvclRyYW5zbGF0b3IudG9DTVlLQU9iamVjdCA9IGZ1bmN0aW9uIChjb2xvciwgb3B0aW9ucykge1xuICAgICAgICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7IG9wdGlvbnMgPSB7fTsgfVxuICAgICAgICB2YXIgbW9kZWwgPSB1dGlscy5nZXRDb2xvck1vZGVsKGNvbG9yKTtcbiAgICAgICAgcmV0dXJuIGdldENvbG9yUmV0dXJuKGNvbG9yLCBtb2RlbCwgb3B0aW9ucywgdXRpbHMudHJhbnNsYXRlQ29sb3IuQ01ZS0EpO1xuICAgIH07XG4gICAgQ29sb3JUcmFuc2xhdG9yLnRvQ01ZS0EgPSBmdW5jdGlvbiAoY29sb3IsIG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkgeyBvcHRpb25zID0ge307IH1cbiAgICAgICAgcmV0dXJuIENTUy5DTVlLKENvbG9yVHJhbnNsYXRvci50b0NNWUtBT2JqZWN0KGNvbG9yLCBvcHRpb25zKSwgZ2V0T3B0aW9uc0Zyb21Db2xvcklucHV0KG9wdGlvbnMsIGNvbG9yKSk7XG4gICAgfTtcbiAgICBDb2xvclRyYW5zbGF0b3IuZ2V0QmxlbmRIRVhPYmplY3QgPSBmdW5jdGlvbiAoZnJvbSwgdG8sIHN0ZXBzKSB7XG4gICAgICAgIGlmIChzdGVwcyA9PT0gdm9pZCAwKSB7IHN0ZXBzID0gREVGQVVMVF9CTEVORF9TVEVQUzsgfVxuICAgICAgICByZXR1cm4gZ2V0QmxlbmRSZXR1cm4oZnJvbSwgdG8sIHN0ZXBzLCB7IGRlY2ltYWxzOiAwIH0sIHV0aWxzLnRyYW5zbGF0ZUNvbG9yLkhFWCk7XG4gICAgfTtcbiAgICBDb2xvclRyYW5zbGF0b3IuZ2V0QmxlbmRIRVggPSBmdW5jdGlvbiAoZnJvbSwgdG8sIHN0ZXBzKSB7XG4gICAgICAgIGlmIChzdGVwcyA9PT0gdm9pZCAwKSB7IHN0ZXBzID0gREVGQVVMVF9CTEVORF9TVEVQUzsgfVxuICAgICAgICByZXR1cm4gQ29sb3JUcmFuc2xhdG9yLmdldEJsZW5kSEVYT2JqZWN0KGZyb20sIHRvLCBzdGVwcylcbiAgICAgICAgICAgIC5tYXAoZnVuY3Rpb24gKGNvbG9yKSB7IHJldHVybiBDU1MuSEVYKGNvbG9yKTsgfSk7XG4gICAgfTtcbiAgICBDb2xvclRyYW5zbGF0b3IuZ2V0QmxlbmRIRVhBT2JqZWN0ID0gZnVuY3Rpb24gKGZyb20sIHRvLCBzdGVwcykge1xuICAgICAgICBpZiAoc3RlcHMgPT09IHZvaWQgMCkgeyBzdGVwcyA9IERFRkFVTFRfQkxFTkRfU1RFUFM7IH1cbiAgICAgICAgcmV0dXJuIGdldEJsZW5kUmV0dXJuKGZyb20sIHRvLCBzdGVwcywgeyBkZWNpbWFsczogMCB9LCB1dGlscy50cmFuc2xhdGVDb2xvci5IRVhBKTtcbiAgICB9O1xuICAgIENvbG9yVHJhbnNsYXRvci5nZXRCbGVuZEhFWEEgPSBmdW5jdGlvbiAoZnJvbSwgdG8sIHN0ZXBzKSB7XG4gICAgICAgIGlmIChzdGVwcyA9PT0gdm9pZCAwKSB7IHN0ZXBzID0gREVGQVVMVF9CTEVORF9TVEVQUzsgfVxuICAgICAgICByZXR1cm4gQ29sb3JUcmFuc2xhdG9yLmdldEJsZW5kSEVYQU9iamVjdChmcm9tLCB0bywgc3RlcHMpXG4gICAgICAgICAgICAubWFwKGZ1bmN0aW9uIChjb2xvcikgeyByZXR1cm4gQ1NTLkhFWChjb2xvcik7IH0pO1xuICAgIH07XG4gICAgQ29sb3JUcmFuc2xhdG9yLmdldEJsZW5kUkdCT2JqZWN0ID0gZnVuY3Rpb24gKGZyb20sIHRvLCBzdGVwcywgb3B0aW9ucykge1xuICAgICAgICBpZiAoc3RlcHMgPT09IHZvaWQgMCkgeyBzdGVwcyA9IERFRkFVTFRfQkxFTkRfU1RFUFM7IH1cbiAgICAgICAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkgeyBvcHRpb25zID0ge307IH1cbiAgICAgICAgcmV0dXJuIGdldEJsZW5kUmV0dXJuKGZyb20sIHRvLCBzdGVwcywgb3B0aW9ucywgdXRpbHMudHJhbnNsYXRlQ29sb3IuUkdCKTtcbiAgICB9O1xuICAgIENvbG9yVHJhbnNsYXRvci5nZXRCbGVuZFJHQiA9IGZ1bmN0aW9uIChmcm9tLCB0bywgc3RlcHMsIG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKHN0ZXBzID09PSB2b2lkIDApIHsgc3RlcHMgPSBERUZBVUxUX0JMRU5EX1NURVBTOyB9XG4gICAgICAgIGlmIChvcHRpb25zID09PSB2b2lkIDApIHsgb3B0aW9ucyA9IHt9OyB9XG4gICAgICAgIHJldHVybiBDb2xvclRyYW5zbGF0b3IuZ2V0QmxlbmRSR0JPYmplY3QoZnJvbSwgdG8sIHN0ZXBzLCBvcHRpb25zKVxuICAgICAgICAgICAgLm1hcChmdW5jdGlvbiAoY29sb3IpIHtcbiAgICAgICAgICAgIHJldHVybiBDU1MuUkdCKGNvbG9yLCBnZXRPcHRpb25zRnJvbUNvbG9ySW5wdXQob3B0aW9ucywgZnJvbSwgdG8pKTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBDb2xvclRyYW5zbGF0b3IuZ2V0QmxlbmRSR0JBT2JqZWN0ID0gZnVuY3Rpb24gKGZyb20sIHRvLCBzdGVwcywgb3B0aW9ucykge1xuICAgICAgICBpZiAoc3RlcHMgPT09IHZvaWQgMCkgeyBzdGVwcyA9IERFRkFVTFRfQkxFTkRfU1RFUFM7IH1cbiAgICAgICAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkgeyBvcHRpb25zID0ge307IH1cbiAgICAgICAgcmV0dXJuIGdldEJsZW5kUmV0dXJuKGZyb20sIHRvLCBzdGVwcywgb3B0aW9ucywgdXRpbHMudHJhbnNsYXRlQ29sb3IuUkdCQSk7XG4gICAgfTtcbiAgICBDb2xvclRyYW5zbGF0b3IuZ2V0QmxlbmRSR0JBID0gZnVuY3Rpb24gKGZyb20sIHRvLCBzdGVwcywgb3B0aW9ucykge1xuICAgICAgICBpZiAoc3RlcHMgPT09IHZvaWQgMCkgeyBzdGVwcyA9IERFRkFVTFRfQkxFTkRfU1RFUFM7IH1cbiAgICAgICAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkgeyBvcHRpb25zID0ge307IH1cbiAgICAgICAgcmV0dXJuIENvbG9yVHJhbnNsYXRvci5nZXRCbGVuZFJHQkFPYmplY3QoZnJvbSwgdG8sIHN0ZXBzLCBvcHRpb25zKVxuICAgICAgICAgICAgLm1hcChmdW5jdGlvbiAoY29sb3IpIHtcbiAgICAgICAgICAgIHJldHVybiBDU1MuUkdCKGNvbG9yLCBnZXRPcHRpb25zRnJvbUNvbG9ySW5wdXQob3B0aW9ucywgZnJvbSwgdG8pKTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBDb2xvclRyYW5zbGF0b3IuZ2V0QmxlbmRIU0xPYmplY3QgPSBmdW5jdGlvbiAoZnJvbSwgdG8sIHN0ZXBzLCBvcHRpb25zKSB7XG4gICAgICAgIGlmIChzdGVwcyA9PT0gdm9pZCAwKSB7IHN0ZXBzID0gREVGQVVMVF9CTEVORF9TVEVQUzsgfVxuICAgICAgICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7IG9wdGlvbnMgPSB7fTsgfVxuICAgICAgICByZXR1cm4gZ2V0QmxlbmRSZXR1cm4oZnJvbSwgdG8sIHN0ZXBzLCBvcHRpb25zLCB1dGlscy50cmFuc2xhdGVDb2xvci5IU0wpO1xuICAgIH07XG4gICAgQ29sb3JUcmFuc2xhdG9yLmdldEJsZW5kSFNMID0gZnVuY3Rpb24gKGZyb20sIHRvLCBzdGVwcywgb3B0aW9ucykge1xuICAgICAgICBpZiAoc3RlcHMgPT09IHZvaWQgMCkgeyBzdGVwcyA9IERFRkFVTFRfQkxFTkRfU1RFUFM7IH1cbiAgICAgICAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkgeyBvcHRpb25zID0ge307IH1cbiAgICAgICAgcmV0dXJuIENvbG9yVHJhbnNsYXRvci5nZXRCbGVuZEhTTE9iamVjdChmcm9tLCB0bywgc3RlcHMsIG9wdGlvbnMpXG4gICAgICAgICAgICAubWFwKGZ1bmN0aW9uIChjb2xvcikge1xuICAgICAgICAgICAgcmV0dXJuIENTUy5IU0woY29sb3IsIGdldE9wdGlvbnNGcm9tQ29sb3JJbnB1dChvcHRpb25zLCBmcm9tLCB0bykpO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIENvbG9yVHJhbnNsYXRvci5nZXRCbGVuZEhTTEFPYmplY3QgPSBmdW5jdGlvbiAoZnJvbSwgdG8sIHN0ZXBzLCBvcHRpb25zKSB7XG4gICAgICAgIGlmIChzdGVwcyA9PT0gdm9pZCAwKSB7IHN0ZXBzID0gREVGQVVMVF9CTEVORF9TVEVQUzsgfVxuICAgICAgICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7IG9wdGlvbnMgPSB7fTsgfVxuICAgICAgICByZXR1cm4gZ2V0QmxlbmRSZXR1cm4oZnJvbSwgdG8sIHN0ZXBzLCBvcHRpb25zLCB1dGlscy50cmFuc2xhdGVDb2xvci5IU0xBKTtcbiAgICB9O1xuICAgIENvbG9yVHJhbnNsYXRvci5nZXRCbGVuZEhTTEEgPSBmdW5jdGlvbiAoZnJvbSwgdG8sIHN0ZXBzLCBvcHRpb25zKSB7XG4gICAgICAgIGlmIChzdGVwcyA9PT0gdm9pZCAwKSB7IHN0ZXBzID0gREVGQVVMVF9CTEVORF9TVEVQUzsgfVxuICAgICAgICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7IG9wdGlvbnMgPSB7fTsgfVxuICAgICAgICByZXR1cm4gQ29sb3JUcmFuc2xhdG9yLmdldEJsZW5kSFNMQU9iamVjdChmcm9tLCB0bywgc3RlcHMsIG9wdGlvbnMpXG4gICAgICAgICAgICAubWFwKGZ1bmN0aW9uIChjb2xvcikge1xuICAgICAgICAgICAgcmV0dXJuIENTUy5IU0woY29sb3IsIGdldE9wdGlvbnNGcm9tQ29sb3JJbnB1dChvcHRpb25zLCBmcm9tLCB0bykpO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIENvbG9yVHJhbnNsYXRvci5nZXRNaXhIRVhPYmplY3QgPSBmdW5jdGlvbiAoY29sb3JzLCBtb2RlKSB7XG4gICAgICAgIGlmIChtb2RlID09PSB2b2lkIDApIHsgbW9kZSA9IE1peC5BRERJVElWRTsgfVxuICAgICAgICByZXR1cm4gdXRpbHMuY29sb3JNaXhlci5IRVgoY29sb3JzLCBtb2RlLCBmYWxzZSk7XG4gICAgfTtcbiAgICBDb2xvclRyYW5zbGF0b3IuZ2V0TWl4SEVYID0gZnVuY3Rpb24gKGNvbG9ycywgbW9kZSkge1xuICAgICAgICBpZiAobW9kZSA9PT0gdm9pZCAwKSB7IG1vZGUgPSBNaXguQURESVRJVkU7IH1cbiAgICAgICAgcmV0dXJuIHV0aWxzLmNvbG9yTWl4ZXIuSEVYKGNvbG9ycywgbW9kZSwgdHJ1ZSk7XG4gICAgfTtcbiAgICBDb2xvclRyYW5zbGF0b3IuZ2V0TWl4SEVYQU9iamVjdCA9IGZ1bmN0aW9uIChjb2xvcnMsIG1vZGUpIHtcbiAgICAgICAgaWYgKG1vZGUgPT09IHZvaWQgMCkgeyBtb2RlID0gTWl4LkFERElUSVZFOyB9XG4gICAgICAgIHJldHVybiB1dGlscy5jb2xvck1peGVyLkhFWEEoY29sb3JzLCBtb2RlLCBmYWxzZSk7XG4gICAgfTtcbiAgICBDb2xvclRyYW5zbGF0b3IuZ2V0TWl4SEVYQSA9IGZ1bmN0aW9uIChjb2xvcnMsIG1vZGUpIHtcbiAgICAgICAgaWYgKG1vZGUgPT09IHZvaWQgMCkgeyBtb2RlID0gTWl4LkFERElUSVZFOyB9XG4gICAgICAgIHJldHVybiB1dGlscy5jb2xvck1peGVyLkhFWEEoY29sb3JzLCBtb2RlLCB0cnVlKTtcbiAgICB9O1xuICAgIENvbG9yVHJhbnNsYXRvci5nZXRNaXhSR0JPYmplY3QgPSBmdW5jdGlvbiAoY29sb3JzLCBtb2RlLCBvcHRpb25zKSB7XG4gICAgICAgIGlmIChtb2RlID09PSB2b2lkIDApIHsgbW9kZSA9IE1peC5BRERJVElWRTsgfVxuICAgICAgICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7IG9wdGlvbnMgPSB7fTsgfVxuICAgICAgICByZXR1cm4gdXRpbHMuY29sb3JNaXhlci5SR0IoY29sb3JzLCBtb2RlLCBmYWxzZSwgZ2V0T3B0aW9uc0Zyb21Db2xvcklucHV0LmFwcGx5KHZvaWQgMCwgX19zcHJlYWRBcnJheShbb3B0aW9uc10sIGNvbG9ycywgZmFsc2UpKSk7XG4gICAgfTtcbiAgICBDb2xvclRyYW5zbGF0b3IuZ2V0TWl4UkdCID0gZnVuY3Rpb24gKGNvbG9ycywgbW9kZSwgb3B0aW9ucykge1xuICAgICAgICBpZiAobW9kZSA9PT0gdm9pZCAwKSB7IG1vZGUgPSBNaXguQURESVRJVkU7IH1cbiAgICAgICAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkgeyBvcHRpb25zID0ge307IH1cbiAgICAgICAgcmV0dXJuIHV0aWxzLmNvbG9yTWl4ZXIuUkdCKGNvbG9ycywgbW9kZSwgdHJ1ZSwgZ2V0T3B0aW9uc0Zyb21Db2xvcklucHV0LmFwcGx5KHZvaWQgMCwgX19zcHJlYWRBcnJheShbb3B0aW9uc10sIGNvbG9ycywgZmFsc2UpKSk7XG4gICAgfTtcbiAgICBDb2xvclRyYW5zbGF0b3IuZ2V0TWl4UkdCQU9iamVjdCA9IGZ1bmN0aW9uIChjb2xvcnMsIG1vZGUsIG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKG1vZGUgPT09IHZvaWQgMCkgeyBtb2RlID0gTWl4LkFERElUSVZFOyB9XG4gICAgICAgIGlmIChvcHRpb25zID09PSB2b2lkIDApIHsgb3B0aW9ucyA9IHt9OyB9XG4gICAgICAgIHJldHVybiB1dGlscy5jb2xvck1peGVyLlJHQkEoY29sb3JzLCBtb2RlLCBmYWxzZSwgZ2V0T3B0aW9uc0Zyb21Db2xvcklucHV0LmFwcGx5KHZvaWQgMCwgX19zcHJlYWRBcnJheShbb3B0aW9uc10sIGNvbG9ycywgZmFsc2UpKSk7XG4gICAgfTtcbiAgICBDb2xvclRyYW5zbGF0b3IuZ2V0TWl4UkdCQSA9IGZ1bmN0aW9uIChjb2xvcnMsIG1vZGUsIG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKG1vZGUgPT09IHZvaWQgMCkgeyBtb2RlID0gTWl4LkFERElUSVZFOyB9XG4gICAgICAgIGlmIChvcHRpb25zID09PSB2b2lkIDApIHsgb3B0aW9ucyA9IHt9OyB9XG4gICAgICAgIHJldHVybiB1dGlscy5jb2xvck1peGVyLlJHQkEoY29sb3JzLCBtb2RlLCB0cnVlLCBnZXRPcHRpb25zRnJvbUNvbG9ySW5wdXQuYXBwbHkodm9pZCAwLCBfX3NwcmVhZEFycmF5KFtvcHRpb25zXSwgY29sb3JzLCBmYWxzZSkpKTtcbiAgICB9O1xuICAgIENvbG9yVHJhbnNsYXRvci5nZXRNaXhIU0xPYmplY3QgPSBmdW5jdGlvbiAoY29sb3JzLCBtb2RlLCBvcHRpb25zKSB7XG4gICAgICAgIGlmIChtb2RlID09PSB2b2lkIDApIHsgbW9kZSA9IE1peC5BRERJVElWRTsgfVxuICAgICAgICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7IG9wdGlvbnMgPSB7fTsgfVxuICAgICAgICByZXR1cm4gdXRpbHMuY29sb3JNaXhlci5IU0woY29sb3JzLCBtb2RlLCBmYWxzZSwgZ2V0T3B0aW9uc0Zyb21Db2xvcklucHV0LmFwcGx5KHZvaWQgMCwgX19zcHJlYWRBcnJheShbb3B0aW9uc10sIGNvbG9ycywgZmFsc2UpKSk7XG4gICAgfTtcbiAgICBDb2xvclRyYW5zbGF0b3IuZ2V0TWl4SFNMID0gZnVuY3Rpb24gKGNvbG9ycywgbW9kZSwgb3B0aW9ucykge1xuICAgICAgICBpZiAobW9kZSA9PT0gdm9pZCAwKSB7IG1vZGUgPSBNaXguQURESVRJVkU7IH1cbiAgICAgICAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkgeyBvcHRpb25zID0ge307IH1cbiAgICAgICAgcmV0dXJuIHV0aWxzLmNvbG9yTWl4ZXIuSFNMKGNvbG9ycywgbW9kZSwgdHJ1ZSwgZ2V0T3B0aW9uc0Zyb21Db2xvcklucHV0LmFwcGx5KHZvaWQgMCwgX19zcHJlYWRBcnJheShbb3B0aW9uc10sIGNvbG9ycywgZmFsc2UpKSk7XG4gICAgfTtcbiAgICBDb2xvclRyYW5zbGF0b3IuZ2V0TWl4SFNMQU9iamVjdCA9IGZ1bmN0aW9uIChjb2xvcnMsIG1vZGUsIG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKG1vZGUgPT09IHZvaWQgMCkgeyBtb2RlID0gTWl4LkFERElUSVZFOyB9XG4gICAgICAgIGlmIChvcHRpb25zID09PSB2b2lkIDApIHsgb3B0aW9ucyA9IHt9OyB9XG4gICAgICAgIHJldHVybiB1dGlscy5jb2xvck1peGVyLkhTTEEoY29sb3JzLCBtb2RlLCBmYWxzZSwgZ2V0T3B0aW9uc0Zyb21Db2xvcklucHV0LmFwcGx5KHZvaWQgMCwgX19zcHJlYWRBcnJheShbb3B0aW9uc10sIGNvbG9ycywgZmFsc2UpKSk7XG4gICAgfTtcbiAgICBDb2xvclRyYW5zbGF0b3IuZ2V0TWl4SFNMQSA9IGZ1bmN0aW9uIChjb2xvcnMsIG1vZGUsIG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKG1vZGUgPT09IHZvaWQgMCkgeyBtb2RlID0gTWl4LkFERElUSVZFOyB9XG4gICAgICAgIGlmIChvcHRpb25zID09PSB2b2lkIDApIHsgb3B0aW9ucyA9IHt9OyB9XG4gICAgICAgIHJldHVybiB1dGlscy5jb2xvck1peGVyLkhTTEEoY29sb3JzLCBtb2RlLCB0cnVlLCBnZXRPcHRpb25zRnJvbUNvbG9ySW5wdXQuYXBwbHkodm9pZCAwLCBfX3NwcmVhZEFycmF5KFtvcHRpb25zXSwgY29sb3JzLCBmYWxzZSkpKTtcbiAgICB9O1xuICAgIENvbG9yVHJhbnNsYXRvci5nZXRTaGFkZXMgPSBmdW5jdGlvbiAoY29sb3IsIHNoYWRlcywgb3B0aW9ucykge1xuICAgICAgICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7IG9wdGlvbnMgPSB7fTsgfVxuICAgICAgICByZXR1cm4gdXRpbHMuZ2V0Q29sb3JNaXh0dXJlKGNvbG9yLCBzaGFkZXMsIHRydWUsIGdldE9wdGlvbnNGcm9tQ29sb3JJbnB1dChvcHRpb25zLCBjb2xvcikpO1xuICAgIH07XG4gICAgQ29sb3JUcmFuc2xhdG9yLmdldFRpbnRzID0gZnVuY3Rpb24gKGNvbG9yLCB0aW50cywgb3B0aW9ucykge1xuICAgICAgICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7IG9wdGlvbnMgPSB7fTsgfVxuICAgICAgICByZXR1cm4gdXRpbHMuZ2V0Q29sb3JNaXh0dXJlKGNvbG9yLCB0aW50cywgZmFsc2UsIGdldE9wdGlvbnNGcm9tQ29sb3JJbnB1dChvcHRpb25zLCBjb2xvcikpO1xuICAgIH07XG4gICAgQ29sb3JUcmFuc2xhdG9yLmdldEhhcm1vbnkgPSBmdW5jdGlvbiAoY29sb3IsIGhhcm1vbnksIG1vZGUsIG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKGhhcm1vbnkgPT09IHZvaWQgMCkgeyBoYXJtb255ID0gSGFybW9ueS5DT01QTEVNRU5UQVJZOyB9XG4gICAgICAgIGlmIChtb2RlID09PSB2b2lkIDApIHsgbW9kZSA9IE1peC5BRERJVElWRTsgfVxuICAgICAgICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7IG9wdGlvbnMgPSB7fTsgfVxuICAgICAgICByZXR1cm4gZ2V0SGFybW9ueVJldHVybihoYXJtb255LCBjb2xvciwgbW9kZSwgZ2V0T3B0aW9uc0Zyb21Db2xvcklucHV0KG9wdGlvbnMsIGNvbG9yKSk7XG4gICAgfTtcbiAgICByZXR1cm4gQ29sb3JUcmFuc2xhdG9yO1xufSgpKTtcbmV4cG9ydCB7IENvbG9yVHJhbnNsYXRvciB9O1xuZXhwb3J0IHsgSGFybW9ueSwgTWl4IH07XG4iLCJpbXBvcnQgJy4vc3R5bGVzLnNjc3MnO1xuXG5leHBvcnQgZGVmYXVsdCAoQ29sb3JUcmFuc2xhdG9yKSA9PiB7XG5cbiAgICBjb25zdCBjb250YWluZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICBjb25zdCBjb2xvciA9IG5ldyBDb2xvclRyYW5zbGF0b3IoJ2hzbCgxODAsMTAwJSw1MCUpJywgeyBkZWNpbWFsczogMCB9KTtcblxuICAgIGZvciAobGV0IHJvdyA9IDA7IHJvdyA8IDEwOyByb3crKykge1xuXG4gICAgICAgIGZvciAobGV0IGNvbCA9IDA7IGNvbCA8IDEwOyBjb2wrKykge1xuXG4gICAgICAgICAgICBjb2xvclxuICAgICAgICAgICAgICAgIC5zZXRTKHJvdyAqIDEwKVxuICAgICAgICAgICAgICAgIC5zZXRMKGNvbCAqIDUgKyAzMCk7XG5cbiAgICAgICAgICAgIGNvbnN0IGJveCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuXG4gICAgICAgICAgICBib3guY2xhc3NMaXN0LmFkZCgnYm94Jyk7XG4gICAgICAgICAgICBib3guc3R5bGUuYmFja2dyb3VuZCA9IGNvbG9yLkhFWDtcblxuICAgICAgICAgICAgYm94LmlubmVyVGV4dCA9XG4gICAgICAgICAgICAgICAgYFI6JHtjb2xvci5SfVxuICAgICAgICAgICAgICAgICBHOiR7Y29sb3IuR31cbiAgICAgICAgICAgICAgICAgQjoke2NvbG9yLkJ9YDtcbiAgICAgICAgICAgIGNvbnRhaW5lci5hcHBlbmRDaGlsZChib3gpO1xuXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gY29udGFpbmVyO1xuXG59OyIsImltcG9ydCAnLi9zdHlsZXMuc2Nzcyc7XG5cbmV4cG9ydCBkZWZhdWx0IChDb2xvclRyYW5zbGF0b3IpID0+IHtcblxuICAgIGNvbnN0IGNvbnRhaW5lciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIGNvbnN0IGNvbG9yID0gbmV3IENvbG9yVHJhbnNsYXRvcih7IHI6IDI1NSwgZzogMCwgYjogMCB9KTtcbiAgICBjb25zdCBodWUgPSBbMCwgMzAsIDYwLCAxMjAsIDI0MCwgMjgwLCAzMjAsIDBdO1xuICAgIGxldCByYWluYm93O1xuXG4gICAgZm9yIChsZXQgciA9IDA7IHIgPCBodWUubGVuZ3RoOyByKyspIHtcblxuICAgICAgICBjb2xvci5zZXRIKGh1ZVtyXSk7XG5cbiAgICAgICAgY29uc3QgYm93ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG5cbiAgICAgICAgYm93LmNsYXNzTGlzdC5hZGQoJ3JhaW5ib3cnKTtcbiAgICAgICAgYm93LnN0eWxlLmJhY2tncm91bmQgPSBjb2xvci5IRVg7XG5cbiAgICAgICAgaWYgKHJhaW5ib3cpIHtcbiAgICAgICAgICAgIHJhaW5ib3cuYXBwZW5kQ2hpbGQoYm93KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbnRhaW5lci5hcHBlbmRDaGlsZChib3cpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmFpbmJvdyA9IGJvdztcbiAgICB9XG5cbiAgICByYWluYm93LnN0eWxlLmJhY2tncm91bmQgPSAnIzMzMyc7XG5cbiAgICByZXR1cm4gY29udGFpbmVyO1xuXG59OyIsImltcG9ydCAnLi9zdHlsZXMuc2Nzcyc7XG5cbmV4cG9ydCBkZWZhdWx0IChDb2xvclRyYW5zbGF0b3IpID0+IHtcblxuICAgIGNvbnN0IGNvbnRhaW5lciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIGNvbnN0IGhzbCA9IHsgaDogMCwgczogJzkwJScsIGw6ICc1MCUnIH07XG4gICAgY29uc3QgaHVlID0gW3VuZGVmaW5lZCwgNTUsIDMwLCAwLCAyOTAsIDIyMCwgMTMwXTtcbiAgICBjb25zdCB0b3RhbCA9IGh1ZS5sZW5ndGg7XG5cbiAgICBmb3IgKGxldCByb3cgPSAwOyByb3cgPCB0b3RhbDsgcm93KyspIHtcblxuICAgICAgICBmb3IgKGxldCBjb2wgPSAwOyBjb2wgPCB0b3RhbDsgY29sKyspIHtcblxuICAgICAgICAgICAgbGV0IGluZGV4ID0gdG90YWwgLSByb3cgKyBjb2w7XG4gICAgICAgICAgICBpZiAoaW5kZXggPj0gdG90YWwpIHtcbiAgICAgICAgICAgICAgICBpbmRleCAtPSB0b3RhbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGhzbC5oID0gaHVlW2luZGV4XTtcbiAgICAgICAgICAgIGNvbnN0IHJnYiA9IGh1ZVtpbmRleF0gPT09IHVuZGVmaW5lZFxuICAgICAgICAgICAgICAgID8gJyNGRkYnXG4gICAgICAgICAgICAgICAgOiBDb2xvclRyYW5zbGF0b3IudG9IRVgoaHNsKTtcbiAgICAgICAgICAgIGNvbnN0IGJveCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuXG4gICAgICAgICAgICBib3guY2xhc3NMaXN0LmFkZCgnZmxhZycpO1xuICAgICAgICAgICAgYm94LnN0eWxlLmJhY2tncm91bmQgPSByZ2I7XG5cbiAgICAgICAgICAgIGNvbnRhaW5lci5hcHBlbmRDaGlsZChib3gpO1xuXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gY29udGFpbmVyO1xuXG59OyIsImltcG9ydCAnLi9zdHlsZXMuc2Nzcyc7XG5cbmV4cG9ydCBkZWZhdWx0IChDb2xvclRyYW5zbGF0b3IpID0+IHtcblxuICAgIGNvbnN0IGNvbnRhaW5lciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIGNvbnN0IGNvbG9ycyA9IFtcbiAgICAgICAgJ3JlZCcsXG4gICAgICAgICdsaW1lJyxcbiAgICAgICAgJ2JsdWUnLFxuICAgICAgICAnYXF1YScsXG4gICAgICAgICd5ZWxsb3cnLFxuICAgICAgICAnZnVjaHNpYSdcbiAgICBdO1xuICAgIGNvbnN0IHRvdGFsID0gY29sb3JzLmxlbmd0aDtcblxuICAgIGZvciAobGV0IHJvdyA9IDA7IHJvdyA8IHRvdGFsOyByb3crKykge1xuXG4gICAgICAgIGNvbnN0IGhzbCA9IENvbG9yVHJhbnNsYXRvci50b0hTTE9iamVjdChjb2xvcnNbcm93XSwgeyBkZWNpbWFsczogMCB9KTtcbiAgICAgICAgY29uc3Qgc3RlcCA9IGhzbC5zIC8gKHRvdGFsIC0gMSk7XG5cbiAgICAgICAgZm9yIChsZXQgY29sID0gMDsgY29sIDwgdG90YWw7IGNvbCsrKSB7XG5cbiAgICAgICAgICAgIGNvbnN0IHJnYiA9IENvbG9yVHJhbnNsYXRvci50b0hFWChoc2wsIHsgZGVjaW1hbHM6IDAgfSk7XG4gICAgICAgICAgICBjb25zdCBjbXlrID0gQ29sb3JUcmFuc2xhdG9yLnRvQ01ZS09iamVjdChoc2wsIHsgZGVjaW1hbHM6IDAgfSk7XG5cbiAgICAgICAgICAgIGNvbnN0IGJveCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICAgICAgYm94LmNsYXNzTGlzdC5hZGQoJ2JveCcpO1xuICAgICAgICAgICAgYm94LnN0eWxlLmJhY2tncm91bmQgPSByZ2I7XG4gICAgICAgICAgICBib3guaW5uZXJUZXh0ID0gYEM6JHtjbXlrLmN9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIE06JHtjbXlrLm19XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIFk6JHtjbXlrLnl9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIEs6JHtjbXlrLmt9YDtcblxuICAgICAgICAgICAgY29udGFpbmVyLmFwcGVuZENoaWxkKGJveCk7XG5cbiAgICAgICAgICAgIGhzbC5zIC09IHN0ZXA7XG5cbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBjb250YWluZXI7XG5cbn07IiwiaW1wb3J0ICcuL3N0eWxlcy5zY3NzJztcblxuZXhwb3J0IGRlZmF1bHQgKENvbG9yVHJhbnNsYXRvcikgPT4ge1xuXG4gICAgY29uc3QgY29udGFpbmVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgY29uc3Qgcm93cyA9IDExO1xuICAgIGNvbnN0IG11bHQgPSAzO1xuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCByb3dzOyBpKyspIHtcblxuICAgICAgICBjb25zdCBibGVuZHMgPSBDb2xvclRyYW5zbGF0b3IuZ2V0QmxlbmRIRVgoJyNGRjAwMDAnLCAnI0ZGRkYwMCcsIG11bHQgKyBpICogbXVsdCk7XG5cbiAgICAgICAgYmxlbmRzLmZvckVhY2goKGJsZW5kLCBpbmRleCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgYm94ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgICAgICBib3guY2xhc3NMaXN0LmFkZCgnYm94JywgYGZpbGUke2l9YCk7XG4gICAgICAgICAgICBib3guc3R5bGUuYmFja2dyb3VuZCA9IGJsZW5kO1xuICAgICAgICAgICAgYm94LmlubmVyVGV4dCA9IGluZGV4ICsgMTtcbiAgICAgICAgICAgIGNvbnRhaW5lci5hcHBlbmRDaGlsZChib3gpO1xuICAgICAgICB9KTtcblxuICAgIH1cblxuICAgIHJldHVybiBjb250YWluZXI7XG5cbn07IiwiaW1wb3J0ICcuL3N0eWxlcy5zY3NzJztcblxuZXhwb3J0IGRlZmF1bHQgKENvbG9yVHJhbnNsYXRvcikgPT4ge1xuXG4gICAgY29uc3QgY29udGFpbmVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG5cbiAgICBjb25zdCBjb2xvcnMgPSBbJyNGMDAnLCAnI0ZGODAwMCcsICcjRkYwJywgJyMwRjAnLCAnIzAwRicsICcjQUEwMEZGJywgJyNGRjAwQUEnXTtcblxuICAgIGNvbnN0IGNyZWF0ZUJveCA9IChjb2xvciwgdHlwZSkgPT4ge1xuICAgICAgICBjb25zdCBib3ggPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgYm94LmNsYXNzTGlzdC5hZGQoJ2JveCcpO1xuICAgICAgICBib3guc3R5bGUuYmFja2dyb3VuZENvbG9yID0gY29sb3I7XG4gICAgICAgIGlmICh0eXBlKSBib3guZGF0YXNldC50eXBlID0gdHlwZTtcbiAgICAgICAgY29udGFpbmVyLmFwcGVuZENoaWxkKGJveCk7XG4gICAgfTtcblxuICAgIGNvbG9ycy5mb3JFYWNoKChjb2xvcikgPT4ge1xuICAgICAgICBjb25zdCBzaGFkZXMgPSBDb2xvclRyYW5zbGF0b3IuZ2V0U2hhZGVzKGNvbG9yLCAzKS5yZXZlcnNlKCk7XG4gICAgICAgIGNvbnN0IHRpbnRzID0gQ29sb3JUcmFuc2xhdG9yLmdldFRpbnRzKGNvbG9yLCAzKTtcbiAgICAgICAgc2hhZGVzLmZvckVhY2goKHNoYWRlKSA9PiBjcmVhdGVCb3goc2hhZGUsICdzaGFkZScpKTtcbiAgICAgICAgY3JlYXRlQm94KGNvbG9yKTtcbiAgICAgICAgdGludHMuZm9yRWFjaCgodGludCkgPT4gY3JlYXRlQm94KHRpbnQsICd0aW50JykpO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIGNvbnRhaW5lcjtcblxufTsiLCJpbXBvcnQgJy4vc3R5bGVzLnNjc3MnO1xuXG5cbmV4cG9ydCBkZWZhdWx0IChDb2xvclRyYW5zbGF0b3IpID0+IHtcblxuICAgIGNvbnN0IGNvbnRhaW5lciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuXG4gICAgY29uc3QgbWl4ZXMgPSBbXG4gICAgICAgICcjRkYwMDAwJyxcbiAgICAgICAgJyMwMEZGMDAnLFxuICAgICAgICAnIzAwMDBGRicsXG4gICAgICAgIFsxLCAzXSxcbiAgICAgICAgWzEsIDJdLFxuICAgICAgICBbMiwgM10sXG4gICAgICAgIFsxLCAyLCAzXVxuICAgIF07XG5cbiAgICBjb25zdCBmaWxsUGxhbmVzID0gKCkgPT4ge1xuICAgICAgICBjb25zdCBwbGFuZXMgPSBjb250YWluZXIucXVlcnlTZWxlY3RvckFsbCgnI3BsYW5lcyBwYXRoJyk7XG4gICAgICAgIHBsYW5lcy5mb3JFYWNoKChwbGFuZSwgaW5kZXgpID0+IHtcbiAgICAgICAgICAgIGxldCBjb2xvciA9ICcjQ0NDQ0NDJztcbiAgICAgICAgICAgIGlmICh0eXBlb2YgbWl4ZXNbaW5kZXhdID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIGNvbG9yID0gbWl4ZXNbaW5kZXhdO1xuICAgICAgICAgICAgfSBlbHNlIGlmKG1peGVzW2luZGV4XSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGNvbG9ycyA9IG1peGVzW2luZGV4XS5tYXAoKGkpID0+IG1peGVzW2kgLSAxXSk7XG4gICAgICAgICAgICAgICAgY29sb3IgPSBtaXhlc1tpbmRleF0gPSBDb2xvclRyYW5zbGF0b3IuZ2V0TWl4SEVYKGNvbG9ycyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwbGFuZS5zZXRBdHRyaWJ1dGUoJ2ZpbGwnLCBjb2xvcik7XG4gICAgICAgIH0pO1xuICAgIH07XG5cbiAgICBmZXRjaCgnaW1hZ2VzL2NvbG9yLW1peGVzLnN2ZycpXG4gICAgICAgIC50aGVuKHJlc3VsdCA9PiByZXN1bHQudGV4dCgpKVxuICAgICAgICAudGhlbigoc3ZnQ29kZSkgPT4ge1xuICAgICAgICAgICAgY29udGFpbmVyLmlubmVySFRNTCA9IHN2Z0NvZGU7XG4gICAgICAgICAgICBmaWxsUGxhbmVzKCk7XG4gICAgICAgIH0pO1xuXG4gICAgcmV0dXJuIGNvbnRhaW5lcjtcblxufTsiLCJpbXBvcnQgJy4vc3R5bGVzLnNjc3MnO1xuXG5leHBvcnQgZGVmYXVsdCAoQ29sb3JUcmFuc2xhdG9yLCB7IE1peCB9KSA9PiB7XG5cbiAgICBjb25zdCBjb250YWluZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcblxuICAgIGNvbnN0IG1peGVzID0gW1xuICAgICAgICAnI0ZGMDAwMCcsXG4gICAgICAgICcjRkZGRjAwJyxcbiAgICAgICAgJyMwMDAwRkYnLFxuICAgICAgICBbMSwgM10sXG4gICAgICAgIFsxLCAyXSxcbiAgICAgICAgWzIsIDNdLFxuICAgICAgICBbMSwgMiwgM11cbiAgICBdO1xuXG4gICAgY29uc3QgZmlsbFBsYW5lcyA9ICgpID0+IHtcbiAgICAgICAgY29uc3QgcGxhbmVzID0gY29udGFpbmVyLnF1ZXJ5U2VsZWN0b3JBbGwoJyNwbGFuZXMgcGF0aCcpO1xuICAgICAgICBwbGFuZXMuZm9yRWFjaCgocGxhbmUsIGluZGV4KSA9PiB7XG4gICAgICAgICAgICBsZXQgY29sb3IgPSAnI0NDQ0NDQyc7XG4gICAgICAgICAgICBpZiAodHlwZW9mIG1peGVzW2luZGV4XSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICBjb2xvciA9IG1peGVzW2luZGV4XTtcbiAgICAgICAgICAgIH0gZWxzZSBpZihtaXhlc1tpbmRleF0pIHtcbiAgICAgICAgICAgICAgICBjb25zdCBjb2xvcnMgPSBtaXhlc1tpbmRleF0ubWFwKChpKSA9PiBtaXhlc1tpIC0gMV0pO1xuICAgICAgICAgICAgICAgIGNvbG9yID0gbWl4ZXNbaW5kZXhdID0gQ29sb3JUcmFuc2xhdG9yLmdldE1peEhFWChjb2xvcnMsIE1peC5TVUJUUkFDVElWRSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwbGFuZS5zZXRBdHRyaWJ1dGUoJ2ZpbGwnLCBjb2xvcik7XG4gICAgICAgIH0pO1xuICAgIH07XG5cbiAgICBmZXRjaCgnaW1hZ2VzL2NvbG9yLW1peGVzLnN2ZycpXG4gICAgICAgIC50aGVuKHJlc3VsdCA9PiByZXN1bHQudGV4dCgpKVxuICAgICAgICAudGhlbigoc3ZnQ29kZSkgPT4ge1xuICAgICAgICAgICAgY29udGFpbmVyLmlubmVySFRNTCA9IHN2Z0NvZGU7XG4gICAgICAgICAgICBmaWxsUGxhbmVzKCk7XG4gICAgICAgIH0pO1xuXG4gICAgcmV0dXJuIGNvbnRhaW5lcjtcblxufTsiLCJpbXBvcnQgJy4vc3R5bGVzLnNjc3MnO1xuXG5leHBvcnQgZGVmYXVsdCAoQ29sb3JUcmFuc2xhdG9yLCB7IEhhcm1vbnkgfSkgPT4ge1xuXG4gICAgY29uc3QgY29udGFpbmVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG5cbiAgICBjb25zdCBoYXJtb25pZXMgPSBbXG4gICAgICAgIHsgbGFiZWw6ICdDb21wbGVtZW50YXJ5JywgICAgICAgdmFsdWU6IEhhcm1vbnkuQ09NUExFTUVOVEFSWSB9LFxuICAgICAgICB7IGxhYmVsOiAnU3BsaXQgQ29tcGxlbWVudGFyeScsIHZhbHVlOiBIYXJtb255LlNQTElUX0NPTVBMRU1FTlRBUlkgfSxcbiAgICAgICAgeyBsYWJlbDogJ0FuYWxvZ291cycsICAgICAgICAgICB2YWx1ZTogSGFybW9ueS5BTkFMT0dPVVMgfSxcbiAgICAgICAgeyBsYWJlbDogJ1RyaWFkaWMnLCAgICAgICAgICAgICB2YWx1ZTogSGFybW9ueS5UUklBRElDIH0sXG4gICAgICAgIHsgbGFiZWw6ICdUZXRyYWRpYycsICAgICAgICAgICAgdmFsdWU6IEhhcm1vbnkuVEVUUkFESUMgfSxcbiAgICAgICAgeyBsYWJlbDogJ1NxdWFyZScsICAgICAgICAgICAgICB2YWx1ZTogSGFybW9ueS5TUVVBUkUgfVxuICAgIF07XG5cbiAgICBjb25zdCBiYXNlQ29sb3IgPSAnI0YwMCc7XG5cbiAgICBjb25zdCBjcmVhdGVFbGVtZW50ID0gKGNsYXNzTmFtZSwgcGFyZW50KSA9PiB7XG4gICAgICAgIGNvbnN0IGRpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICBkaXYuY2xhc3NMaXN0LmFkZChjbGFzc05hbWUpO1xuICAgICAgICBwYXJlbnQuYXBwZW5kQ2hpbGQoZGl2KTtcbiAgICAgICAgcmV0dXJuIGRpdjtcbiAgICB9O1xuXG4gICAgY29uc3QgY3JlYXRlSGFybW9ueSA9IChpdGVtKSA9PiB7XG5cbiAgICAgICAgY29uc3Qgd3JhcHBlciA9IGNyZWF0ZUVsZW1lbnQoJ3dyYXBwZXInLCBjb250YWluZXIpO1xuICAgICAgICBjb25zdCB3aGVlbCA9IGNyZWF0ZUVsZW1lbnQoJ3doZWVsJywgd3JhcHBlcik7XG4gICAgICAgIGNvbnN0IGhhcm1vbnkgPSBjcmVhdGVFbGVtZW50KCdoYXJtb255Jywgd3JhcHBlcik7XG4gICAgICAgIGNyZWF0ZUVsZW1lbnQoJ2xhYmVsJywgd3JhcHBlcikuaW5uZXJUZXh0ID0gaXRlbS5sYWJlbDtcblxuICAgICAgICBmZXRjaCgnaW1hZ2VzL3doZWVsLWFkZGl0aXZlLnN2ZycpXG4gICAgICAgICAgICAudGhlbihyZXN1bHQgPT4gcmVzdWx0LnRleHQoKSlcbiAgICAgICAgICAgIC50aGVuKChzdmdDb2RlKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgaGFybW9ueUNvbG9ycyA9IENvbG9yVHJhbnNsYXRvci5nZXRIYXJtb255KGJhc2VDb2xvciwgaXRlbS52YWx1ZSk7XG4gICAgICAgICAgICAgICAgY29uc3Qgc2VsZWN0b3IgPSAncGF0aCcgKyBoYXJtb255Q29sb3JzLm1hcCgoY29sb3IpID0+IGA6bm90KFtmaWxsPVwiJHtjb2xvcn1cIl0pYCkuam9pbignJyk7XG4gICAgICAgICAgICAgICAgd2hlZWwuaW5uZXJIVE1MID0gc3ZnQ29kZTtcbiAgICAgICAgICAgICAgICBoYXJtb255Q29sb3JzLmZvckVhY2goKGhleCkgPT4gY3JlYXRlRWxlbWVudCgnYm94JywgaGFybW9ueSkuc3R5bGUuYmFja2dyb3VuZCA9IGhleCk7XG4gICAgICAgICAgICAgICAgd2hlZWwucXVlcnlTZWxlY3RvckFsbChzZWxlY3RvcikuZm9yRWFjaCgocGF0aCkgPT4gcGF0aC5zZXRBdHRyaWJ1dGUoJ2ZpbGwtb3BhY2l0eScsICcwLjI1JykpO1xuICAgICAgICAgICAgfSk7XG5cbiAgICB9O1xuXG4gICAgaGFybW9uaWVzLmZvckVhY2goKGl0ZW0pID0+IGNyZWF0ZUhhcm1vbnkoaXRlbSkpO1xuXG4gICAgcmV0dXJuIGNvbnRhaW5lcjtcblxufTsiLCJpbXBvcnQgJy4vc3R5bGVzLnNjc3MnO1xuXG5leHBvcnQgZGVmYXVsdCAoQ29sb3JUcmFuc2xhdG9yLCB7IEhhcm1vbnksIE1peCB9KSA9PiB7XG5cbiAgICBjb25zdCBjb250YWluZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcblxuICAgIGNvbnN0IGhhcm1vbmllcyA9IFtcbiAgICAgICAgeyBsYWJlbDogJ0NvbXBsZW1lbnRhcnknLCAgICAgICB2YWx1ZTogSGFybW9ueS5DT01QTEVNRU5UQVJZIH0sXG4gICAgICAgIHsgbGFiZWw6ICdTcGxpdCBDb21wbGVtZW50YXJ5JywgdmFsdWU6IEhhcm1vbnkuU1BMSVRfQ09NUExFTUVOVEFSWSB9LFxuICAgICAgICB7IGxhYmVsOiAnQW5hbG9nb3VzJywgICAgICAgICAgIHZhbHVlOiBIYXJtb255LkFOQUxPR09VUyB9LFxuICAgICAgICB7IGxhYmVsOiAnVHJpYWRpYycsICAgICAgICAgICAgIHZhbHVlOiBIYXJtb255LlRSSUFESUMgfSxcbiAgICAgICAgeyBsYWJlbDogJ1RldHJhZGljJywgICAgICAgICAgICB2YWx1ZTogSGFybW9ueS5URVRSQURJQyB9LFxuICAgICAgICB7IGxhYmVsOiAnU3F1YXJlJywgICAgICAgICAgICAgIHZhbHVlOiBIYXJtb255LlNRVUFSRSB9XG4gICAgXTtcblxuICAgIGNvbnN0IGJhc2VDb2xvciA9ICcjRjAwJztcblxuICAgIGNvbnN0IGNyZWF0ZUVsZW1lbnQgPSAoY2xhc3NOYW1lLCBwYXJlbnQpID0+IHtcbiAgICAgICAgY29uc3QgZGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgIGRpdi5jbGFzc0xpc3QuYWRkKGNsYXNzTmFtZSk7XG4gICAgICAgIHBhcmVudC5hcHBlbmRDaGlsZChkaXYpO1xuICAgICAgICByZXR1cm4gZGl2O1xuICAgIH07XG5cbiAgICBjb25zdCBjcmVhdGVIYXJtb255ID0gKGl0ZW0pID0+IHtcblxuICAgICAgICBjb25zdCB3cmFwcGVyID0gY3JlYXRlRWxlbWVudCgnd3JhcHBlcicsIGNvbnRhaW5lcik7XG4gICAgICAgIGNvbnN0IHdoZWVsID0gY3JlYXRlRWxlbWVudCgnd2hlZWwnLCB3cmFwcGVyKTtcbiAgICAgICAgY29uc3QgaGFybW9ueSA9IGNyZWF0ZUVsZW1lbnQoJ2hhcm1vbnknLCB3cmFwcGVyKTtcbiAgICAgICAgY3JlYXRlRWxlbWVudCgnbGFiZWwnLCB3cmFwcGVyKS5pbm5lclRleHQgPSBpdGVtLmxhYmVsO1xuXG4gICAgICAgIGZldGNoKCdpbWFnZXMvd2hlZWwtc3VidHJhY3RpdmUuc3ZnJylcbiAgICAgICAgICAgIC50aGVuKHJlc3VsdCA9PiByZXN1bHQudGV4dCgpKVxuICAgICAgICAgICAgLnRoZW4oKHN2Z0NvZGUpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBoYXJtb255Q29sb3JzID0gQ29sb3JUcmFuc2xhdG9yLmdldEhhcm1vbnkoYmFzZUNvbG9yLCBpdGVtLnZhbHVlLCBNaXguU1VCVFJBQ1RJVkUpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHNlbGVjdG9yID0gJ3BhdGgnICsgaGFybW9ueUNvbG9ycy5tYXAoKGNvbG9yKSA9PiBgOm5vdChbZmlsbD1cIiR7Y29sb3J9XCJdKWApLmpvaW4oJycpO1xuICAgICAgICAgICAgICAgIHdoZWVsLmlubmVySFRNTCA9IHN2Z0NvZGU7XG4gICAgICAgICAgICAgICAgaGFybW9ueUNvbG9ycy5mb3JFYWNoKChoZXgpID0+IGNyZWF0ZUVsZW1lbnQoJ2JveCcsIGhhcm1vbnkpLnN0eWxlLmJhY2tncm91bmQgPSBoZXgpO1xuICAgICAgICAgICAgICAgIHdoZWVsLnF1ZXJ5U2VsZWN0b3JBbGwoc2VsZWN0b3IpLmZvckVhY2goKHBhdGgpID0+IHBhdGguc2V0QXR0cmlidXRlKCdmaWxsLW9wYWNpdHknLCAnMC4yNScpKTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgfTtcblxuICAgIGhhcm1vbmllcy5mb3JFYWNoKChpdGVtKSA9PiBjcmVhdGVIYXJtb255KGl0ZW0pKTtcblxuICAgIHJldHVybiBjb250YWluZXI7XG5cbn07IiwiaW1wb3J0ICcuLi8uLi9ub2RlX21vZHVsZXMvZ29vZ2xlLWNvZGUtcHJldHRpZnkvYmluL3J1bl9wcmV0dGlmeS5taW4nO1xuaW1wb3J0ICcuLi8uLi9ub2RlX21vZHVsZXMvZ29vZ2xlLWNvZGUtcHJldHRpZnkvYmluL3ByZXR0aWZ5Lm1pbi5jc3MnO1xuaW1wb3J0ICcuLi8uLi9ub2RlX21vZHVsZXMvZ29vZ2xlLWNvZGUtcHJldHRpZnkvc3R5bGVzL2Rlc2VydC5jc3MnO1xuaW1wb3J0ICd3aGF0d2ctZmV0Y2gnO1xuaW1wb3J0ICcuL3N0eWxlcy5zY3NzJztcbmltcG9ydCB7IENvbG9yVHJhbnNsYXRvciwgSGFybW9ueSwgTWl4IH0gZnJvbSAnLi4vJztcbmltcG9ydCBkZW1vMSBmcm9tICcuL2RlbW8xJztcbmltcG9ydCBkZW1vMiBmcm9tICcuL2RlbW8yJztcbmltcG9ydCBkZW1vMyBmcm9tICcuL2RlbW8zJztcbmltcG9ydCBkZW1vNCBmcm9tICcuL2RlbW80JztcbmltcG9ydCBkZW1vNSBmcm9tICcuL2RlbW81JztcbmltcG9ydCBkZW1vNiBmcm9tICcuL2RlbW82JztcbmltcG9ydCBkZW1vNyBmcm9tICcuL2RlbW83JztcbmltcG9ydCBkZW1vOCBmcm9tICcuL2RlbW84JztcbmltcG9ydCBkZW1vOSBmcm9tICcuL2RlbW85JztcbmltcG9ydCBkZW1vMTAgZnJvbSAnLi9kZW1vMTAnO1xuXG5jb25zdCBmdW5jdGlvVG9TdHJpbmcgPSAoZm4pID0+IHtcbiAgICBjb25zdCBhcnRpY2xlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnYXJ0aWNsZScpO1xuICAgIGNvbnN0IHByZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3ByZScpO1xuICAgIGFydGljbGUuY2xhc3NMaXN0LmFkZCgnZnVuY3Rpb24tY29udGFpbmVyJyk7XG4gICAgcHJlLmNsYXNzTGlzdC5hZGQoJ3ByZXR0eXByaW50Jyk7XG4gICAgYXJ0aWNsZS5hcHBlbmRDaGlsZChwcmUpO1xuICAgIHByZS5pbm5lckhUTUwgPSBmbi50b1N0cmluZygpLnJlcGxhY2UoJyhDb2xvclRyYW5zbGF0b3IpJywgJygpJyk7XG4gICAgcmV0dXJuIGFydGljbGU7XG59O1xuXG5jb25zdCBkZW1vcyA9IG5ldyBNYXAoW1xuICAgIFsnZGVtbzEnLCBkZW1vMV0sXG4gICAgWydkZW1vMicsIGRlbW8yXSxcbiAgICBbJ2RlbW8zJywgZGVtbzNdLFxuICAgIFsnZGVtbzQnLCBkZW1vNF0sXG4gICAgWydkZW1vNScsIGRlbW81XSxcbiAgICBbJ2RlbW82JywgZGVtbzZdLFxuICAgIFsnZGVtbzcnLCBkZW1vN10sXG4gICAgWydkZW1vOCcsIGRlbW84XSxcbiAgICBbJ2RlbW85JywgZGVtbzldLFxuICAgIFsnZGVtbzEwJywgZGVtbzEwXSxcbl0pO1xuXG5kb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdET01Db250ZW50TG9hZGVkJywgKCkgPT4ge1xuICAgIGRlbW9zLmZvckVhY2goKG1vZHVsZSwgZGl2KSA9PiB7XG4gICAgICAgIGNvbnN0IGRlbW8gPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChkaXYpO1xuICAgICAgICBjb25zdCBjb250YWluZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgY29uc3Qgd3JhcHBlciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuXG4gICAgICAgIGNvbnRhaW5lci5jbGFzc0xpc3QuYWRkKCdkZW1vLWNvbnRhaW5lcicpO1xuICAgICAgICB3cmFwcGVyLmNsYXNzTGlzdC5hZGQoJ2RlbW8td3JhcHBlcicpO1xuXG4gICAgICAgIHdyYXBwZXIuYXBwZW5kQ2hpbGQobW9kdWxlKENvbG9yVHJhbnNsYXRvciwgeyBIYXJtb255LCBNaXggfSkpO1xuICAgICAgICBjb250YWluZXIuYXBwZW5kQ2hpbGQod3JhcHBlcik7XG4gICAgICAgIGRlbW8uYXBwZW5kQ2hpbGQoY29udGFpbmVyKTtcbiAgICAgICAgZGVtby5hcHBlbmRDaGlsZChmdW5jdGlvVG9TdHJpbmcobW9kdWxlKSk7XG4gICAgfSk7XG59KTsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///942\n')}},__webpack_module_cache__={};function __webpack_require__(I){var g=__webpack_module_cache__[I];if(void 0!==g)return g.exports;var C=__webpack_module_cache__[I]={exports:{}};return __webpack_modules__[I](C,C.exports,__webpack_require__),C.exports}__webpack_require__.r=I=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(I,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(I,"__esModule",{value:!0})};var __webpack_exports__=__webpack_require__(942),__webpack_export_target__=window;for(var i in __webpack_exports__)__webpack_export_target__[i]=__webpack_exports__[i];__webpack_exports__.__esModule&&Object.defineProperty(__webpack_export_target__,"__esModule",{value:!0})})();