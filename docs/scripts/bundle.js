(()=>{var __webpack_modules__={699:(__unused_webpack_module,__unused_webpack___webpack_exports__,__webpack_require__)=>{"use strict";eval("\n// EXTERNAL MODULE: ./node_modules/.pnpm/google-code-prettify@1.0.5/node_modules/google-code-prettify/bin/run_prettify.min.js\nvar run_prettify_min = __webpack_require__(966);\n;// ./node_modules/.pnpm/whatwg-fetch@3.6.20/node_modules/whatwg-fetch/fetch.js\n/* eslint-disable no-prototype-builtins */\nvar g =\n  (typeof globalThis !== 'undefined' && globalThis) ||\n  (typeof self !== 'undefined' && self) ||\n  // eslint-disable-next-line no-undef\n  (typeof __webpack_require__.g !== 'undefined' && __webpack_require__.g) ||\n  {}\n\nvar support = {\n  searchParams: 'URLSearchParams' in g,\n  iterable: 'Symbol' in g && 'iterator' in Symbol,\n  blob:\n    'FileReader' in g &&\n    'Blob' in g &&\n    (function() {\n      try {\n        new Blob()\n        return true\n      } catch (e) {\n        return false\n      }\n    })(),\n  formData: 'FormData' in g,\n  arrayBuffer: 'ArrayBuffer' in g\n}\n\nfunction isDataView(obj) {\n  return obj && DataView.prototype.isPrototypeOf(obj)\n}\n\nif (support.arrayBuffer) {\n  var viewClasses = [\n    '[object Int8Array]',\n    '[object Uint8Array]',\n    '[object Uint8ClampedArray]',\n    '[object Int16Array]',\n    '[object Uint16Array]',\n    '[object Int32Array]',\n    '[object Uint32Array]',\n    '[object Float32Array]',\n    '[object Float64Array]'\n  ]\n\n  var isArrayBufferView =\n    ArrayBuffer.isView ||\n    function(obj) {\n      return obj && viewClasses.indexOf(Object.prototype.toString.call(obj)) > -1\n    }\n}\n\nfunction normalizeName(name) {\n  if (typeof name !== 'string') {\n    name = String(name)\n  }\n  if (/[^a-z0-9\\-#$%&'*+.^_`|~!]/i.test(name) || name === '') {\n    throw new TypeError('Invalid character in header field name: \"' + name + '\"')\n  }\n  return name.toLowerCase()\n}\n\nfunction normalizeValue(value) {\n  if (typeof value !== 'string') {\n    value = String(value)\n  }\n  return value\n}\n\n// Build a destructive iterator for the value list\nfunction iteratorFor(items) {\n  var iterator = {\n    next: function() {\n      var value = items.shift()\n      return {done: value === undefined, value: value}\n    }\n  }\n\n  if (support.iterable) {\n    iterator[Symbol.iterator] = function() {\n      return iterator\n    }\n  }\n\n  return iterator\n}\n\nfunction Headers(headers) {\n  this.map = {}\n\n  if (headers instanceof Headers) {\n    headers.forEach(function(value, name) {\n      this.append(name, value)\n    }, this)\n  } else if (Array.isArray(headers)) {\n    headers.forEach(function(header) {\n      if (header.length != 2) {\n        throw new TypeError('Headers constructor: expected name/value pair to be length 2, found' + header.length)\n      }\n      this.append(header[0], header[1])\n    }, this)\n  } else if (headers) {\n    Object.getOwnPropertyNames(headers).forEach(function(name) {\n      this.append(name, headers[name])\n    }, this)\n  }\n}\n\nHeaders.prototype.append = function(name, value) {\n  name = normalizeName(name)\n  value = normalizeValue(value)\n  var oldValue = this.map[name]\n  this.map[name] = oldValue ? oldValue + ', ' + value : value\n}\n\nHeaders.prototype['delete'] = function(name) {\n  delete this.map[normalizeName(name)]\n}\n\nHeaders.prototype.get = function(name) {\n  name = normalizeName(name)\n  return this.has(name) ? this.map[name] : null\n}\n\nHeaders.prototype.has = function(name) {\n  return this.map.hasOwnProperty(normalizeName(name))\n}\n\nHeaders.prototype.set = function(name, value) {\n  this.map[normalizeName(name)] = normalizeValue(value)\n}\n\nHeaders.prototype.forEach = function(callback, thisArg) {\n  for (var name in this.map) {\n    if (this.map.hasOwnProperty(name)) {\n      callback.call(thisArg, this.map[name], name, this)\n    }\n  }\n}\n\nHeaders.prototype.keys = function() {\n  var items = []\n  this.forEach(function(value, name) {\n    items.push(name)\n  })\n  return iteratorFor(items)\n}\n\nHeaders.prototype.values = function() {\n  var items = []\n  this.forEach(function(value) {\n    items.push(value)\n  })\n  return iteratorFor(items)\n}\n\nHeaders.prototype.entries = function() {\n  var items = []\n  this.forEach(function(value, name) {\n    items.push([name, value])\n  })\n  return iteratorFor(items)\n}\n\nif (support.iterable) {\n  Headers.prototype[Symbol.iterator] = Headers.prototype.entries\n}\n\nfunction consumed(body) {\n  if (body._noBody) return\n  if (body.bodyUsed) {\n    return Promise.reject(new TypeError('Already read'))\n  }\n  body.bodyUsed = true\n}\n\nfunction fileReaderReady(reader) {\n  return new Promise(function(resolve, reject) {\n    reader.onload = function() {\n      resolve(reader.result)\n    }\n    reader.onerror = function() {\n      reject(reader.error)\n    }\n  })\n}\n\nfunction readBlobAsArrayBuffer(blob) {\n  var reader = new FileReader()\n  var promise = fileReaderReady(reader)\n  reader.readAsArrayBuffer(blob)\n  return promise\n}\n\nfunction readBlobAsText(blob) {\n  var reader = new FileReader()\n  var promise = fileReaderReady(reader)\n  var match = /charset=([A-Za-z0-9_-]+)/.exec(blob.type)\n  var encoding = match ? match[1] : 'utf-8'\n  reader.readAsText(blob, encoding)\n  return promise\n}\n\nfunction readArrayBufferAsText(buf) {\n  var view = new Uint8Array(buf)\n  var chars = new Array(view.length)\n\n  for (var i = 0; i < view.length; i++) {\n    chars[i] = String.fromCharCode(view[i])\n  }\n  return chars.join('')\n}\n\nfunction bufferClone(buf) {\n  if (buf.slice) {\n    return buf.slice(0)\n  } else {\n    var view = new Uint8Array(buf.byteLength)\n    view.set(new Uint8Array(buf))\n    return view.buffer\n  }\n}\n\nfunction Body() {\n  this.bodyUsed = false\n\n  this._initBody = function(body) {\n    /*\n      fetch-mock wraps the Response object in an ES6 Proxy to\n      provide useful test harness features such as flush. However, on\n      ES5 browsers without fetch or Proxy support pollyfills must be used;\n      the proxy-pollyfill is unable to proxy an attribute unless it exists\n      on the object before the Proxy is created. This change ensures\n      Response.bodyUsed exists on the instance, while maintaining the\n      semantic of setting Request.bodyUsed in the constructor before\n      _initBody is called.\n    */\n    // eslint-disable-next-line no-self-assign\n    this.bodyUsed = this.bodyUsed\n    this._bodyInit = body\n    if (!body) {\n      this._noBody = true;\n      this._bodyText = ''\n    } else if (typeof body === 'string') {\n      this._bodyText = body\n    } else if (support.blob && Blob.prototype.isPrototypeOf(body)) {\n      this._bodyBlob = body\n    } else if (support.formData && FormData.prototype.isPrototypeOf(body)) {\n      this._bodyFormData = body\n    } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {\n      this._bodyText = body.toString()\n    } else if (support.arrayBuffer && support.blob && isDataView(body)) {\n      this._bodyArrayBuffer = bufferClone(body.buffer)\n      // IE 10-11 can't handle a DataView body.\n      this._bodyInit = new Blob([this._bodyArrayBuffer])\n    } else if (support.arrayBuffer && (ArrayBuffer.prototype.isPrototypeOf(body) || isArrayBufferView(body))) {\n      this._bodyArrayBuffer = bufferClone(body)\n    } else {\n      this._bodyText = body = Object.prototype.toString.call(body)\n    }\n\n    if (!this.headers.get('content-type')) {\n      if (typeof body === 'string') {\n        this.headers.set('content-type', 'text/plain;charset=UTF-8')\n      } else if (this._bodyBlob && this._bodyBlob.type) {\n        this.headers.set('content-type', this._bodyBlob.type)\n      } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {\n        this.headers.set('content-type', 'application/x-www-form-urlencoded;charset=UTF-8')\n      }\n    }\n  }\n\n  if (support.blob) {\n    this.blob = function() {\n      var rejected = consumed(this)\n      if (rejected) {\n        return rejected\n      }\n\n      if (this._bodyBlob) {\n        return Promise.resolve(this._bodyBlob)\n      } else if (this._bodyArrayBuffer) {\n        return Promise.resolve(new Blob([this._bodyArrayBuffer]))\n      } else if (this._bodyFormData) {\n        throw new Error('could not read FormData body as blob')\n      } else {\n        return Promise.resolve(new Blob([this._bodyText]))\n      }\n    }\n  }\n\n  this.arrayBuffer = function() {\n    if (this._bodyArrayBuffer) {\n      var isConsumed = consumed(this)\n      if (isConsumed) {\n        return isConsumed\n      } else if (ArrayBuffer.isView(this._bodyArrayBuffer)) {\n        return Promise.resolve(\n          this._bodyArrayBuffer.buffer.slice(\n            this._bodyArrayBuffer.byteOffset,\n            this._bodyArrayBuffer.byteOffset + this._bodyArrayBuffer.byteLength\n          )\n        )\n      } else {\n        return Promise.resolve(this._bodyArrayBuffer)\n      }\n    } else if (support.blob) {\n      return this.blob().then(readBlobAsArrayBuffer)\n    } else {\n      throw new Error('could not read as ArrayBuffer')\n    }\n  }\n\n  this.text = function() {\n    var rejected = consumed(this)\n    if (rejected) {\n      return rejected\n    }\n\n    if (this._bodyBlob) {\n      return readBlobAsText(this._bodyBlob)\n    } else if (this._bodyArrayBuffer) {\n      return Promise.resolve(readArrayBufferAsText(this._bodyArrayBuffer))\n    } else if (this._bodyFormData) {\n      throw new Error('could not read FormData body as text')\n    } else {\n      return Promise.resolve(this._bodyText)\n    }\n  }\n\n  if (support.formData) {\n    this.formData = function() {\n      return this.text().then(decode)\n    }\n  }\n\n  this.json = function() {\n    return this.text().then(JSON.parse)\n  }\n\n  return this\n}\n\n// HTTP methods whose capitalization should be normalized\nvar methods = ['CONNECT', 'DELETE', 'GET', 'HEAD', 'OPTIONS', 'PATCH', 'POST', 'PUT', 'TRACE']\n\nfunction normalizeMethod(method) {\n  var upcased = method.toUpperCase()\n  return methods.indexOf(upcased) > -1 ? upcased : method\n}\n\nfunction Request(input, options) {\n  if (!(this instanceof Request)) {\n    throw new TypeError('Please use the \"new\" operator, this DOM object constructor cannot be called as a function.')\n  }\n\n  options = options || {}\n  var body = options.body\n\n  if (input instanceof Request) {\n    if (input.bodyUsed) {\n      throw new TypeError('Already read')\n    }\n    this.url = input.url\n    this.credentials = input.credentials\n    if (!options.headers) {\n      this.headers = new Headers(input.headers)\n    }\n    this.method = input.method\n    this.mode = input.mode\n    this.signal = input.signal\n    if (!body && input._bodyInit != null) {\n      body = input._bodyInit\n      input.bodyUsed = true\n    }\n  } else {\n    this.url = String(input)\n  }\n\n  this.credentials = options.credentials || this.credentials || 'same-origin'\n  if (options.headers || !this.headers) {\n    this.headers = new Headers(options.headers)\n  }\n  this.method = normalizeMethod(options.method || this.method || 'GET')\n  this.mode = options.mode || this.mode || null\n  this.signal = options.signal || this.signal || (function () {\n    if ('AbortController' in g) {\n      var ctrl = new AbortController();\n      return ctrl.signal;\n    }\n  }());\n  this.referrer = null\n\n  if ((this.method === 'GET' || this.method === 'HEAD') && body) {\n    throw new TypeError('Body not allowed for GET or HEAD requests')\n  }\n  this._initBody(body)\n\n  if (this.method === 'GET' || this.method === 'HEAD') {\n    if (options.cache === 'no-store' || options.cache === 'no-cache') {\n      // Search for a '_' parameter in the query string\n      var reParamSearch = /([?&])_=[^&]*/\n      if (reParamSearch.test(this.url)) {\n        // If it already exists then set the value with the current time\n        this.url = this.url.replace(reParamSearch, '$1_=' + new Date().getTime())\n      } else {\n        // Otherwise add a new '_' parameter to the end with the current time\n        var reQueryString = /\\?/\n        this.url += (reQueryString.test(this.url) ? '&' : '?') + '_=' + new Date().getTime()\n      }\n    }\n  }\n}\n\nRequest.prototype.clone = function() {\n  return new Request(this, {body: this._bodyInit})\n}\n\nfunction decode(body) {\n  var form = new FormData()\n  body\n    .trim()\n    .split('&')\n    .forEach(function(bytes) {\n      if (bytes) {\n        var split = bytes.split('=')\n        var name = split.shift().replace(/\\+/g, ' ')\n        var value = split.join('=').replace(/\\+/g, ' ')\n        form.append(decodeURIComponent(name), decodeURIComponent(value))\n      }\n    })\n  return form\n}\n\nfunction parseHeaders(rawHeaders) {\n  var headers = new Headers()\n  // Replace instances of \\r\\n and \\n followed by at least one space or horizontal tab with a space\n  // https://tools.ietf.org/html/rfc7230#section-3.2\n  var preProcessedHeaders = rawHeaders.replace(/\\r?\\n[\\t ]+/g, ' ')\n  // Avoiding split via regex to work around a common IE11 bug with the core-js 3.6.0 regex polyfill\n  // https://github.com/github/fetch/issues/748\n  // https://github.com/zloirock/core-js/issues/751\n  preProcessedHeaders\n    .split('\\r')\n    .map(function(header) {\n      return header.indexOf('\\n') === 0 ? header.substr(1, header.length) : header\n    })\n    .forEach(function(line) {\n      var parts = line.split(':')\n      var key = parts.shift().trim()\n      if (key) {\n        var value = parts.join(':').trim()\n        try {\n          headers.append(key, value)\n        } catch (error) {\n          console.warn('Response ' + error.message)\n        }\n      }\n    })\n  return headers\n}\n\nBody.call(Request.prototype)\n\nfunction Response(bodyInit, options) {\n  if (!(this instanceof Response)) {\n    throw new TypeError('Please use the \"new\" operator, this DOM object constructor cannot be called as a function.')\n  }\n  if (!options) {\n    options = {}\n  }\n\n  this.type = 'default'\n  this.status = options.status === undefined ? 200 : options.status\n  if (this.status < 200 || this.status > 599) {\n    throw new RangeError(\"Failed to construct 'Response': The status provided (0) is outside the range [200, 599].\")\n  }\n  this.ok = this.status >= 200 && this.status < 300\n  this.statusText = options.statusText === undefined ? '' : '' + options.statusText\n  this.headers = new Headers(options.headers)\n  this.url = options.url || ''\n  this._initBody(bodyInit)\n}\n\nBody.call(Response.prototype)\n\nResponse.prototype.clone = function() {\n  return new Response(this._bodyInit, {\n    status: this.status,\n    statusText: this.statusText,\n    headers: new Headers(this.headers),\n    url: this.url\n  })\n}\n\nResponse.error = function() {\n  var response = new Response(null, {status: 200, statusText: ''})\n  response.ok = false\n  response.status = 0\n  response.type = 'error'\n  return response\n}\n\nvar redirectStatuses = [301, 302, 303, 307, 308]\n\nResponse.redirect = function(url, status) {\n  if (redirectStatuses.indexOf(status) === -1) {\n    throw new RangeError('Invalid status code')\n  }\n\n  return new Response(null, {status: status, headers: {location: url}})\n}\n\nvar DOMException = g.DOMException\ntry {\n  new DOMException()\n} catch (err) {\n  DOMException = function(message, name) {\n    this.message = message\n    this.name = name\n    var error = Error(message)\n    this.stack = error.stack\n  }\n  DOMException.prototype = Object.create(Error.prototype)\n  DOMException.prototype.constructor = DOMException\n}\n\nfunction fetch_fetch(input, init) {\n  return new Promise(function(resolve, reject) {\n    var request = new Request(input, init)\n\n    if (request.signal && request.signal.aborted) {\n      return reject(new DOMException('Aborted', 'AbortError'))\n    }\n\n    var xhr = new XMLHttpRequest()\n\n    function abortXhr() {\n      xhr.abort()\n    }\n\n    xhr.onload = function() {\n      var options = {\n        statusText: xhr.statusText,\n        headers: parseHeaders(xhr.getAllResponseHeaders() || '')\n      }\n      // This check if specifically for when a user fetches a file locally from the file system\n      // Only if the status is out of a normal range\n      if (request.url.indexOf('file://') === 0 && (xhr.status < 200 || xhr.status > 599)) {\n        options.status = 200;\n      } else {\n        options.status = xhr.status;\n      }\n      options.url = 'responseURL' in xhr ? xhr.responseURL : options.headers.get('X-Request-URL')\n      var body = 'response' in xhr ? xhr.response : xhr.responseText\n      setTimeout(function() {\n        resolve(new Response(body, options))\n      }, 0)\n    }\n\n    xhr.onerror = function() {\n      setTimeout(function() {\n        reject(new TypeError('Network request failed'))\n      }, 0)\n    }\n\n    xhr.ontimeout = function() {\n      setTimeout(function() {\n        reject(new TypeError('Network request timed out'))\n      }, 0)\n    }\n\n    xhr.onabort = function() {\n      setTimeout(function() {\n        reject(new DOMException('Aborted', 'AbortError'))\n      }, 0)\n    }\n\n    function fixUrl(url) {\n      try {\n        return url === '' && g.location.href ? g.location.href : url\n      } catch (e) {\n        return url\n      }\n    }\n\n    xhr.open(request.method, fixUrl(request.url), true)\n\n    if (request.credentials === 'include') {\n      xhr.withCredentials = true\n    } else if (request.credentials === 'omit') {\n      xhr.withCredentials = false\n    }\n\n    if ('responseType' in xhr) {\n      if (support.blob) {\n        xhr.responseType = 'blob'\n      } else if (\n        support.arrayBuffer\n      ) {\n        xhr.responseType = 'arraybuffer'\n      }\n    }\n\n    if (init && typeof init.headers === 'object' && !(init.headers instanceof Headers || (g.Headers && init.headers instanceof g.Headers))) {\n      var names = [];\n      Object.getOwnPropertyNames(init.headers).forEach(function(name) {\n        names.push(normalizeName(name))\n        xhr.setRequestHeader(name, normalizeValue(init.headers[name]))\n      })\n      request.headers.forEach(function(value, name) {\n        if (names.indexOf(name) === -1) {\n          xhr.setRequestHeader(name, value)\n        }\n      })\n    } else {\n      request.headers.forEach(function(value, name) {\n        xhr.setRequestHeader(name, value)\n      })\n    }\n\n    if (request.signal) {\n      request.signal.addEventListener('abort', abortXhr)\n\n      xhr.onreadystatechange = function() {\n        // DONE (success or failure)\n        if (xhr.readyState === 4) {\n          request.signal.removeEventListener('abort', abortXhr)\n        }\n      }\n    }\n\n    xhr.send(typeof request._bodyInit === 'undefined' ? null : request._bodyInit)\n  })\n}\n\nfetch_fetch.polyfill = true\n\nif (!g.fetch) {\n  g.fetch = fetch_fetch\n  g.Headers = Headers\n  g.Request = Request\n  g.Response = Response\n}\n\n;// ./src/constants/numbers.ts\nconst MAX_DECIMALS = 6;\nconst DEFAULT_BLEND_STEPS = 5;\nconst DEFAULT_SHADES_TINTS_STEPS = 5;\nconst BASE_255 = 255;\nconst MAX_HUE = 360;\nconst MAX_PCENT = 100;\nconst MAX_ALPHA = 1;\nconst MAX_LAB = 125;\nconst MAX_LCH_C = 150;\n\n;// ./src/constants/enums.ts\nvar ColorModel;\n(function (ColorModel) {\n    ColorModel[\"HEX\"] = \"HEX\";\n    ColorModel[\"RGB\"] = \"RGB\";\n    ColorModel[\"HWB\"] = \"HWB\";\n    ColorModel[\"HSL\"] = \"HSL\";\n    ColorModel[\"CIELab\"] = \"CIELab\";\n    ColorModel[\"LCH\"] = \"LCH\";\n    ColorModel[\"CMYK\"] = \"CMYK\";\n})(ColorModel || (ColorModel = {}));\nvar Harmony;\n(function (Harmony) {\n    Harmony[\"ANALOGOUS\"] = \"ANALOGOUS\";\n    Harmony[\"COMPLEMENTARY\"] = \"COMPLEMENTARY\";\n    Harmony[\"SPLIT_COMPLEMENTARY\"] = \"SPLIT_COMPLEMENTARY\";\n    Harmony[\"TRIADIC\"] = \"TRIADIC\";\n    Harmony[\"TETRADIC\"] = \"TETRADIC\";\n    Harmony[\"SQUARE\"] = \"SQUARE\";\n})(Harmony || (Harmony = {}));\nvar Mix;\n(function (Mix) {\n    Mix[\"ADDITIVE\"] = \"ADDITIVE\";\n    Mix[\"SUBTRACTIVE\"] = \"SUBTRACTIVE\";\n})(Mix || (Mix = {}));\nvar ColorKeywords;\n(function (ColorKeywords) {\n    ColorKeywords[\"black\"] = \"#000000\";\n    ColorKeywords[\"silver\"] = \"#C0C0C0\";\n    ColorKeywords[\"gray\"] = \"#808080\";\n    ColorKeywords[\"white\"] = \"#FFFFFF\";\n    ColorKeywords[\"maroon\"] = \"#800000\";\n    ColorKeywords[\"red\"] = \"#FF0000\";\n    ColorKeywords[\"purple\"] = \"#800080\";\n    ColorKeywords[\"fuchsia\"] = \"#FF00FF\";\n    ColorKeywords[\"green\"] = \"#008000\";\n    ColorKeywords[\"lime\"] = \"#00FF00\";\n    ColorKeywords[\"olive\"] = \"#808000\";\n    ColorKeywords[\"yellow\"] = \"#FFFF00\";\n    ColorKeywords[\"navy\"] = \"#000080\";\n    ColorKeywords[\"blue\"] = \"#0000FF\";\n    ColorKeywords[\"teal\"] = \"#008080\";\n    ColorKeywords[\"aqua\"] = \"#00FFFF\";\n    ColorKeywords[\"orange\"] = \"#FFA500\";\n    ColorKeywords[\"aliceblue\"] = \"#F0F8FF\";\n    ColorKeywords[\"antiquewhite\"] = \"#FAEBD7\";\n    ColorKeywords[\"aquamarine\"] = \"#7FFFD4\";\n    ColorKeywords[\"azure\"] = \"#F0FFFF\";\n    ColorKeywords[\"beige\"] = \"#F5F5DC\";\n    ColorKeywords[\"bisque\"] = \"#FFE4C4\";\n    ColorKeywords[\"blanchedalmond\"] = \"#FFEBCD\";\n    ColorKeywords[\"blueviolet\"] = \"#8A2BE2\";\n    ColorKeywords[\"brown\"] = \"#A52A2A\";\n    ColorKeywords[\"burlywood\"] = \"#DEB887\";\n    ColorKeywords[\"cadetblue\"] = \"#5F9EA0\";\n    ColorKeywords[\"chartreuse\"] = \"#7FFF00\";\n    ColorKeywords[\"chocolate\"] = \"#D2691E\";\n    ColorKeywords[\"coral\"] = \"#FF7F50\";\n    ColorKeywords[\"cornflowerblue\"] = \"#6495ED\";\n    ColorKeywords[\"cornsilk\"] = \"#FFF8DC\";\n    ColorKeywords[\"crimson\"] = \"#DC143C\";\n    ColorKeywords[\"cyan\"] = \"#00FFFF\";\n    ColorKeywords[\"darkblue\"] = \"#00008B\";\n    ColorKeywords[\"darkcyan\"] = \"#008B8B\";\n    ColorKeywords[\"darkgoldenrod\"] = \"#B8860B\";\n    ColorKeywords[\"darkgray\"] = \"#A9A9A9\";\n    ColorKeywords[\"darkgreen\"] = \"#006400\";\n    ColorKeywords[\"darkgrey\"] = \"#A9A9A9\";\n    ColorKeywords[\"darkkhaki\"] = \"#BDB76B\";\n    ColorKeywords[\"darkmagenta\"] = \"#8B008B\";\n    ColorKeywords[\"darkolivegreen\"] = \"#556B2F\";\n    ColorKeywords[\"darkorange\"] = \"#FF8C00\";\n    ColorKeywords[\"darkorchid\"] = \"#9932CC\";\n    ColorKeywords[\"darkred\"] = \"#8B0000\";\n    ColorKeywords[\"darksalmon\"] = \"#E9967A\";\n    ColorKeywords[\"darkseagreen\"] = \"#8FBC8F\";\n    ColorKeywords[\"darkslateblue\"] = \"#483D8B\";\n    ColorKeywords[\"darkslategray\"] = \"#2F4F4F\";\n    ColorKeywords[\"darkslategrey\"] = \"#2F4F4F\";\n    ColorKeywords[\"darkturquoise\"] = \"#00CED1\";\n    ColorKeywords[\"darkviolet\"] = \"#9400D3\";\n    ColorKeywords[\"deeppink\"] = \"#FF1493\";\n    ColorKeywords[\"deepskyblue\"] = \"#00BFFF\";\n    ColorKeywords[\"dimgray\"] = \"#696969\";\n    ColorKeywords[\"dimgrey\"] = \"#696969\";\n    ColorKeywords[\"dodgerblue\"] = \"#1E90FF\";\n    ColorKeywords[\"firebrick\"] = \"#B22222\";\n    ColorKeywords[\"floralwhite\"] = \"#FFFAF0\";\n    ColorKeywords[\"forestgreen\"] = \"#228B22\";\n    ColorKeywords[\"gainsboro\"] = \"#DCDCDC\";\n    ColorKeywords[\"ghostwhite\"] = \"#F8F8FF\";\n    ColorKeywords[\"gold\"] = \"#FFD700\";\n    ColorKeywords[\"goldenrod\"] = \"#DAA520\";\n    ColorKeywords[\"greenyellow\"] = \"#ADFF2F\";\n    ColorKeywords[\"grey\"] = \"#808080\";\n    ColorKeywords[\"honeydew\"] = \"#F0FFF0\";\n    ColorKeywords[\"hotpink\"] = \"#FF69B4\";\n    ColorKeywords[\"indianred\"] = \"#CD5C5C\";\n    ColorKeywords[\"indigo\"] = \"#4B0082\";\n    ColorKeywords[\"ivory\"] = \"#FFFFF0\";\n    ColorKeywords[\"khaki\"] = \"#F0E68C\";\n    ColorKeywords[\"lavender\"] = \"#E6E6FA\";\n    ColorKeywords[\"lavenderblush\"] = \"#FFF0F5\";\n    ColorKeywords[\"lawngreen\"] = \"#7CFC00\";\n    ColorKeywords[\"lemonchiffon\"] = \"#FFFACD\";\n    ColorKeywords[\"lightblue\"] = \"#ADD8E6\";\n    ColorKeywords[\"lightcoral\"] = \"#F08080\";\n    ColorKeywords[\"lightcyan\"] = \"#E0FFFF\";\n    ColorKeywords[\"lightgoldenrodyellow\"] = \"#FAFAD2\";\n    ColorKeywords[\"lightgray\"] = \"#D3D3D3\";\n    ColorKeywords[\"lightgreen\"] = \"#90EE90\";\n    ColorKeywords[\"lightgrey\"] = \"#D3D3D3\";\n    ColorKeywords[\"lightpink\"] = \"#FFB6C1\";\n    ColorKeywords[\"lightsalmon\"] = \"#FFA07A\";\n    ColorKeywords[\"lightseagreen\"] = \"#20B2AA\";\n    ColorKeywords[\"lightskyblue\"] = \"#87CEFA\";\n    ColorKeywords[\"lightslategray\"] = \"#778899\";\n    ColorKeywords[\"lightslategrey\"] = \"#778899\";\n    ColorKeywords[\"lightsteelblue\"] = \"#B0C4DE\";\n    ColorKeywords[\"lightyellow\"] = \"#FFFFE0\";\n    ColorKeywords[\"limegreen\"] = \"#32CD32\";\n    ColorKeywords[\"linen\"] = \"#FAF0E6\";\n    ColorKeywords[\"magenta\"] = \"#FF00FF\";\n    ColorKeywords[\"mediumaquamarine\"] = \"#66CDAA\";\n    ColorKeywords[\"mediumblue\"] = \"#0000CD\";\n    ColorKeywords[\"mediumorchid\"] = \"#BA55D3\";\n    ColorKeywords[\"mediumpurple\"] = \"#9370DB\";\n    ColorKeywords[\"mediumseagreen\"] = \"#3CB371\";\n    ColorKeywords[\"mediumslateblue\"] = \"#7B68EE\";\n    ColorKeywords[\"mediumspringgreen\"] = \"#00FA9A\";\n    ColorKeywords[\"mediumturquoise\"] = \"#48D1CC\";\n    ColorKeywords[\"mediumvioletred\"] = \"#C71585\";\n    ColorKeywords[\"midnightblue\"] = \"#191970\";\n    ColorKeywords[\"mintcream\"] = \"#F5FFFA\";\n    ColorKeywords[\"mistyrose\"] = \"#FFE4E1\";\n    ColorKeywords[\"moccasin\"] = \"#FFE4B5\";\n    ColorKeywords[\"navajowhite\"] = \"#FFDEAD\";\n    ColorKeywords[\"oldlace\"] = \"#FDF5E6\";\n    ColorKeywords[\"olivedrab\"] = \"#6B8E23\";\n    ColorKeywords[\"orangered\"] = \"#FF4500\";\n    ColorKeywords[\"orchid\"] = \"#DA70D6\";\n    ColorKeywords[\"palegoldenrod\"] = \"#EEE8AA\";\n    ColorKeywords[\"palegreen\"] = \"#98FB98\";\n    ColorKeywords[\"paleturquoise\"] = \"#AFEEEE\";\n    ColorKeywords[\"palevioletred\"] = \"#DB7093\";\n    ColorKeywords[\"papayawhip\"] = \"#FFEFD5\";\n    ColorKeywords[\"peachpuff\"] = \"#FFDAB9\";\n    ColorKeywords[\"peru\"] = \"#CD853F\";\n    ColorKeywords[\"pink\"] = \"#FFC0CB\";\n    ColorKeywords[\"plum\"] = \"#DDA0DD\";\n    ColorKeywords[\"powderblue\"] = \"#B0E0E6\";\n    ColorKeywords[\"rosybrown\"] = \"#BC8F8F\";\n    ColorKeywords[\"royalblue\"] = \"#4169E1\";\n    ColorKeywords[\"saddlebrown\"] = \"#8B4513\";\n    ColorKeywords[\"salmon\"] = \"#FA8072\";\n    ColorKeywords[\"sandybrown\"] = \"#F4A460\";\n    ColorKeywords[\"seagreen\"] = \"#2E8B57\";\n    ColorKeywords[\"seashell\"] = \"#FFF5EE\";\n    ColorKeywords[\"sienna\"] = \"#A0522D\";\n    ColorKeywords[\"skyblue\"] = \"#87CEEB\";\n    ColorKeywords[\"slateblue\"] = \"#6A5ACD\";\n    ColorKeywords[\"slategray\"] = \"#708090\";\n    ColorKeywords[\"slategrey\"] = \"#708090\";\n    ColorKeywords[\"snow\"] = \"#FFFAFA\";\n    ColorKeywords[\"springgreen\"] = \"#00FF7F\";\n    ColorKeywords[\"steelblue\"] = \"#4682B4\";\n    ColorKeywords[\"tan\"] = \"#D2B48C\";\n    ColorKeywords[\"thistle\"] = \"#D8BFD8\";\n    ColorKeywords[\"tomato\"] = \"#FF6347\";\n    ColorKeywords[\"turquoise\"] = \"#40E0D0\";\n    ColorKeywords[\"violet\"] = \"#EE82EE\";\n    ColorKeywords[\"wheat\"] = \"#F5DEB3\";\n    ColorKeywords[\"whitesmoke\"] = \"#F5F5F5\";\n    ColorKeywords[\"yellowgreen\"] = \"#9ACD32\";\n    ColorKeywords[\"rebeccapurple\"] = \"#663399\";\n})(ColorKeywords || (ColorKeywords = {}));\nconst COLOR_KEYS = Object.keys(ColorKeywords);\nconst COLOR_PROPS = {\n    HEX: ['R', 'G', 'B', 'A'],\n    RGB: ['R', 'G', 'B', 'A'],\n    HSL: ['H', 'S', 'L', 'A'],\n    HWB: ['H', 'W', 'B', 'A'],\n    CIELab: ['L', 'a', 'b', 'A'],\n    LCH: ['L', 'C', 'H', 'A'],\n    CMYK: ['C', 'M', 'Y', 'K', 'A']\n};\nconst VALID_COLOR_OBJECTS = {\n    ABGR: ColorModel.RGB,\n    ABHW: ColorModel.HWB,\n    ACHL: ColorModel.LCH,\n    ACKMY: ColorModel.CMYK,\n    AHLS: ColorModel.HSL,\n    ALAB: ColorModel.CIELab,\n    BGR: ColorModel.RGB,\n    BHW: ColorModel.HWB,\n    CHL: ColorModel.LCH,\n    CKMY: ColorModel.CMYK,\n    HLS: ColorModel.HSL,\n    LAB: ColorModel.CIELab\n};\nvar TypeOf;\n(function (TypeOf) {\n    TypeOf[\"NUMBER\"] = \"number\";\n    TypeOf[\"BOOLEAN\"] = \"boolean\";\n})(TypeOf || (TypeOf = {}));\n\n;// ./src/constants/regexps.ts\n\nconst COLORREGS = {\n    [ColorModel.HEX]: /^#(?:(?<r>[a-f\\d])(?<g>[a-f\\d])(?<b>[a-f\\d])(?<a>[a-f\\d])?|(?<rr>[a-f\\d]{2})(?<gg>[a-f\\d]{2})(?<bb>[a-f\\d]{2})(?<aa>[a-f\\d]{2})?)$/i,\n    [ColorModel.RGB]: /^rgba?\\s*\\(\\s*(?:(?<r_legacy>(?:\\d*\\.)?\\d+%?)\\s*,\\s*(?<g_legacy>(?:\\d*\\.)?\\d+%?)\\s*,\\s*(?<b_legacy>(?:\\d*\\.)?\\d+%?)(?:\\s*,\\s*(?<a_legacy>(?:\\d*\\.)?\\d+))?|(?<r>(?:\\d*\\.)?\\d+%?)\\s+(?<g>(?:\\d*\\.)?\\d+%?)\\s+(?<b>(?:\\d*\\.)?\\d+%?)(?:\\s*\\/\\s*(?<a>(?:\\d*\\.)?\\d+%?))?|from\\s+(?<from>(?:\\w+|\\w+\\(\\s*[^())]+\\s*\\)|\\w+\\(from\\s+\\w+\\(.*\\)\\s*\\)|#[a-fA-F\\d]+))\\s+(?<relative_r>(?:[rgb]|(?:\\d*\\.)?\\d+|calc\\([rgb()/*\\-+\\d.\\s]+\\)))\\s+(?<relative_g>(?:[rgb]|(?:\\d*\\.)?\\d+|calc\\([rgb()/*\\-+\\d.\\s]+\\)))\\s+(?<relative_b>(?:[rgb]|(?:\\d*\\.)?\\d+|calc\\([rgb()/*\\-+\\d.\\s]+\\)))(?:\\s*\\/\\s*(?<relative_a>(?:(?:\\d*\\.)?\\d+%?|calc\\([()/*\\-+\\d.\\s\\w]*(?:alpha)?[()/*\\-+\\d.\\s\\w]*\\)|alpha)))?)\\s*\\)$/,\n    [ColorModel.HWB]: /^hwb\\s*\\(\\s*(?:(?<h>(?:\\d*\\.)?\\d+(?:deg|grad|rad|turn)?)\\s+(?<w>(?:\\d*\\.)?\\d+)%\\s+(?<b>(?:\\d*\\.)?\\d+)%(?:\\s*\\/\\s*(?<a>(?:\\d*\\.)?\\d+%?))?|from\\s+(?<from>(?:\\w+|\\w+\\(\\s*[^())]+\\s*\\)|\\w+\\(from\\s+\\w+\\(.*\\)\\s*\\)|#[a-fA-F\\d]+))\\s+(?<relative_h>(?:[hwb]|(?:\\d*\\.)?\\d+|calc\\([hwb()/*\\-+\\d.\\s]+\\)))\\s+(?<relative_w>(?:[hwb]|(?:\\d*\\.)?\\d+|calc\\([hwb()/*\\-+\\d.\\s]+\\)))%?\\s+(?<relative_b>(?:[hwb]|(?:\\d*\\.)?\\d+|calc\\([hwb()/*\\-+\\d.\\s]+\\)))%?(?:\\s*\\/\\s*(?<relative_a>(?:(?:\\d*\\.)?\\d+%?|calc\\([()/*\\-+\\d.\\s\\w]*(?:alpha)?[()/*\\-+\\d.\\s\\w]*\\)|alpha)))?)\\s*\\)$/,\n    [ColorModel.HSL]: /^hsla?\\s*\\(\\s*(?:(?<h_legacy>-?(?:\\d*\\.)?\\d+(?:deg|grad|rad|turn)?)\\s*,\\s*(?<s_legacy>(?:\\d*\\.)?\\d+)%\\s*,\\s*(?<l_legacy>(?:\\d*\\.)?\\d+)%(?:\\s*,\\s*(?<a_legacy>(?:\\d*\\.)?\\d+))?|(?<h>-?(?:\\d*\\.)?\\d+(?:deg|grad|rad|turn)?)\\s+(?<s>(?:\\d*\\.)?\\d+)%?\\s+(?<l>(?:\\d*\\.)?\\d+)%?(?:\\s*\\/\\s*(?<a>(?:\\d*\\.)?\\d+%?))?|from\\s+(?<from>(?:\\w+|\\w+\\(\\s*[^())]+\\s*\\)|\\w+\\(from\\s+\\w+\\(.*\\)\\s*\\)|#[a-fA-F\\d]+))\\s+(?<relative_h>(?:[hsl]|(?:\\d*\\.)?\\d+|calc\\([hsl()/*\\-+\\d.\\s]+\\)))\\s+(?<relative_s>(?:[hsl]|(?:\\d*\\.)?\\d+|calc\\([hsl()/*\\-+\\d.\\s]+\\)))%?\\s+(?<relative_l>(?:[hsl]|(?:\\d*\\.)?\\d+|calc\\([hsl()/*\\-+\\d.\\s]+\\)))%?(?:\\s*\\/\\s*(?<relative_a>(?:(?:\\d*\\.)?\\d+%?|calc\\([()/*\\-+\\d.\\s\\w]*(?:alpha)?[()/*\\-+\\d.\\s\\w]*\\)|alpha)))?)\\s*\\)$/,\n    [ColorModel.CIELab]: /^lab\\s*\\(\\s*(?:(?<L>(?:\\d*\\.)?\\d+%?)\\s+(?<a>-?(?:\\d*\\.)?\\d+%?)\\s+(?<b>-?(?:\\d*\\.)?\\d+%?)(?:\\s*\\/\\s*(?<A>(?:\\d*\\.)?\\d+%?))?|from\\s+(?<from>(?:\\w+|\\w+\\(\\s*[^())]+\\s*\\)|\\w+\\(from\\s+\\w+\\(.*\\)\\s*\\)|#[a-fA-F\\d]+))\\s+(?<relative_L>(?:[lab]|(?:\\d*\\.)?\\d+|calc\\([lab()/*\\-+\\d.\\s]+\\)))\\s+(?<relative_a>(?:[lab]|(?:\\d*\\.)?\\d+|calc\\([lab()/*\\-+\\d.\\s]+\\)))\\s+(?<relative_b>(?:[lab]|(?:\\d*\\.)?\\d+|calc\\([lab()/*\\-+\\d.\\s]+\\)))(?:\\s*\\/\\s*(?<relative_A>(?:(?:\\d*\\.)?\\d+%?|calc\\([()/*\\-+\\d.\\s\\w]*(?:alpha)?[()/*\\-+\\d.\\s\\w]*\\)|alpha)))?)\\s*\\)$/,\n    [ColorModel.LCH]: /^lch\\s*\\(\\s*(?:(?<l>(?:\\d*\\.)?\\d+%?)\\s+(?<c>-?(?:\\d*\\.)?\\d+%?)\\s+(?<h>-?(?:\\d*\\.)?\\d+(?:deg|grad|rad|turn)?)(?:\\s*\\/\\s*(?<a>(?:\\d*\\.)?\\d+%?))?|from\\s+(?<from>(?:\\w+|\\w+\\(\\s*[^())]+\\s*\\)|\\w+\\(from\\s+\\w+\\(.*\\)\\s*\\)|#[a-fA-F\\d]+))\\s+(?<relative_l>(?:[lch]|(?:\\d*\\.)?\\d+|calc\\([lch()/*\\-+\\d.\\s]+\\)))\\s+(?<relative_c>(?:[lch]|(?:\\d*\\.)?\\d+|calc\\([lch()/*\\-+\\d.\\s]+\\)))\\s+(?<relative_h>(?:[lch]|(?:\\d*\\.)?\\d+|calc\\([lch()/*\\-+\\d.\\s]+\\)))(?:\\s*\\/\\s*(?<relative_a>(?:(?:\\d*\\.)?\\d+%?|calc\\([()/*\\-+\\d.\\s\\w]*(?:alpha)?[()/*\\-+\\d.\\s\\w]*\\)|alpha)))?)\\s*\\)$/,\n    [ColorModel.CMYK]: /^(?:device-cmyk|cmyk)\\s*\\(\\s*(?:(?<c_legacy>(?:\\d*\\.)?\\d+%?)\\s*,\\s*(?<m_legacy>(?:\\d*\\.)?\\d+%?)\\s*,\\s*(?<y_legacy>(?:\\d*\\.)?\\d+%?)\\s*,\\s*(?<k_legacy>(?:\\d*\\.)?\\d+%?)(?:\\s*,\\s*(?<a_legacy>(?:\\d*\\.)?\\d+))?|(?<c>(?:\\d*\\.)?\\d+%?)\\s+(?<m>(?:\\d*\\.)?\\d+%?)\\s+(?<y>(?:\\d*\\.)?\\d+%?)\\s+(?<k>(?:\\d*\\.)?\\d+%?)(?:\\s*\\/\\s*(?<a>(?:\\d*\\.)?\\d+%?))?)\\s*\\)$/\n};\nconst CALC = {\n    REGEXP: /^calc\\(\\s*(?<operation>[\\d./*+-\\w\\s]+)\\s*\\)$/,\n    SCOPED: /\\(\\s*([^()]+)\\s*\\)/g,\n    DIVISION: /\\s*(?<left>(?:(?:\\d*\\.)?\\d+|\\w+))\\s*\\/\\s*(?<right>(?:(?:\\d*\\.)?\\d+|\\w+))\\s*/,\n    MULTIPLICATION: /\\s*(?<left>(?:(?:\\d*\\.)?\\d+|\\w+))\\s*\\*\\s*(?<right>(?:(?:\\d*\\.)?\\d+|\\w+))\\s*/,\n    SUM: /\\s*(?<left>(?:(?:\\d*\\.)?\\d+|\\w+))\\s*\\+\\s*(?<right>(?:(?:\\d*\\.)?\\d+|\\w+))\\s*/,\n    REST: /\\s*(?<left>(?:(?:\\d*\\.)?\\d+|\\w+))\\s*-\\s*(?<right>(?:(?:\\d*\\.)?\\d+|\\w+))\\s*/\n};\nconst HSL_HUE = /^(?<number>-?(?:\\d*\\.)?\\d+)(?<units>(?:deg|grad|rad|turn)?)$/;\nconst PCENT = /^(-?\\d+(?:\\.\\d+)?|-?\\.\\d+)%$/;\nconst HEX = /^0x([a-f\\d]{1,2})$/i;\nconst TEMPLATE_VAR = /\\{(\\d+)\\}/g;\nconst COMMAS_AND_NEXT_CHARS = /,( +|\\d+)/g;\nconst SPACES = / +/;\n\n;// ./src/constants/errors.ts\nconst ERRORS = {\n    NOT_ACCEPTED_STRING_INPUT: 'The provided string color doesn\\'t have a correct format',\n    NOT_ACCEPTED_OBJECT_INPUT: 'The provided color object doesn\\'t have the proper keys or format',\n    NOT_A_VALID_RELATIVE_COLOR: 'is not a valid operation for a relative color'\n};\n\n;// ./src/@types/index.ts\nvar AnglesUnitEnum;\n(function (AnglesUnitEnum) {\n    AnglesUnitEnum[\"NONE\"] = \"none\";\n    AnglesUnitEnum[\"DEGREES\"] = \"deg\";\n    AnglesUnitEnum[\"GRADIANS\"] = \"grad\";\n    AnglesUnitEnum[\"RADIANS\"] = \"rad\";\n    AnglesUnitEnum[\"TURNS\"] = \"turn\";\n})(AnglesUnitEnum || (AnglesUnitEnum = {}));\nvar ColorUnitEnum;\n(function (ColorUnitEnum) {\n    ColorUnitEnum[\"NONE\"] = \"none\";\n    ColorUnitEnum[\"PERCENT\"] = \"percent\";\n})(ColorUnitEnum || (ColorUnitEnum = {}));\nvar CMYKFunctionEnum;\n(function (CMYKFunctionEnum) {\n    CMYKFunctionEnum[\"DEVICE_CMYK\"] = \"device-cmyk\";\n    CMYKFunctionEnum[\"CMYK\"] = \"cmyk\";\n})(CMYKFunctionEnum || (CMYKFunctionEnum = {}));\n\n;// ./src/constants/options.ts\n\n\nconst DEFAULT_OPTIONS = {\n    decimals: MAX_DECIMALS,\n    legacyCSS: false,\n    spacesAfterCommas: false,\n    anglesUnit: AnglesUnitEnum.NONE,\n    rgbUnit: ColorUnitEnum.NONE,\n    labUnit: ColorUnitEnum.NONE,\n    lchUnit: ColorUnitEnum.NONE,\n    cmykUnit: ColorUnitEnum.PERCENT,\n    alphaUnit: ColorUnitEnum.NONE,\n    cmykFunction: CMYKFunctionEnum.DEVICE_CMYK\n};\n\n;// ./src/constants/index.ts\n\n\n\n\n\n\n\n;// ./src/helpers/index.ts\n\n\nconst hasProp = (obj, prop) => Object.prototype.hasOwnProperty.call(obj, prop);\nconst percentNumber = (percent) => {\n    return +`${percent}`.replace(PCENT, '$1');\n};\nconst percent = (percent) => PCENT.test(`${percent}`)\n    ? percentNumber(percent)\n    : Math.min(+percent, 100);\nconst getDEC = (hex) => {\n    if (hex.length === 1) {\n        hex += hex;\n    }\n    return parseInt(hex, 16);\n};\nconst getHEX = (number) => {\n    const hex = round(number, 0).toString(16).toUpperCase();\n    if (hex.length === 1) {\n        return `0x0${hex}`;\n    }\n    return `0x${hex}`;\n};\nconst toHEX = (h) => {\n    let hex = round(h, 0).toString(16).toUpperCase();\n    if (hex.length === 1) {\n        hex = `0${hex}`;\n    }\n    return hex;\n};\nconst from255NumberToPercent = (value, decimals) => round(value / BASE_255 * 100, decimals);\nconst from125NumberToPercent = (value, decimals) => round(value / MAX_LAB * 100, decimals);\nconst from150NumberToPercent = (value, decimals) => round(value / MAX_LCH_C * 100, decimals);\nconst getBase255Number = (color, alpha = false) => {\n    if (!alpha && PCENT.test(color)) {\n        return Math.min(BASE_255 * percentNumber(color) / 100, BASE_255);\n    }\n    if (HEX.test(color)) {\n        if (color.length === 3) {\n            color += color.slice(-1);\n        }\n        return alpha\n            ? round(color) / BASE_255\n            : round(color);\n    }\n    return Math.min(+color, alpha ? 1 : BASE_255);\n};\nconst getBase125Number = (color) => {\n    if (PCENT.test(color)) {\n        return minmax(MAX_LAB * percentNumber(color) / 100, -MAX_LAB, MAX_LAB);\n    }\n    return minmax(+color, -MAX_LAB, MAX_LAB);\n};\nconst getBase150Number = (color) => {\n    if (PCENT.test(color)) {\n        return minmax(MAX_LCH_C * percentNumber(color) / 100, -MAX_LCH_C, MAX_LCH_C);\n    }\n    return minmax(+color, -MAX_LCH_C, MAX_LCH_C);\n};\nconst getCMYKNumber = (color) => Math.min(PCENT.test(color) ? percentNumber(color) / 100 : +color, 1);\nconst getOrderedArrayString = (keys) => [...keys].sort().join('').toUpperCase();\nconst round = (value, decimals = MAX_DECIMALS) => {\n    const exp = Math.pow(10, decimals);\n    return Math.round(+value * exp) / exp;\n};\nconst minmax = (n, min, max) => Math.max(min, Math.min(n, max));\nconst degrees = (radian) => radian * 180 / Math.PI;\nconst radians = (degrees) => degrees * Math.PI / 180;\nconst pi2 = 360;\nconst normalizeHue = (hue) => {\n    if (typeof hue === 'string') {\n        const matches = hue.match(HSL_HUE);\n        const groups = matches.groups;\n        const value = +groups.number;\n        const units = groups.units;\n        switch (units) {\n            case AnglesUnitEnum.RADIANS:\n                hue = round(degrees(value));\n                break;\n            case AnglesUnitEnum.TURNS:\n                hue = round(value * pi2);\n                break;\n            case AnglesUnitEnum.GRADIANS:\n                hue = round(9 / 10 * value);\n                break;\n            case AnglesUnitEnum.DEGREES:\n            default:\n                hue = value;\n        }\n    }\n    if (hue > 360 || hue < 0) {\n        hue -= Math.floor(hue / pi2) * pi2;\n    }\n    return hue;\n};\nconst normalizeAlpha = (alpha) => {\n    if (typeof alpha === 'string') {\n        if (PCENT.test(alpha)) {\n            alpha = percentNumber(alpha) / 100;\n        }\n        else {\n            alpha = +alpha;\n        }\n    }\n    return (isNaN(+alpha) || alpha > MAX_ALPHA) ? MAX_ALPHA : round(alpha);\n};\nconst translateDegrees = (degrees, units) => {\n    let hue;\n    switch (units) {\n        case AnglesUnitEnum.RADIANS:\n            hue = round(radians(degrees));\n            break;\n        case AnglesUnitEnum.TURNS:\n            hue = round(degrees / pi2);\n            break;\n        case AnglesUnitEnum.GRADIANS:\n            hue = round(10 / 9 * degrees);\n            break;\n        case AnglesUnitEnum.DEGREES:\n        case AnglesUnitEnum.NONE:\n        default:\n            hue = degrees;\n    }\n    return hue;\n};\nconst isHarmony = (param) => {\n    return `${param}` in Harmony;\n};\nconst isMix = (param) => {\n    return `${param}` in Mix;\n};\n\n;// ./src/color/translators.ts\n\n\nconst MATRIX_LRGB_XYZ_D50 = [\n    [0.4360747, 0.3850649, 0.1430804],\n    [0.2225045, 0.7168786, 0.0606169],\n    [0.0139322, 0.0971045, 0.7141733]\n];\nconst MATRIX_XYZ_D50_LRGB = [\n    [3.1338561, -1.6168667, -0.4906146],\n    [-0.9787684, 1.9161415, 0.033454],\n    [0.0719453, -0.2289914, 1.4052427]\n];\nconst TRISTIMULUS_D50 = MATRIX_LRGB_XYZ_D50.map((matrix) => {\n    return matrix.reduce((sum, value) => sum + value, 0);\n});\nconst hueToRgb = (t1, t2, hue) => {\n    if (hue < 0) {\n        hue += 6;\n    }\n    if (hue >= 6) {\n        hue -= 6;\n    }\n    if (hue < 1) {\n        return round(((t2 - t1) * hue + t1) * BASE_255);\n    }\n    else if (hue < 3) {\n        return round(t2 * BASE_255);\n    }\n    else if (hue < 4) {\n        return round(((t2 - t1) * (4 - hue) + t1) * BASE_255);\n    }\n    else {\n        return round(t1 * BASE_255);\n    }\n};\nconst rgbToLinearLightRgb = (value) => {\n    return value <= 0.04045\n        ? value / 12.92\n        : ((value + 0.055) / 1.055) ** 2.4;\n};\nconst linearLightRgbToRgb = (value) => {\n    return value <= 0.0031308\n        ? 12.92 * value\n        : 1.055 * (value ** (1 / 2.4)) - 0.055;\n};\nconst matrixVectorMultiplication = (v1, v2, v3, matrix) => {\n    const result = [0, 0, 0];\n    const linearRgb = [v1, v2, v3];\n    matrix.forEach((array, index) => {\n        array.forEach((value, mindex) => {\n            result[index] += value * linearRgb[mindex];\n        });\n    });\n    return result;\n};\nconst from_CIE_XYZ_D50_to_CIE_LAB = (x, y, z) => {\n    const f = (t) => {\n        return t > (6 / 29) ** 3\n            ? Math.cbrt(t)\n            : t / (3 * (6 / 29) ** 2) + (4 / 29);\n    };\n    const fx = f(x / TRISTIMULUS_D50[0]);\n    const fy = f(y / TRISTIMULUS_D50[1]);\n    const fz = f(z / TRISTIMULUS_D50[2]);\n    return [\n        116 * fy - 16,\n        500 * (fx - fy),\n        200 * (fy - fz)\n    ];\n};\nconst from_CIE_LAB_to_CIE_XYZ_D50 = (L, a, b) => {\n    const f = (t) => {\n        return t > 6 / 29\n            ? t ** 3\n            : 3 * (6 / 29) ** 2 * (t - 4 / 29);\n    };\n    const fl = (L + 16) / 116;\n    const fa = a / 500;\n    const fb = b / 200;\n    return [\n        TRISTIMULUS_D50[0] * f(fl + fa),\n        TRISTIMULUS_D50[1] * f(fl),\n        TRISTIMULUS_D50[2] * f(fl - fb)\n    ];\n};\nconst hslToRgb = (H, S, L) => {\n    H /= 60;\n    S /= 100;\n    L /= 100;\n    const t2 = (L <= .5)\n        ? L * (S + 1)\n        : L + S - (L * S);\n    const t1 = L * 2 - t2;\n    const R = hueToRgb(t1, t2, H + 2);\n    const G = hueToRgb(t1, t2, H);\n    const B = hueToRgb(t1, t2, H - 2);\n    return { R, G, B };\n};\nconst rgbToHsl = (R, G, B, A = 1) => {\n    R /= BASE_255;\n    G /= BASE_255;\n    B /= BASE_255;\n    A = Math.min(A, MAX_ALPHA);\n    const MAX = Math.max(R, G, B);\n    const MIN = Math.min(R, G, B);\n    const D = MAX - MIN;\n    let H = 0;\n    let S = 0;\n    const L = (MAX + MIN) / 2;\n    if (D !== 0) {\n        switch (MAX) {\n            case R:\n                H = ((G - B) / D) % 6;\n                break;\n            case G:\n                H = (B - R) / D + 2;\n                break;\n            case B:\n                H = (R - G) / D + 4;\n                break;\n        }\n        H = round(H * 60);\n        if (H < 0) {\n            H += 360;\n        }\n        S = D / (1 - Math.abs(2 * L - 1));\n    }\n    return {\n        H,\n        S: round(S * 100),\n        L: round(L * 100),\n        A\n    };\n};\nconst rgbToLab = (R, G, B) => {\n    const LINEAR_LIGHT_RGB = [\n        R / BASE_255,\n        G / BASE_255,\n        B / BASE_255\n    ].map(rgbToLinearLightRgb);\n    const CIE_XYZ_D50 = matrixVectorMultiplication(LINEAR_LIGHT_RGB[0], LINEAR_LIGHT_RGB[1], LINEAR_LIGHT_RGB[2], MATRIX_LRGB_XYZ_D50);\n    const CIE_LAB = from_CIE_XYZ_D50_to_CIE_LAB(CIE_XYZ_D50[0], CIE_XYZ_D50[1], CIE_XYZ_D50[2]);\n    return {\n        L: CIE_LAB[0],\n        a: CIE_LAB[1],\n        b: CIE_LAB[2]\n    };\n};\nconst labToRgb = (L, a, b) => {\n    const CIE_XYZ_D50 = from_CIE_LAB_to_CIE_XYZ_D50(L, a, b);\n    const LINEAR_LIGHT_RGB = matrixVectorMultiplication(CIE_XYZ_D50[0], CIE_XYZ_D50[1], CIE_XYZ_D50[2], MATRIX_XYZ_D50_LRGB);\n    const rgb = LINEAR_LIGHT_RGB.map(linearLightRgbToRgb);\n    return {\n        R: minmax(rgb[0] * BASE_255, 0, BASE_255),\n        G: minmax(rgb[1] * BASE_255, 0, BASE_255),\n        B: minmax(rgb[2] * BASE_255, 0, BASE_255)\n    };\n};\nconst labToLch = (L, a, b) => {\n    const C = Math.sqrt(a ** 2 + b ** 2);\n    const H = degrees(Math.atan2(b, a));\n    return {\n        L,\n        C,\n        H: normalizeHue(H)\n    };\n};\nconst lchToLab = (L, C, H) => {\n    const radH = radians(H);\n    const a = C * Math.cos(radH);\n    const b = C * Math.sin(radH);\n    return {\n        L,\n        a,\n        b\n    };\n};\nconst rgbToLch = (R, G, B) => {\n    const lab = rgbToLab(R, G, B);\n    return labToLch(lab.L, lab.a, lab.b);\n};\nconst lchToRgb = (L, C, H) => {\n    const lab = lchToLab(L, C, H);\n    return labToRgb(lab.L, lab.a, lab.b);\n};\nconst rgbToHwb = (R, G, B, A = 1) => {\n    const hsl = rgbToHsl(R, G, B, A);\n    return {\n        H: hsl.H,\n        W: round(Math.min(R, G, B) / BASE_255 * 100),\n        B: round((1 - Math.max(R, G, B) / BASE_255) * 100),\n        A\n    };\n};\nconst hwbToRgb = (H, W, B) => {\n    W /= 100;\n    B /= 100;\n    const v = 1 - B;\n    const c = v - W;\n    const x = c * (1 - Math.abs((H / 60) % 2 - 1));\n    let rgbR = 0;\n    let rgbG = 0;\n    let rgbB = 0;\n    if (H < 60) {\n        rgbR = c;\n        rgbG = x;\n        rgbB = 0;\n    }\n    else if (H >= 60 && H < 120) {\n        rgbR = x;\n        rgbG = c;\n        rgbB = 0;\n    }\n    else if (H >= 120 && H < 180) {\n        rgbR = 0;\n        rgbG = c;\n        rgbB = x;\n    }\n    else if (H >= 180 && H < 240) {\n        rgbR = 0;\n        rgbG = x;\n        rgbB = c;\n    }\n    else if (H >= 240 && H < 300) {\n        rgbR = x;\n        rgbG = 0;\n        rgbB = c;\n    }\n    else if (H >= 300) {\n        rgbR = c;\n        rgbG = 0;\n        rgbB = x;\n    }\n    rgbR += W;\n    rgbG += W;\n    rgbB += W;\n    return {\n        R: minmax(rgbR * BASE_255, 0, BASE_255),\n        G: minmax(rgbG * BASE_255, 0, BASE_255),\n        B: minmax(rgbB * BASE_255, 0, BASE_255)\n    };\n};\nconst cmykToRgb = (C, M, Y, K) => {\n    K = 1 - K;\n    return {\n        R: round(BASE_255 * (1 - C) * K),\n        G: round(BASE_255 * (1 - M) * K),\n        B: round(BASE_255 * (1 - Y) * K)\n    };\n};\nconst rgbToCmyk = (R, G, B) => {\n    R /= BASE_255;\n    G /= BASE_255;\n    B /= BASE_255;\n    const K = 1 - Math.max(R, G, B);\n    const K1 = 1 - K;\n    const C = K1 && (K1 - R) / K1;\n    const M = K1 && (K1 - G) / K1;\n    const Y = K1 && (K1 - B) / K1;\n    return {\n        C: round(C * 100),\n        M: round(M * 100),\n        Y: round(Y * 100),\n        K: round(K * 100)\n    };\n};\nconst rgbToRyb = (R, G, B) => {\n    const Iw = Math.min(R, G, B);\n    const Ib = Math.min(BASE_255 - R, BASE_255 - G, BASE_255 - B);\n    const rRgb = R - Iw;\n    const gRgb = G - Iw;\n    const bRgb = B - Iw;\n    const minRg = Math.min(rRgb, gRgb);\n    const rRyb = rRgb - minRg;\n    const yRyb = (gRgb + minRg) / 2;\n    const bRyb = (bRgb + gRgb - minRg) / 2;\n    const n = Math.max(rRyb, yRyb, bRyb) / Math.max(rRgb, gRgb, bRgb);\n    const N = isNaN(n) || n === Infinity || n <= 0 ? 1 : n;\n    return {\n        R: rRyb / N + Ib,\n        Y: yRyb / N + Ib,\n        B: bRyb / N + Ib\n    };\n};\nconst rybToRgb = (R, Y, B) => {\n    const Iw = Math.min(R, Y, B);\n    const Ib = Math.min(BASE_255 - R, BASE_255 - Y, BASE_255 - B);\n    const rRyb = R - Iw;\n    const yRyb = Y - Iw;\n    const bRyb = B - Iw;\n    const minYb = Math.min(yRyb, bRyb);\n    const rRgb = rRyb + yRyb - minYb;\n    const gRgb = yRyb + minYb;\n    const bRgb = 2 * (bRyb - minYb);\n    const n = Math.max(rRgb, gRgb, bRgb) / Math.max(rRyb, yRyb, bRyb);\n    const N = isNaN(n) || n === Infinity || n <= 0 ? 1 : n;\n    return {\n        R: rRgb / N + Ib,\n        G: gRgb / N + Ib,\n        B: bRgb / N + Ib\n    };\n};\nconst hueRyb = (hue, toRyb) => {\n    if (hue < 0)\n        hue += 360;\n    if (hue > 360)\n        hue -= 360;\n    if (hue === 360 || hue === 0)\n        return hue;\n    const map1 = [\n        [0, 120],\n        [120, 180],\n        [180, 240],\n        [240, 360]\n    ];\n    const map2 = [\n        [0, 60],\n        [60, 120],\n        [120, 240],\n        [240, 360]\n    ];\n    const from = toRyb ? map1 : map2;\n    const to = toRyb ? map2 : map1;\n    let A = 0;\n    let B = 0;\n    let C = 0;\n    let D = 0;\n    from.find((arr, index) => {\n        if (hue >= arr[0] && hue < arr[1]) {\n            A = arr[0];\n            B = arr[1];\n            C = to[index][0];\n            D = to[index][1];\n            return true;\n        }\n        return false;\n    });\n    return C + (hue - A) * ((D - C) / (B - A));\n};\n\n;// ./src/parsers/baseClasses/_RgbClass.ts\nclass RgbClass {\n    get rgb() {\n        return this._rgb;\n    }\n}\n\n;// ./src/parsers/_HEXStringParser.ts\n\n\n\nclass HEXStringParser extends RgbClass {\n    constructor(colorString) {\n        super();\n        const match = colorString.match(COLORREGS.HEX);\n        const groups = match.groups;\n        this._r = groups.r ?? groups.rr;\n        this._g = groups.g ?? groups.gg;\n        this._b = groups.b ?? groups.bb;\n        this._a = groups.a ?? groups.aa;\n        const rgb = {\n            R: getDEC(this._r),\n            G: getDEC(this._g),\n            B: getDEC(this._b)\n        };\n        if (this._a !== undefined) {\n            rgb.A = getDEC(this._a) / BASE_255;\n        }\n        this._rgb = rgb;\n    }\n}\n\n;// ./src/parsers/_CalcParser.ts\n\nconst MAX_STACK = 100;\nclass CalcParser {\n    constructor(colorIndex, calc, vars) {\n        this._operations = new Map([\n            [CALC.DIVISION, this._division],\n            [CALC.MULTIPLICATION, this._multiplication],\n            [CALC.SUM, this._sum],\n            [CALC.REST, this._rest]\n        ]);\n        this._colorIndex = colorIndex;\n        let calcString = calc;\n        let stack = 0;\n        if (!Number.isNaN(+calc)) {\n            this._result = +calc;\n        }\n        else if (calc in vars) {\n            this._result = vars[calc];\n        }\n        else if (CALC.REGEXP.test(calcString)) {\n            CALC.REGEXP.lastIndex = 0;\n            this._result = this._getCalcValue(calcString, vars);\n        }\n        else {\n            while (CALC.SCOPED.test(calcString) && stack < MAX_STACK) {\n                CALC.SCOPED.lastIndex = 0;\n                calcString = calcString.replace(CALC.SCOPED, (__match, operation) => {\n                    return this._calculate(operation, vars).toString();\n                });\n                if (CALC.REGEXP.test(calcString)) {\n                    CALC.REGEXP.lastIndex = 0;\n                    break;\n                }\n                stack++;\n            }\n            this._result = this._getCalcValue(calcString, vars);\n        }\n    }\n    _division(left, right) {\n        return left / right;\n    }\n    _multiplication(left, right) {\n        return left * right;\n    }\n    _sum(left, right) {\n        return left + right;\n    }\n    _rest(left, right) {\n        return left - right;\n    }\n    _getCalcValue(calc, vars) {\n        const match = calc.match(CALC.REGEXP);\n        const operation = match.groups.operation;\n        const value = this._calculate(operation, vars);\n        if (Number.isNaN(value)) {\n            throw new Error(`Invalid value for ${this._colorIndex}. ${operation} ${ERRORS.NOT_A_VALID_RELATIVE_COLOR}`);\n        }\n        return value;\n    }\n    _calculate(operation, vars) {\n        this._operations.forEach((method, regExp) => {\n            let stack = 0;\n            while (regExp.test(operation) && stack < MAX_STACK) {\n                operation = operation.replace(regExp, (__match, left, right) => {\n                    return method(vars[left] ?? +left, vars[right] ?? +right).toString();\n                });\n                stack++;\n            }\n        });\n        return +operation;\n    }\n    get result() {\n        return this._result;\n    }\n}\n\n;// ./src/parsers/baseClasses/_AlphaBaseClass.ts\n\n\nclass AlphaBaseClass extends RgbClass {\n    get hasPercentageAlpha() {\n        return PCENT.test(this._a);\n    }\n}\n\n;// ./src/parsers/_RGBStringParser.ts\n\n\n\n\nclass RGBStringParser extends AlphaBaseClass {\n    constructor(colorString, getRGBObject) {\n        super();\n        const match = colorString.match(COLORREGS.RGB);\n        const groups = match.groups;\n        const { r_legacy, g_legacy, b_legacy, a_legacy, r, g, b, a, from, relative_r, relative_g, relative_b, relative_a } = groups;\n        if (from) {\n            const fromRGB = getRGBObject(from);\n            const fromRGBVars = {\n                r: fromRGB.R,\n                g: fromRGB.G,\n                b: fromRGB.B,\n                alpha: fromRGB.A ?? 1\n            };\n            const R = new CalcParser('r', relative_r, fromRGBVars).result;\n            const G = new CalcParser('g', relative_g, fromRGBVars).result;\n            const B = new CalcParser('b', relative_b, fromRGBVars).result;\n            const rgb = {\n                R: Math.min(R, BASE_255),\n                G: Math.min(G, BASE_255),\n                B: Math.min(B, BASE_255)\n            };\n            if (relative_a) {\n                const A = new CalcParser('alpha', relative_a, fromRGBVars).result;\n                rgb.A = Math.min(A, 1);\n            }\n            this._rgb = rgb;\n        }\n        else {\n            this._r = r_legacy ?? r;\n            this._g = g_legacy ?? g;\n            this._b = b_legacy ?? b;\n            this._a = a_legacy ?? a;\n            const rgb = {\n                R: Math.min(getBase255Number(this._r), BASE_255),\n                G: Math.min(getBase255Number(this._g), BASE_255),\n                B: Math.min(getBase255Number(this._b), BASE_255)\n            };\n            if (this._a !== undefined) {\n                rgb.A = normalizeAlpha(this._a);\n            }\n            this._rgb = rgb;\n        }\n    }\n    get hasPercentageValues() {\n        return (PCENT.test(this._r) &&\n            PCENT.test(this._g) &&\n            PCENT.test(this._b));\n    }\n    static test(colorString) {\n        return COLORREGS.RGB.test(colorString);\n    }\n}\n\n;// ./src/parsers/baseClasses/_HueBaseClass.ts\n\n\n\nclass HueBaseClass extends AlphaBaseClass {\n    get angleUnit() {\n        if (this._h) {\n            const angleUnitMatch = this._h.match(HSL_HUE);\n            const angleUnit = angleUnitMatch.groups.units;\n            return angleUnit === ''\n                ? AnglesUnitEnum.NONE\n                : angleUnit;\n        }\n        return AnglesUnitEnum.NONE;\n    }\n}\n\n;// ./src/parsers/_HSLStringParser.ts\n\n\n\n\n\nclass HSLStringParser extends HueBaseClass {\n    constructor(colorString, getRGBObject) {\n        super();\n        const match = colorString.match(COLORREGS.HSL);\n        const groups = match.groups;\n        const { h_legacy, s_legacy, l_legacy, a_legacy, h, s, l, a, from, relative_h, relative_s, relative_l, relative_a } = groups;\n        if (from) {\n            const fromRGB = getRGBObject(from);\n            const fromHSL = rgbToHsl(fromRGB.R, fromRGB.G, fromRGB.B, fromRGB.A);\n            const fromHSLVars = {\n                h: fromHSL.H,\n                s: fromHSL.S,\n                l: fromHSL.L,\n                alpha: fromHSL.A\n            };\n            const H = new CalcParser('h', relative_h, fromHSLVars).result;\n            const S = new CalcParser('s', relative_s, fromHSLVars).result;\n            const L = new CalcParser('l', relative_l, fromHSLVars).result;\n            const rgb = hslToRgb(minmax(H, 0, MAX_HUE), minmax(S, 0, MAX_PCENT), minmax(L, 0, MAX_PCENT));\n            if (relative_a) {\n                const A = new CalcParser('alpha', relative_a, fromHSLVars).result;\n                rgb.A = minmax(A, 0, MAX_ALPHA);\n            }\n            this._rgb = rgb;\n        }\n        else {\n            this._h = h_legacy ?? h;\n            this._s = s_legacy ?? s;\n            this._l = l_legacy ?? l;\n            this._a = a_legacy ?? a;\n            const rgb = hslToRgb(normalizeHue(this._h), percent(this._s), percent(this._l));\n            if (this._a !== undefined) {\n                rgb.A = normalizeAlpha(this._a);\n            }\n            this._rgb = rgb;\n        }\n    }\n    static test(colorString) {\n        return COLORREGS.HSL.test(colorString);\n    }\n}\n\n;// ./src/parsers/_HWBStringParser.ts\n\n\n\n\n\nclass HWBStringParser extends HueBaseClass {\n    constructor(colorString, getRGBObject) {\n        super();\n        const match = colorString.match(COLORREGS.HWB);\n        const groups = match.groups;\n        const { h, w, b, a, from, relative_h, relative_w, relative_b, relative_a } = groups;\n        if (from) {\n            const fromRGB = getRGBObject(from);\n            const fromHWB = rgbToHwb(fromRGB.R, fromRGB.G, fromRGB.B, fromRGB.A);\n            const fromHWBVars = {\n                h: fromHWB.H,\n                w: fromHWB.W,\n                b: fromHWB.B,\n                alpha: fromHWB.A\n            };\n            const H = new CalcParser('h', relative_h, fromHWBVars).result;\n            const W = new CalcParser('w', relative_w, fromHWBVars).result;\n            const B = new CalcParser('b', relative_b, fromHWBVars).result;\n            const rgb = hwbToRgb(minmax(H, 0, MAX_HUE), minmax(W, 0, MAX_PCENT), minmax(B, 0, MAX_PCENT));\n            if (relative_a) {\n                const A = new CalcParser('alpha', relative_a, fromHWBVars).result;\n                rgb.A = minmax(A, 0, MAX_ALPHA);\n            }\n            this._rgb = rgb;\n        }\n        else {\n            this._h = h;\n            this._w = w;\n            this._b = b;\n            this._a = a;\n            const rgb = hwbToRgb(normalizeHue(this._h), percent(this._w), percent(this._b));\n            if (this._a !== undefined) {\n                rgb.A = normalizeAlpha(this._a);\n            }\n            this._rgb = rgb;\n        }\n    }\n    static test(colorString) {\n        return COLORREGS.HWB.test(colorString);\n    }\n}\n\n;// ./src/parsers/_CIELabStringParser.ts\n\n\n\n\n\nclass CIELabStringParser extends AlphaBaseClass {\n    constructor(colorString, getRGBObject) {\n        super();\n        const match = colorString.match(COLORREGS.CIELab);\n        const groups = match.groups;\n        const { L, a, b, A, from, relative_L, relative_a, relative_b, relative_A } = groups;\n        if (from) {\n            const fromRGB = getRGBObject(from);\n            const fromLab = rgbToLab(fromRGB.R, fromRGB.G, fromRGB.B);\n            const fromLabVars = {\n                l: fromLab.L,\n                a: fromLab.a,\n                b: fromLab.b,\n                alpha: fromRGB.A ?? 1\n            };\n            const L = new CalcParser('l', relative_L, fromLabVars).result;\n            const a = new CalcParser('a', relative_a, fromLabVars).result;\n            const b = new CalcParser('b', relative_b, fromLabVars).result;\n            const rgb = labToRgb(minmax(L, 0, MAX_PCENT), minmax(a, -MAX_LAB, MAX_LAB), minmax(b, -MAX_LAB, MAX_LAB));\n            if (relative_A) {\n                const A = new CalcParser('alpha', relative_A, fromLabVars).result;\n                rgb.A = minmax(A, 0, MAX_ALPHA);\n            }\n            this._rgb = rgb;\n        }\n        else {\n            this._L = L;\n            this._A = a;\n            this._B = b;\n            this._a = A;\n            const rgb = labToRgb(percent(this._L), getBase125Number(this._A), getBase125Number(this._B));\n            if (this._a !== undefined) {\n                rgb.A = normalizeAlpha(this._a);\n            }\n            this._rgb = rgb;\n        }\n    }\n    get hasPercentageValues() {\n        return (PCENT.test(this._L) &&\n            PCENT.test(this._A) &&\n            PCENT.test(this._B));\n    }\n    static test(colorString) {\n        return COLORREGS.CIELab.test(colorString);\n    }\n}\n\n;// ./src/parsers/_LCHStringParser.ts\n\n\n\n\n\nclass LCHStringParser extends HueBaseClass {\n    constructor(colorString, getRGBObject) {\n        super();\n        const match = colorString.match(COLORREGS.LCH);\n        const groups = match.groups;\n        const { l, c, h, a, from, relative_l, relative_c, relative_h, relative_a } = groups;\n        if (from) {\n            const fromRGB = getRGBObject(from);\n            const fromLCH = rgbToLch(fromRGB.R, fromRGB.G, fromRGB.B);\n            const fromLCHVars = {\n                l: fromLCH.L,\n                c: fromLCH.C,\n                h: fromLCH.H,\n                alpha: fromRGB.A ?? 1\n            };\n            const L = new CalcParser('l', relative_l, fromLCHVars).result;\n            const C = new CalcParser('c', relative_c, fromLCHVars).result;\n            const H = new CalcParser('h', relative_h, fromLCHVars).result;\n            const rgb = lchToRgb(minmax(L, 0, MAX_PCENT), minmax(C, -MAX_LCH_C, MAX_LCH_C), normalizeHue(H));\n            if (relative_a) {\n                const A = new CalcParser('alpha', relative_a, fromLCHVars).result;\n                rgb.A = minmax(A, 0, MAX_ALPHA);\n            }\n            this._rgb = rgb;\n        }\n        else {\n            this._l = l;\n            this._c = c;\n            this._h = h;\n            this._a = a;\n            const rgb = lchToRgb(percent(this._l), getBase150Number(this._c), normalizeHue(this._h));\n            if (this._a !== undefined) {\n                rgb.A = normalizeAlpha(this._a);\n            }\n            this._rgb = rgb;\n        }\n    }\n    get hasPercentageValues() {\n        return (PCENT.test(this._l) &&\n            PCENT.test(this._c));\n    }\n    static test(colorString) {\n        return COLORREGS.LCH.test(colorString);\n    }\n}\n\n;// ./src/parsers/_CMYKStringParser.ts\n\n\n\n\nclass CMYKStringParser extends AlphaBaseClass {\n    constructor(colorString) {\n        super();\n        const match = colorString.match(COLORREGS.CMYK);\n        const groups = match.groups;\n        this._c = groups.c_legacy ?? groups.c;\n        this._m = groups.m_legacy ?? groups.m;\n        this._y = groups.y_legacy ?? groups.y;\n        this._k = groups.k_legacy ?? groups.k;\n        this._a = groups.a_legacy ?? groups.a;\n        const rgb = cmykToRgb(getCMYKNumber(this._c), getCMYKNumber(this._m), getCMYKNumber(this._y), getCMYKNumber(this._k));\n        if (this._a !== undefined) {\n            rgb.A = normalizeAlpha(this._a);\n        }\n        this._rgb = rgb;\n    }\n    get hasPercentageValues() {\n        return (PCENT.test(this._c) &&\n            PCENT.test(this._m) &&\n            PCENT.test(this._y) &&\n            PCENT.test(this._k));\n    }\n    static test(colorString) {\n        return COLORREGS.CMYK.test(colorString);\n    }\n}\n\n;// ./src/parsers/index.ts\n\n\n\n\n\n\n\n\n;// ./src/color/extractors.ts\n\n\n\n\n\nconst getColorModelFromString = (color) => {\n    let model;\n    Object.keys(ColorModel).some((p) => {\n        const reg = COLORREGS[p];\n        if (reg.test(color)) {\n            model = p;\n            return true;\n        }\n    });\n    if (!model &&\n        !!~COLOR_KEYS.indexOf(color)) {\n        model = ColorModel.HEX;\n    }\n    if (!model) {\n        throw new Error(ERRORS.NOT_ACCEPTED_STRING_INPUT);\n    }\n    return model;\n};\nconst getColorModelFromObject = (color) => {\n    let model;\n    let invalid = false;\n    const props = getOrderedArrayString(Object.keys(color));\n    if (VALID_COLOR_OBJECTS[props]) {\n        model = VALID_COLOR_OBJECTS[props];\n    }\n    if (model && model === ColorModel.RGB) {\n        const hasInvalidHex = Object.entries(color).some((item) => {\n            return !HEX.test(`${item[1]}`);\n        });\n        const hasInvalidRegb = Object.entries(color).some((item) => {\n            return !(PCENT.test(`${item[1]}`) ||\n                (!HEX.test(`${item[1]}`) &&\n                    !isNaN(+item[1]) &&\n                    +item[1] <= BASE_255));\n        });\n        if (hasInvalidHex && hasInvalidRegb) {\n            invalid = true;\n        }\n        if (!hasInvalidHex) {\n            model = ColorModel.HEX;\n        }\n    }\n    if (!model || invalid) {\n        throw new Error(ERRORS.NOT_ACCEPTED_OBJECT_INPUT);\n    }\n    return model;\n};\nconst getColorModel = (color) => typeof color === 'string'\n    ? getColorModelFromString(color)\n    : getColorModelFromObject(color);\nconst getRGBObjectFromString = {\n    [ColorModel.HEX](color) {\n        const colorStr = !~COLOR_KEYS.indexOf(color)\n            ? color\n            : ColorKeywords[color];\n        return new HEXStringParser(colorStr).rgb;\n    },\n    [ColorModel.RGB](color) {\n        return new RGBStringParser(color, getRGBObject).rgb;\n    },\n    [ColorModel.HSL](color) {\n        return new HSLStringParser(color, getRGBObject).rgb;\n    },\n    [ColorModel.HWB](color) {\n        return new HWBStringParser(color, getRGBObject).rgb;\n    },\n    [ColorModel.CIELab](color) {\n        return new CIELabStringParser(color, getRGBObject).rgb;\n    },\n    [ColorModel.LCH](color) {\n        return new LCHStringParser(color, getRGBObject).rgb;\n    },\n    [ColorModel.CMYK](color) {\n        return new CMYKStringParser(color).rgb;\n    }\n};\nconst getRGBObjectFromObject = {\n    [ColorModel.HEX](color) {\n        const object = {\n            R: getBase255Number(`${color.R}`),\n            G: getBase255Number(`${color.G}`),\n            B: getBase255Number(`${color.B}`)\n        };\n        if (hasProp(color, 'A')) {\n            object.A = Math.min(getBase255Number(`${color.A}`, true), 1);\n        }\n        return object;\n    },\n    [ColorModel.RGB](color) {\n        return this.HEX(color);\n    },\n    [ColorModel.HSL](color) {\n        const S = percent(`${color.S}`);\n        const L = percent(`${color.L}`);\n        const RGB = hslToRgb(normalizeHue(color.H), S, L);\n        if (hasProp(color, 'A')) {\n            RGB.A = normalizeAlpha(color.A);\n        }\n        return RGB;\n    },\n    [ColorModel.HWB](color) {\n        const W = percent(`${color.W}`);\n        const B = percent(`${color.B}`);\n        const RGB = hwbToRgb(normalizeHue(color.H), W, B);\n        if (hasProp(color, 'A')) {\n            RGB.A = normalizeAlpha(color.A);\n        }\n        return RGB;\n    },\n    [ColorModel.CIELab](color) {\n        const L = percent(`${color.L}`);\n        const a = getBase125Number(`${color.a}`);\n        const b = getBase125Number(`${color.b}`);\n        const RGB = labToRgb(L, a, b);\n        if (hasProp(color, 'A')) {\n            RGB.A = normalizeAlpha(color.A);\n        }\n        return RGB;\n    },\n    [ColorModel.LCH](color) {\n        const L = percent(`${color.L}`);\n        const C = getBase150Number(`${color.C}`);\n        const H = normalizeHue(`${color.H}`);\n        const RGB = lchToRgb(L, C, H);\n        if (hasProp(color, 'A')) {\n            RGB.A = normalizeAlpha(color.A);\n        }\n        return RGB;\n    },\n    [ColorModel.CMYK](color) {\n        const C = getCMYKNumber(`${color.C}`);\n        const M = getCMYKNumber(`${color.M}`);\n        const Y = getCMYKNumber(`${color.Y}`);\n        const K = getCMYKNumber(`${color.K}`);\n        const RGB = cmykToRgb(C, M, Y, K);\n        if (hasProp(color, 'A')) {\n            RGB.A = normalizeAlpha(color.A);\n        }\n        return RGB;\n    }\n};\nconst getRGBObject = (color, model = getColorModel(color)) => {\n    return typeof color === 'string'\n        ? getRGBObjectFromString[model](color)\n        : getRGBObjectFromObject[model](color);\n};\nconst getOptionsFromColorInput = (options, ...colors) => {\n    const cssColors = [];\n    const anglesUnits = [];\n    const rgbColors = [];\n    const labColors = [];\n    const lchColors = [];\n    const cmykColors = [];\n    const alphaValues = [];\n    const anglesUnitValues = Object.values(AnglesUnitEnum);\n    const colorUnitValues = Object.values(ColorUnitEnum);\n    const cmykFunctionValues = Object.values(CMYKFunctionEnum);\n    const matchOptions = {\n        legacyCSS: 0,\n        spacesAfterCommas: 0,\n        cmykFunction: 0\n    };\n    for (const color of colors) {\n        if (typeof color === 'string') {\n            cssColors.push(color);\n            if (color.includes(',')) {\n                matchOptions.legacyCSS++;\n                const commasWithNextCharacter = color.match(COMMAS_AND_NEXT_CHARS);\n                if (new Set(commasWithNextCharacter).size === 1 &&\n                    SPACES.test(commasWithNextCharacter[0].slice(1))) {\n                    matchOptions.spacesAfterCommas++;\n                }\n            }\n            if (HSLStringParser.test(color)) {\n                const parser = new HSLStringParser(color, getRGBObject);\n                anglesUnits.push(parser.angleUnit);\n                alphaValues.push(parser.hasPercentageAlpha);\n                continue;\n            }\n            if (HWBStringParser.test(color)) {\n                const parser = new HWBStringParser(color, getRGBObject);\n                anglesUnits.push(parser.angleUnit);\n                alphaValues.push(parser.hasPercentageAlpha);\n                continue;\n            }\n            if (RGBStringParser.test(color)) {\n                const parser = new RGBStringParser(color, getRGBObject);\n                rgbColors.push(parser.hasPercentageValues);\n                alphaValues.push(parser.hasPercentageAlpha);\n                continue;\n            }\n            if (CIELabStringParser.test(color)) {\n                const parser = new CIELabStringParser(color, getRGBObject);\n                labColors.push(parser.hasPercentageValues);\n                alphaValues.push(parser.hasPercentageAlpha);\n                continue;\n            }\n            if (LCHStringParser.test(color)) {\n                const parser = new LCHStringParser(color, getRGBObject);\n                anglesUnits.push(parser.angleUnit);\n                lchColors.push(parser.hasPercentageValues);\n                alphaValues.push(parser.hasPercentageAlpha);\n                continue;\n            }\n            if (CMYKStringParser.test(color)) {\n                const parser = new CMYKStringParser(color);\n                cmykColors.push(parser.hasPercentageValues);\n                if (color.startsWith('cmyk')) {\n                    matchOptions.cmykFunction++;\n                }\n                alphaValues.push(parser.hasPercentageAlpha);\n            }\n        }\n    }\n    return {\n        decimals: typeof options.decimals === TypeOf.NUMBER\n            ? options.decimals\n            : DEFAULT_OPTIONS.decimals,\n        legacyCSS: typeof options.legacyCSS === TypeOf.BOOLEAN\n            ? options.legacyCSS\n            : Boolean(cssColors.length &&\n                matchOptions.legacyCSS === cssColors.length) || DEFAULT_OPTIONS.legacyCSS,\n        spacesAfterCommas: typeof options.spacesAfterCommas === TypeOf.BOOLEAN\n            ? options.spacesAfterCommas\n            : Boolean(cssColors.length &&\n                matchOptions.spacesAfterCommas === cssColors.length) || DEFAULT_OPTIONS.spacesAfterCommas,\n        anglesUnit: options.anglesUnit && anglesUnitValues.includes(options.anglesUnit)\n            ? options.anglesUnit\n            : (new Set(anglesUnits).size === 1\n                ? anglesUnits[0]\n                : DEFAULT_OPTIONS.anglesUnit),\n        rgbUnit: options.rgbUnit && colorUnitValues.includes(options.rgbUnit)\n            ? options.rgbUnit\n            : (new Set(rgbColors).size === 1 && rgbColors[0]\n                ? ColorUnitEnum.PERCENT\n                : DEFAULT_OPTIONS.rgbUnit),\n        labUnit: options.labUnit && colorUnitValues.includes(options.labUnit)\n            ? options.labUnit\n            : (new Set(labColors).size === 1 && labColors[0]\n                ? ColorUnitEnum.PERCENT\n                : DEFAULT_OPTIONS.labUnit),\n        lchUnit: options.lchUnit && colorUnitValues.includes(options.lchUnit)\n            ? options.lchUnit\n            : (new Set(lchColors).size === 1 && lchColors[0]\n                ? ColorUnitEnum.PERCENT\n                : DEFAULT_OPTIONS.lchUnit),\n        cmykUnit: options.cmykUnit && colorUnitValues.includes(options.cmykUnit)\n            ? options.cmykUnit\n            : (new Set(cmykColors).size === 1 && !cmykColors[0]\n                ? ColorUnitEnum.NONE\n                : DEFAULT_OPTIONS.cmykUnit),\n        alphaUnit: options.alphaUnit && colorUnitValues.includes(options.alphaUnit)\n            ? options.alphaUnit\n            : (new Set(alphaValues).size === 1 && alphaValues[0]\n                ? ColorUnitEnum.PERCENT\n                : DEFAULT_OPTIONS.alphaUnit),\n        cmykFunction: options.cmykFunction && cmykFunctionValues.includes(options.cmykFunction)\n            ? options.cmykFunction\n            : (cmykColors.length && cmykColors.length === matchOptions.cmykFunction\n                ? CMYKFunctionEnum.CMYK\n                : DEFAULT_OPTIONS.cmykFunction)\n    };\n};\n\n;// ./src/color/rounders.ts\n\nconst roundHSLObject = (color, decimals) => {\n    return {\n        H: round(color.H, decimals),\n        S: round(color.S, decimals),\n        L: round(color.L, decimals)\n    };\n};\nconst roundHWBObject = (color, decimals) => {\n    return {\n        H: round(color.H, decimals),\n        W: round(color.W, decimals),\n        B: round(color.B, decimals)\n    };\n};\nconst roundCIELabObject = (color, decimals) => {\n    return {\n        L: round(color.L, decimals),\n        a: round(color.a, decimals),\n        b: round(color.b, decimals)\n    };\n};\nconst roundLCHObject = (color, decimals) => {\n    return {\n        L: round(color.L, decimals),\n        C: round(color.C, decimals),\n        H: round(color.H, decimals)\n    };\n};\nconst roundCMYKObject = (color, decimals) => {\n    return {\n        C: round(color.C, decimals),\n        M: round(color.M, decimals),\n        Y: round(color.Y, decimals),\n        K: round(color.K, decimals)\n    };\n};\n\n;// ./src/color/css.ts\n\n\n\nconst getComma = (withSpace) => withSpace\n    ? ', '\n    : ',';\nconst prepareColorForCss = (color, transformer) => {\n    const props = getOrderedArrayString(Object.keys(color));\n    const model = VALID_COLOR_OBJECTS[props];\n    const keys = COLOR_PROPS[model];\n    return keys.reduce((result, key, index) => {\n        const value = color[key];\n        if (typeof value !== 'undefined') {\n            result.push(transformer(value, index));\n        }\n        return result;\n    }, []);\n};\nconst getResultFromTemplate = (template, vars) => {\n    return template.replace(TEMPLATE_VAR, (__match, indexStr) => {\n        const index = +indexStr - 1;\n        return `${vars[index]}`;\n    });\n};\nconst getAlpha = (value, options, ignoreLegacy = false) => {\n    const { alphaUnit, legacyCSS, decimals } = options;\n    if (alphaUnit === ColorUnitEnum.PERCENT &&\n        (!legacyCSS ||\n            ignoreLegacy)) {\n        return `${round(value * 100, decimals)}%`;\n    }\n    return round(value, decimals);\n};\nconst buildHueTransformer = (options) => {\n    const { anglesUnit, decimals } = options;\n    return (value, index) => {\n        if (index === 0 &&\n            anglesUnit !== AnglesUnitEnum.NONE) {\n            const translated = round(translateDegrees(value, anglesUnit), decimals);\n            return `${translated}${anglesUnit}`;\n        }\n        return index === 3\n            ? getAlpha(value, options)\n            : round(value, decimals);\n    };\n};\nconst CSS = {\n    [ColorModel.HEX]: (color) => {\n        const transformer = (value) => toHEX(round(value));\n        const values = prepareColorForCss(color, transformer);\n        const template = values.length === 4\n            ? '#{1}{2}{3}{4}'\n            : '#{1}{2}{3}';\n        return getResultFromTemplate(template, values);\n    },\n    [ColorModel.RGB]: (color, options) => {\n        const { decimals, legacyCSS, spacesAfterCommas, rgbUnit } = options;\n        const comma = getComma(spacesAfterCommas);\n        const transformer = (value, index) => {\n            return rgbUnit === ColorUnitEnum.PERCENT && index < 3\n                ? `${from255NumberToPercent(value, decimals)}%`\n                : (index === 3\n                    ? getAlpha(value, options)\n                    : round(value, decimals));\n        };\n        const values = prepareColorForCss(color, transformer);\n        const template = legacyCSS\n            ? (values.length === 4\n                ? `rgba({1}${comma}{2}${comma}{3}${comma}{4})`\n                : `rgb({1}${comma}{2}${comma}{3})`)\n            : (values.length === 4\n                ? `rgb({1} {2} {3} / {4})`\n                : `rgb({1} {2} {3})`);\n        return getResultFromTemplate(template, values);\n    },\n    [ColorModel.HSL]: (color, options) => {\n        const { legacyCSS, spacesAfterCommas } = options;\n        const comma = getComma(spacesAfterCommas);\n        const transformer = buildHueTransformer(options);\n        const values = prepareColorForCss(color, transformer);\n        const template = legacyCSS\n            ? (values.length === 4\n                ? `hsla({1}${comma}{2}%${comma}{3}%${comma}{4})`\n                : `hsl({1}${comma}{2}%${comma}{3}%)`)\n            : (values.length === 4\n                ? `hsl({1} {2}% {3}% / {4})`\n                : `hsl({1} {2}% {3}%)`);\n        return getResultFromTemplate(template, values);\n    },\n    [ColorModel.HWB]: (color, options) => {\n        const transformer = buildHueTransformer(options);\n        const values = prepareColorForCss(color, transformer);\n        const template = values.length === 4\n            ? `hwb({1} {2}% {3}% / {4})`\n            : `hwb({1} {2}% {3}%)`;\n        return getResultFromTemplate(template, values);\n    },\n    [ColorModel.CIELab]: (color, options) => {\n        const { decimals, labUnit } = options;\n        const transformer = (value, index) => {\n            if (index === 0) {\n                const L = round(percent(value), decimals);\n                return labUnit === ColorUnitEnum.PERCENT\n                    ? `${L}%`\n                    : `${L}`;\n            }\n            if (index < 3) {\n                return labUnit === ColorUnitEnum.PERCENT\n                    ? `${from125NumberToPercent(value, decimals)}%`\n                    : round(value, decimals);\n            }\n            return getAlpha(value, options, true);\n        };\n        const values = prepareColorForCss(color, transformer);\n        const template = values.length === 4\n            ? `lab({1} {2} {3} / {4})`\n            : `lab({1} {2} {3})`;\n        return getResultFromTemplate(template, values);\n    },\n    [ColorModel.LCH]: (color, options) => {\n        const { decimals, lchUnit, anglesUnit } = options;\n        const transformer = (value, index) => {\n            if (index === 0) {\n                const L = round(percent(value), decimals);\n                return lchUnit === ColorUnitEnum.PERCENT\n                    ? `${L}%`\n                    : `${L}`;\n            }\n            if (index === 1) {\n                return lchUnit === ColorUnitEnum.PERCENT\n                    ? `${from150NumberToPercent(value, decimals)}%`\n                    : round(value, decimals);\n            }\n            if (index === 2) {\n                if (anglesUnit !== AnglesUnitEnum.NONE) {\n                    const translated = round(translateDegrees(value, anglesUnit), decimals);\n                    return `${translated}${anglesUnit}`;\n                }\n                return round(value, decimals);\n            }\n            return getAlpha(value, options, true);\n        };\n        const values = prepareColorForCss(color, transformer);\n        const template = values.length === 4\n            ? `lch({1} {2} {3} / {4})`\n            : `lch({1} {2} {3})`;\n        return getResultFromTemplate(template, values);\n    },\n    [ColorModel.CMYK]: (color, options) => {\n        const { decimals, legacyCSS, spacesAfterCommas, cmykUnit, cmykFunction } = options;\n        const comma = getComma(spacesAfterCommas);\n        const transformer = (value, index) => {\n            if (cmykUnit === ColorUnitEnum.PERCENT &&\n                index < 4) {\n                return `${round(value, decimals)}%`;\n            }\n            return index === 4\n                ? getAlpha(value, options)\n                : round(value / 100, decimals);\n        };\n        const values = prepareColorForCss(color, transformer);\n        const template = legacyCSS\n            ? (values.length === 5\n                ? `${cmykFunction}({1}${comma}{2}${comma}{3}${comma}{4}${comma}{5})`\n                : `${cmykFunction}({1}${comma}{2}${comma}{3}${comma}{4})`)\n            : (values.length === 5\n                ? `${cmykFunction}({1} {2} {3} {4} / {5})`\n                : `${cmykFunction}({1} {2} {3} {4})`);\n        return getResultFromTemplate(template, values);\n    }\n};\n\n;// ./src/color/utils.ts\n\n\n\n\n\n\nconst harmony = (color, angles, mode) => angles.reduce((arr, num) => ([\n    ...arr,\n    {\n        ...color,\n        H: mode === Mix.ADDITIVE\n            ? normalizeHue(color.H + num)\n            : normalizeHue(hueRyb(hueRyb(color.H, false) + num, true))\n    }\n]), [{ ...color }]);\nconst analogous = (color, mode) => harmony(color, [30, -30], mode);\nconst complementary = (color, mode) => harmony(color, [180], mode);\nconst splitComplementary = (color, mode) => harmony(color, [150, -150], mode);\nconst triadic = (color, mode) => harmony(color, [120, -120], mode);\nconst tetradic = (color, mode) => harmony(color, [60, -120, 180], mode);\nconst square = (color, mode) => harmony(color, [90, -90, 180], mode);\nconst translateColor = {\n    [ColorModel.HEX](color) {\n        return {\n            R: getHEX(color.R),\n            G: getHEX(color.G),\n            B: getHEX(color.B)\n        };\n    },\n    HEXA(color) {\n        const RGB = translateColor.HEX(color);\n        RGB.A = hasProp(color, 'A')\n            ? getHEX(color.A * BASE_255)\n            : '0xFF';\n        return RGB;\n    },\n    [ColorModel.RGB](color, decimals) {\n        const RGB = roundRGBObject(color, decimals);\n        if (hasProp(RGB, 'A')) {\n            delete RGB.A;\n        }\n        return RGB;\n    },\n    RGBA(color, decimals) {\n        const RGB = translateColor.RGB(color, decimals);\n        RGB.A = hasProp(color, 'A')\n            ? round(color.A)\n            : 1;\n        return RGB;\n    },\n    [ColorModel.HSL](color, decimals) {\n        const HSL = rgbToHsl(color.R, color.G, color.B);\n        delete HSL.A;\n        return roundHSLObject(HSL, decimals);\n    },\n    HSLA(color, decimals) {\n        const HSL = translateColor.HSL(color, decimals);\n        HSL.A = hasProp(color, 'A')\n            ? round(color.A, decimals)\n            : 1;\n        return HSL;\n    },\n    [ColorModel.HWB](color, decimals) {\n        const HWB = rgbToHwb(color.R, color.G, color.B);\n        delete HWB.A;\n        return roundHWBObject(HWB, decimals);\n    },\n    HWBA(color, decimals) {\n        const HWB = translateColor.HWB(color, decimals);\n        HWB.A = hasProp(color, 'A')\n            ? round(color.A, decimals)\n            : 1;\n        return HWB;\n    },\n    [ColorModel.CIELab](color, decimals) {\n        const Lab = rgbToLab(color.R, color.G, color.B);\n        return roundCIELabObject(Lab, decimals);\n    },\n    CIELabA(color, decimals) {\n        const Lab = translateColor.CIELab(color, decimals);\n        Lab.A = hasProp(color, 'A')\n            ? round(color.A, decimals)\n            : 1;\n        return Lab;\n    },\n    [ColorModel.LCH](color, decimals) {\n        const lch = rgbToLch(color.R, color.G, color.B);\n        return roundLCHObject(lch, decimals);\n    },\n    LCHA(color, decimals) {\n        const lch = translateColor.LCH(color, decimals);\n        lch.A = hasProp(color, 'A')\n            ? round(color.A, decimals)\n            : 1;\n        return lch;\n    },\n    [ColorModel.CMYK](color, decimals) {\n        return roundCMYKObject(rgbToCmyk(color.R, color.G, color.B), decimals);\n    },\n    CMYKA(color, decimals) {\n        const CMYK = translateColor.CMYK(color, decimals);\n        CMYK.A = hasProp(color, 'A')\n            ? round(color.A, decimals)\n            : 1;\n        return CMYK;\n    }\n};\nconst blend = (from, to, steps) => {\n    const div = steps - 1;\n    const diffR = (to.R - from.R) / div;\n    const diffG = (to.G - from.G) / div;\n    const diffB = (to.B - from.B) / div;\n    const fromA = normalizeAlpha(from.A);\n    const toA = normalizeAlpha(to.A);\n    const diffA = (toA - fromA) / div;\n    return Array(steps).fill(null).map((__n, i) => {\n        if (i === 0) {\n            return from;\n        }\n        if (i === div) {\n            return to;\n        }\n        return {\n            R: round(from.R + diffR * i),\n            G: round(from.G + diffG * i),\n            B: round(from.B + diffB * i),\n            A: round(fromA + diffA * i)\n        };\n    });\n};\nconst getColorMixture = (color, steps, shades, options) => {\n    const model = getColorModel(color);\n    const isCSS = typeof color === 'string';\n    const RGB = getRGBObject(color, model);\n    const hasAlpha = ((typeof color === 'string' && hasProp(RGB, 'A')) ||\n        (typeof color !== 'string' &&\n            hasProp(color, 'A')));\n    const HSL = rgbToHsl(RGB.R, RGB.G, RGB.B, RGB.A);\n    if (!hasAlpha)\n        delete HSL.A;\n    const increment = shades\n        ? HSL.L / (steps + 1)\n        : (100 - HSL.L) / (steps + 1);\n    const hslMap = Array(steps).fill(null).map((__n, i) => ({\n        ...HSL,\n        L: HSL.L + increment * (i + 1) * (1 - +shades * 2)\n    }));\n    switch (model) {\n        case ColorModel.HEX:\n        default:\n            return hslMap.map((HSLColor) => {\n                const RGBColor = hslToRgb(HSLColor.H, HSLColor.S, HSLColor.L);\n                if (hasAlpha)\n                    RGBColor.A = HSLColor.A;\n                return isCSS\n                    ? hasAlpha\n                        ? CSS.HEX({\n                            ...RGBColor,\n                            A: round(RGBColor.A * BASE_255)\n                        })\n                        : CSS.HEX(RGBColor)\n                    : hasAlpha\n                        ? translateColor.HEXA(RGBColor)\n                        : translateColor.HEX(RGBColor);\n            });\n        case ColorModel.RGB:\n            return hslMap.map((HSLColor) => {\n                const RGBColor = hslToRgb(HSLColor.H, HSLColor.S, HSLColor.L);\n                if (hasAlpha)\n                    RGBColor.A = HSLColor.A;\n                return isCSS\n                    ? CSS.RGB(RGBColor, options)\n                    : hasAlpha\n                        ? translateColor.RGBA(RGBColor, options.decimals)\n                        : translateColor.RGB(RGBColor, options.decimals);\n                // removed by dead control flow\n{}\n            });\n        case ColorModel.HSL:\n            return hslMap.map((HSLColor) => {\n                return isCSS\n                    ? CSS.HSL(HSLColor, options)\n                    : hasAlpha\n                        ? translateColor.HSLA({\n                            ...hslToRgb(HSLColor.H, HSLColor.S, HSLColor.L),\n                            A: HSLColor.A\n                        }, options.decimals)\n                        : translateColor.HSL(hslToRgb(HSLColor.H, HSLColor.S, HSLColor.L), options.decimals);\n            });\n        case ColorModel.HWB:\n            return hslMap.map((HSLColor) => {\n                const RGBColor = hslToRgb(HSLColor.H, HSLColor.S, HSLColor.L);\n                if (hasAlpha)\n                    RGBColor.A = HSLColor.A;\n                const hwb = hasAlpha\n                    ? translateColor.HWBA(RGBColor, options.decimals)\n                    : translateColor.HWB(RGBColor, options.decimals);\n                return isCSS\n                    ? CSS.HWB(hwb, options)\n                    : hwb;\n            });\n        case ColorModel.CIELab:\n            return hslMap.map((HSLColor) => {\n                const RGBColor = hslToRgb(HSLColor.H, HSLColor.S, HSLColor.L);\n                if (hasAlpha)\n                    RGBColor.A = HSLColor.A;\n                const lab = hasAlpha\n                    ? translateColor.CIELabA(RGBColor, options.decimals)\n                    : translateColor.CIELab(RGBColor, options.decimals);\n                return isCSS\n                    ? CSS.CIELab(lab, options)\n                    : lab;\n            });\n        case ColorModel.LCH:\n            return hslMap.map((HSLColor) => {\n                const RGBColor = hslToRgb(HSLColor.H, HSLColor.S, HSLColor.L);\n                const LCHColor = rgbToLch(RGBColor.R, RGBColor.G, RGBColor.B);\n                if (hasAlpha)\n                    LCHColor.A = HSLColor.A;\n                return isCSS\n                    ? CSS.LCH(LCHColor, options)\n                    : hasAlpha\n                        ? translateColor.LCHA({\n                            ...RGBColor,\n                            A: HSLColor.A\n                        }, options.decimals)\n                        : translateColor.LCH(RGBColor, options.decimals);\n            });\n    }\n};\nconst colorHarmony = {\n    buildHarmony(color, harmonyFunction, mode, options) {\n        const model = getColorModel(color);\n        const RGB = getRGBObject(color, model);\n        const HSL = rgbToHsl(RGB.R, RGB.G, RGB.B, RGB.A);\n        const hasAlpha = ((typeof color === 'string' && hasProp(RGB, 'A')) ||\n            (typeof color !== 'string' &&\n                hasProp(color, 'A')));\n        const isCSS = typeof color === 'string';\n        switch (model) {\n            case ColorModel.HEX:\n            default:\n                return hasAlpha\n                    ? this.HEXA(roundHSLObject(HSL, 0), harmonyFunction, mode, isCSS)\n                    : this.HEX(roundHSLObject(HSL, 0), harmonyFunction, mode, isCSS);\n            case ColorModel.HSL:\n                return hasAlpha\n                    ? this.HSLA(HSL, harmonyFunction, mode, isCSS, options)\n                    : this.HSL(HSL, harmonyFunction, mode, isCSS, options);\n            case ColorModel.HWB:\n                return hasAlpha\n                    ? this.HWBA(HSL, harmonyFunction, mode, isCSS, options)\n                    : this.HWB(HSL, harmonyFunction, mode, isCSS, options);\n            case ColorModel.RGB:\n                return hasAlpha\n                    ? this.RGBA(HSL, harmonyFunction, mode, isCSS, options)\n                    : this.RGB(HSL, harmonyFunction, mode, isCSS, options);\n            case ColorModel.CIELab:\n                return hasAlpha\n                    ? this.CIELabA(HSL, harmonyFunction, mode, isCSS, options)\n                    : this.CIELab(HSL, harmonyFunction, mode, isCSS, options);\n            case ColorModel.LCH:\n                return hasAlpha\n                    ? this.LCHA(HSL, harmonyFunction, mode, isCSS, options)\n                    : this.LCH(HSL, harmonyFunction, mode, isCSS, options);\n        }\n    },\n    [ColorModel.HEX](color, harmonyFunction, mode, css) {\n        const array = harmonyFunction(color, mode);\n        return array.map((c) => (css\n            ? CSS.HEX(hslToRgb(c.H, c.S, c.L))\n            : translateColor.HEX(hslToRgb(c.H, c.S, c.L))));\n    },\n    HEXA(color, harmonyFunction, mode, css) {\n        const array = harmonyFunction(color, mode);\n        return array.map((c) => (css\n            ? CSS.HEX({\n                ...hslToRgb(c.H, c.S, c.L),\n                A: normalizeAlpha(c.A) * BASE_255\n            })\n            : translateColor.HEXA({\n                ...hslToRgb(c.H, c.S, c.L),\n                A: normalizeAlpha(c.A)\n            })));\n    },\n    [ColorModel.RGB](color, harmonyFunction, mode, css, options) {\n        const array = harmonyFunction(color, mode);\n        return array.map((c) => (css\n            ? CSS.RGB(hslToRgb(c.H, c.S, c.L), options)\n            : translateColor.RGB(hslToRgb(c.H, c.S, c.L), options.decimals)));\n    },\n    RGBA(color, harmonyFunction, mode, css, options) {\n        const array = harmonyFunction(color, mode);\n        return array.map((c) => (css\n            ? CSS.RGB({\n                ...hslToRgb(c.H, c.S, c.L),\n                A: normalizeAlpha(c.A)\n            }, options)\n            : translateColor.RGBA({\n                ...hslToRgb(c.H, c.S, c.L),\n                A: normalizeAlpha(c.A)\n            }, options.decimals)));\n    },\n    [ColorModel.HSL](color, harmonyFunction, mode, css, options) {\n        const array = harmonyFunction(color, mode);\n        return array.map((c) => (css\n            ? CSS.HSL({\n                H: c.H,\n                S: c.S,\n                L: c.L\n            }, options)\n            : translateColor.HSL(hslToRgb(c.H, c.S, c.L), options.decimals)));\n    },\n    HSLA(color, harmonyFunction, mode, css, options) {\n        const array = harmonyFunction(color, mode);\n        return array.map((c) => (css\n            ? CSS.HSL({\n                ...c,\n                A: normalizeAlpha(c.A)\n            }, options)\n            : translateColor.HSLA({\n                ...hslToRgb(c.H, c.S, c.L),\n                A: normalizeAlpha(c.A)\n            }, options.decimals)));\n    },\n    [ColorModel.HWB](color, harmonyFunction, mode, css, options) {\n        const array = harmonyFunction(color, mode);\n        return array.map((c) => {\n            const rgb = hslToRgb(c.H, c.S, c.L);\n            const hwb = rgbToHwb(rgb.R, rgb.G, rgb.B);\n            return css\n                ? CSS.HWB({\n                    H: hwb.H,\n                    W: hwb.W,\n                    B: hwb.B\n                }, options)\n                : translateColor.HWB(rgb, options.decimals);\n        });\n    },\n    HWBA(color, harmonyFunction, mode, css, options) {\n        const array = harmonyFunction(color, mode);\n        return array.map((c) => {\n            const rgb = hslToRgb(c.H, c.S, c.L);\n            const hwb = rgbToHwb(rgb.R, rgb.G, rgb.B);\n            return css\n                ? CSS.HWB({\n                    ...hwb,\n                    A: normalizeAlpha(c.A)\n                }, options)\n                : translateColor.HWBA({\n                    ...rgb,\n                    A: normalizeAlpha(c.A)\n                }, options.decimals);\n        });\n    },\n    [ColorModel.CIELab](color, harmonyFunction, mode, css, options) {\n        const array = harmonyFunction(color, mode);\n        return array.map((c) => {\n            const RGB = hslToRgb(c.H, c.S, c.L);\n            return (css\n                ? CSS.CIELab(rgbToLab(RGB.R, RGB.G, RGB.B), options)\n                : translateColor.CIELab(RGB, options.decimals));\n        });\n    },\n    CIELabA(color, harmonyFunction, mode, css, options) {\n        const array = harmonyFunction(color, mode);\n        return array.map((c) => {\n            const RGB = hslToRgb(c.H, c.S, c.L);\n            return (css\n                ? CSS.CIELab({\n                    ...rgbToLab(RGB.R, RGB.G, RGB.B),\n                    A: normalizeAlpha(c.A)\n                }, options)\n                : translateColor.CIELabA({\n                    ...RGB,\n                    A: normalizeAlpha(c.A)\n                }, options.decimals));\n        });\n    },\n    [ColorModel.LCH](color, harmonyFunction, mode, css, options) {\n        const array = harmonyFunction(color, mode);\n        return array.map((c) => {\n            const RGB = hslToRgb(c.H, c.S, c.L);\n            return (css\n                ? CSS.LCH(rgbToLch(RGB.R, RGB.G, RGB.B), options)\n                : translateColor.LCH(RGB, options.decimals));\n        });\n    },\n    LCHA(color, harmonyFunction, mode, css, options) {\n        const array = harmonyFunction(color, mode);\n        return array.map((c) => {\n            const RGB = hslToRgb(c.H, c.S, c.L);\n            return (css\n                ? CSS.LCH({\n                    ...rgbToLch(RGB.R, RGB.G, RGB.B),\n                    A: normalizeAlpha(c.A)\n                }, options)\n                : translateColor.LCHA({\n                    ...RGB,\n                    A: normalizeAlpha(c.A)\n                }, options.decimals));\n        });\n    }\n};\nconst colorMixer = {\n    mix(colors, mode) {\n        const rgbMap = colors.map((color) => {\n            const model = getColorModel(color);\n            return getRGBObject(color, model);\n        });\n        const rybMap = mode === Mix.SUBTRACTIVE\n            ? rgbMap.map((color) => {\n                const RYB = rgbToRyb(color.R, color.G, color.B);\n                if (hasProp(color, 'A')) {\n                    RYB.A = color.A;\n                }\n                return RYB;\n            })\n            : null;\n        function createMix(items) {\n            const initial = mode === Mix.ADDITIVE\n                ? { R: 0, G: 0, B: 0, A: 0 }\n                : { R: 0, Y: 0, B: 0, A: 0 };\n            return items.reduce((mix, color) => {\n                const colorA = hasProp(color, 'A') ? color.A : 1;\n                const common = {\n                    R: Math.min(mix.R + color.R * colorA, BASE_255),\n                    B: Math.min(mix.B + color.B * colorA, BASE_255),\n                    A: 1 - (1 - colorA) * (1 - mix.A)\n                };\n                const mixGY = 'G' in mix\n                    ? mix.G\n                    : mix.Y;\n                const colorGY = 'G' in color\n                    ? color.G\n                    : color.Y;\n                return {\n                    ...common,\n                    ...(mode === Mix.ADDITIVE\n                        ? { G: Math.min(mixGY + colorGY * colorA, BASE_255) }\n                        : { Y: Math.min(mixGY + colorGY * colorA, BASE_255) })\n                };\n            }, initial);\n        }\n        let mix;\n        if (mode === Mix.ADDITIVE) {\n            mix = createMix(rgbMap);\n        }\n        else {\n            const RYB = createMix(rybMap);\n            mix = rybToRgb(RYB.R, RYB.Y, RYB.B);\n            mix.A = RYB.A;\n        }\n        return {\n            R: round(mix.R),\n            G: round(mix.G),\n            B: round(mix.B),\n            A: minmax(mix.A, 0, 1)\n        };\n    },\n    [ColorModel.HEX](colors, mode, css) {\n        const mix = this.mix(colors, mode);\n        delete mix.A;\n        return (css\n            ? CSS.HEX(mix)\n            : translateColor.HEX(mix));\n    },\n    HEXA(colors, mode, css) {\n        const mix = this.mix(colors, mode);\n        mix.A = css\n            ? normalizeAlpha(mix.A) * BASE_255\n            : normalizeAlpha(mix.A);\n        return (css\n            ? CSS.HEX(mix)\n            : translateColor.HEXA(mix));\n    },\n    [ColorModel.RGB](colors, mode, css, options) {\n        const mix = this.mix(colors, mode);\n        delete mix.A;\n        return (css\n            ? CSS.RGB(mix, options)\n            : translateColor.RGB(mix, options.decimals));\n    },\n    RGBA(colors, mode, css, options) {\n        const mix = this.mix(colors, mode);\n        return (css\n            ? CSS.RGB(mix, options)\n            : translateColor.RGBA(mix, options.decimals));\n    },\n    [ColorModel.HSL](colors, mode, css, options) {\n        const mix = this.mix(colors, mode);\n        const HSL = rgbToHsl(mix.R, mix.G, mix.B);\n        delete mix.A;\n        delete HSL.A;\n        return (css\n            ? CSS.HSL(HSL, options)\n            : translateColor.HSL(mix, options.decimals));\n    },\n    HSLA(colors, mode, css, options) {\n        const mix = this.mix(colors, mode);\n        const HSL = rgbToHsl(mix.R, mix.G, mix.B, mix.A);\n        return (css\n            ? CSS.HSL(HSL, options)\n            : translateColor.HSLA(mix, options.decimals));\n    },\n    [ColorModel.HWB](colors, mode, css, options) {\n        const mix = this.mix(colors, mode);\n        const HWB = rgbToHwb(mix.R, mix.G, mix.B);\n        delete mix.A;\n        delete HWB.A;\n        return (css\n            ? CSS.HWB(HWB, options)\n            : translateColor.HWB(mix, options.decimals));\n    },\n    HWBA(colors, mode, css, options) {\n        const mix = this.mix(colors, mode);\n        const HWB = rgbToHwb(mix.R, mix.G, mix.B, mix.A);\n        return (css\n            ? CSS.HWB(HWB, options)\n            : translateColor.HWBA(mix, options.decimals));\n    },\n    [ColorModel.CIELab](colors, mode, css, options) {\n        const mix = this.mix(colors, mode);\n        const Lab = rgbToLab(mix.R, mix.G, mix.B);\n        delete mix.A;\n        return (css\n            ? CSS.CIELab(Lab, options)\n            : translateColor.CIELab(mix, options.decimals));\n    },\n    CIELabA(colors, mode, css, options) {\n        const mix = this.mix(colors, mode);\n        const Lab = rgbToLab(mix.R, mix.G, mix.B);\n        if (hasProp(mix, 'A')) {\n            Lab.A = mix.A;\n        }\n        return (css\n            ? CSS.CIELab(Lab, options)\n            : translateColor.CIELabA(mix, options.decimals));\n    },\n    [ColorModel.LCH](colors, mode, css, options) {\n        const mix = this.mix(colors, mode);\n        const lch = rgbToLch(mix.R, mix.G, mix.B);\n        delete mix.A;\n        return (css\n            ? CSS.LCH(lch, options)\n            : translateColor.LCH(mix, options.decimals));\n    },\n    LCHA(colors, mode, css, options) {\n        const mix = this.mix(colors, mode);\n        const lch = rgbToLch(mix.R, mix.G, mix.B);\n        if (hasProp(mix, 'A')) {\n            lch.A = mix.A;\n        }\n        return (css\n            ? CSS.LCH(lch, options)\n            : translateColor.LCHA(mix, options.decimals));\n    }\n};\nconst roundRGBObject = (color, decimals) => {\n    const R = round(color.R, decimals);\n    const G = round(color.G, decimals);\n    const B = round(color.B, decimals);\n    return {\n        R,\n        G,\n        B,\n        ...(hasProp(color, 'A')\n            ? {\n                A: round(color.A, decimals)\n            }\n            : {})\n    };\n};\n\n;// ./src/returns/index.ts\n\n\n\nconst getColorReturn = (color, model, decimals, translateFunction) => {\n    const rgbObject = getRGBObject(color, model);\n    return translateFunction(rgbObject, decimals);\n};\nconst getBlendReturn = (from, to, steps, decimals, translateFunction) => {\n    if (steps < 1)\n        steps = DEFAULT_BLEND_STEPS;\n    const fromRGBObject = getRGBObject(from);\n    const toRGBObject = getRGBObject(to);\n    const blendArray = blend(fromRGBObject, toRGBObject, steps);\n    return blendArray.map((color) => {\n        return translateFunction(color, decimals);\n    });\n};\nfunction getBlendReturnWithParameters(params) {\n    const { from, to, thirdParameter, fourthParameter, translateFunction, cssFunction } = params;\n    const result = typeof thirdParameter === 'number'\n        ? getBlendReturn(from, to, thirdParameter, fourthParameter?.decimals, translateFunction)\n        : getBlendReturn(from, to, DEFAULT_BLEND_STEPS, thirdParameter?.decimals, translateFunction);\n    if (cssFunction) {\n        return result.map((color) => cssFunction(color, getOptionsFromColorInput((typeof thirdParameter === 'number'\n            ? fourthParameter\n            : thirdParameter) ?? {}, from, to)));\n    }\n    return result;\n}\nfunction getMixReturn(params) {\n    const { colors, secondParameter, thirdParameter, colorMixerFunction, css } = params;\n    const options = getOptionsFromColorInput((typeof secondParameter === 'string'\n        ? thirdParameter\n        : secondParameter) ?? {}, ...colors);\n    if (typeof secondParameter === 'string') {\n        return colorMixerFunction(colors, secondParameter, css, options);\n    }\n    return colorMixerFunction(colors, Mix.ADDITIVE, css, options);\n}\nconst getHarmonyReturn = (harmony, color, mode, options) => {\n    return ({\n        [Harmony.ANALOGOUS]: colorHarmony.buildHarmony(color, analogous, mode, options),\n        [Harmony.COMPLEMENTARY]: colorHarmony.buildHarmony(color, complementary, mode, options),\n        [Harmony.SPLIT_COMPLEMENTARY]: colorHarmony.buildHarmony(color, splitComplementary, mode, options),\n        [Harmony.TRIADIC]: colorHarmony.buildHarmony(color, triadic, mode, options),\n        [Harmony.TETRADIC]: colorHarmony.buildHarmony(color, tetradic, mode, options),\n        [Harmony.SQUARE]: colorHarmony.buildHarmony(color, square, mode, options)\n    })[harmony];\n};\n\n;// ./src/index.ts\n\n\n\n\n\n\n\nconst bindedMixers = Object.fromEntries(Object.entries(colorMixer).map((entry) => {\n    const [key, fn] = entry;\n    return [key, fn.bind(colorMixer)];\n}));\nclass ColorTranslator {\n    constructor(color, options = {}) {\n        this._options = getOptionsFromColorInput(options, color);\n        this.rgb = getRGBObject(color);\n        this.update('rgb');\n    }\n    update(...exclude) {\n        if (!exclude.includes('rgb')) {\n            this.updateRGB();\n        }\n        if (!exclude.includes('hsl')) {\n            this.updateHSL();\n        }\n        if (!exclude.includes('hwb')) {\n            this.updateHWB();\n        }\n        if (!exclude.includes('lab')) {\n            this.updateLAB();\n        }\n        if (!exclude.includes('lch')) {\n            this.updateLCH();\n        }\n        if (!exclude.includes('cmyk')) {\n            this.updateCMYK();\n        }\n    }\n    updateRGB() {\n        this.rgb = {\n            ...hslToRgb(this.hsl.H, this.hsl.S, this.hsl.L),\n            A: this.hsl.A\n        };\n    }\n    updateHSL() {\n        this.hsl = rgbToHsl(this.rgb.R, this.rgb.G, this.rgb.B, this.rgb.A);\n    }\n    updateHWB() {\n        this.hwb = rgbToHwb(this.rgb.R, this.rgb.G, this.rgb.B, this.rgb.A);\n    }\n    updateLAB() {\n        this.lab = {\n            ...rgbToLab(this.rgb.R, this.rgb.G, this.rgb.B),\n            A: this.rgb.A\n        };\n    }\n    updateLCH() {\n        this.lch = {\n            ...rgbToLch(this.rgb.R, this.rgb.G, this.rgb.B),\n            A: this.rgb.A\n        };\n    }\n    updateCMYK() {\n        this.cmyk = rgbToCmyk(this.rgb.R, this.rgb.G, this.rgb.B);\n    }\n    updateRGBFromHWB() {\n        this.rgb = {\n            ...hwbToRgb(this.hwb.H, this.hwb.W, this.hwb.B),\n            A: this.rgb.A\n        };\n    }\n    updateRGBFromLCH() {\n        this.rgb = {\n            ...lchToRgb(this.lch.L, this.lch.C, this.lch.H),\n            A: this.rgb.A\n        };\n    }\n    updateRGBFromCMYK() {\n        this.rgb = {\n            ...cmykToRgb(this.cmyk.C, this.cmyk.M, this.cmyk.Y, this.cmyk.K),\n            A: this.rgb.A\n        };\n    }\n    updateRGBFromLAB() {\n        this.rgb = {\n            ...labToRgb(this.lab.L, this.lab.a, this.lab.b),\n            A: this.rgb.A\n        };\n    }\n    updateLCHFromLAB() {\n        this.lch = {\n            ...labToLch(this.lab.L, this.lab.a, this.lab.b),\n            A: this.lab.A\n        };\n    }\n    updateLABromLCH() {\n        this.lab = {\n            ...lchToLab(this.lch.L, this.lch.C, this.lch.H),\n            A: this.lch.A\n        };\n    }\n    setOptions(options = {}) {\n        this._options = {\n            ...this._options,\n            ...options\n        };\n        return this;\n    }\n    setR(R) {\n        this.rgb.R = minmax(R, 0, BASE_255);\n        this.update('rgb');\n        return;\n    }\n    setG(G) {\n        this.rgb.G = minmax(G, 0, BASE_255);\n        this.update('rgb');\n        return this;\n    }\n    setB(B) {\n        this.rgb.B = minmax(B, 0, BASE_255);\n        this.update('rgb');\n        return this;\n    }\n    setH(H) {\n        this.hsl.H = normalizeHue(H);\n        this.update('hsl');\n        return this;\n    }\n    setS(S) {\n        this.hsl.S = minmax(S, 0, MAX_PCENT);\n        this.update('hsl');\n        return this;\n    }\n    setL(L) {\n        this.hsl.L = minmax(L, 0, MAX_PCENT);\n        this.update('hsl');\n        return this;\n    }\n    setWhiteness(W) {\n        this.hwb.W = minmax(W, 0, MAX_PCENT);\n        this.updateRGBFromHWB();\n        this.update('rgb', 'hwb');\n        return this;\n    }\n    setBlackness(B) {\n        this.hwb.B = minmax(B, 0, MAX_PCENT);\n        this.updateRGBFromHWB();\n        this.update('rgb', 'hwb');\n        return this;\n    }\n    setCIEL(L) {\n        this.lab.L = minmax(L, 0, MAX_PCENT);\n        this.updateRGBFromLAB();\n        this.updateLCHFromLAB();\n        this.update('rgb', 'lab', 'lch');\n        return this;\n    }\n    setCIEa(a) {\n        this.lab.a = minmax(a, -MAX_LAB, MAX_LAB);\n        this.updateRGBFromLAB();\n        this.updateLCHFromLAB();\n        this.update('rgb', 'lab', 'lch');\n        return this;\n    }\n    setCIEb(b) {\n        this.lab.b = minmax(b, -MAX_LAB, MAX_LAB);\n        this.updateRGBFromLAB();\n        this.updateLCHFromLAB();\n        this.update('rgb', 'lab', 'lch');\n        return this;\n    }\n    setLCHL(l) {\n        this.lch.L = minmax(l, 0, MAX_PCENT);\n        this.updateRGBFromLCH();\n        this.updateLABromLCH();\n        this.update('rgb', 'lab', 'lch');\n        return this;\n    }\n    setLCHC(c) {\n        this.lch.C = minmax(c, 0, MAX_LCH_C);\n        this.updateRGBFromLCH();\n        this.updateLABromLCH();\n        this.update('rgb', 'lab', 'lch');\n        return this;\n    }\n    setLCHH(h) {\n        this.lch.H = normalizeHue(h);\n        this.updateRGBFromLCH();\n        this.updateLABromLCH();\n        this.update('rgb', 'lab', 'lch');\n        return this;\n    }\n    setA(A) {\n        const alpha = minmax(A, 0, MAX_ALPHA);\n        this.rgb.A = alpha;\n        this.hsl.A = alpha;\n        this.hwb.A = alpha;\n        this.lab.A = alpha;\n        this.lch.A = alpha;\n        this.cmyk.A = alpha;\n        return this;\n    }\n    setC(C) {\n        this.cmyk.C = minmax(C, 0, 100);\n        this.updateRGBFromCMYK();\n        this.update('cmyk');\n        return this;\n    }\n    setM(M) {\n        this.cmyk.M = minmax(M, 0, 100);\n        this.updateRGBFromCMYK();\n        this.update('cmyk');\n        return this;\n    }\n    setY(Y) {\n        this.cmyk.Y = minmax(Y, 0, 100);\n        this.updateRGBFromCMYK();\n        this.update('cmyk');\n        return this;\n    }\n    setK(K) {\n        this.cmyk.K = minmax(K, 0, 100);\n        this.updateRGBFromCMYK();\n        this.update('cmyk');\n        return this;\n    }\n    get options() {\n        return this._options;\n    }\n    get R() {\n        return round(this.rgb.R, this.options.decimals);\n    }\n    get G() {\n        return round(this.rgb.G, this.options.decimals);\n    }\n    get B() {\n        return round(this.rgb.B, this.options.decimals);\n    }\n    get H() {\n        return round(this.hsl.H, this.options.decimals);\n    }\n    get S() {\n        return round(this.hsl.S, this.options.decimals);\n    }\n    get L() {\n        return round(this.hsl.L, this.options.decimals);\n    }\n    get Whiteness() {\n        return round(this.hwb.W, this.options.decimals);\n    }\n    get Blackness() {\n        return round(this.hwb.B, this.options.decimals);\n    }\n    get CIEL() {\n        return round(this.lab.L, this.options.decimals);\n    }\n    get CIEa() {\n        return round(this.lab.a, this.options.decimals);\n    }\n    get CIEb() {\n        return round(this.lab.b, this.options.decimals);\n    }\n    get LCHL() {\n        return round(this.lch.L, this.options.decimals);\n    }\n    get LCHC() {\n        return round(this.lch.C, this.options.decimals);\n    }\n    get LCHH() {\n        return round(this.lch.H, this.options.decimals);\n    }\n    get A() {\n        return round(this.hsl.A, this.options.decimals);\n    }\n    get C() {\n        return round(this.cmyk.C, this.options.decimals);\n    }\n    get M() {\n        return round(this.cmyk.M, this.options.decimals);\n    }\n    get Y() {\n        return round(this.cmyk.Y, this.options.decimals);\n    }\n    get K() {\n        return round(this.cmyk.K, this.options.decimals);\n    }\n    get HEXObject() {\n        return translateColor.HEX(this.rgb);\n    }\n    get HEXAObject() {\n        return translateColor.HEXA(this.rgb);\n    }\n    get RGBObject() {\n        return {\n            R: this.R,\n            G: this.G,\n            B: this.B\n        };\n    }\n    get RGBAObject() {\n        return {\n            ...this.RGBObject,\n            A: this.A\n        };\n    }\n    get HSLObject() {\n        return {\n            H: this.H,\n            S: this.S,\n            L: this.L\n        };\n    }\n    get HSLAObject() {\n        return {\n            ...this.HSLObject,\n            A: this.A\n        };\n    }\n    get HWBObject() {\n        return {\n            H: this.H,\n            W: this.Whiteness,\n            B: this.Blackness\n        };\n    }\n    get HWBAObject() {\n        return {\n            ...this.HWBObject,\n            A: this.A\n        };\n    }\n    get CIELabObject() {\n        return {\n            L: this.CIEL,\n            a: this.CIEa,\n            b: this.CIEb\n        };\n    }\n    get CIELabAObject() {\n        return {\n            ...this.CIELabObject,\n            A: this.A\n        };\n    }\n    get LCHObject() {\n        return {\n            L: this.LCHL,\n            C: this.LCHC,\n            H: this.LCHH\n        };\n    }\n    get LCHAObject() {\n        return {\n            ...this.LCHObject,\n            A: this.A\n        };\n    }\n    get CMYKObject() {\n        return {\n            C: this.C,\n            M: this.M,\n            Y: this.Y,\n            K: this.K\n        };\n    }\n    get CMYKAObject() {\n        return {\n            ...this.CMYKObject,\n            A: this.A\n        };\n    }\n    get HEX() {\n        return CSS.HEX({\n            R: this.R,\n            G: this.G,\n            B: this.B\n        });\n    }\n    get HEXA() {\n        return CSS.HEX({\n            R: this.R,\n            G: this.G,\n            B: this.B,\n            A: this.A * BASE_255\n        });\n    }\n    get RGB() {\n        return CSS.RGB({\n            R: this.R,\n            G: this.G,\n            B: this.B\n        }, this.options);\n    }\n    get RGBA() {\n        return CSS.RGB({\n            R: this.R,\n            G: this.G,\n            B: this.B,\n            A: this.A\n        }, this.options);\n    }\n    get HSL() {\n        return CSS.HSL({\n            H: this.H,\n            S: this.S,\n            L: this.L\n        }, this.options);\n    }\n    get HSLA() {\n        return CSS.HSL({\n            H: this.H,\n            S: this.S,\n            L: this.L,\n            A: this.A\n        }, this.options);\n    }\n    get HWB() {\n        return CSS.HWB({\n            H: this.H,\n            W: this.Whiteness,\n            B: this.Blackness\n        }, this.options);\n    }\n    get HWBA() {\n        return CSS.HWB({\n            H: this.H,\n            W: this.Whiteness,\n            B: this.Blackness,\n            A: this.A\n        }, this.options);\n    }\n    get CIELab() {\n        return CSS.CIELab({\n            L: this.CIEL,\n            a: this.CIEa,\n            b: this.CIEb\n        }, this.options);\n    }\n    get CIELabA() {\n        return CSS.CIELab({\n            L: this.CIEL,\n            a: this.CIEa,\n            b: this.CIEb,\n            A: this.A\n        }, this.options);\n    }\n    get LCH() {\n        return CSS.LCH({\n            L: this.LCHL,\n            C: this.LCHC,\n            H: this.LCHH\n        }, this.options);\n    }\n    get LCHA() {\n        return CSS.LCH({\n            L: this.LCHL,\n            C: this.LCHC,\n            H: this.LCHH,\n            A: this.A\n        }, this.options);\n    }\n    get CMYK() {\n        return CSS.CMYK({\n            C: this.C,\n            M: this.M,\n            Y: this.Y,\n            K: this.K\n        }, this.options);\n    }\n    get CMYKA() {\n        return CSS.CMYK({\n            C: this.C,\n            M: this.M,\n            Y: this.Y,\n            K: this.K,\n            A: this.A\n        }, this.options);\n    }\n    static toHEXObject(color) {\n        const model = getColorModel(color);\n        return getColorReturn(color, model, 0, translateColor.HEX);\n    }\n    static toHEX(color) {\n        return CSS.HEX(ColorTranslator.toHEXObject(color));\n    }\n    static toHEXAObject(color) {\n        const model = getColorModel(color);\n        return getColorReturn(color, model, 0, translateColor.HEXA);\n    }\n    static toHEXA(color) {\n        return CSS.HEX(ColorTranslator.toHEXAObject(color));\n    }\n    static toRGBObject(color, options = {}) {\n        const model = getColorModel(color);\n        return getColorReturn(color, model, options.decimals, translateColor.RGB);\n    }\n    static toRGB(color, options = {}) {\n        const rgb = ColorTranslator.toRGBObject(color, options);\n        const detectedOptions = getOptionsFromColorInput(options, color);\n        return CSS.RGB(rgb, detectedOptions);\n    }\n    static toRGBAObject(color, options = {}) {\n        const model = getColorModel(color);\n        return getColorReturn(color, model, options.decimals, translateColor.RGBA);\n    }\n    static toRGBA(color, options = {}) {\n        const rgba = ColorTranslator.toRGBAObject(color, options);\n        const detectedOptions = getOptionsFromColorInput(options, color);\n        return CSS.RGB(rgba, detectedOptions);\n    }\n    static toHSLObject(color, options = {}) {\n        const model = getColorModel(color);\n        return getColorReturn(color, model, options.decimals, translateColor.HSL);\n    }\n    static toHSL(color, options = {}) {\n        const hsl = ColorTranslator.toHSLObject(color, options);\n        const detectedOptions = getOptionsFromColorInput(options, color);\n        return CSS.HSL(hsl, detectedOptions);\n    }\n    static toHSLAObject(color, options = {}) {\n        const model = getColorModel(color);\n        return getColorReturn(color, model, options.decimals, translateColor.HSLA);\n    }\n    static toHSLA(color, options = {}) {\n        const hsla = ColorTranslator.toHSLAObject(color, options);\n        const detectedOptions = getOptionsFromColorInput(options, color);\n        return CSS.HSL(hsla, detectedOptions);\n    }\n    static toHWBObject(color, options = {}) {\n        const model = getColorModel(color);\n        return getColorReturn(color, model, options.decimals, translateColor.HWB);\n    }\n    static toHWB(color, options = {}) {\n        const hwb = ColorTranslator.toHWBObject(color, options);\n        const detectedOptions = getOptionsFromColorInput(options, color);\n        return CSS.HWB(hwb, detectedOptions);\n    }\n    static toHWBAObject(color, options = {}) {\n        const model = getColorModel(color);\n        return getColorReturn(color, model, options.decimals, translateColor.HWBA);\n    }\n    static toHWBA(color, options = {}) {\n        const hwb = ColorTranslator.toHWBAObject(color, options);\n        const detectedOptions = getOptionsFromColorInput(options, color);\n        return CSS.HWB(hwb, detectedOptions);\n    }\n    static toCIELabObject(color, options = {}) {\n        const model = getColorModel(color);\n        return getColorReturn(color, model, options.decimals, translateColor.CIELab);\n    }\n    static toCIELab(color, options = {}) {\n        const lab = ColorTranslator.toCIELabObject(color, options);\n        const detectedOptions = getOptionsFromColorInput(options, color);\n        return CSS.CIELab(lab, detectedOptions);\n    }\n    static toCIELabAObject(color, options = {}) {\n        const model = getColorModel(color);\n        return getColorReturn(color, model, options.decimals, translateColor.CIELabA);\n    }\n    static toCIELabA(color, options = {}) {\n        const lab = ColorTranslator.toCIELabAObject(color, options);\n        const detectedOptions = getOptionsFromColorInput(options, color);\n        return CSS.CIELab(lab, detectedOptions);\n    }\n    static toLCHObject(color, options = {}) {\n        const model = getColorModel(color);\n        return getColorReturn(color, model, options.decimals, translateColor.LCH);\n    }\n    static toLCH(color, options = {}) {\n        const lch = ColorTranslator.toLCHObject(color, options);\n        const detectedOptions = getOptionsFromColorInput(options, color);\n        return CSS.LCH(lch, detectedOptions);\n    }\n    static toLCHAObject(color, options = {}) {\n        const model = getColorModel(color);\n        return getColorReturn(color, model, options.decimals, translateColor.LCHA);\n    }\n    static toLCHA(color, options = {}) {\n        const lch = ColorTranslator.toLCHAObject(color, options);\n        const detectedOptions = getOptionsFromColorInput(options, color);\n        return CSS.LCH(lch, detectedOptions);\n    }\n    static toCMYKObject(color, options = {}) {\n        const model = getColorModel(color);\n        return getColorReturn(color, model, options.decimals, translateColor.CMYK);\n    }\n    static toCMYK(color, options = {}) {\n        const cmyk = ColorTranslator.toCMYKObject(color, options);\n        const detectedOptions = getOptionsFromColorInput(options, color);\n        return CSS.CMYK(cmyk, detectedOptions);\n    }\n    static toCMYKAObject(color, options = {}) {\n        const model = getColorModel(color);\n        return getColorReturn(color, model, options.decimals, translateColor.CMYKA);\n    }\n    static toCMYKA(color, options = {}) {\n        const cmyka = ColorTranslator.toCMYKAObject(color, options);\n        const detectedOptions = getOptionsFromColorInput(options, color);\n        return CSS.CMYK(cmyka, detectedOptions);\n    }\n    static getBlendHEXObject(from, to, steps = DEFAULT_BLEND_STEPS) {\n        return getBlendReturn(from, to, steps, 0, translateColor.HEX);\n    }\n    static getBlendHEX(from, to, steps = DEFAULT_BLEND_STEPS) {\n        return ColorTranslator.getBlendHEXObject(from, to, steps)\n            .map((color) => CSS.HEX(color));\n    }\n    static getBlendHEXAObject(from, to, steps = DEFAULT_BLEND_STEPS) {\n        return getBlendReturn(from, to, steps, 0, translateColor.HEXA);\n    }\n    static getBlendHEXA(from, to, steps = DEFAULT_BLEND_STEPS) {\n        return ColorTranslator.getBlendHEXAObject(from, to, steps)\n            .map((color) => CSS.HEX(color));\n    }\n    static getBlendRGBObject(from, to, thirdParameter, fourthParameter) {\n        return getBlendReturnWithParameters({\n            from,\n            to,\n            thirdParameter,\n            fourthParameter,\n            translateFunction: translateColor.RGB\n        });\n    }\n    static getBlendRGB(from, to, thirdParameter, fourthParameter) {\n        return getBlendReturnWithParameters({\n            from,\n            to,\n            thirdParameter,\n            fourthParameter,\n            translateFunction: translateColor.RGB,\n            cssFunction: CSS.RGB\n        });\n    }\n    static getBlendRGBAObject(from, to, thirdParameter, fourthParameter) {\n        return getBlendReturnWithParameters({\n            from,\n            to,\n            thirdParameter,\n            fourthParameter,\n            translateFunction: translateColor.RGBA\n        });\n    }\n    static getBlendRGBA(from, to, thirdParameter, fourthParameter) {\n        return getBlendReturnWithParameters({\n            from,\n            to,\n            thirdParameter,\n            fourthParameter,\n            translateFunction: translateColor.RGBA,\n            cssFunction: CSS.RGB\n        });\n    }\n    static getBlendHSLObject(from, to, thirdParameter, fourthParameter) {\n        return getBlendReturnWithParameters({\n            from,\n            to,\n            thirdParameter,\n            fourthParameter,\n            translateFunction: translateColor.HSL\n        });\n    }\n    static getBlendHSL(from, to, thirdParameter, fourthParameter) {\n        return getBlendReturnWithParameters({\n            from,\n            to,\n            thirdParameter,\n            fourthParameter,\n            translateFunction: translateColor.HSL,\n            cssFunction: CSS.HSL\n        });\n    }\n    static getBlendHSLAObject(from, to, thirdParameter, fourthParameter) {\n        return getBlendReturnWithParameters({\n            from,\n            to,\n            thirdParameter,\n            fourthParameter,\n            translateFunction: translateColor.HSLA\n        });\n    }\n    static getBlendHSLA(from, to, thirdParameter, fourthParameter) {\n        return getBlendReturnWithParameters({\n            from,\n            to,\n            thirdParameter,\n            fourthParameter,\n            translateFunction: translateColor.HSLA,\n            cssFunction: CSS.HSL\n        });\n    }\n    static getBlendHWBObject(from, to, thirdParameter, fourthParameter) {\n        return getBlendReturnWithParameters({\n            from,\n            to,\n            thirdParameter,\n            fourthParameter,\n            translateFunction: translateColor.HWB\n        });\n    }\n    static getBlendHWB(from, to, thirdParameter, fourthParameter) {\n        return getBlendReturnWithParameters({\n            from,\n            to,\n            thirdParameter,\n            fourthParameter,\n            translateFunction: translateColor.HWB,\n            cssFunction: CSS.HWB\n        });\n    }\n    static getBlendHWBAObject(from, to, thirdParameter, fourthParameter) {\n        return getBlendReturnWithParameters({\n            from,\n            to,\n            thirdParameter,\n            fourthParameter,\n            translateFunction: translateColor.HWBA\n        });\n    }\n    static getBlendHWBA(from, to, thirdParameter, fourthParameter) {\n        return getBlendReturnWithParameters({\n            from,\n            to,\n            thirdParameter,\n            fourthParameter,\n            translateFunction: translateColor.HWBA,\n            cssFunction: CSS.HWB\n        });\n    }\n    static getBlendCIELabObject(from, to, thirdParameter, fourthParameter) {\n        return getBlendReturnWithParameters({\n            from,\n            to,\n            thirdParameter,\n            fourthParameter,\n            translateFunction: translateColor.CIELab\n        });\n    }\n    static getBlendCIELab(from, to, thirdParameter, fourthParameter) {\n        return getBlendReturnWithParameters({\n            from,\n            to,\n            thirdParameter,\n            fourthParameter,\n            translateFunction: translateColor.CIELab,\n            cssFunction: CSS.CIELab\n        });\n    }\n    static getBlendCIELabAObject(from, to, thirdParameter, fourthParameter) {\n        return getBlendReturnWithParameters({\n            from,\n            to,\n            thirdParameter,\n            fourthParameter,\n            translateFunction: translateColor.CIELabA\n        });\n    }\n    static getBlendCIELabA(from, to, thirdParameter, fourthParameter) {\n        return getBlendReturnWithParameters({\n            from,\n            to,\n            thirdParameter,\n            fourthParameter,\n            translateFunction: translateColor.CIELabA,\n            cssFunction: CSS.CIELab\n        });\n    }\n    static getBlendLCHObject(from, to, thirdParameter, fourthParameter) {\n        return getBlendReturnWithParameters({\n            from,\n            to,\n            thirdParameter,\n            fourthParameter,\n            translateFunction: translateColor.LCH\n        });\n    }\n    static getBlendLCH(from, to, thirdParameter, fourthParameter) {\n        return getBlendReturnWithParameters({\n            from,\n            to,\n            thirdParameter,\n            fourthParameter,\n            translateFunction: translateColor.LCH,\n            cssFunction: CSS.LCH\n        });\n    }\n    static getBlendLCHAObject(from, to, thirdParameter, fourthParameter) {\n        return getBlendReturnWithParameters({\n            from,\n            to,\n            thirdParameter,\n            fourthParameter,\n            translateFunction: translateColor.LCHA\n        });\n    }\n    static getBlendLCHA(from, to, thirdParameter, fourthParameter) {\n        return getBlendReturnWithParameters({\n            from,\n            to,\n            thirdParameter,\n            fourthParameter,\n            translateFunction: translateColor.LCHA,\n            cssFunction: CSS.LCH\n        });\n    }\n    static getMixHEXObject(colors, mode = Mix.ADDITIVE) {\n        return colorMixer.HEX(colors, mode, false);\n    }\n    static getMixHEX(colors, mode = Mix.ADDITIVE) {\n        return colorMixer.HEX(colors, mode, true);\n    }\n    static getMixHEXAObject(colors, mode = Mix.ADDITIVE) {\n        return colorMixer.HEXA(colors, mode, false);\n    }\n    static getMixHEXA(colors, mode = Mix.ADDITIVE) {\n        return colorMixer.HEXA(colors, mode, true);\n    }\n    static getMixRGBObject(colors, secondParameter, thirdParameter) {\n        return getMixReturn({\n            colors,\n            secondParameter,\n            thirdParameter,\n            colorMixerFunction: bindedMixers.RGB,\n            css: false\n        });\n    }\n    static getMixRGB(colors, secondParameter, thirdParameter) {\n        return getMixReturn({\n            colors,\n            secondParameter,\n            thirdParameter,\n            colorMixerFunction: bindedMixers.RGB,\n            css: true\n        });\n    }\n    static getMixRGBAObject(colors, secondParameter, thirdParameter) {\n        return getMixReturn({\n            colors,\n            secondParameter,\n            thirdParameter,\n            colorMixerFunction: bindedMixers.RGBA,\n            css: false\n        });\n    }\n    static getMixRGBA(colors, secondParameter, thirdParameter) {\n        return getMixReturn({\n            colors,\n            secondParameter,\n            thirdParameter,\n            colorMixerFunction: bindedMixers.RGBA,\n            css: true\n        });\n    }\n    static getMixHSLObject(colors, secondParameter, thirdParameter) {\n        return getMixReturn({\n            colors,\n            secondParameter,\n            thirdParameter,\n            colorMixerFunction: bindedMixers.HSL,\n            css: false\n        });\n    }\n    static getMixHSL(colors, secondParameter, thirdParameter) {\n        return getMixReturn({\n            colors,\n            secondParameter,\n            thirdParameter,\n            colorMixerFunction: bindedMixers.HSL,\n            css: true\n        });\n    }\n    static getMixHSLAObject(colors, secondParameter, thirdParameter) {\n        return getMixReturn({\n            colors,\n            secondParameter,\n            thirdParameter,\n            colorMixerFunction: bindedMixers.HSLA,\n            css: false\n        });\n    }\n    static getMixHSLA(colors, secondParameter, thirdParameter) {\n        return getMixReturn({\n            colors,\n            secondParameter,\n            thirdParameter,\n            colorMixerFunction: bindedMixers.HSLA,\n            css: true\n        });\n    }\n    static getMixHWBObject(colors, secondParameter, thirdParameter) {\n        return getMixReturn({\n            colors,\n            secondParameter,\n            thirdParameter,\n            colorMixerFunction: bindedMixers.HWB,\n            css: false\n        });\n    }\n    static getMixHWB(colors, secondParameter, thirdParameter) {\n        return getMixReturn({\n            colors,\n            secondParameter,\n            thirdParameter,\n            colorMixerFunction: bindedMixers.HWB,\n            css: true\n        });\n    }\n    static getMixHWBAObject(colors, secondParameter, thirdParameter) {\n        return getMixReturn({\n            colors,\n            secondParameter,\n            thirdParameter,\n            colorMixerFunction: bindedMixers.HWBA,\n            css: false\n        });\n    }\n    static getMixHWBA(colors, secondParameter, thirdParameter) {\n        return getMixReturn({\n            colors,\n            secondParameter,\n            thirdParameter,\n            colorMixerFunction: bindedMixers.HWBA,\n            css: true\n        });\n    }\n    static getMixCIELabObject(colors, secondParameter, thirdParameter) {\n        return getMixReturn({\n            colors,\n            secondParameter,\n            thirdParameter,\n            colorMixerFunction: bindedMixers.CIELab,\n            css: false\n        });\n    }\n    static getMixCIELab(colors, secondParameter, thirdParameter) {\n        return getMixReturn({\n            colors,\n            secondParameter,\n            thirdParameter,\n            colorMixerFunction: bindedMixers.CIELab,\n            css: true\n        });\n    }\n    static getMixCIELabAObject(colors, secondParameter, thirdParameter) {\n        return getMixReturn({\n            colors,\n            secondParameter,\n            thirdParameter,\n            colorMixerFunction: bindedMixers.CIELabA,\n            css: false\n        });\n    }\n    static getMixCIELabA(colors, secondParameter, thirdParameter) {\n        return getMixReturn({\n            colors,\n            secondParameter,\n            thirdParameter,\n            colorMixerFunction: bindedMixers.CIELabA,\n            css: true\n        });\n    }\n    static getMixLCHObject(colors, secondParameter, thirdParameter) {\n        return getMixReturn({\n            colors,\n            secondParameter,\n            thirdParameter,\n            colorMixerFunction: bindedMixers.LCH,\n            css: false\n        });\n    }\n    static getMixLCH(colors, secondParameter, thirdParameter) {\n        return getMixReturn({\n            colors,\n            secondParameter,\n            thirdParameter,\n            colorMixerFunction: bindedMixers.LCH,\n            css: true\n        });\n    }\n    static getMixLCHAObject(colors, secondParameter, thirdParameter) {\n        return getMixReturn({\n            colors,\n            secondParameter,\n            thirdParameter,\n            colorMixerFunction: bindedMixers.LCHA,\n            css: false\n        });\n    }\n    static getMixLCHA(colors, secondParameter, thirdParameter) {\n        return getMixReturn({\n            colors,\n            secondParameter,\n            thirdParameter,\n            colorMixerFunction: bindedMixers.LCHA,\n            css: true\n        });\n    }\n    static getShades(color, secondParameter, thirdParameter) {\n        if (typeof secondParameter === 'number') {\n            return getColorMixture(color, secondParameter, true, getOptionsFromColorInput(thirdParameter || {}, color));\n        }\n        return getColorMixture(color, DEFAULT_SHADES_TINTS_STEPS, true, getOptionsFromColorInput(secondParameter || {}, color));\n    }\n    static getTints(color, secondParameter, thirdParameter) {\n        if (typeof secondParameter === 'number') {\n            return getColorMixture(color, secondParameter, false, getOptionsFromColorInput(thirdParameter || {}, color));\n        }\n        return getColorMixture(color, DEFAULT_SHADES_TINTS_STEPS, false, getOptionsFromColorInput(secondParameter || {}, color));\n    }\n    static getHarmony(color, secondParam, thirdParam, fourthParam) {\n        if (isHarmony(secondParam)) {\n            return getHarmonyReturn(secondParam, color, isMix(thirdParam)\n                ? thirdParam\n                : Mix.ADDITIVE, getOptionsFromColorInput(isMix(thirdParam)\n                ? (fourthParam || {})\n                : thirdParam || {}, color));\n        }\n        else if (isMix(secondParam)) {\n            return getHarmonyReturn(Harmony.COMPLEMENTARY, color, secondParam, getOptionsFromColorInput(thirdParam || {}, color));\n        }\n        return getHarmonyReturn(Harmony.COMPLEMENTARY, color, Mix.ADDITIVE, getOptionsFromColorInput(secondParam || {}, color));\n    }\n}\n\n\n;// ./src/@demo/demo1/index.js\n\n\n/* harmony default export */ const demo1 = ((ColorTranslator) => {\n\n    const container = document.createElement('div');\n    const color = new ColorTranslator('hsl(180 100% 50%)', { decimals: 0 });\n\n    for (let row = 0; row < 10; row++) {\n\n        for (let col = 0; col < 10; col++) {\n\n            color\n                .setS(row * 10)\n                .setL(col * 5 + 30);\n\n            const box = document.createElement('div');\n\n            box.classList.add('box');\n            box.style.background = color.HEX;\n\n            box.innerText =\n                `R:${color.R}\n                 G:${color.G}\n                 B:${color.B}`;\n            container.appendChild(box);\n\n        }\n    }\n\n    return container;\n\n});\n;// ./src/@demo/demo2/index.js\n\n\n/* harmony default export */ const demo2 = ((ColorTranslator) => {\n\n    const container = document.createElement('div');\n    const color = new ColorTranslator({ R: 255, G: 0, B: 0 });\n    const hue = [0, 30, 60, 120, 240, 280, 320, 0];\n    let rainbow;\n\n    for (let r = 0; r < hue.length; r++) {\n\n        color.setH(hue[r]);\n\n        const bow = document.createElement('div');\n\n        bow.classList.add('rainbow');\n        bow.style.background = color.HEX;\n\n        if (rainbow) {\n            rainbow.appendChild(bow);\n        } else {\n            container.appendChild(bow);\n        }\n\n        rainbow = bow;\n    }\n\n    rainbow.style.background = '#333';\n\n    return container;\n\n});\n;// ./src/@demo/demo3/index.js\n\n\n/* harmony default export */ const demo3 = ((ColorTranslator) => {\n\n    const container = document.createElement('div');\n    const hsl = { H: 0, S: '90%', L: '50%' };\n    const hue = [undefined, 55, 30, 0, 290, 220, 130];\n    const total = hue.length;\n\n    for (let row = 0; row < total; row++) {\n\n        for (let col = 0; col < total; col++) {\n\n            let index = total - row + col;\n            if (index >= total) {\n                index -= total;\n            }\n            hsl.H = hue[index];\n            const rgb = hue[index] === undefined\n                ? '#FFF'\n                : ColorTranslator.toHEX(hsl);\n            const box = document.createElement('div');\n\n            box.classList.add('flag');\n            box.style.background = rgb;\n\n            container.appendChild(box);\n\n        }\n    }\n\n    return container;\n\n});\n;// ./src/@demo/demo4/index.js\n\n\n/* harmony default export */ const demo4 = ((ColorTranslator) => {\n\n    const container = document.createElement('div');\n    const hexColors = [\n        '#FE2712', '#FE5409', '#FB9902',\n        '#FABD03', '#FFFE32', '#D1EA2C',\n        '#66B132', '#0392CE', '#0247FE',\n        '#3D00A5', '#8601B0', '#A7194B'\n    ];\n\n    hexColors.forEach((color) => {\n\n        const rgb = ColorTranslator.toRGB(color);\n        const hsl = ColorTranslator.toHSL(color, { decimals: 0 });\n        const hwb = ColorTranslator.toHWB(color, { decimals: 0 });\n        const lab = ColorTranslator.toCIELab(color, { decimals: 0 });\n        const lch = ColorTranslator.toLCH(color, { decimals: 0 });\n\n        const rgbDiv = document.createElement('div');\n        const hslDiv = document.createElement('div');\n        const hwbDiv = document.createElement('div');\n        const labDiv = document.createElement('div');\n        const lchDiv = document.createElement('div');\n\n        rgbDiv.style.backgroundColor = rgb;\n        rgbDiv.textContent = rgb;\n\n        hslDiv.style.backgroundColor = hsl;\n        hslDiv.textContent = hsl;\n\n        hwbDiv.style.backgroundColor = hwb;\n        hwbDiv.textContent = hwb;\n\n        labDiv.style.backgroundColor = lab;\n        labDiv.textContent = lab;\n\n        lchDiv.style.backgroundColor = lch;\n        lchDiv.textContent = lch;\n\n        container.appendChild(rgbDiv);\n        container.appendChild(hslDiv);\n        container.appendChild(hwbDiv);\n        container.appendChild(labDiv);\n        container.appendChild(lchDiv);\n\n    });\n\n    return container;\n\n});\n;// ./src/@demo/demo5/index.js\n\n\n/* harmony default export */ const demo5 = ((ColorTranslator) => {\n\n    const container = document.createElement('div');\n    const colors = [\n        'red',\n        'lime',\n        'blue',\n        'aqua',\n        'yellow',\n        'fuchsia'\n    ];\n    const total = colors.length;\n\n    for (let row = 0; row < total; row++) {\n\n        const hsl = ColorTranslator.toHSLObject(colors[row]);\n        const step = hsl.S / (total - 1);\n\n        for (let col = 0; col < total; col++) {\n\n            const rgb = ColorTranslator.toHEX(hsl);\n            const cmyk = ColorTranslator.toCMYKObject(hsl, { decimals: 0 });\n\n            const box = document.createElement('div');\n            box.classList.add('box');\n            box.style.background = rgb;\n            box.innerText = `C:${cmyk.C}\n                             M:${cmyk.M}\n                             Y:${cmyk.Y}\n                             K:${cmyk.K}`;\n\n            container.appendChild(box);\n\n            hsl.S -= step;\n\n        }\n    }\n\n    return container;\n\n});\n;// ./src/@demo/demo6/index.js\n\n\n/* harmony default export */ const demo6 = ((ColorTranslator) => {\n\n    const container = document.createElement('div');\n    const rows = 11;\n    const mult = 3;\n\n    for (let i = 0; i < rows; i++) {\n\n        const blends = ColorTranslator.getBlendHEX('#F00', '#FF0', mult + i * mult);\n\n        blends.forEach((blend, index) => {\n            const box = document.createElement('div');\n            box.classList.add('box', `file${i}`);\n            box.style.background = blend;\n            box.innerText = index + 1;\n            container.appendChild(box);\n        });\n\n    }\n\n    return container;\n\n});\n;// ./src/@demo/demo7/index.js\n\n\n/* harmony default export */ const demo7 = ((ColorTranslator) => {\n\n    const container = document.createElement('div');\n\n    const colors = ['#F00', '#FF8000', '#FF0', '#0F0', '#00F', '#A0F', '#F0A'];\n\n    const createBox = (color, type) => {\n        const box = document.createElement('div');\n        box.classList.add('box');\n        box.style.backgroundColor = color;\n        if (type) box.dataset.type = type;\n        container.appendChild(box);\n    };\n\n    colors.forEach((color) => {\n        const shades = ColorTranslator.getShades(color, 3).reverse();\n        const tints = ColorTranslator.getTints(color, 3);\n        shades.forEach((shade) => createBox(shade, 'shade'));\n        createBox(color);\n        tints.forEach((tint) => createBox(tint, 'tint'));\n    });\n\n    return container;\n\n});\n;// ./src/@demo/demo8/index.js\n\n\n\n/* harmony default export */ const demo8 = ((ColorTranslator) => {\n\n    const container = document.createElement('div');\n\n    const mixes = [\n        '#F00',\n        '#0F0',\n        '#00F',\n        [1, 3],\n        [1, 2],\n        [2, 3],\n        [1, 2, 3]\n    ];\n\n    const fillPlanes = () => {\n        const planes = container.querySelectorAll('#planes path');\n        planes.forEach((plane, index) => {\n            let color = '#CCC';\n            if (typeof mixes[index] === 'string') {\n                color = mixes[index];\n            } else if(mixes[index]) {\n                const colors = mixes[index].map((i) => mixes[i - 1]);\n                color = mixes[index] = ColorTranslator.getMixHEX(colors);\n            }\n            plane.setAttribute('fill', color);\n        });\n    };\n\n    fetch('images/color-mixes.svg')\n        .then(result => result.text())\n        .then((svgCode) => {\n            container.innerHTML = svgCode;\n            fillPlanes();\n        });\n\n    return container;\n\n});\n;// ./src/@demo/demo9/index.js\n\n\n/* harmony default export */ const demo9 = ((ColorTranslator, { Mix }) => {\n\n    const container = document.createElement('div');\n\n    const mixes = [\n        '#F00',\n        '#FF0',\n        '#00F',\n        [1, 3],\n        [1, 2],\n        [2, 3],\n        [1, 2, 3]\n    ];\n\n    const fillPlanes = () => {\n        const planes = container.querySelectorAll('#planes path');\n        planes.forEach((plane, index) => {\n            let color = '#CCC';\n            if (typeof mixes[index] === 'string') {\n                color = mixes[index];\n            } else if(mixes[index]) {\n                const colors = mixes[index].map((i) => mixes[i - 1]);\n                color = mixes[index] = ColorTranslator.getMixHEX(colors, Mix.SUBTRACTIVE);\n            }\n            plane.setAttribute('fill', color);\n        });\n    };\n\n    fetch('images/color-mixes.svg')\n        .then(result => result.text())\n        .then((svgCode) => {\n            container.innerHTML = svgCode;\n            fillPlanes();\n        });\n\n    return container;\n\n});\n;// ./src/@demo/demo10/index.js\n\n\n/* harmony default export */ const demo10 = ((ColorTranslator, { Harmony }) => {\n\n    const container = document.createElement('div');\n\n    const harmonies = [\n        { label: 'Complementary',       value: Harmony.COMPLEMENTARY },\n        { label: 'Split Complementary', value: Harmony.SPLIT_COMPLEMENTARY },\n        { label: 'Analogous',           value: Harmony.ANALOGOUS },\n        { label: 'Triadic',             value: Harmony.TRIADIC },\n        { label: 'Tetradic',            value: Harmony.TETRADIC },\n        { label: 'Square',              value: Harmony.SQUARE }\n    ];\n\n    const baseColor = '#F00';\n\n    const createElement = (className, parent) => {\n        const div = document.createElement('div');\n        div.classList.add(className);\n        parent.appendChild(div);\n        return div;\n    };\n\n    const createHarmony = (item) => {\n\n        const wrapper = createElement('wrapper', container);\n        const wheel = createElement('wheel', wrapper);\n        const harmony = createElement('harmony', wrapper);\n        createElement('label', wrapper).innerText = item.label;\n\n        fetch('images/wheel-additive.svg')\n            .then(result => result.text())\n            .then((svgCode) => {\n                const harmonyColors = ColorTranslator.getHarmony(baseColor, item.value);\n                const selector = 'path' + harmonyColors.map((color) => `:not([fill=\"${color}\"])`).join('');\n                wheel.innerHTML = svgCode;\n                harmonyColors.forEach((hex) => createElement('box', harmony).style.background = hex);\n                wheel.querySelectorAll(selector).forEach((path) => path.setAttribute('fill-opacity', '0.25'));\n            });\n\n    };\n\n    harmonies.forEach((item) => createHarmony(item));\n\n    return container;\n\n});\n;// ./src/@demo/demo11/index.js\n\n\n/* harmony default export */ const demo11 = ((ColorTranslator, { Harmony, Mix }) => {\n\n    const container = document.createElement('div');\n\n    const harmonies = [\n        { label: 'Complementary',       value: Harmony.COMPLEMENTARY },\n        { label: 'Split Complementary', value: Harmony.SPLIT_COMPLEMENTARY },\n        { label: 'Analogous',           value: Harmony.ANALOGOUS },\n        { label: 'Triadic',             value: Harmony.TRIADIC },\n        { label: 'Tetradic',            value: Harmony.TETRADIC },\n        { label: 'Square',              value: Harmony.SQUARE }\n    ];\n\n    const baseColor = '#F00';\n\n    const createElement = (className, parent) => {\n        const div = document.createElement('div');\n        div.classList.add(className);\n        parent.appendChild(div);\n        return div;\n    };\n\n    const createHarmony = (item) => {\n\n        const wrapper = createElement('wrapper', container);\n        const wheel = createElement('wheel', wrapper);\n        const harmony = createElement('harmony', wrapper);\n        createElement('label', wrapper).innerText = item.label;\n\n        fetch('images/wheel-subtractive.svg')\n            .then(result => result.text())\n            .then((svgCode) => {\n                const harmonyColors = ColorTranslator.getHarmony(baseColor, item.value, Mix.SUBTRACTIVE);\n                const selector = 'path' + harmonyColors.map((color) => `:not([fill=\"${color}\"])`).join('');\n                wheel.innerHTML = svgCode;\n                harmonyColors.forEach((hex) => createElement('box', harmony).style.background = hex);\n                wheel.querySelectorAll(selector).forEach((path) => path.setAttribute('fill-opacity', '0.25'));\n            });\n\n    };\n\n    harmonies.forEach((item) => createHarmony(item));\n\n    return container;\n\n});\n;// ./src/@demo/demo.js\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nconst functioToString = (fn) => {\n    const article = document.createElement('article');\n    const pre = document.createElement('pre');\n    article.classList.add('function-container');\n    pre.classList.add('prettyprint');\n    article.appendChild(pre);\n    pre.innerHTML = fn.toString().replace('(ColorTranslator)', '()');\n    return article;\n};\n\nconst demos = new Map([\n    ['demo1', demo1],\n    ['demo2', demo2],\n    ['demo3', demo3],\n    ['demo4', demo4],\n    ['demo5', demo5],\n    ['demo6', demo6],\n    ['demo7', demo7],\n    ['demo8', demo8],\n    ['demo9', demo9],\n    ['demo10', demo10],\n    ['demo11', demo11]\n]);\n\ndocument.addEventListener('DOMContentLoaded', () => {\n    demos.forEach((module, div) => {\n        const demo = document.getElementById(div);\n        const container = document.createElement('div');\n        const wrapper = document.createElement('div');\n\n        container.classList.add('demo-container');\n        wrapper.classList.add('demo-wrapper');\n\n        wrapper.appendChild(module(ColorTranslator, { Harmony: Harmony, Mix: Mix }));\n        container.appendChild(wrapper);\n        demo.appendChild(container);\n        demo.appendChild(functioToString(module));\n    });\n});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNjk5LmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxxQkFBTSxvQkFBb0IscUJBQU07QUFDMUM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLElBQUk7QUFDSjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxrQkFBa0IsaUJBQWlCO0FBQ25DO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBO0FBQ0EscURBQXFEO0FBQ3JELFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUiw0RUFBNEU7QUFDNUU7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLHNDQUFzQztBQUNoQztBQUNBO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBLENBQUMsd0JBQXdCOzs7QUMzTVk7QUFDOUI7QUFDUCxL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QUFDQTtBQUNBLGVBQWUsS0FBSztBQUNwQjtBQUNBO0FBQ0EsZUFBZSxLQUFLO0FBQ3BCO0FBQ0E7QUFDQSxlQUFlLEtBQUs7QUFDcEI7QUFDQTtBQUNBLGVBQWUsS0FBSztBQUNwQjtBQUNBO0FBQ0EsZUFBZSxLQUFLO0FBQ3BCO0FBQ0E7QUFDQSxlQUFlLEtBQUs7QUFDcEI7QUFDQTtBQUNBLGVBQWUsS0FBSztBQUNwQjtBQUNBO0FBQ0EsZUFBZSxjQUFvQjtBQUNuQztBQUNBO0FBQ0EsZUFBZSxjQUFvQjtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLEdBQUc7QUFDbEI7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxlQUFlLEdBQUc7QUFDbEI7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLFFBQVE7QUFDaEMsU0FBUztBQUNUO0FBQ0E7QUFDQSxlQUFlLEdBQUc7QUFDbEI7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxlQUFlLEdBQUc7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLGVBQWUsR0FBRztBQUNsQjtBQUNBO0FBQ0E7QUFDQSxT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WUFBWTtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxlQUFlLFlBQVk7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsZUFBZSxZQUFZO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLGVBQWUsWUFBWTtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxlQUFlLFlBQVk7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsZUFBZSxZQUFZO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLGVBQWUsWUFBWTtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxlQUFlLFlBQVk7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsZUFBZSxZQUFZO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLGVBQWUsWUFBWTtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxlQUFlLFlBQVk7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsZUFBZSxZQUFZO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLGVBQWUsWUFBWTtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxlQUFlLFlBQVk7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsZUFBZSxZQUFZO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7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VSw0REFBNEQ7QUFDdEUsVUFBVSxrRUFBa0U7QUFDNUUsVUFBVSx3REFBd0Q7QUFDbEUsVUFBVSxzREFBc0Q7QUFDaEUsVUFBVSx1REFBdUQ7QUFDakUsVUFBVTtBQUNWOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNGQUFzRixNQUFNO0FBQzVGO0FBQ0E7QUFDQTtBQUNBLGFBQWE7O0FBRWI7O0FBRUE7O0FBRUE7O0FBRUEsQ0FBQyxFOztBQy9DcUU7QUFDQTtBQUNIO0FBQzdDO0FBQ0M7QUFDNkI7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0U7QUFDQTs7QUFFOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsY0FBYyxLQUFLO0FBQ25CLGNBQWMsS0FBSztBQUNuQixjQUFjLEtBQUs7QUFDbkIsY0FBYyxLQUFLO0FBQ25CLGNBQWMsS0FBSztBQUNuQixjQUFjLEtBQUs7QUFDbkIsY0FBYyxLQUFLO0FBQ25CLGNBQWMsS0FBSztBQUNuQixjQUFjLEtBQUs7QUFDbkIsZUFBZSxNQUFNO0FBQ3JCLGVBQWUsTUFBTTtBQUNyQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsbUNBQW1DLGVBQWUsSUFBSSxPQUFPLGNBQUssT0FBRTtBQUNwRTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsQ0FBQyIsInNvdXJjZXMiOlsid2VicGFjazovL2NvbG9ydHJhbnNsYXRvci8uL25vZGVfbW9kdWxlcy8ucG5wbS93aGF0d2ctZmV0Y2hAMy42LjIwL25vZGVfbW9kdWxlcy93aGF0d2ctZmV0Y2gvZmV0Y2guanM/ZDRjYiIsIndlYnBhY2s6Ly9jb2xvcnRyYW5zbGF0b3IvLi9zcmMvY29uc3RhbnRzL251bWJlcnMudHM/YjZiNSIsIndlYnBhY2s6Ly9jb2xvcnRyYW5zbGF0b3IvLi9zcmMvY29uc3RhbnRzL2VudW1zLnRzPzkyYzAiLCJ3ZWJwYWNrOi8vY29sb3J0cmFuc2xhdG9yLy4vc3JjL2NvbnN0YW50cy9yZWdleHBzLnRzPzU0ZmEiLCJ3ZWJwYWNrOi8vY29sb3J0cmFuc2xhdG9yLy4vc3JjL2NvbnN0YW50cy9lcnJvcnMudHM/NjVhNSIsIndlYnBhY2s6Ly9jb2xvcnRyYW5zbGF0b3IvLi9zcmMvQHR5cGVzL2luZGV4LnRzPzFjNGYiLCJ3ZWJwYWNrOi8vY29sb3J0cmFuc2xhdG9yLy4vc3JjL2NvbnN0YW50cy9vcHRpb25zLnRzP2MyZjEiLCJ3ZWJwYWNrOi8vY29sb3J0cmFuc2xhdG9yLy4vc3JjL2NvbnN0YW50cy9pbmRleC50cz8yYWFhIiwid2VicGFjazovL2NvbG9ydHJhbnNsYXRvci8uL3NyYy9oZWxwZXJzL2luZGV4LnRzP2MwMzIiLCJ3ZWJwYWNrOi8vY29sb3J0cmFuc2xhdG9yLy4vc3JjL2NvbG9yL3RyYW5zbGF0b3JzLnRzP2NjNTMiLCJ3ZWJwYWNrOi8vY29sb3J0cmFuc2xhdG9yLy4vc3JjL3BhcnNlcnMvYmFzZUNsYXNzZXMvX1JnYkNsYXNzLnRzPzQ4MGUiLCJ3ZWJwYWNrOi8vY29sb3J0cmFuc2xhdG9yLy4vc3JjL3BhcnNlcnMvX0hFWFN0cmluZ1BhcnNlci50cz9iMDFlIiwid2VicGFjazovL2NvbG9ydHJhbnNsYXRvci8uL3NyYy9wYXJzZXJzL19DYWxjUGFyc2VyLnRzPzJlZTciLCJ3ZWJwYWNrOi8vY29sb3J0cmFuc2xhdG9yLy4vc3JjL3BhcnNlcnMvYmFzZUNsYXNzZXMvX0FscGhhQmFzZUNsYXNzLnRzPzdjMWIiLCJ3ZWJwYWNrOi8vY29sb3J0cmFuc2xhdG9yLy4vc3JjL3BhcnNlcnMvX1JHQlN0cmluZ1BhcnNlci50cz8yMjQ4Iiwid2VicGFjazovL2NvbG9ydHJhbnNsYXRvci8uL3NyYy9wYXJzZXJzL2Jhc2VDbGFzc2VzL19IdWVCYXNlQ2xhc3MudHM/Nzc3NCIsIndlYnBhY2s6Ly9jb2xvcnRyYW5zbGF0b3IvLi9zcmMvcGFyc2Vycy9fSFNMU3RyaW5nUGFyc2VyLnRzP2UzYWQiLCJ3ZWJwYWNrOi8vY29sb3J0cmFuc2xhdG9yLy4vc3JjL3BhcnNlcnMvX0hXQlN0cmluZ1BhcnNlci50cz8yYjE0Iiwid2VicGFjazovL2NvbG9ydHJhbnNsYXRvci8uL3NyYy9wYXJzZXJzL19DSUVMYWJTdHJpbmdQYXJzZXIudHM/ZTk3OCIsIndlYnBhY2s6Ly9jb2xvcnRyYW5zbGF0b3IvLi9zcmMvcGFyc2Vycy9fTENIU3RyaW5nUGFyc2VyLnRzPzMwNjEiLCJ3ZWJwYWNrOi8vY29sb3J0cmFuc2xhdG9yLy4vc3JjL3BhcnNlcnMvX0NNWUtTdHJpbmdQYXJzZXIudHM/NmZkYiIsIndlYnBhY2s6Ly9jb2xvcnRyYW5zbGF0b3IvLi9zcmMvcGFyc2Vycy9pbmRleC50cz9hNGM5Iiwid2VicGFjazovL2NvbG9ydHJhbnNsYXRvci8uL3NyYy9jb2xvci9leHRyYWN0b3JzLnRzPzg0NGYiLCJ3ZWJwYWNrOi8vY29sb3J0cmFuc2xhdG9yLy4vc3JjL2NvbG9yL3JvdW5kZXJzLnRzPzk4YWMiLCJ3ZWJwYWNrOi8vY29sb3J0cmFuc2xhdG9yLy4vc3JjL2NvbG9yL2Nzcy50cz9iOWNhIiwid2VicGFjazovL2NvbG9ydHJhbnNsYXRvci8uL3NyYy9jb2xvci91dGlscy50cz9lOWFhIiwid2VicGFjazovL2NvbG9ydHJhbnNsYXRvci8uL3NyYy9yZXR1cm5zL2luZGV4LnRzP2RhYTgiLCJ3ZWJwYWNrOi8vY29sb3J0cmFuc2xhdG9yLy4vc3JjL2luZGV4LnRzP2VmNDAiLCJ3ZWJwYWNrOi8vY29sb3J0cmFuc2xhdG9yLy4vc3JjL0BkZW1vL2RlbW8xL2luZGV4LmpzPzM5NjUiLCJ3ZWJwYWNrOi8vY29sb3J0cmFuc2xhdG9yLy4vc3JjL0BkZW1vL2RlbW8yL2luZGV4LmpzP2Q4ZGMiLCJ3ZWJwYWNrOi8vY29sb3J0cmFuc2xhdG9yLy4vc3JjL0BkZW1vL2RlbW8zL2luZGV4LmpzP2QzODYiLCJ3ZWJwYWNrOi8vY29sb3J0cmFuc2xhdG9yLy4vc3JjL0BkZW1vL2RlbW80L2luZGV4LmpzPzYxOWYiLCJ3ZWJwYWNrOi8vY29sb3J0cmFuc2xhdG9yLy4vc3JjL0BkZW1vL2RlbW81L2luZGV4LmpzP2Q4Y2MiLCJ3ZWJwYWNrOi8vY29sb3J0cmFuc2xhdG9yLy4vc3JjL0BkZW1vL2RlbW82L2luZGV4LmpzPzNhMzIiLCJ3ZWJwYWNrOi8vY29sb3J0cmFuc2xhdG9yLy4vc3JjL0BkZW1vL2RlbW83L2luZGV4LmpzPzgzNDMiLCJ3ZWJwYWNrOi8vY29sb3J0cmFuc2xhdG9yLy4vc3JjL0BkZW1vL2RlbW84L2luZGV4LmpzPzc3MjUiLCJ3ZWJwYWNrOi8vY29sb3J0cmFuc2xhdG9yLy4vc3JjL0BkZW1vL2RlbW85L2luZGV4LmpzPzg1MzIiLCJ3ZWJwYWNrOi8vY29sb3J0cmFuc2xhdG9yLy4vc3JjL0BkZW1vL2RlbW8xMC9pbmRleC5qcz80ZjY3Iiwid2VicGFjazovL2NvbG9ydHJhbnNsYXRvci8uL3NyYy9AZGVtby9kZW1vMTEvaW5kZXguanM/ZGJlNiIsIndlYnBhY2s6Ly9jb2xvcnRyYW5zbGF0b3IvLi9zcmMvQGRlbW8vZGVtby5qcz85YjdkIl0sInNvdXJjZXNDb250ZW50IjpbIi8qIGVzbGludC1kaXNhYmxlIG5vLXByb3RvdHlwZS1idWlsdGlucyAqL1xudmFyIGcgPVxuICAodHlwZW9mIGdsb2JhbFRoaXMgIT09ICd1bmRlZmluZWQnICYmIGdsb2JhbFRoaXMpIHx8XG4gICh0eXBlb2Ygc2VsZiAhPT0gJ3VuZGVmaW5lZCcgJiYgc2VsZikgfHxcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVuZGVmXG4gICh0eXBlb2YgZ2xvYmFsICE9PSAndW5kZWZpbmVkJyAmJiBnbG9iYWwpIHx8XG4gIHt9XG5cbnZhciBzdXBwb3J0ID0ge1xuICBzZWFyY2hQYXJhbXM6ICdVUkxTZWFyY2hQYXJhbXMnIGluIGcsXG4gIGl0ZXJhYmxlOiAnU3ltYm9sJyBpbiBnICYmICdpdGVyYXRvcicgaW4gU3ltYm9sLFxuICBibG9iOlxuICAgICdGaWxlUmVhZGVyJyBpbiBnICYmXG4gICAgJ0Jsb2InIGluIGcgJiZcbiAgICAoZnVuY3Rpb24oKSB7XG4gICAgICB0cnkge1xuICAgICAgICBuZXcgQmxvYigpXG4gICAgICAgIHJldHVybiB0cnVlXG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgfVxuICAgIH0pKCksXG4gIGZvcm1EYXRhOiAnRm9ybURhdGEnIGluIGcsXG4gIGFycmF5QnVmZmVyOiAnQXJyYXlCdWZmZXInIGluIGdcbn1cblxuZnVuY3Rpb24gaXNEYXRhVmlldyhvYmopIHtcbiAgcmV0dXJuIG9iaiAmJiBEYXRhVmlldy5wcm90b3R5cGUuaXNQcm90b3R5cGVPZihvYmopXG59XG5cbmlmIChzdXBwb3J0LmFycmF5QnVmZmVyKSB7XG4gIHZhciB2aWV3Q2xhc3NlcyA9IFtcbiAgICAnW29iamVjdCBJbnQ4QXJyYXldJyxcbiAgICAnW29iamVjdCBVaW50OEFycmF5XScsXG4gICAgJ1tvYmplY3QgVWludDhDbGFtcGVkQXJyYXldJyxcbiAgICAnW29iamVjdCBJbnQxNkFycmF5XScsXG4gICAgJ1tvYmplY3QgVWludDE2QXJyYXldJyxcbiAgICAnW29iamVjdCBJbnQzMkFycmF5XScsXG4gICAgJ1tvYmplY3QgVWludDMyQXJyYXldJyxcbiAgICAnW29iamVjdCBGbG9hdDMyQXJyYXldJyxcbiAgICAnW29iamVjdCBGbG9hdDY0QXJyYXldJ1xuICBdXG5cbiAgdmFyIGlzQXJyYXlCdWZmZXJWaWV3ID1cbiAgICBBcnJheUJ1ZmZlci5pc1ZpZXcgfHxcbiAgICBmdW5jdGlvbihvYmopIHtcbiAgICAgIHJldHVybiBvYmogJiYgdmlld0NsYXNzZXMuaW5kZXhPZihPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwob2JqKSkgPiAtMVxuICAgIH1cbn1cblxuZnVuY3Rpb24gbm9ybWFsaXplTmFtZShuYW1lKSB7XG4gIGlmICh0eXBlb2YgbmFtZSAhPT0gJ3N0cmluZycpIHtcbiAgICBuYW1lID0gU3RyaW5nKG5hbWUpXG4gIH1cbiAgaWYgKC9bXmEtejAtOVxcLSMkJSYnKisuXl9gfH4hXS9pLnRlc3QobmFtZSkgfHwgbmFtZSA9PT0gJycpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdJbnZhbGlkIGNoYXJhY3RlciBpbiBoZWFkZXIgZmllbGQgbmFtZTogXCInICsgbmFtZSArICdcIicpXG4gIH1cbiAgcmV0dXJuIG5hbWUudG9Mb3dlckNhc2UoKVxufVxuXG5mdW5jdGlvbiBub3JtYWxpemVWYWx1ZSh2YWx1ZSkge1xuICBpZiAodHlwZW9mIHZhbHVlICE9PSAnc3RyaW5nJykge1xuICAgIHZhbHVlID0gU3RyaW5nKHZhbHVlKVxuICB9XG4gIHJldHVybiB2YWx1ZVxufVxuXG4vLyBCdWlsZCBhIGRlc3RydWN0aXZlIGl0ZXJhdG9yIGZvciB0aGUgdmFsdWUgbGlzdFxuZnVuY3Rpb24gaXRlcmF0b3JGb3IoaXRlbXMpIHtcbiAgdmFyIGl0ZXJhdG9yID0ge1xuICAgIG5leHQ6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHZhbHVlID0gaXRlbXMuc2hpZnQoKVxuICAgICAgcmV0dXJuIHtkb25lOiB2YWx1ZSA9PT0gdW5kZWZpbmVkLCB2YWx1ZTogdmFsdWV9XG4gICAgfVxuICB9XG5cbiAgaWYgKHN1cHBvcnQuaXRlcmFibGUpIHtcbiAgICBpdGVyYXRvcltTeW1ib2wuaXRlcmF0b3JdID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gaXRlcmF0b3JcbiAgICB9XG4gIH1cblxuICByZXR1cm4gaXRlcmF0b3Jcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIEhlYWRlcnMoaGVhZGVycykge1xuICB0aGlzLm1hcCA9IHt9XG5cbiAgaWYgKGhlYWRlcnMgaW5zdGFuY2VvZiBIZWFkZXJzKSB7XG4gICAgaGVhZGVycy5mb3JFYWNoKGZ1bmN0aW9uKHZhbHVlLCBuYW1lKSB7XG4gICAgICB0aGlzLmFwcGVuZChuYW1lLCB2YWx1ZSlcbiAgICB9LCB0aGlzKVxuICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkoaGVhZGVycykpIHtcbiAgICBoZWFkZXJzLmZvckVhY2goZnVuY3Rpb24oaGVhZGVyKSB7XG4gICAgICBpZiAoaGVhZGVyLmxlbmd0aCAhPSAyKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0hlYWRlcnMgY29uc3RydWN0b3I6IGV4cGVjdGVkIG5hbWUvdmFsdWUgcGFpciB0byBiZSBsZW5ndGggMiwgZm91bmQnICsgaGVhZGVyLmxlbmd0aClcbiAgICAgIH1cbiAgICAgIHRoaXMuYXBwZW5kKGhlYWRlclswXSwgaGVhZGVyWzFdKVxuICAgIH0sIHRoaXMpXG4gIH0gZWxzZSBpZiAoaGVhZGVycykge1xuICAgIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKGhlYWRlcnMpLmZvckVhY2goZnVuY3Rpb24obmFtZSkge1xuICAgICAgdGhpcy5hcHBlbmQobmFtZSwgaGVhZGVyc1tuYW1lXSlcbiAgICB9LCB0aGlzKVxuICB9XG59XG5cbkhlYWRlcnMucHJvdG90eXBlLmFwcGVuZCA9IGZ1bmN0aW9uKG5hbWUsIHZhbHVlKSB7XG4gIG5hbWUgPSBub3JtYWxpemVOYW1lKG5hbWUpXG4gIHZhbHVlID0gbm9ybWFsaXplVmFsdWUodmFsdWUpXG4gIHZhciBvbGRWYWx1ZSA9IHRoaXMubWFwW25hbWVdXG4gIHRoaXMubWFwW25hbWVdID0gb2xkVmFsdWUgPyBvbGRWYWx1ZSArICcsICcgKyB2YWx1ZSA6IHZhbHVlXG59XG5cbkhlYWRlcnMucHJvdG90eXBlWydkZWxldGUnXSA9IGZ1bmN0aW9uKG5hbWUpIHtcbiAgZGVsZXRlIHRoaXMubWFwW25vcm1hbGl6ZU5hbWUobmFtZSldXG59XG5cbkhlYWRlcnMucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uKG5hbWUpIHtcbiAgbmFtZSA9IG5vcm1hbGl6ZU5hbWUobmFtZSlcbiAgcmV0dXJuIHRoaXMuaGFzKG5hbWUpID8gdGhpcy5tYXBbbmFtZV0gOiBudWxsXG59XG5cbkhlYWRlcnMucHJvdG90eXBlLmhhcyA9IGZ1bmN0aW9uKG5hbWUpIHtcbiAgcmV0dXJuIHRoaXMubWFwLmhhc093blByb3BlcnR5KG5vcm1hbGl6ZU5hbWUobmFtZSkpXG59XG5cbkhlYWRlcnMucHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uKG5hbWUsIHZhbHVlKSB7XG4gIHRoaXMubWFwW25vcm1hbGl6ZU5hbWUobmFtZSldID0gbm9ybWFsaXplVmFsdWUodmFsdWUpXG59XG5cbkhlYWRlcnMucHJvdG90eXBlLmZvckVhY2ggPSBmdW5jdGlvbihjYWxsYmFjaywgdGhpc0FyZykge1xuICBmb3IgKHZhciBuYW1lIGluIHRoaXMubWFwKSB7XG4gICAgaWYgKHRoaXMubWFwLmhhc093blByb3BlcnR5KG5hbWUpKSB7XG4gICAgICBjYWxsYmFjay5jYWxsKHRoaXNBcmcsIHRoaXMubWFwW25hbWVdLCBuYW1lLCB0aGlzKVxuICAgIH1cbiAgfVxufVxuXG5IZWFkZXJzLnByb3RvdHlwZS5rZXlzID0gZnVuY3Rpb24oKSB7XG4gIHZhciBpdGVtcyA9IFtdXG4gIHRoaXMuZm9yRWFjaChmdW5jdGlvbih2YWx1ZSwgbmFtZSkge1xuICAgIGl0ZW1zLnB1c2gobmFtZSlcbiAgfSlcbiAgcmV0dXJuIGl0ZXJhdG9yRm9yKGl0ZW1zKVxufVxuXG5IZWFkZXJzLnByb3RvdHlwZS52YWx1ZXMgPSBmdW5jdGlvbigpIHtcbiAgdmFyIGl0ZW1zID0gW11cbiAgdGhpcy5mb3JFYWNoKGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgaXRlbXMucHVzaCh2YWx1ZSlcbiAgfSlcbiAgcmV0dXJuIGl0ZXJhdG9yRm9yKGl0ZW1zKVxufVxuXG5IZWFkZXJzLnByb3RvdHlwZS5lbnRyaWVzID0gZnVuY3Rpb24oKSB7XG4gIHZhciBpdGVtcyA9IFtdXG4gIHRoaXMuZm9yRWFjaChmdW5jdGlvbih2YWx1ZSwgbmFtZSkge1xuICAgIGl0ZW1zLnB1c2goW25hbWUsIHZhbHVlXSlcbiAgfSlcbiAgcmV0dXJuIGl0ZXJhdG9yRm9yKGl0ZW1zKVxufVxuXG5pZiAoc3VwcG9ydC5pdGVyYWJsZSkge1xuICBIZWFkZXJzLnByb3RvdHlwZVtTeW1ib2wuaXRlcmF0b3JdID0gSGVhZGVycy5wcm90b3R5cGUuZW50cmllc1xufVxuXG5mdW5jdGlvbiBjb25zdW1lZChib2R5KSB7XG4gIGlmIChib2R5Ll9ub0JvZHkpIHJldHVyblxuICBpZiAoYm9keS5ib2R5VXNlZCkge1xuICAgIHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgVHlwZUVycm9yKCdBbHJlYWR5IHJlYWQnKSlcbiAgfVxuICBib2R5LmJvZHlVc2VkID0gdHJ1ZVxufVxuXG5mdW5jdGlvbiBmaWxlUmVhZGVyUmVhZHkocmVhZGVyKSB7XG4gIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcbiAgICByZWFkZXIub25sb2FkID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXNvbHZlKHJlYWRlci5yZXN1bHQpXG4gICAgfVxuICAgIHJlYWRlci5vbmVycm9yID0gZnVuY3Rpb24oKSB7XG4gICAgICByZWplY3QocmVhZGVyLmVycm9yKVxuICAgIH1cbiAgfSlcbn1cblxuZnVuY3Rpb24gcmVhZEJsb2JBc0FycmF5QnVmZmVyKGJsb2IpIHtcbiAgdmFyIHJlYWRlciA9IG5ldyBGaWxlUmVhZGVyKClcbiAgdmFyIHByb21pc2UgPSBmaWxlUmVhZGVyUmVhZHkocmVhZGVyKVxuICByZWFkZXIucmVhZEFzQXJyYXlCdWZmZXIoYmxvYilcbiAgcmV0dXJuIHByb21pc2Vcbn1cblxuZnVuY3Rpb24gcmVhZEJsb2JBc1RleHQoYmxvYikge1xuICB2YXIgcmVhZGVyID0gbmV3IEZpbGVSZWFkZXIoKVxuICB2YXIgcHJvbWlzZSA9IGZpbGVSZWFkZXJSZWFkeShyZWFkZXIpXG4gIHZhciBtYXRjaCA9IC9jaGFyc2V0PShbQS1aYS16MC05Xy1dKykvLmV4ZWMoYmxvYi50eXBlKVxuICB2YXIgZW5jb2RpbmcgPSBtYXRjaCA/IG1hdGNoWzFdIDogJ3V0Zi04J1xuICByZWFkZXIucmVhZEFzVGV4dChibG9iLCBlbmNvZGluZylcbiAgcmV0dXJuIHByb21pc2Vcbn1cblxuZnVuY3Rpb24gcmVhZEFycmF5QnVmZmVyQXNUZXh0KGJ1Zikge1xuICB2YXIgdmlldyA9IG5ldyBVaW50OEFycmF5KGJ1ZilcbiAgdmFyIGNoYXJzID0gbmV3IEFycmF5KHZpZXcubGVuZ3RoKVxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdmlldy5sZW5ndGg7IGkrKykge1xuICAgIGNoYXJzW2ldID0gU3RyaW5nLmZyb21DaGFyQ29kZSh2aWV3W2ldKVxuICB9XG4gIHJldHVybiBjaGFycy5qb2luKCcnKVxufVxuXG5mdW5jdGlvbiBidWZmZXJDbG9uZShidWYpIHtcbiAgaWYgKGJ1Zi5zbGljZSkge1xuICAgIHJldHVybiBidWYuc2xpY2UoMClcbiAgfSBlbHNlIHtcbiAgICB2YXIgdmlldyA9IG5ldyBVaW50OEFycmF5KGJ1Zi5ieXRlTGVuZ3RoKVxuICAgIHZpZXcuc2V0KG5ldyBVaW50OEFycmF5KGJ1ZikpXG4gICAgcmV0dXJuIHZpZXcuYnVmZmVyXG4gIH1cbn1cblxuZnVuY3Rpb24gQm9keSgpIHtcbiAgdGhpcy5ib2R5VXNlZCA9IGZhbHNlXG5cbiAgdGhpcy5faW5pdEJvZHkgPSBmdW5jdGlvbihib2R5KSB7XG4gICAgLypcbiAgICAgIGZldGNoLW1vY2sgd3JhcHMgdGhlIFJlc3BvbnNlIG9iamVjdCBpbiBhbiBFUzYgUHJveHkgdG9cbiAgICAgIHByb3ZpZGUgdXNlZnVsIHRlc3QgaGFybmVzcyBmZWF0dXJlcyBzdWNoIGFzIGZsdXNoLiBIb3dldmVyLCBvblxuICAgICAgRVM1IGJyb3dzZXJzIHdpdGhvdXQgZmV0Y2ggb3IgUHJveHkgc3VwcG9ydCBwb2xseWZpbGxzIG11c3QgYmUgdXNlZDtcbiAgICAgIHRoZSBwcm94eS1wb2xseWZpbGwgaXMgdW5hYmxlIHRvIHByb3h5IGFuIGF0dHJpYnV0ZSB1bmxlc3MgaXQgZXhpc3RzXG4gICAgICBvbiB0aGUgb2JqZWN0IGJlZm9yZSB0aGUgUHJveHkgaXMgY3JlYXRlZC4gVGhpcyBjaGFuZ2UgZW5zdXJlc1xuICAgICAgUmVzcG9uc2UuYm9keVVzZWQgZXhpc3RzIG9uIHRoZSBpbnN0YW5jZSwgd2hpbGUgbWFpbnRhaW5pbmcgdGhlXG4gICAgICBzZW1hbnRpYyBvZiBzZXR0aW5nIFJlcXVlc3QuYm9keVVzZWQgaW4gdGhlIGNvbnN0cnVjdG9yIGJlZm9yZVxuICAgICAgX2luaXRCb2R5IGlzIGNhbGxlZC5cbiAgICAqL1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1zZWxmLWFzc2lnblxuICAgIHRoaXMuYm9keVVzZWQgPSB0aGlzLmJvZHlVc2VkXG4gICAgdGhpcy5fYm9keUluaXQgPSBib2R5XG4gICAgaWYgKCFib2R5KSB7XG4gICAgICB0aGlzLl9ub0JvZHkgPSB0cnVlO1xuICAgICAgdGhpcy5fYm9keVRleHQgPSAnJ1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIGJvZHkgPT09ICdzdHJpbmcnKSB7XG4gICAgICB0aGlzLl9ib2R5VGV4dCA9IGJvZHlcbiAgICB9IGVsc2UgaWYgKHN1cHBvcnQuYmxvYiAmJiBCbG9iLnByb3RvdHlwZS5pc1Byb3RvdHlwZU9mKGJvZHkpKSB7XG4gICAgICB0aGlzLl9ib2R5QmxvYiA9IGJvZHlcbiAgICB9IGVsc2UgaWYgKHN1cHBvcnQuZm9ybURhdGEgJiYgRm9ybURhdGEucHJvdG90eXBlLmlzUHJvdG90eXBlT2YoYm9keSkpIHtcbiAgICAgIHRoaXMuX2JvZHlGb3JtRGF0YSA9IGJvZHlcbiAgICB9IGVsc2UgaWYgKHN1cHBvcnQuc2VhcmNoUGFyYW1zICYmIFVSTFNlYXJjaFBhcmFtcy5wcm90b3R5cGUuaXNQcm90b3R5cGVPZihib2R5KSkge1xuICAgICAgdGhpcy5fYm9keVRleHQgPSBib2R5LnRvU3RyaW5nKClcbiAgICB9IGVsc2UgaWYgKHN1cHBvcnQuYXJyYXlCdWZmZXIgJiYgc3VwcG9ydC5ibG9iICYmIGlzRGF0YVZpZXcoYm9keSkpIHtcbiAgICAgIHRoaXMuX2JvZHlBcnJheUJ1ZmZlciA9IGJ1ZmZlckNsb25lKGJvZHkuYnVmZmVyKVxuICAgICAgLy8gSUUgMTAtMTEgY2FuJ3QgaGFuZGxlIGEgRGF0YVZpZXcgYm9keS5cbiAgICAgIHRoaXMuX2JvZHlJbml0ID0gbmV3IEJsb2IoW3RoaXMuX2JvZHlBcnJheUJ1ZmZlcl0pXG4gICAgfSBlbHNlIGlmIChzdXBwb3J0LmFycmF5QnVmZmVyICYmIChBcnJheUJ1ZmZlci5wcm90b3R5cGUuaXNQcm90b3R5cGVPZihib2R5KSB8fCBpc0FycmF5QnVmZmVyVmlldyhib2R5KSkpIHtcbiAgICAgIHRoaXMuX2JvZHlBcnJheUJ1ZmZlciA9IGJ1ZmZlckNsb25lKGJvZHkpXG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX2JvZHlUZXh0ID0gYm9keSA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChib2R5KVxuICAgIH1cblxuICAgIGlmICghdGhpcy5oZWFkZXJzLmdldCgnY29udGVudC10eXBlJykpIHtcbiAgICAgIGlmICh0eXBlb2YgYm9keSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgdGhpcy5oZWFkZXJzLnNldCgnY29udGVudC10eXBlJywgJ3RleHQvcGxhaW47Y2hhcnNldD1VVEYtOCcpXG4gICAgICB9IGVsc2UgaWYgKHRoaXMuX2JvZHlCbG9iICYmIHRoaXMuX2JvZHlCbG9iLnR5cGUpIHtcbiAgICAgICAgdGhpcy5oZWFkZXJzLnNldCgnY29udGVudC10eXBlJywgdGhpcy5fYm9keUJsb2IudHlwZSlcbiAgICAgIH0gZWxzZSBpZiAoc3VwcG9ydC5zZWFyY2hQYXJhbXMgJiYgVVJMU2VhcmNoUGFyYW1zLnByb3RvdHlwZS5pc1Byb3RvdHlwZU9mKGJvZHkpKSB7XG4gICAgICAgIHRoaXMuaGVhZGVycy5zZXQoJ2NvbnRlbnQtdHlwZScsICdhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWQ7Y2hhcnNldD1VVEYtOCcpXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgaWYgKHN1cHBvcnQuYmxvYikge1xuICAgIHRoaXMuYmxvYiA9IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHJlamVjdGVkID0gY29uc3VtZWQodGhpcylcbiAgICAgIGlmIChyZWplY3RlZCkge1xuICAgICAgICByZXR1cm4gcmVqZWN0ZWRcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuX2JvZHlCbG9iKSB7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUodGhpcy5fYm9keUJsb2IpXG4gICAgICB9IGVsc2UgaWYgKHRoaXMuX2JvZHlBcnJheUJ1ZmZlcikge1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKG5ldyBCbG9iKFt0aGlzLl9ib2R5QXJyYXlCdWZmZXJdKSlcbiAgICAgIH0gZWxzZSBpZiAodGhpcy5fYm9keUZvcm1EYXRhKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignY291bGQgbm90IHJlYWQgRm9ybURhdGEgYm9keSBhcyBibG9iJylcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUobmV3IEJsb2IoW3RoaXMuX2JvZHlUZXh0XSkpXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgdGhpcy5hcnJheUJ1ZmZlciA9IGZ1bmN0aW9uKCkge1xuICAgIGlmICh0aGlzLl9ib2R5QXJyYXlCdWZmZXIpIHtcbiAgICAgIHZhciBpc0NvbnN1bWVkID0gY29uc3VtZWQodGhpcylcbiAgICAgIGlmIChpc0NvbnN1bWVkKSB7XG4gICAgICAgIHJldHVybiBpc0NvbnN1bWVkXG4gICAgICB9IGVsc2UgaWYgKEFycmF5QnVmZmVyLmlzVmlldyh0aGlzLl9ib2R5QXJyYXlCdWZmZXIpKSB7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoXG4gICAgICAgICAgdGhpcy5fYm9keUFycmF5QnVmZmVyLmJ1ZmZlci5zbGljZShcbiAgICAgICAgICAgIHRoaXMuX2JvZHlBcnJheUJ1ZmZlci5ieXRlT2Zmc2V0LFxuICAgICAgICAgICAgdGhpcy5fYm9keUFycmF5QnVmZmVyLmJ5dGVPZmZzZXQgKyB0aGlzLl9ib2R5QXJyYXlCdWZmZXIuYnl0ZUxlbmd0aFxuICAgICAgICAgIClcbiAgICAgICAgKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh0aGlzLl9ib2R5QXJyYXlCdWZmZXIpXG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChzdXBwb3J0LmJsb2IpIHtcbiAgICAgIHJldHVybiB0aGlzLmJsb2IoKS50aGVuKHJlYWRCbG9iQXNBcnJheUJ1ZmZlcilcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdjb3VsZCBub3QgcmVhZCBhcyBBcnJheUJ1ZmZlcicpXG4gICAgfVxuICB9XG5cbiAgdGhpcy50ZXh0ID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHJlamVjdGVkID0gY29uc3VtZWQodGhpcylcbiAgICBpZiAocmVqZWN0ZWQpIHtcbiAgICAgIHJldHVybiByZWplY3RlZFxuICAgIH1cblxuICAgIGlmICh0aGlzLl9ib2R5QmxvYikge1xuICAgICAgcmV0dXJuIHJlYWRCbG9iQXNUZXh0KHRoaXMuX2JvZHlCbG9iKVxuICAgIH0gZWxzZSBpZiAodGhpcy5fYm9keUFycmF5QnVmZmVyKSB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHJlYWRBcnJheUJ1ZmZlckFzVGV4dCh0aGlzLl9ib2R5QXJyYXlCdWZmZXIpKVxuICAgIH0gZWxzZSBpZiAodGhpcy5fYm9keUZvcm1EYXRhKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2NvdWxkIG5vdCByZWFkIEZvcm1EYXRhIGJvZHkgYXMgdGV4dCcpXG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUodGhpcy5fYm9keVRleHQpXG4gICAgfVxuICB9XG5cbiAgaWYgKHN1cHBvcnQuZm9ybURhdGEpIHtcbiAgICB0aGlzLmZvcm1EYXRhID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy50ZXh0KCkudGhlbihkZWNvZGUpXG4gICAgfVxuICB9XG5cbiAgdGhpcy5qc29uID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMudGV4dCgpLnRoZW4oSlNPTi5wYXJzZSlcbiAgfVxuXG4gIHJldHVybiB0aGlzXG59XG5cbi8vIEhUVFAgbWV0aG9kcyB3aG9zZSBjYXBpdGFsaXphdGlvbiBzaG91bGQgYmUgbm9ybWFsaXplZFxudmFyIG1ldGhvZHMgPSBbJ0NPTk5FQ1QnLCAnREVMRVRFJywgJ0dFVCcsICdIRUFEJywgJ09QVElPTlMnLCAnUEFUQ0gnLCAnUE9TVCcsICdQVVQnLCAnVFJBQ0UnXVxuXG5mdW5jdGlvbiBub3JtYWxpemVNZXRob2QobWV0aG9kKSB7XG4gIHZhciB1cGNhc2VkID0gbWV0aG9kLnRvVXBwZXJDYXNlKClcbiAgcmV0dXJuIG1ldGhvZHMuaW5kZXhPZih1cGNhc2VkKSA+IC0xID8gdXBjYXNlZCA6IG1ldGhvZFxufVxuXG5leHBvcnQgZnVuY3Rpb24gUmVxdWVzdChpbnB1dCwgb3B0aW9ucykge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgUmVxdWVzdCkpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdQbGVhc2UgdXNlIHRoZSBcIm5ld1wiIG9wZXJhdG9yLCB0aGlzIERPTSBvYmplY3QgY29uc3RydWN0b3IgY2Fubm90IGJlIGNhbGxlZCBhcyBhIGZ1bmN0aW9uLicpXG4gIH1cblxuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fVxuICB2YXIgYm9keSA9IG9wdGlvbnMuYm9keVxuXG4gIGlmIChpbnB1dCBpbnN0YW5jZW9mIFJlcXVlc3QpIHtcbiAgICBpZiAoaW5wdXQuYm9keVVzZWQpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FscmVhZHkgcmVhZCcpXG4gICAgfVxuICAgIHRoaXMudXJsID0gaW5wdXQudXJsXG4gICAgdGhpcy5jcmVkZW50aWFscyA9IGlucHV0LmNyZWRlbnRpYWxzXG4gICAgaWYgKCFvcHRpb25zLmhlYWRlcnMpIHtcbiAgICAgIHRoaXMuaGVhZGVycyA9IG5ldyBIZWFkZXJzKGlucHV0LmhlYWRlcnMpXG4gICAgfVxuICAgIHRoaXMubWV0aG9kID0gaW5wdXQubWV0aG9kXG4gICAgdGhpcy5tb2RlID0gaW5wdXQubW9kZVxuICAgIHRoaXMuc2lnbmFsID0gaW5wdXQuc2lnbmFsXG4gICAgaWYgKCFib2R5ICYmIGlucHV0Ll9ib2R5SW5pdCAhPSBudWxsKSB7XG4gICAgICBib2R5ID0gaW5wdXQuX2JvZHlJbml0XG4gICAgICBpbnB1dC5ib2R5VXNlZCA9IHRydWVcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdGhpcy51cmwgPSBTdHJpbmcoaW5wdXQpXG4gIH1cblxuICB0aGlzLmNyZWRlbnRpYWxzID0gb3B0aW9ucy5jcmVkZW50aWFscyB8fCB0aGlzLmNyZWRlbnRpYWxzIHx8ICdzYW1lLW9yaWdpbidcbiAgaWYgKG9wdGlvbnMuaGVhZGVycyB8fCAhdGhpcy5oZWFkZXJzKSB7XG4gICAgdGhpcy5oZWFkZXJzID0gbmV3IEhlYWRlcnMob3B0aW9ucy5oZWFkZXJzKVxuICB9XG4gIHRoaXMubWV0aG9kID0gbm9ybWFsaXplTWV0aG9kKG9wdGlvbnMubWV0aG9kIHx8IHRoaXMubWV0aG9kIHx8ICdHRVQnKVxuICB0aGlzLm1vZGUgPSBvcHRpb25zLm1vZGUgfHwgdGhpcy5tb2RlIHx8IG51bGxcbiAgdGhpcy5zaWduYWwgPSBvcHRpb25zLnNpZ25hbCB8fCB0aGlzLnNpZ25hbCB8fCAoZnVuY3Rpb24gKCkge1xuICAgIGlmICgnQWJvcnRDb250cm9sbGVyJyBpbiBnKSB7XG4gICAgICB2YXIgY3RybCA9IG5ldyBBYm9ydENvbnRyb2xsZXIoKTtcbiAgICAgIHJldHVybiBjdHJsLnNpZ25hbDtcbiAgICB9XG4gIH0oKSk7XG4gIHRoaXMucmVmZXJyZXIgPSBudWxsXG5cbiAgaWYgKCh0aGlzLm1ldGhvZCA9PT0gJ0dFVCcgfHwgdGhpcy5tZXRob2QgPT09ICdIRUFEJykgJiYgYm9keSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0JvZHkgbm90IGFsbG93ZWQgZm9yIEdFVCBvciBIRUFEIHJlcXVlc3RzJylcbiAgfVxuICB0aGlzLl9pbml0Qm9keShib2R5KVxuXG4gIGlmICh0aGlzLm1ldGhvZCA9PT0gJ0dFVCcgfHwgdGhpcy5tZXRob2QgPT09ICdIRUFEJykge1xuICAgIGlmIChvcHRpb25zLmNhY2hlID09PSAnbm8tc3RvcmUnIHx8IG9wdGlvbnMuY2FjaGUgPT09ICduby1jYWNoZScpIHtcbiAgICAgIC8vIFNlYXJjaCBmb3IgYSAnXycgcGFyYW1ldGVyIGluIHRoZSBxdWVyeSBzdHJpbmdcbiAgICAgIHZhciByZVBhcmFtU2VhcmNoID0gLyhbPyZdKV89W14mXSovXG4gICAgICBpZiAocmVQYXJhbVNlYXJjaC50ZXN0KHRoaXMudXJsKSkge1xuICAgICAgICAvLyBJZiBpdCBhbHJlYWR5IGV4aXN0cyB0aGVuIHNldCB0aGUgdmFsdWUgd2l0aCB0aGUgY3VycmVudCB0aW1lXG4gICAgICAgIHRoaXMudXJsID0gdGhpcy51cmwucmVwbGFjZShyZVBhcmFtU2VhcmNoLCAnJDFfPScgKyBuZXcgRGF0ZSgpLmdldFRpbWUoKSlcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIE90aGVyd2lzZSBhZGQgYSBuZXcgJ18nIHBhcmFtZXRlciB0byB0aGUgZW5kIHdpdGggdGhlIGN1cnJlbnQgdGltZVxuICAgICAgICB2YXIgcmVRdWVyeVN0cmluZyA9IC9cXD8vXG4gICAgICAgIHRoaXMudXJsICs9IChyZVF1ZXJ5U3RyaW5nLnRlc3QodGhpcy51cmwpID8gJyYnIDogJz8nKSArICdfPScgKyBuZXcgRGF0ZSgpLmdldFRpbWUoKVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5SZXF1ZXN0LnByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gbmV3IFJlcXVlc3QodGhpcywge2JvZHk6IHRoaXMuX2JvZHlJbml0fSlcbn1cblxuZnVuY3Rpb24gZGVjb2RlKGJvZHkpIHtcbiAgdmFyIGZvcm0gPSBuZXcgRm9ybURhdGEoKVxuICBib2R5XG4gICAgLnRyaW0oKVxuICAgIC5zcGxpdCgnJicpXG4gICAgLmZvckVhY2goZnVuY3Rpb24oYnl0ZXMpIHtcbiAgICAgIGlmIChieXRlcykge1xuICAgICAgICB2YXIgc3BsaXQgPSBieXRlcy5zcGxpdCgnPScpXG4gICAgICAgIHZhciBuYW1lID0gc3BsaXQuc2hpZnQoKS5yZXBsYWNlKC9cXCsvZywgJyAnKVxuICAgICAgICB2YXIgdmFsdWUgPSBzcGxpdC5qb2luKCc9JykucmVwbGFjZSgvXFwrL2csICcgJylcbiAgICAgICAgZm9ybS5hcHBlbmQoZGVjb2RlVVJJQ29tcG9uZW50KG5hbWUpLCBkZWNvZGVVUklDb21wb25lbnQodmFsdWUpKVxuICAgICAgfVxuICAgIH0pXG4gIHJldHVybiBmb3JtXG59XG5cbmZ1bmN0aW9uIHBhcnNlSGVhZGVycyhyYXdIZWFkZXJzKSB7XG4gIHZhciBoZWFkZXJzID0gbmV3IEhlYWRlcnMoKVxuICAvLyBSZXBsYWNlIGluc3RhbmNlcyBvZiBcXHJcXG4gYW5kIFxcbiBmb2xsb3dlZCBieSBhdCBsZWFzdCBvbmUgc3BhY2Ugb3IgaG9yaXpvbnRhbCB0YWIgd2l0aCBhIHNwYWNlXG4gIC8vIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmM3MjMwI3NlY3Rpb24tMy4yXG4gIHZhciBwcmVQcm9jZXNzZWRIZWFkZXJzID0gcmF3SGVhZGVycy5yZXBsYWNlKC9cXHI/XFxuW1xcdCBdKy9nLCAnICcpXG4gIC8vIEF2b2lkaW5nIHNwbGl0IHZpYSByZWdleCB0byB3b3JrIGFyb3VuZCBhIGNvbW1vbiBJRTExIGJ1ZyB3aXRoIHRoZSBjb3JlLWpzIDMuNi4wIHJlZ2V4IHBvbHlmaWxsXG4gIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9naXRodWIvZmV0Y2gvaXNzdWVzLzc0OFxuICAvLyBodHRwczovL2dpdGh1Yi5jb20vemxvaXJvY2svY29yZS1qcy9pc3N1ZXMvNzUxXG4gIHByZVByb2Nlc3NlZEhlYWRlcnNcbiAgICAuc3BsaXQoJ1xccicpXG4gICAgLm1hcChmdW5jdGlvbihoZWFkZXIpIHtcbiAgICAgIHJldHVybiBoZWFkZXIuaW5kZXhPZignXFxuJykgPT09IDAgPyBoZWFkZXIuc3Vic3RyKDEsIGhlYWRlci5sZW5ndGgpIDogaGVhZGVyXG4gICAgfSlcbiAgICAuZm9yRWFjaChmdW5jdGlvbihsaW5lKSB7XG4gICAgICB2YXIgcGFydHMgPSBsaW5lLnNwbGl0KCc6JylcbiAgICAgIHZhciBrZXkgPSBwYXJ0cy5zaGlmdCgpLnRyaW0oKVxuICAgICAgaWYgKGtleSkge1xuICAgICAgICB2YXIgdmFsdWUgPSBwYXJ0cy5qb2luKCc6JykudHJpbSgpXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgaGVhZGVycy5hcHBlbmQoa2V5LCB2YWx1ZSlcbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICBjb25zb2xlLndhcm4oJ1Jlc3BvbnNlICcgKyBlcnJvci5tZXNzYWdlKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSlcbiAgcmV0dXJuIGhlYWRlcnNcbn1cblxuQm9keS5jYWxsKFJlcXVlc3QucHJvdG90eXBlKVxuXG5leHBvcnQgZnVuY3Rpb24gUmVzcG9uc2UoYm9keUluaXQsIG9wdGlvbnMpIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFJlc3BvbnNlKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1BsZWFzZSB1c2UgdGhlIFwibmV3XCIgb3BlcmF0b3IsIHRoaXMgRE9NIG9iamVjdCBjb25zdHJ1Y3RvciBjYW5ub3QgYmUgY2FsbGVkIGFzIGEgZnVuY3Rpb24uJylcbiAgfVxuICBpZiAoIW9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0ge31cbiAgfVxuXG4gIHRoaXMudHlwZSA9ICdkZWZhdWx0J1xuICB0aGlzLnN0YXR1cyA9IG9wdGlvbnMuc3RhdHVzID09PSB1bmRlZmluZWQgPyAyMDAgOiBvcHRpb25zLnN0YXR1c1xuICBpZiAodGhpcy5zdGF0dXMgPCAyMDAgfHwgdGhpcy5zdGF0dXMgPiA1OTkpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkZhaWxlZCB0byBjb25zdHJ1Y3QgJ1Jlc3BvbnNlJzogVGhlIHN0YXR1cyBwcm92aWRlZCAoMCkgaXMgb3V0c2lkZSB0aGUgcmFuZ2UgWzIwMCwgNTk5XS5cIilcbiAgfVxuICB0aGlzLm9rID0gdGhpcy5zdGF0dXMgPj0gMjAwICYmIHRoaXMuc3RhdHVzIDwgMzAwXG4gIHRoaXMuc3RhdHVzVGV4dCA9IG9wdGlvbnMuc3RhdHVzVGV4dCA9PT0gdW5kZWZpbmVkID8gJycgOiAnJyArIG9wdGlvbnMuc3RhdHVzVGV4dFxuICB0aGlzLmhlYWRlcnMgPSBuZXcgSGVhZGVycyhvcHRpb25zLmhlYWRlcnMpXG4gIHRoaXMudXJsID0gb3B0aW9ucy51cmwgfHwgJydcbiAgdGhpcy5faW5pdEJvZHkoYm9keUluaXQpXG59XG5cbkJvZHkuY2FsbChSZXNwb25zZS5wcm90b3R5cGUpXG5cblJlc3BvbnNlLnByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gbmV3IFJlc3BvbnNlKHRoaXMuX2JvZHlJbml0LCB7XG4gICAgc3RhdHVzOiB0aGlzLnN0YXR1cyxcbiAgICBzdGF0dXNUZXh0OiB0aGlzLnN0YXR1c1RleHQsXG4gICAgaGVhZGVyczogbmV3IEhlYWRlcnModGhpcy5oZWFkZXJzKSxcbiAgICB1cmw6IHRoaXMudXJsXG4gIH0pXG59XG5cblJlc3BvbnNlLmVycm9yID0gZnVuY3Rpb24oKSB7XG4gIHZhciByZXNwb25zZSA9IG5ldyBSZXNwb25zZShudWxsLCB7c3RhdHVzOiAyMDAsIHN0YXR1c1RleHQ6ICcnfSlcbiAgcmVzcG9uc2Uub2sgPSBmYWxzZVxuICByZXNwb25zZS5zdGF0dXMgPSAwXG4gIHJlc3BvbnNlLnR5cGUgPSAnZXJyb3InXG4gIHJldHVybiByZXNwb25zZVxufVxuXG52YXIgcmVkaXJlY3RTdGF0dXNlcyA9IFszMDEsIDMwMiwgMzAzLCAzMDcsIDMwOF1cblxuUmVzcG9uc2UucmVkaXJlY3QgPSBmdW5jdGlvbih1cmwsIHN0YXR1cykge1xuICBpZiAocmVkaXJlY3RTdGF0dXNlcy5pbmRleE9mKHN0YXR1cykgPT09IC0xKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0ludmFsaWQgc3RhdHVzIGNvZGUnKVxuICB9XG5cbiAgcmV0dXJuIG5ldyBSZXNwb25zZShudWxsLCB7c3RhdHVzOiBzdGF0dXMsIGhlYWRlcnM6IHtsb2NhdGlvbjogdXJsfX0pXG59XG5cbmV4cG9ydCB2YXIgRE9NRXhjZXB0aW9uID0gZy5ET01FeGNlcHRpb25cbnRyeSB7XG4gIG5ldyBET01FeGNlcHRpb24oKVxufSBjYXRjaCAoZXJyKSB7XG4gIERPTUV4Y2VwdGlvbiA9IGZ1bmN0aW9uKG1lc3NhZ2UsIG5hbWUpIHtcbiAgICB0aGlzLm1lc3NhZ2UgPSBtZXNzYWdlXG4gICAgdGhpcy5uYW1lID0gbmFtZVxuICAgIHZhciBlcnJvciA9IEVycm9yKG1lc3NhZ2UpXG4gICAgdGhpcy5zdGFjayA9IGVycm9yLnN0YWNrXG4gIH1cbiAgRE9NRXhjZXB0aW9uLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoRXJyb3IucHJvdG90eXBlKVxuICBET01FeGNlcHRpb24ucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gRE9NRXhjZXB0aW9uXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBmZXRjaChpbnB1dCwgaW5pdCkge1xuICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgdmFyIHJlcXVlc3QgPSBuZXcgUmVxdWVzdChpbnB1dCwgaW5pdClcblxuICAgIGlmIChyZXF1ZXN0LnNpZ25hbCAmJiByZXF1ZXN0LnNpZ25hbC5hYm9ydGVkKSB7XG4gICAgICByZXR1cm4gcmVqZWN0KG5ldyBET01FeGNlcHRpb24oJ0Fib3J0ZWQnLCAnQWJvcnRFcnJvcicpKVxuICAgIH1cblxuICAgIHZhciB4aHIgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKVxuXG4gICAgZnVuY3Rpb24gYWJvcnRYaHIoKSB7XG4gICAgICB4aHIuYWJvcnQoKVxuICAgIH1cblxuICAgIHhoci5vbmxvYWQgPSBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBvcHRpb25zID0ge1xuICAgICAgICBzdGF0dXNUZXh0OiB4aHIuc3RhdHVzVGV4dCxcbiAgICAgICAgaGVhZGVyczogcGFyc2VIZWFkZXJzKHhoci5nZXRBbGxSZXNwb25zZUhlYWRlcnMoKSB8fCAnJylcbiAgICAgIH1cbiAgICAgIC8vIFRoaXMgY2hlY2sgaWYgc3BlY2lmaWNhbGx5IGZvciB3aGVuIGEgdXNlciBmZXRjaGVzIGEgZmlsZSBsb2NhbGx5IGZyb20gdGhlIGZpbGUgc3lzdGVtXG4gICAgICAvLyBPbmx5IGlmIHRoZSBzdGF0dXMgaXMgb3V0IG9mIGEgbm9ybWFsIHJhbmdlXG4gICAgICBpZiAocmVxdWVzdC51cmwuaW5kZXhPZignZmlsZTovLycpID09PSAwICYmICh4aHIuc3RhdHVzIDwgMjAwIHx8IHhoci5zdGF0dXMgPiA1OTkpKSB7XG4gICAgICAgIG9wdGlvbnMuc3RhdHVzID0gMjAwO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgb3B0aW9ucy5zdGF0dXMgPSB4aHIuc3RhdHVzO1xuICAgICAgfVxuICAgICAgb3B0aW9ucy51cmwgPSAncmVzcG9uc2VVUkwnIGluIHhociA/IHhoci5yZXNwb25zZVVSTCA6IG9wdGlvbnMuaGVhZGVycy5nZXQoJ1gtUmVxdWVzdC1VUkwnKVxuICAgICAgdmFyIGJvZHkgPSAncmVzcG9uc2UnIGluIHhociA/IHhoci5yZXNwb25zZSA6IHhoci5yZXNwb25zZVRleHRcbiAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgIHJlc29sdmUobmV3IFJlc3BvbnNlKGJvZHksIG9wdGlvbnMpKVxuICAgICAgfSwgMClcbiAgICB9XG5cbiAgICB4aHIub25lcnJvciA9IGZ1bmN0aW9uKCkge1xuICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgcmVqZWN0KG5ldyBUeXBlRXJyb3IoJ05ldHdvcmsgcmVxdWVzdCBmYWlsZWQnKSlcbiAgICAgIH0sIDApXG4gICAgfVxuXG4gICAgeGhyLm9udGltZW91dCA9IGZ1bmN0aW9uKCkge1xuICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgcmVqZWN0KG5ldyBUeXBlRXJyb3IoJ05ldHdvcmsgcmVxdWVzdCB0aW1lZCBvdXQnKSlcbiAgICAgIH0sIDApXG4gICAgfVxuXG4gICAgeGhyLm9uYWJvcnQgPSBmdW5jdGlvbigpIHtcbiAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgIHJlamVjdChuZXcgRE9NRXhjZXB0aW9uKCdBYm9ydGVkJywgJ0Fib3J0RXJyb3InKSlcbiAgICAgIH0sIDApXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZml4VXJsKHVybCkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIHVybCA9PT0gJycgJiYgZy5sb2NhdGlvbi5ocmVmID8gZy5sb2NhdGlvbi5ocmVmIDogdXJsXG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHJldHVybiB1cmxcbiAgICAgIH1cbiAgICB9XG5cbiAgICB4aHIub3BlbihyZXF1ZXN0Lm1ldGhvZCwgZml4VXJsKHJlcXVlc3QudXJsKSwgdHJ1ZSlcblxuICAgIGlmIChyZXF1ZXN0LmNyZWRlbnRpYWxzID09PSAnaW5jbHVkZScpIHtcbiAgICAgIHhoci53aXRoQ3JlZGVudGlhbHMgPSB0cnVlXG4gICAgfSBlbHNlIGlmIChyZXF1ZXN0LmNyZWRlbnRpYWxzID09PSAnb21pdCcpIHtcbiAgICAgIHhoci53aXRoQ3JlZGVudGlhbHMgPSBmYWxzZVxuICAgIH1cblxuICAgIGlmICgncmVzcG9uc2VUeXBlJyBpbiB4aHIpIHtcbiAgICAgIGlmIChzdXBwb3J0LmJsb2IpIHtcbiAgICAgICAgeGhyLnJlc3BvbnNlVHlwZSA9ICdibG9iJ1xuICAgICAgfSBlbHNlIGlmIChcbiAgICAgICAgc3VwcG9ydC5hcnJheUJ1ZmZlclxuICAgICAgKSB7XG4gICAgICAgIHhoci5yZXNwb25zZVR5cGUgPSAnYXJyYXlidWZmZXInXG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGluaXQgJiYgdHlwZW9mIGluaXQuaGVhZGVycyA9PT0gJ29iamVjdCcgJiYgIShpbml0LmhlYWRlcnMgaW5zdGFuY2VvZiBIZWFkZXJzIHx8IChnLkhlYWRlcnMgJiYgaW5pdC5oZWFkZXJzIGluc3RhbmNlb2YgZy5IZWFkZXJzKSkpIHtcbiAgICAgIHZhciBuYW1lcyA9IFtdO1xuICAgICAgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoaW5pdC5oZWFkZXJzKS5mb3JFYWNoKGZ1bmN0aW9uKG5hbWUpIHtcbiAgICAgICAgbmFtZXMucHVzaChub3JtYWxpemVOYW1lKG5hbWUpKVxuICAgICAgICB4aHIuc2V0UmVxdWVzdEhlYWRlcihuYW1lLCBub3JtYWxpemVWYWx1ZShpbml0LmhlYWRlcnNbbmFtZV0pKVxuICAgICAgfSlcbiAgICAgIHJlcXVlc3QuaGVhZGVycy5mb3JFYWNoKGZ1bmN0aW9uKHZhbHVlLCBuYW1lKSB7XG4gICAgICAgIGlmIChuYW1lcy5pbmRleE9mKG5hbWUpID09PSAtMSkge1xuICAgICAgICAgIHhoci5zZXRSZXF1ZXN0SGVhZGVyKG5hbWUsIHZhbHVlKVxuICAgICAgICB9XG4gICAgICB9KVxuICAgIH0gZWxzZSB7XG4gICAgICByZXF1ZXN0LmhlYWRlcnMuZm9yRWFjaChmdW5jdGlvbih2YWx1ZSwgbmFtZSkge1xuICAgICAgICB4aHIuc2V0UmVxdWVzdEhlYWRlcihuYW1lLCB2YWx1ZSlcbiAgICAgIH0pXG4gICAgfVxuXG4gICAgaWYgKHJlcXVlc3Quc2lnbmFsKSB7XG4gICAgICByZXF1ZXN0LnNpZ25hbC5hZGRFdmVudExpc3RlbmVyKCdhYm9ydCcsIGFib3J0WGhyKVxuXG4gICAgICB4aHIub25yZWFkeXN0YXRlY2hhbmdlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIC8vIERPTkUgKHN1Y2Nlc3Mgb3IgZmFpbHVyZSlcbiAgICAgICAgaWYgKHhoci5yZWFkeVN0YXRlID09PSA0KSB7XG4gICAgICAgICAgcmVxdWVzdC5zaWduYWwucmVtb3ZlRXZlbnRMaXN0ZW5lcignYWJvcnQnLCBhYm9ydFhocilcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHhoci5zZW5kKHR5cGVvZiByZXF1ZXN0Ll9ib2R5SW5pdCA9PT0gJ3VuZGVmaW5lZCcgPyBudWxsIDogcmVxdWVzdC5fYm9keUluaXQpXG4gIH0pXG59XG5cbmZldGNoLnBvbHlmaWxsID0gdHJ1ZVxuXG5pZiAoIWcuZmV0Y2gpIHtcbiAgZy5mZXRjaCA9IGZldGNoXG4gIGcuSGVhZGVycyA9IEhlYWRlcnNcbiAgZy5SZXF1ZXN0ID0gUmVxdWVzdFxuICBnLlJlc3BvbnNlID0gUmVzcG9uc2Vcbn1cbiIsImV4cG9ydCBjb25zdCBNQVhfREVDSU1BTFMgPSA2O1xuZXhwb3J0IGNvbnN0IERFRkFVTFRfQkxFTkRfU1RFUFMgPSA1O1xuZXhwb3J0IGNvbnN0IERFRkFVTFRfU0hBREVTX1RJTlRTX1NURVBTID0gNTtcbmV4cG9ydCBjb25zdCBCQVNFXzI1NSA9IDI1NTtcbmV4cG9ydCBjb25zdCBNQVhfSFVFID0gMzYwO1xuZXhwb3J0IGNvbnN0IE1BWF9QQ0VOVCA9IDEwMDtcbmV4cG9ydCBjb25zdCBNQVhfQUxQSEEgPSAxO1xuZXhwb3J0IGNvbnN0IE1BWF9MQUIgPSAxMjU7XG5leHBvcnQgY29uc3QgTUFYX0xDSF9DID0gMTUwO1xuIiwiZXhwb3J0IHZhciBDb2xvck1vZGVsO1xuKGZ1bmN0aW9uIChDb2xvck1vZGVsKSB7XG4gICAgQ29sb3JNb2RlbFtcIkhFWFwiXSA9IFwiSEVYXCI7XG4gICAgQ29sb3JNb2RlbFtcIlJHQlwiXSA9IFwiUkdCXCI7XG4gICAgQ29sb3JNb2RlbFtcIkhXQlwiXSA9IFwiSFdCXCI7XG4gICAgQ29sb3JNb2RlbFtcIkhTTFwiXSA9IFwiSFNMXCI7XG4gICAgQ29sb3JNb2RlbFtcIkNJRUxhYlwiXSA9IFwiQ0lFTGFiXCI7XG4gICAgQ29sb3JNb2RlbFtcIkxDSFwiXSA9IFwiTENIXCI7XG4gICAgQ29sb3JNb2RlbFtcIkNNWUtcIl0gPSBcIkNNWUtcIjtcbn0pKENvbG9yTW9kZWwgfHwgKENvbG9yTW9kZWwgPSB7fSkpO1xuZXhwb3J0IHZhciBIYXJtb255O1xuKGZ1bmN0aW9uIChIYXJtb255KSB7XG4gICAgSGFybW9ueVtcIkFOQUxPR09VU1wiXSA9IFwiQU5BTE9HT1VTXCI7XG4gICAgSGFybW9ueVtcIkNPTVBMRU1FTlRBUllcIl0gPSBcIkNPTVBMRU1FTlRBUllcIjtcbiAgICBIYXJtb255W1wiU1BMSVRfQ09NUExFTUVOVEFSWVwiXSA9IFwiU1BMSVRfQ09NUExFTUVOVEFSWVwiO1xuICAgIEhhcm1vbnlbXCJUUklBRElDXCJdID0gXCJUUklBRElDXCI7XG4gICAgSGFybW9ueVtcIlRFVFJBRElDXCJdID0gXCJURVRSQURJQ1wiO1xuICAgIEhhcm1vbnlbXCJTUVVBUkVcIl0gPSBcIlNRVUFSRVwiO1xufSkoSGFybW9ueSB8fCAoSGFybW9ueSA9IHt9KSk7XG5leHBvcnQgdmFyIE1peDtcbihmdW5jdGlvbiAoTWl4KSB7XG4gICAgTWl4W1wiQURESVRJVkVcIl0gPSBcIkFERElUSVZFXCI7XG4gICAgTWl4W1wiU1VCVFJBQ1RJVkVcIl0gPSBcIlNVQlRSQUNUSVZFXCI7XG59KShNaXggfHwgKE1peCA9IHt9KSk7XG5leHBvcnQgdmFyIENvbG9yS2V5d29yZHM7XG4oZnVuY3Rpb24gKENvbG9yS2V5d29yZHMpIHtcbiAgICBDb2xvcktleXdvcmRzW1wiYmxhY2tcIl0gPSBcIiMwMDAwMDBcIjtcbiAgICBDb2xvcktleXdvcmRzW1wic2lsdmVyXCJdID0gXCIjQzBDMEMwXCI7XG4gICAgQ29sb3JLZXl3b3Jkc1tcImdyYXlcIl0gPSBcIiM4MDgwODBcIjtcbiAgICBDb2xvcktleXdvcmRzW1wid2hpdGVcIl0gPSBcIiNGRkZGRkZcIjtcbiAgICBDb2xvcktleXdvcmRzW1wibWFyb29uXCJdID0gXCIjODAwMDAwXCI7XG4gICAgQ29sb3JLZXl3b3Jkc1tcInJlZFwiXSA9IFwiI0ZGMDAwMFwiO1xuICAgIENvbG9yS2V5d29yZHNbXCJwdXJwbGVcIl0gPSBcIiM4MDAwODBcIjtcbiAgICBDb2xvcktleXdvcmRzW1wiZnVjaHNpYVwiXSA9IFwiI0ZGMDBGRlwiO1xuICAgIENvbG9yS2V5d29yZHNbXCJncmVlblwiXSA9IFwiIzAwODAwMFwiO1xuICAgIENvbG9yS2V5d29yZHNbXCJsaW1lXCJdID0gXCIjMDBGRjAwXCI7XG4gICAgQ29sb3JLZXl3b3Jkc1tcIm9saXZlXCJdID0gXCIjODA4MDAwXCI7XG4gICAgQ29sb3JLZXl3b3Jkc1tcInllbGxvd1wiXSA9IFwiI0ZGRkYwMFwiO1xuICAgIENvbG9yS2V5d29yZHNbXCJuYXZ5XCJdID0gXCIjMDAwMDgwXCI7XG4gICAgQ29sb3JLZXl3b3Jkc1tcImJsdWVcIl0gPSBcIiMwMDAwRkZcIjtcbiAgICBDb2xvcktleXdvcmRzW1widGVhbFwiXSA9IFwiIzAwODA4MFwiO1xuICAgIENvbG9yS2V5d29yZHNbXCJhcXVhXCJdID0gXCIjMDBGRkZGXCI7XG4gICAgQ29sb3JLZXl3b3Jkc1tcIm9yYW5nZVwiXSA9IFwiI0ZGQTUwMFwiO1xuICAgIENvbG9yS2V5d29yZHNbXCJhbGljZWJsdWVcIl0gPSBcIiNGMEY4RkZcIjtcbiAgICBDb2xvcktleXdvcmRzW1wiYW50aXF1ZXdoaXRlXCJdID0gXCIjRkFFQkQ3XCI7XG4gICAgQ29sb3JLZXl3b3Jkc1tcImFxdWFtYXJpbmVcIl0gPSBcIiM3RkZGRDRcIjtcbiAgICBDb2xvcktleXdvcmRzW1wiYXp1cmVcIl0gPSBcIiNGMEZGRkZcIjtcbiAgICBDb2xvcktleXdvcmRzW1wiYmVpZ2VcIl0gPSBcIiNGNUY1RENcIjtcbiAgICBDb2xvcktleXdvcmRzW1wiYmlzcXVlXCJdID0gXCIjRkZFNEM0XCI7XG4gICAgQ29sb3JLZXl3b3Jkc1tcImJsYW5jaGVkYWxtb25kXCJdID0gXCIjRkZFQkNEXCI7XG4gICAgQ29sb3JLZXl3b3Jkc1tcImJsdWV2aW9sZXRcIl0gPSBcIiM4QTJCRTJcIjtcbiAgICBDb2xvcktleXdvcmRzW1wiYnJvd25cIl0gPSBcIiNBNTJBMkFcIjtcbiAgICBDb2xvcktleXdvcmRzW1wiYnVybHl3b29kXCJdID0gXCIjREVCODg3XCI7XG4gICAgQ29sb3JLZXl3b3Jkc1tcImNhZGV0Ymx1ZVwiXSA9IFwiIzVGOUVBMFwiO1xuICAgIENvbG9yS2V5d29yZHNbXCJjaGFydHJldXNlXCJdID0gXCIjN0ZGRjAwXCI7XG4gICAgQ29sb3JLZXl3b3Jkc1tcImNob2NvbGF0ZVwiXSA9IFwiI0QyNjkxRVwiO1xuICAgIENvbG9yS2V5d29yZHNbXCJjb3JhbFwiXSA9IFwiI0ZGN0Y1MFwiO1xuICAgIENvbG9yS2V5d29yZHNbXCJjb3JuZmxvd2VyYmx1ZVwiXSA9IFwiIzY0OTVFRFwiO1xuICAgIENvbG9yS2V5d29yZHNbXCJjb3Juc2lsa1wiXSA9IFwiI0ZGRjhEQ1wiO1xuICAgIENvbG9yS2V5d29yZHNbXCJjcmltc29uXCJdID0gXCIjREMxNDNDXCI7XG4gICAgQ29sb3JLZXl3b3Jkc1tcImN5YW5cIl0gPSBcIiMwMEZGRkZcIjtcbiAgICBDb2xvcktleXdvcmRzW1wiZGFya2JsdWVcIl0gPSBcIiMwMDAwOEJcIjtcbiAgICBDb2xvcktleXdvcmRzW1wiZGFya2N5YW5cIl0gPSBcIiMwMDhCOEJcIjtcbiAgICBDb2xvcktleXdvcmRzW1wiZGFya2dvbGRlbnJvZFwiXSA9IFwiI0I4ODYwQlwiO1xuICAgIENvbG9yS2V5d29yZHNbXCJkYXJrZ3JheVwiXSA9IFwiI0E5QTlBOVwiO1xuICAgIENvbG9yS2V5d29yZHNbXCJkYXJrZ3JlZW5cIl0gPSBcIiMwMDY0MDBcIjtcbiAgICBDb2xvcktleXdvcmRzW1wiZGFya2dyZXlcIl0gPSBcIiNBOUE5QTlcIjtcbiAgICBDb2xvcktleXdvcmRzW1wiZGFya2toYWtpXCJdID0gXCIjQkRCNzZCXCI7XG4gICAgQ29sb3JLZXl3b3Jkc1tcImRhcmttYWdlbnRhXCJdID0gXCIjOEIwMDhCXCI7XG4gICAgQ29sb3JLZXl3b3Jkc1tcImRhcmtvbGl2ZWdyZWVuXCJdID0gXCIjNTU2QjJGXCI7XG4gICAgQ29sb3JLZXl3b3Jkc1tcImRhcmtvcmFuZ2VcIl0gPSBcIiNGRjhDMDBcIjtcbiAgICBDb2xvcktleXdvcmRzW1wiZGFya29yY2hpZFwiXSA9IFwiIzk5MzJDQ1wiO1xuICAgIENvbG9yS2V5d29yZHNbXCJkYXJrcmVkXCJdID0gXCIjOEIwMDAwXCI7XG4gICAgQ29sb3JLZXl3b3Jkc1tcImRhcmtzYWxtb25cIl0gPSBcIiNFOTk2N0FcIjtcbiAgICBDb2xvcktleXdvcmRzW1wiZGFya3NlYWdyZWVuXCJdID0gXCIjOEZCQzhGXCI7XG4gICAgQ29sb3JLZXl3b3Jkc1tcImRhcmtzbGF0ZWJsdWVcIl0gPSBcIiM0ODNEOEJcIjtcbiAgICBDb2xvcktleXdvcmRzW1wiZGFya3NsYXRlZ3JheVwiXSA9IFwiIzJGNEY0RlwiO1xuICAgIENvbG9yS2V5d29yZHNbXCJkYXJrc2xhdGVncmV5XCJdID0gXCIjMkY0RjRGXCI7XG4gICAgQ29sb3JLZXl3b3Jkc1tcImRhcmt0dXJxdW9pc2VcIl0gPSBcIiMwMENFRDFcIjtcbiAgICBDb2xvcktleXdvcmRzW1wiZGFya3Zpb2xldFwiXSA9IFwiIzk0MDBEM1wiO1xuICAgIENvbG9yS2V5d29yZHNbXCJkZWVwcGlua1wiXSA9IFwiI0ZGMTQ5M1wiO1xuICAgIENvbG9yS2V5d29yZHNbXCJkZWVwc2t5Ymx1ZVwiXSA9IFwiIzAwQkZGRlwiO1xuICAgIENvbG9yS2V5d29yZHNbXCJkaW1ncmF5XCJdID0gXCIjNjk2OTY5XCI7XG4gICAgQ29sb3JLZXl3b3Jkc1tcImRpbWdyZXlcIl0gPSBcIiM2OTY5NjlcIjtcbiAgICBDb2xvcktleXdvcmRzW1wiZG9kZ2VyYmx1ZVwiXSA9IFwiIzFFOTBGRlwiO1xuICAgIENvbG9yS2V5d29yZHNbXCJmaXJlYnJpY2tcIl0gPSBcIiNCMjIyMjJcIjtcbiAgICBDb2xvcktleXdvcmRzW1wiZmxvcmFsd2hpdGVcIl0gPSBcIiNGRkZBRjBcIjtcbiAgICBDb2xvcktleXdvcmRzW1wiZm9yZXN0Z3JlZW5cIl0gPSBcIiMyMjhCMjJcIjtcbiAgICBDb2xvcktleXdvcmRzW1wiZ2FpbnNib3JvXCJdID0gXCIjRENEQ0RDXCI7XG4gICAgQ29sb3JLZXl3b3Jkc1tcImdob3N0d2hpdGVcIl0gPSBcIiNGOEY4RkZcIjtcbiAgICBDb2xvcktleXdvcmRzW1wiZ29sZFwiXSA9IFwiI0ZGRDcwMFwiO1xuICAgIENvbG9yS2V5d29yZHNbXCJnb2xkZW5yb2RcIl0gPSBcIiNEQUE1MjBcIjtcbiAgICBDb2xvcktleXdvcmRzW1wiZ3JlZW55ZWxsb3dcIl0gPSBcIiNBREZGMkZcIjtcbiAgICBDb2xvcktleXdvcmRzW1wiZ3JleVwiXSA9IFwiIzgwODA4MFwiO1xuICAgIENvbG9yS2V5d29yZHNbXCJob25leWRld1wiXSA9IFwiI0YwRkZGMFwiO1xuICAgIENvbG9yS2V5d29yZHNbXCJob3RwaW5rXCJdID0gXCIjRkY2OUI0XCI7XG4gICAgQ29sb3JLZXl3b3Jkc1tcImluZGlhbnJlZFwiXSA9IFwiI0NENUM1Q1wiO1xuICAgIENvbG9yS2V5d29yZHNbXCJpbmRpZ29cIl0gPSBcIiM0QjAwODJcIjtcbiAgICBDb2xvcktleXdvcmRzW1wiaXZvcnlcIl0gPSBcIiNGRkZGRjBcIjtcbiAgICBDb2xvcktleXdvcmRzW1wia2hha2lcIl0gPSBcIiNGMEU2OENcIjtcbiAgICBDb2xvcktleXdvcmRzW1wibGF2ZW5kZXJcIl0gPSBcIiNFNkU2RkFcIjtcbiAgICBDb2xvcktleXdvcmRzW1wibGF2ZW5kZXJibHVzaFwiXSA9IFwiI0ZGRjBGNVwiO1xuICAgIENvbG9yS2V5d29yZHNbXCJsYXduZ3JlZW5cIl0gPSBcIiM3Q0ZDMDBcIjtcbiAgICBDb2xvcktleXdvcmRzW1wibGVtb25jaGlmZm9uXCJdID0gXCIjRkZGQUNEXCI7XG4gICAgQ29sb3JLZXl3b3Jkc1tcImxpZ2h0Ymx1ZVwiXSA9IFwiI0FERDhFNlwiO1xuICAgIENvbG9yS2V5d29yZHNbXCJsaWdodGNvcmFsXCJdID0gXCIjRjA4MDgwXCI7XG4gICAgQ29sb3JLZXl3b3Jkc1tcImxpZ2h0Y3lhblwiXSA9IFwiI0UwRkZGRlwiO1xuICAgIENvbG9yS2V5d29yZHNbXCJsaWdodGdvbGRlbnJvZHllbGxvd1wiXSA9IFwiI0ZBRkFEMlwiO1xuICAgIENvbG9yS2V5d29yZHNbXCJsaWdodGdyYXlcIl0gPSBcIiNEM0QzRDNcIjtcbiAgICBDb2xvcktleXdvcmRzW1wibGlnaHRncmVlblwiXSA9IFwiIzkwRUU5MFwiO1xuICAgIENvbG9yS2V5d29yZHNbXCJsaWdodGdyZXlcIl0gPSBcIiNEM0QzRDNcIjtcbiAgICBDb2xvcktleXdvcmRzW1wibGlnaHRwaW5rXCJdID0gXCIjRkZCNkMxXCI7XG4gICAgQ29sb3JLZXl3b3Jkc1tcImxpZ2h0c2FsbW9uXCJdID0gXCIjRkZBMDdBXCI7XG4gICAgQ29sb3JLZXl3b3Jkc1tcImxpZ2h0c2VhZ3JlZW5cIl0gPSBcIiMyMEIyQUFcIjtcbiAgICBDb2xvcktleXdvcmRzW1wibGlnaHRza3libHVlXCJdID0gXCIjODdDRUZBXCI7XG4gICAgQ29sb3JLZXl3b3Jkc1tcImxpZ2h0c2xhdGVncmF5XCJdID0gXCIjNzc4ODk5XCI7XG4gICAgQ29sb3JLZXl3b3Jkc1tcImxpZ2h0c2xhdGVncmV5XCJdID0gXCIjNzc4ODk5XCI7XG4gICAgQ29sb3JLZXl3b3Jkc1tcImxpZ2h0c3RlZWxibHVlXCJdID0gXCIjQjBDNERFXCI7XG4gICAgQ29sb3JLZXl3b3Jkc1tcImxpZ2h0eWVsbG93XCJdID0gXCIjRkZGRkUwXCI7XG4gICAgQ29sb3JLZXl3b3Jkc1tcImxpbWVncmVlblwiXSA9IFwiIzMyQ0QzMlwiO1xuICAgIENvbG9yS2V5d29yZHNbXCJsaW5lblwiXSA9IFwiI0ZBRjBFNlwiO1xuICAgIENvbG9yS2V5d29yZHNbXCJtYWdlbnRhXCJdID0gXCIjRkYwMEZGXCI7XG4gICAgQ29sb3JLZXl3b3Jkc1tcIm1lZGl1bWFxdWFtYXJpbmVcIl0gPSBcIiM2NkNEQUFcIjtcbiAgICBDb2xvcktleXdvcmRzW1wibWVkaXVtYmx1ZVwiXSA9IFwiIzAwMDBDRFwiO1xuICAgIENvbG9yS2V5d29yZHNbXCJtZWRpdW1vcmNoaWRcIl0gPSBcIiNCQTU1RDNcIjtcbiAgICBDb2xvcktleXdvcmRzW1wibWVkaXVtcHVycGxlXCJdID0gXCIjOTM3MERCXCI7XG4gICAgQ29sb3JLZXl3b3Jkc1tcIm1lZGl1bXNlYWdyZWVuXCJdID0gXCIjM0NCMzcxXCI7XG4gICAgQ29sb3JLZXl3b3Jkc1tcIm1lZGl1bXNsYXRlYmx1ZVwiXSA9IFwiIzdCNjhFRVwiO1xuICAgIENvbG9yS2V5d29yZHNbXCJtZWRpdW1zcHJpbmdncmVlblwiXSA9IFwiIzAwRkE5QVwiO1xuICAgIENvbG9yS2V5d29yZHNbXCJtZWRpdW10dXJxdW9pc2VcIl0gPSBcIiM0OEQxQ0NcIjtcbiAgICBDb2xvcktleXdvcmRzW1wibWVkaXVtdmlvbGV0cmVkXCJdID0gXCIjQzcxNTg1XCI7XG4gICAgQ29sb3JLZXl3b3Jkc1tcIm1pZG5pZ2h0Ymx1ZVwiXSA9IFwiIzE5MTk3MFwiO1xuICAgIENvbG9yS2V5d29yZHNbXCJtaW50Y3JlYW1cIl0gPSBcIiNGNUZGRkFcIjtcbiAgICBDb2xvcktleXdvcmRzW1wibWlzdHlyb3NlXCJdID0gXCIjRkZFNEUxXCI7XG4gICAgQ29sb3JLZXl3b3Jkc1tcIm1vY2Nhc2luXCJdID0gXCIjRkZFNEI1XCI7XG4gICAgQ29sb3JLZXl3b3Jkc1tcIm5hdmFqb3doaXRlXCJdID0gXCIjRkZERUFEXCI7XG4gICAgQ29sb3JLZXl3b3Jkc1tcIm9sZGxhY2VcIl0gPSBcIiNGREY1RTZcIjtcbiAgICBDb2xvcktleXdvcmRzW1wib2xpdmVkcmFiXCJdID0gXCIjNkI4RTIzXCI7XG4gICAgQ29sb3JLZXl3b3Jkc1tcIm9yYW5nZXJlZFwiXSA9IFwiI0ZGNDUwMFwiO1xuICAgIENvbG9yS2V5d29yZHNbXCJvcmNoaWRcIl0gPSBcIiNEQTcwRDZcIjtcbiAgICBDb2xvcktleXdvcmRzW1wicGFsZWdvbGRlbnJvZFwiXSA9IFwiI0VFRThBQVwiO1xuICAgIENvbG9yS2V5d29yZHNbXCJwYWxlZ3JlZW5cIl0gPSBcIiM5OEZCOThcIjtcbiAgICBDb2xvcktleXdvcmRzW1wicGFsZXR1cnF1b2lzZVwiXSA9IFwiI0FGRUVFRVwiO1xuICAgIENvbG9yS2V5d29yZHNbXCJwYWxldmlvbGV0cmVkXCJdID0gXCIjREI3MDkzXCI7XG4gICAgQ29sb3JLZXl3b3Jkc1tcInBhcGF5YXdoaXBcIl0gPSBcIiNGRkVGRDVcIjtcbiAgICBDb2xvcktleXdvcmRzW1wicGVhY2hwdWZmXCJdID0gXCIjRkZEQUI5XCI7XG4gICAgQ29sb3JLZXl3b3Jkc1tcInBlcnVcIl0gPSBcIiNDRDg1M0ZcIjtcbiAgICBDb2xvcktleXdvcmRzW1wicGlua1wiXSA9IFwiI0ZGQzBDQlwiO1xuICAgIENvbG9yS2V5d29yZHNbXCJwbHVtXCJdID0gXCIjRERBMEREXCI7XG4gICAgQ29sb3JLZXl3b3Jkc1tcInBvd2RlcmJsdWVcIl0gPSBcIiNCMEUwRTZcIjtcbiAgICBDb2xvcktleXdvcmRzW1wicm9zeWJyb3duXCJdID0gXCIjQkM4RjhGXCI7XG4gICAgQ29sb3JLZXl3b3Jkc1tcInJveWFsYmx1ZVwiXSA9IFwiIzQxNjlFMVwiO1xuICAgIENvbG9yS2V5d29yZHNbXCJzYWRkbGVicm93blwiXSA9IFwiIzhCNDUxM1wiO1xuICAgIENvbG9yS2V5d29yZHNbXCJzYWxtb25cIl0gPSBcIiNGQTgwNzJcIjtcbiAgICBDb2xvcktleXdvcmRzW1wic2FuZHlicm93blwiXSA9IFwiI0Y0QTQ2MFwiO1xuICAgIENvbG9yS2V5d29yZHNbXCJzZWFncmVlblwiXSA9IFwiIzJFOEI1N1wiO1xuICAgIENvbG9yS2V5d29yZHNbXCJzZWFzaGVsbFwiXSA9IFwiI0ZGRjVFRVwiO1xuICAgIENvbG9yS2V5d29yZHNbXCJzaWVubmFcIl0gPSBcIiNBMDUyMkRcIjtcbiAgICBDb2xvcktleXdvcmRzW1wic2t5Ymx1ZVwiXSA9IFwiIzg3Q0VFQlwiO1xuICAgIENvbG9yS2V5d29yZHNbXCJzbGF0ZWJsdWVcIl0gPSBcIiM2QTVBQ0RcIjtcbiAgICBDb2xvcktleXdvcmRzW1wic2xhdGVncmF5XCJdID0gXCIjNzA4MDkwXCI7XG4gICAgQ29sb3JLZXl3b3Jkc1tcInNsYXRlZ3JleVwiXSA9IFwiIzcwODA5MFwiO1xuICAgIENvbG9yS2V5d29yZHNbXCJzbm93XCJdID0gXCIjRkZGQUZBXCI7XG4gICAgQ29sb3JLZXl3b3Jkc1tcInNwcmluZ2dyZWVuXCJdID0gXCIjMDBGRjdGXCI7XG4gICAgQ29sb3JLZXl3b3Jkc1tcInN0ZWVsYmx1ZVwiXSA9IFwiIzQ2ODJCNFwiO1xuICAgIENvbG9yS2V5d29yZHNbXCJ0YW5cIl0gPSBcIiNEMkI0OENcIjtcbiAgICBDb2xvcktleXdvcmRzW1widGhpc3RsZVwiXSA9IFwiI0Q4QkZEOFwiO1xuICAgIENvbG9yS2V5d29yZHNbXCJ0b21hdG9cIl0gPSBcIiNGRjYzNDdcIjtcbiAgICBDb2xvcktleXdvcmRzW1widHVycXVvaXNlXCJdID0gXCIjNDBFMEQwXCI7XG4gICAgQ29sb3JLZXl3b3Jkc1tcInZpb2xldFwiXSA9IFwiI0VFODJFRVwiO1xuICAgIENvbG9yS2V5d29yZHNbXCJ3aGVhdFwiXSA9IFwiI0Y1REVCM1wiO1xuICAgIENvbG9yS2V5d29yZHNbXCJ3aGl0ZXNtb2tlXCJdID0gXCIjRjVGNUY1XCI7XG4gICAgQ29sb3JLZXl3b3Jkc1tcInllbGxvd2dyZWVuXCJdID0gXCIjOUFDRDMyXCI7XG4gICAgQ29sb3JLZXl3b3Jkc1tcInJlYmVjY2FwdXJwbGVcIl0gPSBcIiM2NjMzOTlcIjtcbn0pKENvbG9yS2V5d29yZHMgfHwgKENvbG9yS2V5d29yZHMgPSB7fSkpO1xuZXhwb3J0IGNvbnN0IENPTE9SX0tFWVMgPSBPYmplY3Qua2V5cyhDb2xvcktleXdvcmRzKTtcbmV4cG9ydCBjb25zdCBDT0xPUl9QUk9QUyA9IHtcbiAgICBIRVg6IFsnUicsICdHJywgJ0InLCAnQSddLFxuICAgIFJHQjogWydSJywgJ0cnLCAnQicsICdBJ10sXG4gICAgSFNMOiBbJ0gnLCAnUycsICdMJywgJ0EnXSxcbiAgICBIV0I6IFsnSCcsICdXJywgJ0InLCAnQSddLFxuICAgIENJRUxhYjogWydMJywgJ2EnLCAnYicsICdBJ10sXG4gICAgTENIOiBbJ0wnLCAnQycsICdIJywgJ0EnXSxcbiAgICBDTVlLOiBbJ0MnLCAnTScsICdZJywgJ0snLCAnQSddXG59O1xuZXhwb3J0IGNvbnN0IFZBTElEX0NPTE9SX09CSkVDVFMgPSB7XG4gICAgQUJHUjogQ29sb3JNb2RlbC5SR0IsXG4gICAgQUJIVzogQ29sb3JNb2RlbC5IV0IsXG4gICAgQUNITDogQ29sb3JNb2RlbC5MQ0gsXG4gICAgQUNLTVk6IENvbG9yTW9kZWwuQ01ZSyxcbiAgICBBSExTOiBDb2xvck1vZGVsLkhTTCxcbiAgICBBTEFCOiBDb2xvck1vZGVsLkNJRUxhYixcbiAgICBCR1I6IENvbG9yTW9kZWwuUkdCLFxuICAgIEJIVzogQ29sb3JNb2RlbC5IV0IsXG4gICAgQ0hMOiBDb2xvck1vZGVsLkxDSCxcbiAgICBDS01ZOiBDb2xvck1vZGVsLkNNWUssXG4gICAgSExTOiBDb2xvck1vZGVsLkhTTCxcbiAgICBMQUI6IENvbG9yTW9kZWwuQ0lFTGFiXG59O1xuZXhwb3J0IHZhciBUeXBlT2Y7XG4oZnVuY3Rpb24gKFR5cGVPZikge1xuICAgIFR5cGVPZltcIk5VTUJFUlwiXSA9IFwibnVtYmVyXCI7XG4gICAgVHlwZU9mW1wiQk9PTEVBTlwiXSA9IFwiYm9vbGVhblwiO1xufSkoVHlwZU9mIHx8IChUeXBlT2YgPSB7fSkpO1xuIiwiaW1wb3J0IHsgQ29sb3JNb2RlbCB9IGZyb20gJy4vZW51bXMnO1xuZXhwb3J0IGNvbnN0IENPTE9SUkVHUyA9IHtcbiAgICBbQ29sb3JNb2RlbC5IRVhdOiAvXiMoPzooPzxyPlthLWZcXGRdKSg/PGc+W2EtZlxcZF0pKD88Yj5bYS1mXFxkXSkoPzxhPlthLWZcXGRdKT98KD88cnI+W2EtZlxcZF17Mn0pKD88Z2c+W2EtZlxcZF17Mn0pKD88YmI+W2EtZlxcZF17Mn0pKD88YWE+W2EtZlxcZF17Mn0pPykkL2ksXG4gICAgW0NvbG9yTW9kZWwuUkdCXTogL15yZ2JhP1xccypcXChcXHMqKD86KD88cl9sZWdhY3k+KD86XFxkKlxcLik/XFxkKyU/KVxccyosXFxzKig/PGdfbGVnYWN5Pig/OlxcZCpcXC4pP1xcZCslPylcXHMqLFxccyooPzxiX2xlZ2FjeT4oPzpcXGQqXFwuKT9cXGQrJT8pKD86XFxzKixcXHMqKD88YV9sZWdhY3k+KD86XFxkKlxcLik/XFxkKykpP3woPzxyPig/OlxcZCpcXC4pP1xcZCslPylcXHMrKD88Zz4oPzpcXGQqXFwuKT9cXGQrJT8pXFxzKyg/PGI+KD86XFxkKlxcLik/XFxkKyU/KSg/OlxccypcXC9cXHMqKD88YT4oPzpcXGQqXFwuKT9cXGQrJT8pKT98ZnJvbVxccysoPzxmcm9tPig/Olxcdyt8XFx3K1xcKFxccypbXigpKV0rXFxzKlxcKXxcXHcrXFwoZnJvbVxccytcXHcrXFwoLipcXClcXHMqXFwpfCNbYS1mQS1GXFxkXSspKVxccysoPzxyZWxhdGl2ZV9yPig/OltyZ2JdfCg/OlxcZCpcXC4pP1xcZCt8Y2FsY1xcKFtyZ2IoKS8qXFwtK1xcZC5cXHNdK1xcKSkpXFxzKyg/PHJlbGF0aXZlX2c+KD86W3JnYl18KD86XFxkKlxcLik/XFxkK3xjYWxjXFwoW3JnYigpLypcXC0rXFxkLlxcc10rXFwpKSlcXHMrKD88cmVsYXRpdmVfYj4oPzpbcmdiXXwoPzpcXGQqXFwuKT9cXGQrfGNhbGNcXChbcmdiKCkvKlxcLStcXGQuXFxzXStcXCkpKSg/OlxccypcXC9cXHMqKD88cmVsYXRpdmVfYT4oPzooPzpcXGQqXFwuKT9cXGQrJT98Y2FsY1xcKFsoKS8qXFwtK1xcZC5cXHNcXHddKig/OmFscGhhKT9bKCkvKlxcLStcXGQuXFxzXFx3XSpcXCl8YWxwaGEpKSk/KVxccypcXCkkLyxcbiAgICBbQ29sb3JNb2RlbC5IV0JdOiAvXmh3YlxccypcXChcXHMqKD86KD88aD4oPzpcXGQqXFwuKT9cXGQrKD86ZGVnfGdyYWR8cmFkfHR1cm4pPylcXHMrKD88dz4oPzpcXGQqXFwuKT9cXGQrKSVcXHMrKD88Yj4oPzpcXGQqXFwuKT9cXGQrKSUoPzpcXHMqXFwvXFxzKig/PGE+KD86XFxkKlxcLik/XFxkKyU/KSk/fGZyb21cXHMrKD88ZnJvbT4oPzpcXHcrfFxcdytcXChcXHMqW14oKSldK1xccypcXCl8XFx3K1xcKGZyb21cXHMrXFx3K1xcKC4qXFwpXFxzKlxcKXwjW2EtZkEtRlxcZF0rKSlcXHMrKD88cmVsYXRpdmVfaD4oPzpbaHdiXXwoPzpcXGQqXFwuKT9cXGQrfGNhbGNcXChbaHdiKCkvKlxcLStcXGQuXFxzXStcXCkpKVxccysoPzxyZWxhdGl2ZV93Pig/Oltod2JdfCg/OlxcZCpcXC4pP1xcZCt8Y2FsY1xcKFtod2IoKS8qXFwtK1xcZC5cXHNdK1xcKSkpJT9cXHMrKD88cmVsYXRpdmVfYj4oPzpbaHdiXXwoPzpcXGQqXFwuKT9cXGQrfGNhbGNcXChbaHdiKCkvKlxcLStcXGQuXFxzXStcXCkpKSU/KD86XFxzKlxcL1xccyooPzxyZWxhdGl2ZV9hPig/Oig/OlxcZCpcXC4pP1xcZCslP3xjYWxjXFwoWygpLypcXC0rXFxkLlxcc1xcd10qKD86YWxwaGEpP1soKS8qXFwtK1xcZC5cXHNcXHddKlxcKXxhbHBoYSkpKT8pXFxzKlxcKSQvLFxuICAgIFtDb2xvck1vZGVsLkhTTF06IC9eaHNsYT9cXHMqXFwoXFxzKig/Oig/PGhfbGVnYWN5Pi0/KD86XFxkKlxcLik/XFxkKyg/OmRlZ3xncmFkfHJhZHx0dXJuKT8pXFxzKixcXHMqKD88c19sZWdhY3k+KD86XFxkKlxcLik/XFxkKyklXFxzKixcXHMqKD88bF9sZWdhY3k+KD86XFxkKlxcLik/XFxkKyklKD86XFxzKixcXHMqKD88YV9sZWdhY3k+KD86XFxkKlxcLik/XFxkKykpP3woPzxoPi0/KD86XFxkKlxcLik/XFxkKyg/OmRlZ3xncmFkfHJhZHx0dXJuKT8pXFxzKyg/PHM+KD86XFxkKlxcLik/XFxkKyklP1xccysoPzxsPig/OlxcZCpcXC4pP1xcZCspJT8oPzpcXHMqXFwvXFxzKig/PGE+KD86XFxkKlxcLik/XFxkKyU/KSk/fGZyb21cXHMrKD88ZnJvbT4oPzpcXHcrfFxcdytcXChcXHMqW14oKSldK1xccypcXCl8XFx3K1xcKGZyb21cXHMrXFx3K1xcKC4qXFwpXFxzKlxcKXwjW2EtZkEtRlxcZF0rKSlcXHMrKD88cmVsYXRpdmVfaD4oPzpbaHNsXXwoPzpcXGQqXFwuKT9cXGQrfGNhbGNcXChbaHNsKCkvKlxcLStcXGQuXFxzXStcXCkpKVxccysoPzxyZWxhdGl2ZV9zPig/Oltoc2xdfCg/OlxcZCpcXC4pP1xcZCt8Y2FsY1xcKFtoc2woKS8qXFwtK1xcZC5cXHNdK1xcKSkpJT9cXHMrKD88cmVsYXRpdmVfbD4oPzpbaHNsXXwoPzpcXGQqXFwuKT9cXGQrfGNhbGNcXChbaHNsKCkvKlxcLStcXGQuXFxzXStcXCkpKSU/KD86XFxzKlxcL1xccyooPzxyZWxhdGl2ZV9hPig/Oig/OlxcZCpcXC4pP1xcZCslP3xjYWxjXFwoWygpLypcXC0rXFxkLlxcc1xcd10qKD86YWxwaGEpP1soKS8qXFwtK1xcZC5cXHNcXHddKlxcKXxhbHBoYSkpKT8pXFxzKlxcKSQvLFxuICAgIFtDb2xvck1vZGVsLkNJRUxhYl06IC9ebGFiXFxzKlxcKFxccyooPzooPzxMPig/OlxcZCpcXC4pP1xcZCslPylcXHMrKD88YT4tPyg/OlxcZCpcXC4pP1xcZCslPylcXHMrKD88Yj4tPyg/OlxcZCpcXC4pP1xcZCslPykoPzpcXHMqXFwvXFxzKig/PEE+KD86XFxkKlxcLik/XFxkKyU/KSk/fGZyb21cXHMrKD88ZnJvbT4oPzpcXHcrfFxcdytcXChcXHMqW14oKSldK1xccypcXCl8XFx3K1xcKGZyb21cXHMrXFx3K1xcKC4qXFwpXFxzKlxcKXwjW2EtZkEtRlxcZF0rKSlcXHMrKD88cmVsYXRpdmVfTD4oPzpbbGFiXXwoPzpcXGQqXFwuKT9cXGQrfGNhbGNcXChbbGFiKCkvKlxcLStcXGQuXFxzXStcXCkpKVxccysoPzxyZWxhdGl2ZV9hPig/OltsYWJdfCg/OlxcZCpcXC4pP1xcZCt8Y2FsY1xcKFtsYWIoKS8qXFwtK1xcZC5cXHNdK1xcKSkpXFxzKyg/PHJlbGF0aXZlX2I+KD86W2xhYl18KD86XFxkKlxcLik/XFxkK3xjYWxjXFwoW2xhYigpLypcXC0rXFxkLlxcc10rXFwpKSkoPzpcXHMqXFwvXFxzKig/PHJlbGF0aXZlX0E+KD86KD86XFxkKlxcLik/XFxkKyU/fGNhbGNcXChbKCkvKlxcLStcXGQuXFxzXFx3XSooPzphbHBoYSk/WygpLypcXC0rXFxkLlxcc1xcd10qXFwpfGFscGhhKSkpPylcXHMqXFwpJC8sXG4gICAgW0NvbG9yTW9kZWwuTENIXTogL15sY2hcXHMqXFwoXFxzKig/Oig/PGw+KD86XFxkKlxcLik/XFxkKyU/KVxccysoPzxjPi0/KD86XFxkKlxcLik/XFxkKyU/KVxccysoPzxoPi0/KD86XFxkKlxcLik/XFxkKyg/OmRlZ3xncmFkfHJhZHx0dXJuKT8pKD86XFxzKlxcL1xccyooPzxhPig/OlxcZCpcXC4pP1xcZCslPykpP3xmcm9tXFxzKyg/PGZyb20+KD86XFx3K3xcXHcrXFwoXFxzKlteKCkpXStcXHMqXFwpfFxcdytcXChmcm9tXFxzK1xcdytcXCguKlxcKVxccypcXCl8I1thLWZBLUZcXGRdKykpXFxzKyg/PHJlbGF0aXZlX2w+KD86W2xjaF18KD86XFxkKlxcLik/XFxkK3xjYWxjXFwoW2xjaCgpLypcXC0rXFxkLlxcc10rXFwpKSlcXHMrKD88cmVsYXRpdmVfYz4oPzpbbGNoXXwoPzpcXGQqXFwuKT9cXGQrfGNhbGNcXChbbGNoKCkvKlxcLStcXGQuXFxzXStcXCkpKVxccysoPzxyZWxhdGl2ZV9oPig/OltsY2hdfCg/OlxcZCpcXC4pP1xcZCt8Y2FsY1xcKFtsY2goKS8qXFwtK1xcZC5cXHNdK1xcKSkpKD86XFxzKlxcL1xccyooPzxyZWxhdGl2ZV9hPig/Oig/OlxcZCpcXC4pP1xcZCslP3xjYWxjXFwoWygpLypcXC0rXFxkLlxcc1xcd10qKD86YWxwaGEpP1soKS8qXFwtK1xcZC5cXHNcXHddKlxcKXxhbHBoYSkpKT8pXFxzKlxcKSQvLFxuICAgIFtDb2xvck1vZGVsLkNNWUtdOiAvXig/OmRldmljZS1jbXlrfGNteWspXFxzKlxcKFxccyooPzooPzxjX2xlZ2FjeT4oPzpcXGQqXFwuKT9cXGQrJT8pXFxzKixcXHMqKD88bV9sZWdhY3k+KD86XFxkKlxcLik/XFxkKyU/KVxccyosXFxzKig/PHlfbGVnYWN5Pig/OlxcZCpcXC4pP1xcZCslPylcXHMqLFxccyooPzxrX2xlZ2FjeT4oPzpcXGQqXFwuKT9cXGQrJT8pKD86XFxzKixcXHMqKD88YV9sZWdhY3k+KD86XFxkKlxcLik/XFxkKykpP3woPzxjPig/OlxcZCpcXC4pP1xcZCslPylcXHMrKD88bT4oPzpcXGQqXFwuKT9cXGQrJT8pXFxzKyg/PHk+KD86XFxkKlxcLik/XFxkKyU/KVxccysoPzxrPig/OlxcZCpcXC4pP1xcZCslPykoPzpcXHMqXFwvXFxzKig/PGE+KD86XFxkKlxcLik/XFxkKyU/KSk/KVxccypcXCkkL1xufTtcbmV4cG9ydCBjb25zdCBDQUxDID0ge1xuICAgIFJFR0VYUDogL15jYWxjXFwoXFxzKig/PG9wZXJhdGlvbj5bXFxkLi8qKy1cXHdcXHNdKylcXHMqXFwpJC8sXG4gICAgU0NPUEVEOiAvXFwoXFxzKihbXigpXSspXFxzKlxcKS9nLFxuICAgIERJVklTSU9OOiAvXFxzKig/PGxlZnQ+KD86KD86XFxkKlxcLik/XFxkK3xcXHcrKSlcXHMqXFwvXFxzKig/PHJpZ2h0Pig/Oig/OlxcZCpcXC4pP1xcZCt8XFx3KykpXFxzKi8sXG4gICAgTVVMVElQTElDQVRJT046IC9cXHMqKD88bGVmdD4oPzooPzpcXGQqXFwuKT9cXGQrfFxcdyspKVxccypcXCpcXHMqKD88cmlnaHQ+KD86KD86XFxkKlxcLik/XFxkK3xcXHcrKSlcXHMqLyxcbiAgICBTVU06IC9cXHMqKD88bGVmdD4oPzooPzpcXGQqXFwuKT9cXGQrfFxcdyspKVxccypcXCtcXHMqKD88cmlnaHQ+KD86KD86XFxkKlxcLik/XFxkK3xcXHcrKSlcXHMqLyxcbiAgICBSRVNUOiAvXFxzKig/PGxlZnQ+KD86KD86XFxkKlxcLik/XFxkK3xcXHcrKSlcXHMqLVxccyooPzxyaWdodD4oPzooPzpcXGQqXFwuKT9cXGQrfFxcdyspKVxccyovXG59O1xuZXhwb3J0IGNvbnN0IEhTTF9IVUUgPSAvXig/PG51bWJlcj4tPyg/OlxcZCpcXC4pP1xcZCspKD88dW5pdHM+KD86ZGVnfGdyYWR8cmFkfHR1cm4pPykkLztcbmV4cG9ydCBjb25zdCBQQ0VOVCA9IC9eKC0/XFxkKyg/OlxcLlxcZCspP3wtP1xcLlxcZCspJSQvO1xuZXhwb3J0IGNvbnN0IEhFWCA9IC9eMHgoW2EtZlxcZF17MSwyfSkkL2k7XG5leHBvcnQgY29uc3QgVEVNUExBVEVfVkFSID0gL1xceyhcXGQrKVxcfS9nO1xuZXhwb3J0IGNvbnN0IENPTU1BU19BTkRfTkVYVF9DSEFSUyA9IC8sKCArfFxcZCspL2c7XG5leHBvcnQgY29uc3QgU1BBQ0VTID0gLyArLztcbiIsImV4cG9ydCBjb25zdCBFUlJPUlMgPSB7XG4gICAgTk9UX0FDQ0VQVEVEX1NUUklOR19JTlBVVDogJ1RoZSBwcm92aWRlZCBzdHJpbmcgY29sb3IgZG9lc25cXCd0IGhhdmUgYSBjb3JyZWN0IGZvcm1hdCcsXG4gICAgTk9UX0FDQ0VQVEVEX09CSkVDVF9JTlBVVDogJ1RoZSBwcm92aWRlZCBjb2xvciBvYmplY3QgZG9lc25cXCd0IGhhdmUgdGhlIHByb3BlciBrZXlzIG9yIGZvcm1hdCcsXG4gICAgTk9UX0FfVkFMSURfUkVMQVRJVkVfQ09MT1I6ICdpcyBub3QgYSB2YWxpZCBvcGVyYXRpb24gZm9yIGEgcmVsYXRpdmUgY29sb3InXG59O1xuIiwiZXhwb3J0IHZhciBBbmdsZXNVbml0RW51bTtcbihmdW5jdGlvbiAoQW5nbGVzVW5pdEVudW0pIHtcbiAgICBBbmdsZXNVbml0RW51bVtcIk5PTkVcIl0gPSBcIm5vbmVcIjtcbiAgICBBbmdsZXNVbml0RW51bVtcIkRFR1JFRVNcIl0gPSBcImRlZ1wiO1xuICAgIEFuZ2xlc1VuaXRFbnVtW1wiR1JBRElBTlNcIl0gPSBcImdyYWRcIjtcbiAgICBBbmdsZXNVbml0RW51bVtcIlJBRElBTlNcIl0gPSBcInJhZFwiO1xuICAgIEFuZ2xlc1VuaXRFbnVtW1wiVFVSTlNcIl0gPSBcInR1cm5cIjtcbn0pKEFuZ2xlc1VuaXRFbnVtIHx8IChBbmdsZXNVbml0RW51bSA9IHt9KSk7XG5leHBvcnQgdmFyIENvbG9yVW5pdEVudW07XG4oZnVuY3Rpb24gKENvbG9yVW5pdEVudW0pIHtcbiAgICBDb2xvclVuaXRFbnVtW1wiTk9ORVwiXSA9IFwibm9uZVwiO1xuICAgIENvbG9yVW5pdEVudW1bXCJQRVJDRU5UXCJdID0gXCJwZXJjZW50XCI7XG59KShDb2xvclVuaXRFbnVtIHx8IChDb2xvclVuaXRFbnVtID0ge30pKTtcbmV4cG9ydCB2YXIgQ01ZS0Z1bmN0aW9uRW51bTtcbihmdW5jdGlvbiAoQ01ZS0Z1bmN0aW9uRW51bSkge1xuICAgIENNWUtGdW5jdGlvbkVudW1bXCJERVZJQ0VfQ01ZS1wiXSA9IFwiZGV2aWNlLWNteWtcIjtcbiAgICBDTVlLRnVuY3Rpb25FbnVtW1wiQ01ZS1wiXSA9IFwiY215a1wiO1xufSkoQ01ZS0Z1bmN0aW9uRW51bSB8fCAoQ01ZS0Z1bmN0aW9uRW51bSA9IHt9KSk7XG4iLCJpbXBvcnQgeyBBbmdsZXNVbml0RW51bSwgQ01ZS0Z1bmN0aW9uRW51bSwgQ29sb3JVbml0RW51bSB9IGZyb20gJ0B0eXBlcyc7XG5pbXBvcnQgeyBNQVhfREVDSU1BTFMgfSBmcm9tICcuL251bWJlcnMnO1xuZXhwb3J0IGNvbnN0IERFRkFVTFRfT1BUSU9OUyA9IHtcbiAgICBkZWNpbWFsczogTUFYX0RFQ0lNQUxTLFxuICAgIGxlZ2FjeUNTUzogZmFsc2UsXG4gICAgc3BhY2VzQWZ0ZXJDb21tYXM6IGZhbHNlLFxuICAgIGFuZ2xlc1VuaXQ6IEFuZ2xlc1VuaXRFbnVtLk5PTkUsXG4gICAgcmdiVW5pdDogQ29sb3JVbml0RW51bS5OT05FLFxuICAgIGxhYlVuaXQ6IENvbG9yVW5pdEVudW0uTk9ORSxcbiAgICBsY2hVbml0OiBDb2xvclVuaXRFbnVtLk5PTkUsXG4gICAgY215a1VuaXQ6IENvbG9yVW5pdEVudW0uUEVSQ0VOVCxcbiAgICBhbHBoYVVuaXQ6IENvbG9yVW5pdEVudW0uTk9ORSxcbiAgICBjbXlrRnVuY3Rpb246IENNWUtGdW5jdGlvbkVudW0uREVWSUNFX0NNWUtcbn07XG4iLCJleHBvcnQgKiBmcm9tICcuL251bWJlcnMnO1xuZXhwb3J0ICogZnJvbSAnLi9lbnVtcyc7XG5leHBvcnQgKiBmcm9tICcuL2VudW1zLXN0cmluZ3MnO1xuZXhwb3J0ICogZnJvbSAnLi9yZWdleHBzJztcbmV4cG9ydCAqIGZyb20gJy4vZXJyb3JzJztcbmV4cG9ydCAqIGZyb20gJy4vb3B0aW9ucyc7XG4iLCJpbXBvcnQgeyBBbmdsZXNVbml0RW51bSB9IGZyb20gJ0B0eXBlcyc7XG5pbXBvcnQgeyBCQVNFXzI1NSwgSGFybW9ueSwgSEVYLCBIU0xfSFVFLCBNQVhfQUxQSEEsIE1BWF9ERUNJTUFMUywgTUFYX0xBQiwgTUFYX0xDSF9DLCBNaXgsIFBDRU5UIH0gZnJvbSAnI2NvbnN0YW50cyc7XG5leHBvcnQgY29uc3QgaGFzUHJvcCA9IChvYmosIHByb3ApID0+IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIHByb3ApO1xuZXhwb3J0IGNvbnN0IHBlcmNlbnROdW1iZXIgPSAocGVyY2VudCkgPT4ge1xuICAgIHJldHVybiArYCR7cGVyY2VudH1gLnJlcGxhY2UoUENFTlQsICckMScpO1xufTtcbmV4cG9ydCBjb25zdCBwZXJjZW50ID0gKHBlcmNlbnQpID0+IFBDRU5ULnRlc3QoYCR7cGVyY2VudH1gKVxuICAgID8gcGVyY2VudE51bWJlcihwZXJjZW50KVxuICAgIDogTWF0aC5taW4oK3BlcmNlbnQsIDEwMCk7XG5leHBvcnQgY29uc3QgZ2V0REVDID0gKGhleCkgPT4ge1xuICAgIGlmIChoZXgubGVuZ3RoID09PSAxKSB7XG4gICAgICAgIGhleCArPSBoZXg7XG4gICAgfVxuICAgIHJldHVybiBwYXJzZUludChoZXgsIDE2KTtcbn07XG5leHBvcnQgY29uc3QgZ2V0SEVYID0gKG51bWJlcikgPT4ge1xuICAgIGNvbnN0IGhleCA9IHJvdW5kKG51bWJlciwgMCkudG9TdHJpbmcoMTYpLnRvVXBwZXJDYXNlKCk7XG4gICAgaWYgKGhleC5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgcmV0dXJuIGAweDAke2hleH1gO1xuICAgIH1cbiAgICByZXR1cm4gYDB4JHtoZXh9YDtcbn07XG5leHBvcnQgY29uc3QgdG9IRVggPSAoaCkgPT4ge1xuICAgIGxldCBoZXggPSByb3VuZChoLCAwKS50b1N0cmluZygxNikudG9VcHBlckNhc2UoKTtcbiAgICBpZiAoaGV4Lmxlbmd0aCA9PT0gMSkge1xuICAgICAgICBoZXggPSBgMCR7aGV4fWA7XG4gICAgfVxuICAgIHJldHVybiBoZXg7XG59O1xuZXhwb3J0IGNvbnN0IGZyb20yNTVOdW1iZXJUb1BlcmNlbnQgPSAodmFsdWUsIGRlY2ltYWxzKSA9PiByb3VuZCh2YWx1ZSAvIEJBU0VfMjU1ICogMTAwLCBkZWNpbWFscyk7XG5leHBvcnQgY29uc3QgZnJvbTEyNU51bWJlclRvUGVyY2VudCA9ICh2YWx1ZSwgZGVjaW1hbHMpID0+IHJvdW5kKHZhbHVlIC8gTUFYX0xBQiAqIDEwMCwgZGVjaW1hbHMpO1xuZXhwb3J0IGNvbnN0IGZyb20xNTBOdW1iZXJUb1BlcmNlbnQgPSAodmFsdWUsIGRlY2ltYWxzKSA9PiByb3VuZCh2YWx1ZSAvIE1BWF9MQ0hfQyAqIDEwMCwgZGVjaW1hbHMpO1xuZXhwb3J0IGNvbnN0IGdldEJhc2UyNTVOdW1iZXIgPSAoY29sb3IsIGFscGhhID0gZmFsc2UpID0+IHtcbiAgICBpZiAoIWFscGhhICYmIFBDRU5ULnRlc3QoY29sb3IpKSB7XG4gICAgICAgIHJldHVybiBNYXRoLm1pbihCQVNFXzI1NSAqIHBlcmNlbnROdW1iZXIoY29sb3IpIC8gMTAwLCBCQVNFXzI1NSk7XG4gICAgfVxuICAgIGlmIChIRVgudGVzdChjb2xvcikpIHtcbiAgICAgICAgaWYgKGNvbG9yLmxlbmd0aCA9PT0gMykge1xuICAgICAgICAgICAgY29sb3IgKz0gY29sb3Iuc2xpY2UoLTEpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhbHBoYVxuICAgICAgICAgICAgPyByb3VuZChjb2xvcikgLyBCQVNFXzI1NVxuICAgICAgICAgICAgOiByb3VuZChjb2xvcik7XG4gICAgfVxuICAgIHJldHVybiBNYXRoLm1pbigrY29sb3IsIGFscGhhID8gMSA6IEJBU0VfMjU1KTtcbn07XG5leHBvcnQgY29uc3QgZ2V0QmFzZTEyNU51bWJlciA9IChjb2xvcikgPT4ge1xuICAgIGlmIChQQ0VOVC50ZXN0KGNvbG9yKSkge1xuICAgICAgICByZXR1cm4gbWlubWF4KE1BWF9MQUIgKiBwZXJjZW50TnVtYmVyKGNvbG9yKSAvIDEwMCwgLU1BWF9MQUIsIE1BWF9MQUIpO1xuICAgIH1cbiAgICByZXR1cm4gbWlubWF4KCtjb2xvciwgLU1BWF9MQUIsIE1BWF9MQUIpO1xufTtcbmV4cG9ydCBjb25zdCBnZXRCYXNlMTUwTnVtYmVyID0gKGNvbG9yKSA9PiB7XG4gICAgaWYgKFBDRU5ULnRlc3QoY29sb3IpKSB7XG4gICAgICAgIHJldHVybiBtaW5tYXgoTUFYX0xDSF9DICogcGVyY2VudE51bWJlcihjb2xvcikgLyAxMDAsIC1NQVhfTENIX0MsIE1BWF9MQ0hfQyk7XG4gICAgfVxuICAgIHJldHVybiBtaW5tYXgoK2NvbG9yLCAtTUFYX0xDSF9DLCBNQVhfTENIX0MpO1xufTtcbmV4cG9ydCBjb25zdCBnZXRDTVlLTnVtYmVyID0gKGNvbG9yKSA9PiBNYXRoLm1pbihQQ0VOVC50ZXN0KGNvbG9yKSA/IHBlcmNlbnROdW1iZXIoY29sb3IpIC8gMTAwIDogK2NvbG9yLCAxKTtcbmV4cG9ydCBjb25zdCBnZXRPcmRlcmVkQXJyYXlTdHJpbmcgPSAoa2V5cykgPT4gWy4uLmtleXNdLnNvcnQoKS5qb2luKCcnKS50b1VwcGVyQ2FzZSgpO1xuZXhwb3J0IGNvbnN0IHJvdW5kID0gKHZhbHVlLCBkZWNpbWFscyA9IE1BWF9ERUNJTUFMUykgPT4ge1xuICAgIGNvbnN0IGV4cCA9IE1hdGgucG93KDEwLCBkZWNpbWFscyk7XG4gICAgcmV0dXJuIE1hdGgucm91bmQoK3ZhbHVlICogZXhwKSAvIGV4cDtcbn07XG5leHBvcnQgY29uc3QgbWlubWF4ID0gKG4sIG1pbiwgbWF4KSA9PiBNYXRoLm1heChtaW4sIE1hdGgubWluKG4sIG1heCkpO1xuZXhwb3J0IGNvbnN0IGRlZ3JlZXMgPSAocmFkaWFuKSA9PiByYWRpYW4gKiAxODAgLyBNYXRoLlBJO1xuZXhwb3J0IGNvbnN0IHJhZGlhbnMgPSAoZGVncmVlcykgPT4gZGVncmVlcyAqIE1hdGguUEkgLyAxODA7XG5jb25zdCBwaTIgPSAzNjA7XG5leHBvcnQgY29uc3Qgbm9ybWFsaXplSHVlID0gKGh1ZSkgPT4ge1xuICAgIGlmICh0eXBlb2YgaHVlID09PSAnc3RyaW5nJykge1xuICAgICAgICBjb25zdCBtYXRjaGVzID0gaHVlLm1hdGNoKEhTTF9IVUUpO1xuICAgICAgICBjb25zdCBncm91cHMgPSBtYXRjaGVzLmdyb3VwcztcbiAgICAgICAgY29uc3QgdmFsdWUgPSArZ3JvdXBzLm51bWJlcjtcbiAgICAgICAgY29uc3QgdW5pdHMgPSBncm91cHMudW5pdHM7XG4gICAgICAgIHN3aXRjaCAodW5pdHMpIHtcbiAgICAgICAgICAgIGNhc2UgQW5nbGVzVW5pdEVudW0uUkFESUFOUzpcbiAgICAgICAgICAgICAgICBodWUgPSByb3VuZChkZWdyZWVzKHZhbHVlKSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIEFuZ2xlc1VuaXRFbnVtLlRVUk5TOlxuICAgICAgICAgICAgICAgIGh1ZSA9IHJvdW5kKHZhbHVlICogcGkyKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgQW5nbGVzVW5pdEVudW0uR1JBRElBTlM6XG4gICAgICAgICAgICAgICAgaHVlID0gcm91bmQoOSAvIDEwICogdmFsdWUpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBBbmdsZXNVbml0RW51bS5ERUdSRUVTOlxuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICBodWUgPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoaHVlID4gMzYwIHx8IGh1ZSA8IDApIHtcbiAgICAgICAgaHVlIC09IE1hdGguZmxvb3IoaHVlIC8gcGkyKSAqIHBpMjtcbiAgICB9XG4gICAgcmV0dXJuIGh1ZTtcbn07XG5leHBvcnQgY29uc3Qgbm9ybWFsaXplQWxwaGEgPSAoYWxwaGEpID0+IHtcbiAgICBpZiAodHlwZW9mIGFscGhhID09PSAnc3RyaW5nJykge1xuICAgICAgICBpZiAoUENFTlQudGVzdChhbHBoYSkpIHtcbiAgICAgICAgICAgIGFscGhhID0gcGVyY2VudE51bWJlcihhbHBoYSkgLyAxMDA7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBhbHBoYSA9ICthbHBoYTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gKGlzTmFOKCthbHBoYSkgfHwgYWxwaGEgPiBNQVhfQUxQSEEpID8gTUFYX0FMUEhBIDogcm91bmQoYWxwaGEpO1xufTtcbmV4cG9ydCBjb25zdCB0cmFuc2xhdGVEZWdyZWVzID0gKGRlZ3JlZXMsIHVuaXRzKSA9PiB7XG4gICAgbGV0IGh1ZTtcbiAgICBzd2l0Y2ggKHVuaXRzKSB7XG4gICAgICAgIGNhc2UgQW5nbGVzVW5pdEVudW0uUkFESUFOUzpcbiAgICAgICAgICAgIGh1ZSA9IHJvdW5kKHJhZGlhbnMoZGVncmVlcykpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgQW5nbGVzVW5pdEVudW0uVFVSTlM6XG4gICAgICAgICAgICBodWUgPSByb3VuZChkZWdyZWVzIC8gcGkyKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIEFuZ2xlc1VuaXRFbnVtLkdSQURJQU5TOlxuICAgICAgICAgICAgaHVlID0gcm91bmQoMTAgLyA5ICogZGVncmVlcyk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBBbmdsZXNVbml0RW51bS5ERUdSRUVTOlxuICAgICAgICBjYXNlIEFuZ2xlc1VuaXRFbnVtLk5PTkU6XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICBodWUgPSBkZWdyZWVzO1xuICAgIH1cbiAgICByZXR1cm4gaHVlO1xufTtcbmV4cG9ydCBjb25zdCBpc0hhcm1vbnkgPSAocGFyYW0pID0+IHtcbiAgICByZXR1cm4gYCR7cGFyYW19YCBpbiBIYXJtb255O1xufTtcbmV4cG9ydCBjb25zdCBpc01peCA9IChwYXJhbSkgPT4ge1xuICAgIHJldHVybiBgJHtwYXJhbX1gIGluIE1peDtcbn07XG4iLCJpbXBvcnQgeyBCQVNFXzI1NSwgTUFYX0FMUEhBIH0gZnJvbSAnI2NvbnN0YW50cyc7XG5pbXBvcnQgeyBkZWdyZWVzLCBtaW5tYXgsIG5vcm1hbGl6ZUh1ZSwgcmFkaWFucywgcm91bmQgfSBmcm9tICcjaGVscGVycyc7XG5jb25zdCBNQVRSSVhfTFJHQl9YWVpfRDUwID0gW1xuICAgIFswLjQzNjA3NDcsIDAuMzg1MDY0OSwgMC4xNDMwODA0XSxcbiAgICBbMC4yMjI1MDQ1LCAwLjcxNjg3ODYsIDAuMDYwNjE2OV0sXG4gICAgWzAuMDEzOTMyMiwgMC4wOTcxMDQ1LCAwLjcxNDE3MzNdXG5dO1xuY29uc3QgTUFUUklYX1hZWl9ENTBfTFJHQiA9IFtcbiAgICBbMy4xMzM4NTYxLCAtMS42MTY4NjY3LCAtMC40OTA2MTQ2XSxcbiAgICBbLTAuOTc4NzY4NCwgMS45MTYxNDE1LCAwLjAzMzQ1NF0sXG4gICAgWzAuMDcxOTQ1MywgLTAuMjI4OTkxNCwgMS40MDUyNDI3XVxuXTtcbmNvbnN0IFRSSVNUSU1VTFVTX0Q1MCA9IE1BVFJJWF9MUkdCX1hZWl9ENTAubWFwKChtYXRyaXgpID0+IHtcbiAgICByZXR1cm4gbWF0cml4LnJlZHVjZSgoc3VtLCB2YWx1ZSkgPT4gc3VtICsgdmFsdWUsIDApO1xufSk7XG5jb25zdCBodWVUb1JnYiA9ICh0MSwgdDIsIGh1ZSkgPT4ge1xuICAgIGlmIChodWUgPCAwKSB7XG4gICAgICAgIGh1ZSArPSA2O1xuICAgIH1cbiAgICBpZiAoaHVlID49IDYpIHtcbiAgICAgICAgaHVlIC09IDY7XG4gICAgfVxuICAgIGlmIChodWUgPCAxKSB7XG4gICAgICAgIHJldHVybiByb3VuZCgoKHQyIC0gdDEpICogaHVlICsgdDEpICogQkFTRV8yNTUpO1xuICAgIH1cbiAgICBlbHNlIGlmIChodWUgPCAzKSB7XG4gICAgICAgIHJldHVybiByb3VuZCh0MiAqIEJBU0VfMjU1KTtcbiAgICB9XG4gICAgZWxzZSBpZiAoaHVlIDwgNCkge1xuICAgICAgICByZXR1cm4gcm91bmQoKCh0MiAtIHQxKSAqICg0IC0gaHVlKSArIHQxKSAqIEJBU0VfMjU1KTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiByb3VuZCh0MSAqIEJBU0VfMjU1KTtcbiAgICB9XG59O1xuY29uc3QgcmdiVG9MaW5lYXJMaWdodFJnYiA9ICh2YWx1ZSkgPT4ge1xuICAgIHJldHVybiB2YWx1ZSA8PSAwLjA0MDQ1XG4gICAgICAgID8gdmFsdWUgLyAxMi45MlxuICAgICAgICA6ICgodmFsdWUgKyAwLjA1NSkgLyAxLjA1NSkgKiogMi40O1xufTtcbmNvbnN0IGxpbmVhckxpZ2h0UmdiVG9SZ2IgPSAodmFsdWUpID0+IHtcbiAgICByZXR1cm4gdmFsdWUgPD0gMC4wMDMxMzA4XG4gICAgICAgID8gMTIuOTIgKiB2YWx1ZVxuICAgICAgICA6IDEuMDU1ICogKHZhbHVlICoqICgxIC8gMi40KSkgLSAwLjA1NTtcbn07XG5jb25zdCBtYXRyaXhWZWN0b3JNdWx0aXBsaWNhdGlvbiA9ICh2MSwgdjIsIHYzLCBtYXRyaXgpID0+IHtcbiAgICBjb25zdCByZXN1bHQgPSBbMCwgMCwgMF07XG4gICAgY29uc3QgbGluZWFyUmdiID0gW3YxLCB2MiwgdjNdO1xuICAgIG1hdHJpeC5mb3JFYWNoKChhcnJheSwgaW5kZXgpID0+IHtcbiAgICAgICAgYXJyYXkuZm9yRWFjaCgodmFsdWUsIG1pbmRleCkgPT4ge1xuICAgICAgICAgICAgcmVzdWx0W2luZGV4XSArPSB2YWx1ZSAqIGxpbmVhclJnYlttaW5kZXhdO1xuICAgICAgICB9KTtcbiAgICB9KTtcbiAgICByZXR1cm4gcmVzdWx0O1xufTtcbmNvbnN0IGZyb21fQ0lFX1hZWl9ENTBfdG9fQ0lFX0xBQiA9ICh4LCB5LCB6KSA9PiB7XG4gICAgY29uc3QgZiA9ICh0KSA9PiB7XG4gICAgICAgIHJldHVybiB0ID4gKDYgLyAyOSkgKiogM1xuICAgICAgICAgICAgPyBNYXRoLmNicnQodClcbiAgICAgICAgICAgIDogdCAvICgzICogKDYgLyAyOSkgKiogMikgKyAoNCAvIDI5KTtcbiAgICB9O1xuICAgIGNvbnN0IGZ4ID0gZih4IC8gVFJJU1RJTVVMVVNfRDUwWzBdKTtcbiAgICBjb25zdCBmeSA9IGYoeSAvIFRSSVNUSU1VTFVTX0Q1MFsxXSk7XG4gICAgY29uc3QgZnogPSBmKHogLyBUUklTVElNVUxVU19ENTBbMl0pO1xuICAgIHJldHVybiBbXG4gICAgICAgIDExNiAqIGZ5IC0gMTYsXG4gICAgICAgIDUwMCAqIChmeCAtIGZ5KSxcbiAgICAgICAgMjAwICogKGZ5IC0gZnopXG4gICAgXTtcbn07XG5jb25zdCBmcm9tX0NJRV9MQUJfdG9fQ0lFX1hZWl9ENTAgPSAoTCwgYSwgYikgPT4ge1xuICAgIGNvbnN0IGYgPSAodCkgPT4ge1xuICAgICAgICByZXR1cm4gdCA+IDYgLyAyOVxuICAgICAgICAgICAgPyB0ICoqIDNcbiAgICAgICAgICAgIDogMyAqICg2IC8gMjkpICoqIDIgKiAodCAtIDQgLyAyOSk7XG4gICAgfTtcbiAgICBjb25zdCBmbCA9IChMICsgMTYpIC8gMTE2O1xuICAgIGNvbnN0IGZhID0gYSAvIDUwMDtcbiAgICBjb25zdCBmYiA9IGIgLyAyMDA7XG4gICAgcmV0dXJuIFtcbiAgICAgICAgVFJJU1RJTVVMVVNfRDUwWzBdICogZihmbCArIGZhKSxcbiAgICAgICAgVFJJU1RJTVVMVVNfRDUwWzFdICogZihmbCksXG4gICAgICAgIFRSSVNUSU1VTFVTX0Q1MFsyXSAqIGYoZmwgLSBmYilcbiAgICBdO1xufTtcbmV4cG9ydCBjb25zdCBoc2xUb1JnYiA9IChILCBTLCBMKSA9PiB7XG4gICAgSCAvPSA2MDtcbiAgICBTIC89IDEwMDtcbiAgICBMIC89IDEwMDtcbiAgICBjb25zdCB0MiA9IChMIDw9IC41KVxuICAgICAgICA/IEwgKiAoUyArIDEpXG4gICAgICAgIDogTCArIFMgLSAoTCAqIFMpO1xuICAgIGNvbnN0IHQxID0gTCAqIDIgLSB0MjtcbiAgICBjb25zdCBSID0gaHVlVG9SZ2IodDEsIHQyLCBIICsgMik7XG4gICAgY29uc3QgRyA9IGh1ZVRvUmdiKHQxLCB0MiwgSCk7XG4gICAgY29uc3QgQiA9IGh1ZVRvUmdiKHQxLCB0MiwgSCAtIDIpO1xuICAgIHJldHVybiB7IFIsIEcsIEIgfTtcbn07XG5leHBvcnQgY29uc3QgcmdiVG9Ic2wgPSAoUiwgRywgQiwgQSA9IDEpID0+IHtcbiAgICBSIC89IEJBU0VfMjU1O1xuICAgIEcgLz0gQkFTRV8yNTU7XG4gICAgQiAvPSBCQVNFXzI1NTtcbiAgICBBID0gTWF0aC5taW4oQSwgTUFYX0FMUEhBKTtcbiAgICBjb25zdCBNQVggPSBNYXRoLm1heChSLCBHLCBCKTtcbiAgICBjb25zdCBNSU4gPSBNYXRoLm1pbihSLCBHLCBCKTtcbiAgICBjb25zdCBEID0gTUFYIC0gTUlOO1xuICAgIGxldCBIID0gMDtcbiAgICBsZXQgUyA9IDA7XG4gICAgY29uc3QgTCA9IChNQVggKyBNSU4pIC8gMjtcbiAgICBpZiAoRCAhPT0gMCkge1xuICAgICAgICBzd2l0Y2ggKE1BWCkge1xuICAgICAgICAgICAgY2FzZSBSOlxuICAgICAgICAgICAgICAgIEggPSAoKEcgLSBCKSAvIEQpICUgNjtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgRzpcbiAgICAgICAgICAgICAgICBIID0gKEIgLSBSKSAvIEQgKyAyO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBCOlxuICAgICAgICAgICAgICAgIEggPSAoUiAtIEcpIC8gRCArIDQ7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgSCA9IHJvdW5kKEggKiA2MCk7XG4gICAgICAgIGlmIChIIDwgMCkge1xuICAgICAgICAgICAgSCArPSAzNjA7XG4gICAgICAgIH1cbiAgICAgICAgUyA9IEQgLyAoMSAtIE1hdGguYWJzKDIgKiBMIC0gMSkpO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICBILFxuICAgICAgICBTOiByb3VuZChTICogMTAwKSxcbiAgICAgICAgTDogcm91bmQoTCAqIDEwMCksXG4gICAgICAgIEFcbiAgICB9O1xufTtcbmV4cG9ydCBjb25zdCByZ2JUb0xhYiA9IChSLCBHLCBCKSA9PiB7XG4gICAgY29uc3QgTElORUFSX0xJR0hUX1JHQiA9IFtcbiAgICAgICAgUiAvIEJBU0VfMjU1LFxuICAgICAgICBHIC8gQkFTRV8yNTUsXG4gICAgICAgIEIgLyBCQVNFXzI1NVxuICAgIF0ubWFwKHJnYlRvTGluZWFyTGlnaHRSZ2IpO1xuICAgIGNvbnN0IENJRV9YWVpfRDUwID0gbWF0cml4VmVjdG9yTXVsdGlwbGljYXRpb24oTElORUFSX0xJR0hUX1JHQlswXSwgTElORUFSX0xJR0hUX1JHQlsxXSwgTElORUFSX0xJR0hUX1JHQlsyXSwgTUFUUklYX0xSR0JfWFlaX0Q1MCk7XG4gICAgY29uc3QgQ0lFX0xBQiA9IGZyb21fQ0lFX1hZWl9ENTBfdG9fQ0lFX0xBQihDSUVfWFlaX0Q1MFswXSwgQ0lFX1hZWl9ENTBbMV0sIENJRV9YWVpfRDUwWzJdKTtcbiAgICByZXR1cm4ge1xuICAgICAgICBMOiBDSUVfTEFCWzBdLFxuICAgICAgICBhOiBDSUVfTEFCWzFdLFxuICAgICAgICBiOiBDSUVfTEFCWzJdXG4gICAgfTtcbn07XG5leHBvcnQgY29uc3QgbGFiVG9SZ2IgPSAoTCwgYSwgYikgPT4ge1xuICAgIGNvbnN0IENJRV9YWVpfRDUwID0gZnJvbV9DSUVfTEFCX3RvX0NJRV9YWVpfRDUwKEwsIGEsIGIpO1xuICAgIGNvbnN0IExJTkVBUl9MSUdIVF9SR0IgPSBtYXRyaXhWZWN0b3JNdWx0aXBsaWNhdGlvbihDSUVfWFlaX0Q1MFswXSwgQ0lFX1hZWl9ENTBbMV0sIENJRV9YWVpfRDUwWzJdLCBNQVRSSVhfWFlaX0Q1MF9MUkdCKTtcbiAgICBjb25zdCByZ2IgPSBMSU5FQVJfTElHSFRfUkdCLm1hcChsaW5lYXJMaWdodFJnYlRvUmdiKTtcbiAgICByZXR1cm4ge1xuICAgICAgICBSOiBtaW5tYXgocmdiWzBdICogQkFTRV8yNTUsIDAsIEJBU0VfMjU1KSxcbiAgICAgICAgRzogbWlubWF4KHJnYlsxXSAqIEJBU0VfMjU1LCAwLCBCQVNFXzI1NSksXG4gICAgICAgIEI6IG1pbm1heChyZ2JbMl0gKiBCQVNFXzI1NSwgMCwgQkFTRV8yNTUpXG4gICAgfTtcbn07XG5leHBvcnQgY29uc3QgbGFiVG9MY2ggPSAoTCwgYSwgYikgPT4ge1xuICAgIGNvbnN0IEMgPSBNYXRoLnNxcnQoYSAqKiAyICsgYiAqKiAyKTtcbiAgICBjb25zdCBIID0gZGVncmVlcyhNYXRoLmF0YW4yKGIsIGEpKTtcbiAgICByZXR1cm4ge1xuICAgICAgICBMLFxuICAgICAgICBDLFxuICAgICAgICBIOiBub3JtYWxpemVIdWUoSClcbiAgICB9O1xufTtcbmV4cG9ydCBjb25zdCBsY2hUb0xhYiA9IChMLCBDLCBIKSA9PiB7XG4gICAgY29uc3QgcmFkSCA9IHJhZGlhbnMoSCk7XG4gICAgY29uc3QgYSA9IEMgKiBNYXRoLmNvcyhyYWRIKTtcbiAgICBjb25zdCBiID0gQyAqIE1hdGguc2luKHJhZEgpO1xuICAgIHJldHVybiB7XG4gICAgICAgIEwsXG4gICAgICAgIGEsXG4gICAgICAgIGJcbiAgICB9O1xufTtcbmV4cG9ydCBjb25zdCByZ2JUb0xjaCA9IChSLCBHLCBCKSA9PiB7XG4gICAgY29uc3QgbGFiID0gcmdiVG9MYWIoUiwgRywgQik7XG4gICAgcmV0dXJuIGxhYlRvTGNoKGxhYi5MLCBsYWIuYSwgbGFiLmIpO1xufTtcbmV4cG9ydCBjb25zdCBsY2hUb1JnYiA9IChMLCBDLCBIKSA9PiB7XG4gICAgY29uc3QgbGFiID0gbGNoVG9MYWIoTCwgQywgSCk7XG4gICAgcmV0dXJuIGxhYlRvUmdiKGxhYi5MLCBsYWIuYSwgbGFiLmIpO1xufTtcbmV4cG9ydCBjb25zdCByZ2JUb0h3YiA9IChSLCBHLCBCLCBBID0gMSkgPT4ge1xuICAgIGNvbnN0IGhzbCA9IHJnYlRvSHNsKFIsIEcsIEIsIEEpO1xuICAgIHJldHVybiB7XG4gICAgICAgIEg6IGhzbC5ILFxuICAgICAgICBXOiByb3VuZChNYXRoLm1pbihSLCBHLCBCKSAvIEJBU0VfMjU1ICogMTAwKSxcbiAgICAgICAgQjogcm91bmQoKDEgLSBNYXRoLm1heChSLCBHLCBCKSAvIEJBU0VfMjU1KSAqIDEwMCksXG4gICAgICAgIEFcbiAgICB9O1xufTtcbmV4cG9ydCBjb25zdCBod2JUb1JnYiA9IChILCBXLCBCKSA9PiB7XG4gICAgVyAvPSAxMDA7XG4gICAgQiAvPSAxMDA7XG4gICAgY29uc3QgdiA9IDEgLSBCO1xuICAgIGNvbnN0IGMgPSB2IC0gVztcbiAgICBjb25zdCB4ID0gYyAqICgxIC0gTWF0aC5hYnMoKEggLyA2MCkgJSAyIC0gMSkpO1xuICAgIGxldCByZ2JSID0gMDtcbiAgICBsZXQgcmdiRyA9IDA7XG4gICAgbGV0IHJnYkIgPSAwO1xuICAgIGlmIChIIDwgNjApIHtcbiAgICAgICAgcmdiUiA9IGM7XG4gICAgICAgIHJnYkcgPSB4O1xuICAgICAgICByZ2JCID0gMDtcbiAgICB9XG4gICAgZWxzZSBpZiAoSCA+PSA2MCAmJiBIIDwgMTIwKSB7XG4gICAgICAgIHJnYlIgPSB4O1xuICAgICAgICByZ2JHID0gYztcbiAgICAgICAgcmdiQiA9IDA7XG4gICAgfVxuICAgIGVsc2UgaWYgKEggPj0gMTIwICYmIEggPCAxODApIHtcbiAgICAgICAgcmdiUiA9IDA7XG4gICAgICAgIHJnYkcgPSBjO1xuICAgICAgICByZ2JCID0geDtcbiAgICB9XG4gICAgZWxzZSBpZiAoSCA+PSAxODAgJiYgSCA8IDI0MCkge1xuICAgICAgICByZ2JSID0gMDtcbiAgICAgICAgcmdiRyA9IHg7XG4gICAgICAgIHJnYkIgPSBjO1xuICAgIH1cbiAgICBlbHNlIGlmIChIID49IDI0MCAmJiBIIDwgMzAwKSB7XG4gICAgICAgIHJnYlIgPSB4O1xuICAgICAgICByZ2JHID0gMDtcbiAgICAgICAgcmdiQiA9IGM7XG4gICAgfVxuICAgIGVsc2UgaWYgKEggPj0gMzAwKSB7XG4gICAgICAgIHJnYlIgPSBjO1xuICAgICAgICByZ2JHID0gMDtcbiAgICAgICAgcmdiQiA9IHg7XG4gICAgfVxuICAgIHJnYlIgKz0gVztcbiAgICByZ2JHICs9IFc7XG4gICAgcmdiQiArPSBXO1xuICAgIHJldHVybiB7XG4gICAgICAgIFI6IG1pbm1heChyZ2JSICogQkFTRV8yNTUsIDAsIEJBU0VfMjU1KSxcbiAgICAgICAgRzogbWlubWF4KHJnYkcgKiBCQVNFXzI1NSwgMCwgQkFTRV8yNTUpLFxuICAgICAgICBCOiBtaW5tYXgocmdiQiAqIEJBU0VfMjU1LCAwLCBCQVNFXzI1NSlcbiAgICB9O1xufTtcbmV4cG9ydCBjb25zdCBjbXlrVG9SZ2IgPSAoQywgTSwgWSwgSykgPT4ge1xuICAgIEsgPSAxIC0gSztcbiAgICByZXR1cm4ge1xuICAgICAgICBSOiByb3VuZChCQVNFXzI1NSAqICgxIC0gQykgKiBLKSxcbiAgICAgICAgRzogcm91bmQoQkFTRV8yNTUgKiAoMSAtIE0pICogSyksXG4gICAgICAgIEI6IHJvdW5kKEJBU0VfMjU1ICogKDEgLSBZKSAqIEspXG4gICAgfTtcbn07XG5leHBvcnQgY29uc3QgcmdiVG9DbXlrID0gKFIsIEcsIEIpID0+IHtcbiAgICBSIC89IEJBU0VfMjU1O1xuICAgIEcgLz0gQkFTRV8yNTU7XG4gICAgQiAvPSBCQVNFXzI1NTtcbiAgICBjb25zdCBLID0gMSAtIE1hdGgubWF4KFIsIEcsIEIpO1xuICAgIGNvbnN0IEsxID0gMSAtIEs7XG4gICAgY29uc3QgQyA9IEsxICYmIChLMSAtIFIpIC8gSzE7XG4gICAgY29uc3QgTSA9IEsxICYmIChLMSAtIEcpIC8gSzE7XG4gICAgY29uc3QgWSA9IEsxICYmIChLMSAtIEIpIC8gSzE7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgQzogcm91bmQoQyAqIDEwMCksXG4gICAgICAgIE06IHJvdW5kKE0gKiAxMDApLFxuICAgICAgICBZOiByb3VuZChZICogMTAwKSxcbiAgICAgICAgSzogcm91bmQoSyAqIDEwMClcbiAgICB9O1xufTtcbmV4cG9ydCBjb25zdCByZ2JUb1J5YiA9IChSLCBHLCBCKSA9PiB7XG4gICAgY29uc3QgSXcgPSBNYXRoLm1pbihSLCBHLCBCKTtcbiAgICBjb25zdCBJYiA9IE1hdGgubWluKEJBU0VfMjU1IC0gUiwgQkFTRV8yNTUgLSBHLCBCQVNFXzI1NSAtIEIpO1xuICAgIGNvbnN0IHJSZ2IgPSBSIC0gSXc7XG4gICAgY29uc3QgZ1JnYiA9IEcgLSBJdztcbiAgICBjb25zdCBiUmdiID0gQiAtIEl3O1xuICAgIGNvbnN0IG1pblJnID0gTWF0aC5taW4oclJnYiwgZ1JnYik7XG4gICAgY29uc3QgclJ5YiA9IHJSZ2IgLSBtaW5SZztcbiAgICBjb25zdCB5UnliID0gKGdSZ2IgKyBtaW5SZykgLyAyO1xuICAgIGNvbnN0IGJSeWIgPSAoYlJnYiArIGdSZ2IgLSBtaW5SZykgLyAyO1xuICAgIGNvbnN0IG4gPSBNYXRoLm1heChyUnliLCB5UnliLCBiUnliKSAvIE1hdGgubWF4KHJSZ2IsIGdSZ2IsIGJSZ2IpO1xuICAgIGNvbnN0IE4gPSBpc05hTihuKSB8fCBuID09PSBJbmZpbml0eSB8fCBuIDw9IDAgPyAxIDogbjtcbiAgICByZXR1cm4ge1xuICAgICAgICBSOiByUnliIC8gTiArIEliLFxuICAgICAgICBZOiB5UnliIC8gTiArIEliLFxuICAgICAgICBCOiBiUnliIC8gTiArIEliXG4gICAgfTtcbn07XG5leHBvcnQgY29uc3QgcnliVG9SZ2IgPSAoUiwgWSwgQikgPT4ge1xuICAgIGNvbnN0IEl3ID0gTWF0aC5taW4oUiwgWSwgQik7XG4gICAgY29uc3QgSWIgPSBNYXRoLm1pbihCQVNFXzI1NSAtIFIsIEJBU0VfMjU1IC0gWSwgQkFTRV8yNTUgLSBCKTtcbiAgICBjb25zdCByUnliID0gUiAtIEl3O1xuICAgIGNvbnN0IHlSeWIgPSBZIC0gSXc7XG4gICAgY29uc3QgYlJ5YiA9IEIgLSBJdztcbiAgICBjb25zdCBtaW5ZYiA9IE1hdGgubWluKHlSeWIsIGJSeWIpO1xuICAgIGNvbnN0IHJSZ2IgPSByUnliICsgeVJ5YiAtIG1pblliO1xuICAgIGNvbnN0IGdSZ2IgPSB5UnliICsgbWluWWI7XG4gICAgY29uc3QgYlJnYiA9IDIgKiAoYlJ5YiAtIG1pblliKTtcbiAgICBjb25zdCBuID0gTWF0aC5tYXgoclJnYiwgZ1JnYiwgYlJnYikgLyBNYXRoLm1heChyUnliLCB5UnliLCBiUnliKTtcbiAgICBjb25zdCBOID0gaXNOYU4obikgfHwgbiA9PT0gSW5maW5pdHkgfHwgbiA8PSAwID8gMSA6IG47XG4gICAgcmV0dXJuIHtcbiAgICAgICAgUjogclJnYiAvIE4gKyBJYixcbiAgICAgICAgRzogZ1JnYiAvIE4gKyBJYixcbiAgICAgICAgQjogYlJnYiAvIE4gKyBJYlxuICAgIH07XG59O1xuZXhwb3J0IGNvbnN0IGh1ZVJ5YiA9IChodWUsIHRvUnliKSA9PiB7XG4gICAgaWYgKGh1ZSA8IDApXG4gICAgICAgIGh1ZSArPSAzNjA7XG4gICAgaWYgKGh1ZSA+IDM2MClcbiAgICAgICAgaHVlIC09IDM2MDtcbiAgICBpZiAoaHVlID09PSAzNjAgfHwgaHVlID09PSAwKVxuICAgICAgICByZXR1cm4gaHVlO1xuICAgIGNvbnN0IG1hcDEgPSBbXG4gICAgICAgIFswLCAxMjBdLFxuICAgICAgICBbMTIwLCAxODBdLFxuICAgICAgICBbMTgwLCAyNDBdLFxuICAgICAgICBbMjQwLCAzNjBdXG4gICAgXTtcbiAgICBjb25zdCBtYXAyID0gW1xuICAgICAgICBbMCwgNjBdLFxuICAgICAgICBbNjAsIDEyMF0sXG4gICAgICAgIFsxMjAsIDI0MF0sXG4gICAgICAgIFsyNDAsIDM2MF1cbiAgICBdO1xuICAgIGNvbnN0IGZyb20gPSB0b1J5YiA/IG1hcDEgOiBtYXAyO1xuICAgIGNvbnN0IHRvID0gdG9SeWIgPyBtYXAyIDogbWFwMTtcbiAgICBsZXQgQSA9IDA7XG4gICAgbGV0IEIgPSAwO1xuICAgIGxldCBDID0gMDtcbiAgICBsZXQgRCA9IDA7XG4gICAgZnJvbS5maW5kKChhcnIsIGluZGV4KSA9PiB7XG4gICAgICAgIGlmIChodWUgPj0gYXJyWzBdICYmIGh1ZSA8IGFyclsxXSkge1xuICAgICAgICAgICAgQSA9IGFyclswXTtcbiAgICAgICAgICAgIEIgPSBhcnJbMV07XG4gICAgICAgICAgICBDID0gdG9baW5kZXhdWzBdO1xuICAgICAgICAgICAgRCA9IHRvW2luZGV4XVsxXTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9KTtcbiAgICByZXR1cm4gQyArIChodWUgLSBBKSAqICgoRCAtIEMpIC8gKEIgLSBBKSk7XG59O1xuIiwiZXhwb3J0IGNsYXNzIFJnYkNsYXNzIHtcbiAgICBnZXQgcmdiKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcmdiO1xuICAgIH1cbn1cbiIsImltcG9ydCB7IEJBU0VfMjU1LCBDT0xPUlJFR1MgfSBmcm9tICcjY29uc3RhbnRzJztcbmltcG9ydCB7IGdldERFQyB9IGZyb20gJyNoZWxwZXJzJztcbmltcG9ydCB7IFJnYkNsYXNzIH0gZnJvbSAnLi9iYXNlQ2xhc3Nlcy9fUmdiQ2xhc3MnO1xuZXhwb3J0IGNsYXNzIEhFWFN0cmluZ1BhcnNlciBleHRlbmRzIFJnYkNsYXNzIHtcbiAgICBjb25zdHJ1Y3Rvcihjb2xvclN0cmluZykge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICBjb25zdCBtYXRjaCA9IGNvbG9yU3RyaW5nLm1hdGNoKENPTE9SUkVHUy5IRVgpO1xuICAgICAgICBjb25zdCBncm91cHMgPSBtYXRjaC5ncm91cHM7XG4gICAgICAgIHRoaXMuX3IgPSBncm91cHMuciA/PyBncm91cHMucnI7XG4gICAgICAgIHRoaXMuX2cgPSBncm91cHMuZyA/PyBncm91cHMuZ2c7XG4gICAgICAgIHRoaXMuX2IgPSBncm91cHMuYiA/PyBncm91cHMuYmI7XG4gICAgICAgIHRoaXMuX2EgPSBncm91cHMuYSA/PyBncm91cHMuYWE7XG4gICAgICAgIGNvbnN0IHJnYiA9IHtcbiAgICAgICAgICAgIFI6IGdldERFQyh0aGlzLl9yKSxcbiAgICAgICAgICAgIEc6IGdldERFQyh0aGlzLl9nKSxcbiAgICAgICAgICAgIEI6IGdldERFQyh0aGlzLl9iKVxuICAgICAgICB9O1xuICAgICAgICBpZiAodGhpcy5fYSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZ2IuQSA9IGdldERFQyh0aGlzLl9hKSAvIEJBU0VfMjU1O1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3JnYiA9IHJnYjtcbiAgICB9XG59XG4iLCJpbXBvcnQgeyBDQUxDLCBFUlJPUlMgfSBmcm9tICcjY29uc3RhbnRzJztcbmNvbnN0IE1BWF9TVEFDSyA9IDEwMDtcbmV4cG9ydCBjbGFzcyBDYWxjUGFyc2VyIHtcbiAgICBjb25zdHJ1Y3Rvcihjb2xvckluZGV4LCBjYWxjLCB2YXJzKSB7XG4gICAgICAgIHRoaXMuX29wZXJhdGlvbnMgPSBuZXcgTWFwKFtcbiAgICAgICAgICAgIFtDQUxDLkRJVklTSU9OLCB0aGlzLl9kaXZpc2lvbl0sXG4gICAgICAgICAgICBbQ0FMQy5NVUxUSVBMSUNBVElPTiwgdGhpcy5fbXVsdGlwbGljYXRpb25dLFxuICAgICAgICAgICAgW0NBTEMuU1VNLCB0aGlzLl9zdW1dLFxuICAgICAgICAgICAgW0NBTEMuUkVTVCwgdGhpcy5fcmVzdF1cbiAgICAgICAgXSk7XG4gICAgICAgIHRoaXMuX2NvbG9ySW5kZXggPSBjb2xvckluZGV4O1xuICAgICAgICBsZXQgY2FsY1N0cmluZyA9IGNhbGM7XG4gICAgICAgIGxldCBzdGFjayA9IDA7XG4gICAgICAgIGlmICghTnVtYmVyLmlzTmFOKCtjYWxjKSkge1xuICAgICAgICAgICAgdGhpcy5fcmVzdWx0ID0gK2NhbGM7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoY2FsYyBpbiB2YXJzKSB7XG4gICAgICAgICAgICB0aGlzLl9yZXN1bHQgPSB2YXJzW2NhbGNdO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKENBTEMuUkVHRVhQLnRlc3QoY2FsY1N0cmluZykpIHtcbiAgICAgICAgICAgIENBTEMuUkVHRVhQLmxhc3RJbmRleCA9IDA7XG4gICAgICAgICAgICB0aGlzLl9yZXN1bHQgPSB0aGlzLl9nZXRDYWxjVmFsdWUoY2FsY1N0cmluZywgdmFycyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB3aGlsZSAoQ0FMQy5TQ09QRUQudGVzdChjYWxjU3RyaW5nKSAmJiBzdGFjayA8IE1BWF9TVEFDSykge1xuICAgICAgICAgICAgICAgIENBTEMuU0NPUEVELmxhc3RJbmRleCA9IDA7XG4gICAgICAgICAgICAgICAgY2FsY1N0cmluZyA9IGNhbGNTdHJpbmcucmVwbGFjZShDQUxDLlNDT1BFRCwgKF9fbWF0Y2gsIG9wZXJhdGlvbikgPT4ge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fY2FsY3VsYXRlKG9wZXJhdGlvbiwgdmFycykudG9TdHJpbmcoKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBpZiAoQ0FMQy5SRUdFWFAudGVzdChjYWxjU3RyaW5nKSkge1xuICAgICAgICAgICAgICAgICAgICBDQUxDLlJFR0VYUC5sYXN0SW5kZXggPSAwO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgc3RhY2srKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX3Jlc3VsdCA9IHRoaXMuX2dldENhbGNWYWx1ZShjYWxjU3RyaW5nLCB2YXJzKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBfZGl2aXNpb24obGVmdCwgcmlnaHQpIHtcbiAgICAgICAgcmV0dXJuIGxlZnQgLyByaWdodDtcbiAgICB9XG4gICAgX211bHRpcGxpY2F0aW9uKGxlZnQsIHJpZ2h0KSB7XG4gICAgICAgIHJldHVybiBsZWZ0ICogcmlnaHQ7XG4gICAgfVxuICAgIF9zdW0obGVmdCwgcmlnaHQpIHtcbiAgICAgICAgcmV0dXJuIGxlZnQgKyByaWdodDtcbiAgICB9XG4gICAgX3Jlc3QobGVmdCwgcmlnaHQpIHtcbiAgICAgICAgcmV0dXJuIGxlZnQgLSByaWdodDtcbiAgICB9XG4gICAgX2dldENhbGNWYWx1ZShjYWxjLCB2YXJzKSB7XG4gICAgICAgIGNvbnN0IG1hdGNoID0gY2FsYy5tYXRjaChDQUxDLlJFR0VYUCk7XG4gICAgICAgIGNvbnN0IG9wZXJhdGlvbiA9IG1hdGNoLmdyb3Vwcy5vcGVyYXRpb247XG4gICAgICAgIGNvbnN0IHZhbHVlID0gdGhpcy5fY2FsY3VsYXRlKG9wZXJhdGlvbiwgdmFycyk7XG4gICAgICAgIGlmIChOdW1iZXIuaXNOYU4odmFsdWUpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgdmFsdWUgZm9yICR7dGhpcy5fY29sb3JJbmRleH0uICR7b3BlcmF0aW9ufSAke0VSUk9SUy5OT1RfQV9WQUxJRF9SRUxBVElWRV9DT0xPUn1gKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuICAgIF9jYWxjdWxhdGUob3BlcmF0aW9uLCB2YXJzKSB7XG4gICAgICAgIHRoaXMuX29wZXJhdGlvbnMuZm9yRWFjaCgobWV0aG9kLCByZWdFeHApID0+IHtcbiAgICAgICAgICAgIGxldCBzdGFjayA9IDA7XG4gICAgICAgICAgICB3aGlsZSAocmVnRXhwLnRlc3Qob3BlcmF0aW9uKSAmJiBzdGFjayA8IE1BWF9TVEFDSykge1xuICAgICAgICAgICAgICAgIG9wZXJhdGlvbiA9IG9wZXJhdGlvbi5yZXBsYWNlKHJlZ0V4cCwgKF9fbWF0Y2gsIGxlZnQsIHJpZ2h0KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBtZXRob2QodmFyc1tsZWZ0XSA/PyArbGVmdCwgdmFyc1tyaWdodF0gPz8gK3JpZ2h0KS50b1N0cmluZygpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHN0YWNrKys7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gK29wZXJhdGlvbjtcbiAgICB9XG4gICAgZ2V0IHJlc3VsdCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3Jlc3VsdDtcbiAgICB9XG59XG4iLCJpbXBvcnQgeyBQQ0VOVCB9IGZyb20gJyNjb25zdGFudHMnO1xuaW1wb3J0IHsgUmdiQ2xhc3MgfSBmcm9tICcuL19SZ2JDbGFzcyc7XG5leHBvcnQgY2xhc3MgQWxwaGFCYXNlQ2xhc3MgZXh0ZW5kcyBSZ2JDbGFzcyB7XG4gICAgZ2V0IGhhc1BlcmNlbnRhZ2VBbHBoYSgpIHtcbiAgICAgICAgcmV0dXJuIFBDRU5ULnRlc3QodGhpcy5fYSk7XG4gICAgfVxufVxuIiwiaW1wb3J0IHsgQkFTRV8yNTUsIENPTE9SUkVHUywgUENFTlQgfSBmcm9tICcjY29uc3RhbnRzJztcbmltcG9ydCB7IGdldEJhc2UyNTVOdW1iZXIsIG5vcm1hbGl6ZUFscGhhIH0gZnJvbSAnI2hlbHBlcnMnO1xuaW1wb3J0IHsgQ2FsY1BhcnNlciB9IGZyb20gJy4vX0NhbGNQYXJzZXInO1xuaW1wb3J0IHsgQWxwaGFCYXNlQ2xhc3MgfSBmcm9tICcuL2Jhc2VDbGFzc2VzL19BbHBoYUJhc2VDbGFzcyc7XG5leHBvcnQgY2xhc3MgUkdCU3RyaW5nUGFyc2VyIGV4dGVuZHMgQWxwaGFCYXNlQ2xhc3Mge1xuICAgIGNvbnN0cnVjdG9yKGNvbG9yU3RyaW5nLCBnZXRSR0JPYmplY3QpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgY29uc3QgbWF0Y2ggPSBjb2xvclN0cmluZy5tYXRjaChDT0xPUlJFR1MuUkdCKTtcbiAgICAgICAgY29uc3QgZ3JvdXBzID0gbWF0Y2guZ3JvdXBzO1xuICAgICAgICBjb25zdCB7IHJfbGVnYWN5LCBnX2xlZ2FjeSwgYl9sZWdhY3ksIGFfbGVnYWN5LCByLCBnLCBiLCBhLCBmcm9tLCByZWxhdGl2ZV9yLCByZWxhdGl2ZV9nLCByZWxhdGl2ZV9iLCByZWxhdGl2ZV9hIH0gPSBncm91cHM7XG4gICAgICAgIGlmIChmcm9tKSB7XG4gICAgICAgICAgICBjb25zdCBmcm9tUkdCID0gZ2V0UkdCT2JqZWN0KGZyb20pO1xuICAgICAgICAgICAgY29uc3QgZnJvbVJHQlZhcnMgPSB7XG4gICAgICAgICAgICAgICAgcjogZnJvbVJHQi5SLFxuICAgICAgICAgICAgICAgIGc6IGZyb21SR0IuRyxcbiAgICAgICAgICAgICAgICBiOiBmcm9tUkdCLkIsXG4gICAgICAgICAgICAgICAgYWxwaGE6IGZyb21SR0IuQSA/PyAxXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgY29uc3QgUiA9IG5ldyBDYWxjUGFyc2VyKCdyJywgcmVsYXRpdmVfciwgZnJvbVJHQlZhcnMpLnJlc3VsdDtcbiAgICAgICAgICAgIGNvbnN0IEcgPSBuZXcgQ2FsY1BhcnNlcignZycsIHJlbGF0aXZlX2csIGZyb21SR0JWYXJzKS5yZXN1bHQ7XG4gICAgICAgICAgICBjb25zdCBCID0gbmV3IENhbGNQYXJzZXIoJ2InLCByZWxhdGl2ZV9iLCBmcm9tUkdCVmFycykucmVzdWx0O1xuICAgICAgICAgICAgY29uc3QgcmdiID0ge1xuICAgICAgICAgICAgICAgIFI6IE1hdGgubWluKFIsIEJBU0VfMjU1KSxcbiAgICAgICAgICAgICAgICBHOiBNYXRoLm1pbihHLCBCQVNFXzI1NSksXG4gICAgICAgICAgICAgICAgQjogTWF0aC5taW4oQiwgQkFTRV8yNTUpXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgaWYgKHJlbGF0aXZlX2EpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBBID0gbmV3IENhbGNQYXJzZXIoJ2FscGhhJywgcmVsYXRpdmVfYSwgZnJvbVJHQlZhcnMpLnJlc3VsdDtcbiAgICAgICAgICAgICAgICByZ2IuQSA9IE1hdGgubWluKEEsIDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fcmdiID0gcmdiO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fciA9IHJfbGVnYWN5ID8/IHI7XG4gICAgICAgICAgICB0aGlzLl9nID0gZ19sZWdhY3kgPz8gZztcbiAgICAgICAgICAgIHRoaXMuX2IgPSBiX2xlZ2FjeSA/PyBiO1xuICAgICAgICAgICAgdGhpcy5fYSA9IGFfbGVnYWN5ID8/IGE7XG4gICAgICAgICAgICBjb25zdCByZ2IgPSB7XG4gICAgICAgICAgICAgICAgUjogTWF0aC5taW4oZ2V0QmFzZTI1NU51bWJlcih0aGlzLl9yKSwgQkFTRV8yNTUpLFxuICAgICAgICAgICAgICAgIEc6IE1hdGgubWluKGdldEJhc2UyNTVOdW1iZXIodGhpcy5fZyksIEJBU0VfMjU1KSxcbiAgICAgICAgICAgICAgICBCOiBNYXRoLm1pbihnZXRCYXNlMjU1TnVtYmVyKHRoaXMuX2IpLCBCQVNFXzI1NSlcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBpZiAodGhpcy5fYSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgcmdiLkEgPSBub3JtYWxpemVBbHBoYSh0aGlzLl9hKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX3JnYiA9IHJnYjtcbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXQgaGFzUGVyY2VudGFnZVZhbHVlcygpIHtcbiAgICAgICAgcmV0dXJuIChQQ0VOVC50ZXN0KHRoaXMuX3IpICYmXG4gICAgICAgICAgICBQQ0VOVC50ZXN0KHRoaXMuX2cpICYmXG4gICAgICAgICAgICBQQ0VOVC50ZXN0KHRoaXMuX2IpKTtcbiAgICB9XG4gICAgc3RhdGljIHRlc3QoY29sb3JTdHJpbmcpIHtcbiAgICAgICAgcmV0dXJuIENPTE9SUkVHUy5SR0IudGVzdChjb2xvclN0cmluZyk7XG4gICAgfVxufVxuIiwiaW1wb3J0IHsgQW5nbGVzVW5pdEVudW0gfSBmcm9tICdAdHlwZXMnO1xuaW1wb3J0IHsgSFNMX0hVRSB9IGZyb20gJyNjb25zdGFudHMnO1xuaW1wb3J0IHsgQWxwaGFCYXNlQ2xhc3MgfSBmcm9tICcuL19BbHBoYUJhc2VDbGFzcyc7XG5leHBvcnQgY2xhc3MgSHVlQmFzZUNsYXNzIGV4dGVuZHMgQWxwaGFCYXNlQ2xhc3Mge1xuICAgIGdldCBhbmdsZVVuaXQoKSB7XG4gICAgICAgIGlmICh0aGlzLl9oKSB7XG4gICAgICAgICAgICBjb25zdCBhbmdsZVVuaXRNYXRjaCA9IHRoaXMuX2gubWF0Y2goSFNMX0hVRSk7XG4gICAgICAgICAgICBjb25zdCBhbmdsZVVuaXQgPSBhbmdsZVVuaXRNYXRjaC5ncm91cHMudW5pdHM7XG4gICAgICAgICAgICByZXR1cm4gYW5nbGVVbml0ID09PSAnJ1xuICAgICAgICAgICAgICAgID8gQW5nbGVzVW5pdEVudW0uTk9ORVxuICAgICAgICAgICAgICAgIDogYW5nbGVVbml0O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBBbmdsZXNVbml0RW51bS5OT05FO1xuICAgIH1cbn1cbiIsImltcG9ydCB7IENPTE9SUkVHUywgTUFYX0FMUEhBLCBNQVhfSFVFLCBNQVhfUENFTlQgfSBmcm9tICcjY29uc3RhbnRzJztcbmltcG9ydCB7IG1pbm1heCwgbm9ybWFsaXplQWxwaGEsIG5vcm1hbGl6ZUh1ZSwgcGVyY2VudCB9IGZyb20gJyNoZWxwZXJzJztcbmltcG9ydCB7IGhzbFRvUmdiLCByZ2JUb0hzbCB9IGZyb20gJyNjb2xvci90cmFuc2xhdG9ycyc7XG5pbXBvcnQgeyBDYWxjUGFyc2VyIH0gZnJvbSAnLi9fQ2FsY1BhcnNlcic7XG5pbXBvcnQgeyBIdWVCYXNlQ2xhc3MgfSBmcm9tICcuL2Jhc2VDbGFzc2VzL19IdWVCYXNlQ2xhc3MnO1xuZXhwb3J0IGNsYXNzIEhTTFN0cmluZ1BhcnNlciBleHRlbmRzIEh1ZUJhc2VDbGFzcyB7XG4gICAgY29uc3RydWN0b3IoY29sb3JTdHJpbmcsIGdldFJHQk9iamVjdCkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICBjb25zdCBtYXRjaCA9IGNvbG9yU3RyaW5nLm1hdGNoKENPTE9SUkVHUy5IU0wpO1xuICAgICAgICBjb25zdCBncm91cHMgPSBtYXRjaC5ncm91cHM7XG4gICAgICAgIGNvbnN0IHsgaF9sZWdhY3ksIHNfbGVnYWN5LCBsX2xlZ2FjeSwgYV9sZWdhY3ksIGgsIHMsIGwsIGEsIGZyb20sIHJlbGF0aXZlX2gsIHJlbGF0aXZlX3MsIHJlbGF0aXZlX2wsIHJlbGF0aXZlX2EgfSA9IGdyb3VwcztcbiAgICAgICAgaWYgKGZyb20pIHtcbiAgICAgICAgICAgIGNvbnN0IGZyb21SR0IgPSBnZXRSR0JPYmplY3QoZnJvbSk7XG4gICAgICAgICAgICBjb25zdCBmcm9tSFNMID0gcmdiVG9Ic2woZnJvbVJHQi5SLCBmcm9tUkdCLkcsIGZyb21SR0IuQiwgZnJvbVJHQi5BKTtcbiAgICAgICAgICAgIGNvbnN0IGZyb21IU0xWYXJzID0ge1xuICAgICAgICAgICAgICAgIGg6IGZyb21IU0wuSCxcbiAgICAgICAgICAgICAgICBzOiBmcm9tSFNMLlMsXG4gICAgICAgICAgICAgICAgbDogZnJvbUhTTC5MLFxuICAgICAgICAgICAgICAgIGFscGhhOiBmcm9tSFNMLkFcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBjb25zdCBIID0gbmV3IENhbGNQYXJzZXIoJ2gnLCByZWxhdGl2ZV9oLCBmcm9tSFNMVmFycykucmVzdWx0O1xuICAgICAgICAgICAgY29uc3QgUyA9IG5ldyBDYWxjUGFyc2VyKCdzJywgcmVsYXRpdmVfcywgZnJvbUhTTFZhcnMpLnJlc3VsdDtcbiAgICAgICAgICAgIGNvbnN0IEwgPSBuZXcgQ2FsY1BhcnNlcignbCcsIHJlbGF0aXZlX2wsIGZyb21IU0xWYXJzKS5yZXN1bHQ7XG4gICAgICAgICAgICBjb25zdCByZ2IgPSBoc2xUb1JnYihtaW5tYXgoSCwgMCwgTUFYX0hVRSksIG1pbm1heChTLCAwLCBNQVhfUENFTlQpLCBtaW5tYXgoTCwgMCwgTUFYX1BDRU5UKSk7XG4gICAgICAgICAgICBpZiAocmVsYXRpdmVfYSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IEEgPSBuZXcgQ2FsY1BhcnNlcignYWxwaGEnLCByZWxhdGl2ZV9hLCBmcm9tSFNMVmFycykucmVzdWx0O1xuICAgICAgICAgICAgICAgIHJnYi5BID0gbWlubWF4KEEsIDAsIE1BWF9BTFBIQSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9yZ2IgPSByZ2I7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl9oID0gaF9sZWdhY3kgPz8gaDtcbiAgICAgICAgICAgIHRoaXMuX3MgPSBzX2xlZ2FjeSA/PyBzO1xuICAgICAgICAgICAgdGhpcy5fbCA9IGxfbGVnYWN5ID8/IGw7XG4gICAgICAgICAgICB0aGlzLl9hID0gYV9sZWdhY3kgPz8gYTtcbiAgICAgICAgICAgIGNvbnN0IHJnYiA9IGhzbFRvUmdiKG5vcm1hbGl6ZUh1ZSh0aGlzLl9oKSwgcGVyY2VudCh0aGlzLl9zKSwgcGVyY2VudCh0aGlzLl9sKSk7XG4gICAgICAgICAgICBpZiAodGhpcy5fYSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgcmdiLkEgPSBub3JtYWxpemVBbHBoYSh0aGlzLl9hKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX3JnYiA9IHJnYjtcbiAgICAgICAgfVxuICAgIH1cbiAgICBzdGF0aWMgdGVzdChjb2xvclN0cmluZykge1xuICAgICAgICByZXR1cm4gQ09MT1JSRUdTLkhTTC50ZXN0KGNvbG9yU3RyaW5nKTtcbiAgICB9XG59XG4iLCJpbXBvcnQgeyBDT0xPUlJFR1MsIE1BWF9BTFBIQSwgTUFYX0hVRSwgTUFYX1BDRU5UIH0gZnJvbSAnI2NvbnN0YW50cyc7XG5pbXBvcnQgeyBtaW5tYXgsIG5vcm1hbGl6ZUFscGhhLCBub3JtYWxpemVIdWUsIHBlcmNlbnQgfSBmcm9tICcjaGVscGVycyc7XG5pbXBvcnQgeyBod2JUb1JnYiwgcmdiVG9Id2IgfSBmcm9tICcjY29sb3IvdHJhbnNsYXRvcnMnO1xuaW1wb3J0IHsgQ2FsY1BhcnNlciB9IGZyb20gJy4vX0NhbGNQYXJzZXInO1xuaW1wb3J0IHsgSHVlQmFzZUNsYXNzIH0gZnJvbSAnLi9iYXNlQ2xhc3Nlcy9fSHVlQmFzZUNsYXNzJztcbmV4cG9ydCBjbGFzcyBIV0JTdHJpbmdQYXJzZXIgZXh0ZW5kcyBIdWVCYXNlQ2xhc3Mge1xuICAgIGNvbnN0cnVjdG9yKGNvbG9yU3RyaW5nLCBnZXRSR0JPYmplY3QpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgY29uc3QgbWF0Y2ggPSBjb2xvclN0cmluZy5tYXRjaChDT0xPUlJFR1MuSFdCKTtcbiAgICAgICAgY29uc3QgZ3JvdXBzID0gbWF0Y2guZ3JvdXBzO1xuICAgICAgICBjb25zdCB7IGgsIHcsIGIsIGEsIGZyb20sIHJlbGF0aXZlX2gsIHJlbGF0aXZlX3csIHJlbGF0aXZlX2IsIHJlbGF0aXZlX2EgfSA9IGdyb3VwcztcbiAgICAgICAgaWYgKGZyb20pIHtcbiAgICAgICAgICAgIGNvbnN0IGZyb21SR0IgPSBnZXRSR0JPYmplY3QoZnJvbSk7XG4gICAgICAgICAgICBjb25zdCBmcm9tSFdCID0gcmdiVG9Id2IoZnJvbVJHQi5SLCBmcm9tUkdCLkcsIGZyb21SR0IuQiwgZnJvbVJHQi5BKTtcbiAgICAgICAgICAgIGNvbnN0IGZyb21IV0JWYXJzID0ge1xuICAgICAgICAgICAgICAgIGg6IGZyb21IV0IuSCxcbiAgICAgICAgICAgICAgICB3OiBmcm9tSFdCLlcsXG4gICAgICAgICAgICAgICAgYjogZnJvbUhXQi5CLFxuICAgICAgICAgICAgICAgIGFscGhhOiBmcm9tSFdCLkFcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBjb25zdCBIID0gbmV3IENhbGNQYXJzZXIoJ2gnLCByZWxhdGl2ZV9oLCBmcm9tSFdCVmFycykucmVzdWx0O1xuICAgICAgICAgICAgY29uc3QgVyA9IG5ldyBDYWxjUGFyc2VyKCd3JywgcmVsYXRpdmVfdywgZnJvbUhXQlZhcnMpLnJlc3VsdDtcbiAgICAgICAgICAgIGNvbnN0IEIgPSBuZXcgQ2FsY1BhcnNlcignYicsIHJlbGF0aXZlX2IsIGZyb21IV0JWYXJzKS5yZXN1bHQ7XG4gICAgICAgICAgICBjb25zdCByZ2IgPSBod2JUb1JnYihtaW5tYXgoSCwgMCwgTUFYX0hVRSksIG1pbm1heChXLCAwLCBNQVhfUENFTlQpLCBtaW5tYXgoQiwgMCwgTUFYX1BDRU5UKSk7XG4gICAgICAgICAgICBpZiAocmVsYXRpdmVfYSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IEEgPSBuZXcgQ2FsY1BhcnNlcignYWxwaGEnLCByZWxhdGl2ZV9hLCBmcm9tSFdCVmFycykucmVzdWx0O1xuICAgICAgICAgICAgICAgIHJnYi5BID0gbWlubWF4KEEsIDAsIE1BWF9BTFBIQSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9yZ2IgPSByZ2I7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl9oID0gaDtcbiAgICAgICAgICAgIHRoaXMuX3cgPSB3O1xuICAgICAgICAgICAgdGhpcy5fYiA9IGI7XG4gICAgICAgICAgICB0aGlzLl9hID0gYTtcbiAgICAgICAgICAgIGNvbnN0IHJnYiA9IGh3YlRvUmdiKG5vcm1hbGl6ZUh1ZSh0aGlzLl9oKSwgcGVyY2VudCh0aGlzLl93KSwgcGVyY2VudCh0aGlzLl9iKSk7XG4gICAgICAgICAgICBpZiAodGhpcy5fYSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgcmdiLkEgPSBub3JtYWxpemVBbHBoYSh0aGlzLl9hKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX3JnYiA9IHJnYjtcbiAgICAgICAgfVxuICAgIH1cbiAgICBzdGF0aWMgdGVzdChjb2xvclN0cmluZykge1xuICAgICAgICByZXR1cm4gQ09MT1JSRUdTLkhXQi50ZXN0KGNvbG9yU3RyaW5nKTtcbiAgICB9XG59XG4iLCJpbXBvcnQgeyBDT0xPUlJFR1MsIE1BWF9BTFBIQSwgTUFYX0xBQiwgTUFYX1BDRU5ULCBQQ0VOVCB9IGZyb20gJyNjb25zdGFudHMnO1xuaW1wb3J0IHsgZ2V0QmFzZTEyNU51bWJlciwgbWlubWF4LCBub3JtYWxpemVBbHBoYSwgcGVyY2VudCB9IGZyb20gJyNoZWxwZXJzJztcbmltcG9ydCB7IGxhYlRvUmdiLCByZ2JUb0xhYiB9IGZyb20gJyNjb2xvci90cmFuc2xhdG9ycyc7XG5pbXBvcnQgeyBDYWxjUGFyc2VyIH0gZnJvbSAnLi9fQ2FsY1BhcnNlcic7XG5pbXBvcnQgeyBBbHBoYUJhc2VDbGFzcyB9IGZyb20gJy4vYmFzZUNsYXNzZXMvX0FscGhhQmFzZUNsYXNzJztcbmV4cG9ydCBjbGFzcyBDSUVMYWJTdHJpbmdQYXJzZXIgZXh0ZW5kcyBBbHBoYUJhc2VDbGFzcyB7XG4gICAgY29uc3RydWN0b3IoY29sb3JTdHJpbmcsIGdldFJHQk9iamVjdCkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICBjb25zdCBtYXRjaCA9IGNvbG9yU3RyaW5nLm1hdGNoKENPTE9SUkVHUy5DSUVMYWIpO1xuICAgICAgICBjb25zdCBncm91cHMgPSBtYXRjaC5ncm91cHM7XG4gICAgICAgIGNvbnN0IHsgTCwgYSwgYiwgQSwgZnJvbSwgcmVsYXRpdmVfTCwgcmVsYXRpdmVfYSwgcmVsYXRpdmVfYiwgcmVsYXRpdmVfQSB9ID0gZ3JvdXBzO1xuICAgICAgICBpZiAoZnJvbSkge1xuICAgICAgICAgICAgY29uc3QgZnJvbVJHQiA9IGdldFJHQk9iamVjdChmcm9tKTtcbiAgICAgICAgICAgIGNvbnN0IGZyb21MYWIgPSByZ2JUb0xhYihmcm9tUkdCLlIsIGZyb21SR0IuRywgZnJvbVJHQi5CKTtcbiAgICAgICAgICAgIGNvbnN0IGZyb21MYWJWYXJzID0ge1xuICAgICAgICAgICAgICAgIGw6IGZyb21MYWIuTCxcbiAgICAgICAgICAgICAgICBhOiBmcm9tTGFiLmEsXG4gICAgICAgICAgICAgICAgYjogZnJvbUxhYi5iLFxuICAgICAgICAgICAgICAgIGFscGhhOiBmcm9tUkdCLkEgPz8gMVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGNvbnN0IEwgPSBuZXcgQ2FsY1BhcnNlcignbCcsIHJlbGF0aXZlX0wsIGZyb21MYWJWYXJzKS5yZXN1bHQ7XG4gICAgICAgICAgICBjb25zdCBhID0gbmV3IENhbGNQYXJzZXIoJ2EnLCByZWxhdGl2ZV9hLCBmcm9tTGFiVmFycykucmVzdWx0O1xuICAgICAgICAgICAgY29uc3QgYiA9IG5ldyBDYWxjUGFyc2VyKCdiJywgcmVsYXRpdmVfYiwgZnJvbUxhYlZhcnMpLnJlc3VsdDtcbiAgICAgICAgICAgIGNvbnN0IHJnYiA9IGxhYlRvUmdiKG1pbm1heChMLCAwLCBNQVhfUENFTlQpLCBtaW5tYXgoYSwgLU1BWF9MQUIsIE1BWF9MQUIpLCBtaW5tYXgoYiwgLU1BWF9MQUIsIE1BWF9MQUIpKTtcbiAgICAgICAgICAgIGlmIChyZWxhdGl2ZV9BKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgQSA9IG5ldyBDYWxjUGFyc2VyKCdhbHBoYScsIHJlbGF0aXZlX0EsIGZyb21MYWJWYXJzKS5yZXN1bHQ7XG4gICAgICAgICAgICAgICAgcmdiLkEgPSBtaW5tYXgoQSwgMCwgTUFYX0FMUEhBKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX3JnYiA9IHJnYjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX0wgPSBMO1xuICAgICAgICAgICAgdGhpcy5fQSA9IGE7XG4gICAgICAgICAgICB0aGlzLl9CID0gYjtcbiAgICAgICAgICAgIHRoaXMuX2EgPSBBO1xuICAgICAgICAgICAgY29uc3QgcmdiID0gbGFiVG9SZ2IocGVyY2VudCh0aGlzLl9MKSwgZ2V0QmFzZTEyNU51bWJlcih0aGlzLl9BKSwgZ2V0QmFzZTEyNU51bWJlcih0aGlzLl9CKSk7XG4gICAgICAgICAgICBpZiAodGhpcy5fYSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgcmdiLkEgPSBub3JtYWxpemVBbHBoYSh0aGlzLl9hKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX3JnYiA9IHJnYjtcbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXQgaGFzUGVyY2VudGFnZVZhbHVlcygpIHtcbiAgICAgICAgcmV0dXJuIChQQ0VOVC50ZXN0KHRoaXMuX0wpICYmXG4gICAgICAgICAgICBQQ0VOVC50ZXN0KHRoaXMuX0EpICYmXG4gICAgICAgICAgICBQQ0VOVC50ZXN0KHRoaXMuX0IpKTtcbiAgICB9XG4gICAgc3RhdGljIHRlc3QoY29sb3JTdHJpbmcpIHtcbiAgICAgICAgcmV0dXJuIENPTE9SUkVHUy5DSUVMYWIudGVzdChjb2xvclN0cmluZyk7XG4gICAgfVxufVxuIiwiaW1wb3J0IHsgQ09MT1JSRUdTLCBNQVhfQUxQSEEsIE1BWF9MQ0hfQywgTUFYX1BDRU5ULCBQQ0VOVCB9IGZyb20gJyNjb25zdGFudHMnO1xuaW1wb3J0IHsgZ2V0QmFzZTE1ME51bWJlciwgbWlubWF4LCBub3JtYWxpemVBbHBoYSwgbm9ybWFsaXplSHVlLCBwZXJjZW50IH0gZnJvbSAnI2hlbHBlcnMnO1xuaW1wb3J0IHsgbGNoVG9SZ2IsIHJnYlRvTGNoIH0gZnJvbSAnI2NvbG9yL3RyYW5zbGF0b3JzJztcbmltcG9ydCB7IENhbGNQYXJzZXIgfSBmcm9tICcuL19DYWxjUGFyc2VyJztcbmltcG9ydCB7IEh1ZUJhc2VDbGFzcyB9IGZyb20gJy4vYmFzZUNsYXNzZXMvX0h1ZUJhc2VDbGFzcyc7XG5leHBvcnQgY2xhc3MgTENIU3RyaW5nUGFyc2VyIGV4dGVuZHMgSHVlQmFzZUNsYXNzIHtcbiAgICBjb25zdHJ1Y3Rvcihjb2xvclN0cmluZywgZ2V0UkdCT2JqZWN0KSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIGNvbnN0IG1hdGNoID0gY29sb3JTdHJpbmcubWF0Y2goQ09MT1JSRUdTLkxDSCk7XG4gICAgICAgIGNvbnN0IGdyb3VwcyA9IG1hdGNoLmdyb3VwcztcbiAgICAgICAgY29uc3QgeyBsLCBjLCBoLCBhLCBmcm9tLCByZWxhdGl2ZV9sLCByZWxhdGl2ZV9jLCByZWxhdGl2ZV9oLCByZWxhdGl2ZV9hIH0gPSBncm91cHM7XG4gICAgICAgIGlmIChmcm9tKSB7XG4gICAgICAgICAgICBjb25zdCBmcm9tUkdCID0gZ2V0UkdCT2JqZWN0KGZyb20pO1xuICAgICAgICAgICAgY29uc3QgZnJvbUxDSCA9IHJnYlRvTGNoKGZyb21SR0IuUiwgZnJvbVJHQi5HLCBmcm9tUkdCLkIpO1xuICAgICAgICAgICAgY29uc3QgZnJvbUxDSFZhcnMgPSB7XG4gICAgICAgICAgICAgICAgbDogZnJvbUxDSC5MLFxuICAgICAgICAgICAgICAgIGM6IGZyb21MQ0guQyxcbiAgICAgICAgICAgICAgICBoOiBmcm9tTENILkgsXG4gICAgICAgICAgICAgICAgYWxwaGE6IGZyb21SR0IuQSA/PyAxXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgY29uc3QgTCA9IG5ldyBDYWxjUGFyc2VyKCdsJywgcmVsYXRpdmVfbCwgZnJvbUxDSFZhcnMpLnJlc3VsdDtcbiAgICAgICAgICAgIGNvbnN0IEMgPSBuZXcgQ2FsY1BhcnNlcignYycsIHJlbGF0aXZlX2MsIGZyb21MQ0hWYXJzKS5yZXN1bHQ7XG4gICAgICAgICAgICBjb25zdCBIID0gbmV3IENhbGNQYXJzZXIoJ2gnLCByZWxhdGl2ZV9oLCBmcm9tTENIVmFycykucmVzdWx0O1xuICAgICAgICAgICAgY29uc3QgcmdiID0gbGNoVG9SZ2IobWlubWF4KEwsIDAsIE1BWF9QQ0VOVCksIG1pbm1heChDLCAtTUFYX0xDSF9DLCBNQVhfTENIX0MpLCBub3JtYWxpemVIdWUoSCkpO1xuICAgICAgICAgICAgaWYgKHJlbGF0aXZlX2EpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBBID0gbmV3IENhbGNQYXJzZXIoJ2FscGhhJywgcmVsYXRpdmVfYSwgZnJvbUxDSFZhcnMpLnJlc3VsdDtcbiAgICAgICAgICAgICAgICByZ2IuQSA9IG1pbm1heChBLCAwLCBNQVhfQUxQSEEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fcmdiID0gcmdiO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fbCA9IGw7XG4gICAgICAgICAgICB0aGlzLl9jID0gYztcbiAgICAgICAgICAgIHRoaXMuX2ggPSBoO1xuICAgICAgICAgICAgdGhpcy5fYSA9IGE7XG4gICAgICAgICAgICBjb25zdCByZ2IgPSBsY2hUb1JnYihwZXJjZW50KHRoaXMuX2wpLCBnZXRCYXNlMTUwTnVtYmVyKHRoaXMuX2MpLCBub3JtYWxpemVIdWUodGhpcy5faCkpO1xuICAgICAgICAgICAgaWYgKHRoaXMuX2EgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHJnYi5BID0gbm9ybWFsaXplQWxwaGEodGhpcy5fYSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9yZ2IgPSByZ2I7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0IGhhc1BlcmNlbnRhZ2VWYWx1ZXMoKSB7XG4gICAgICAgIHJldHVybiAoUENFTlQudGVzdCh0aGlzLl9sKSAmJlxuICAgICAgICAgICAgUENFTlQudGVzdCh0aGlzLl9jKSk7XG4gICAgfVxuICAgIHN0YXRpYyB0ZXN0KGNvbG9yU3RyaW5nKSB7XG4gICAgICAgIHJldHVybiBDT0xPUlJFR1MuTENILnRlc3QoY29sb3JTdHJpbmcpO1xuICAgIH1cbn1cbiIsImltcG9ydCB7IENPTE9SUkVHUywgUENFTlQgfSBmcm9tICcjY29uc3RhbnRzJztcbmltcG9ydCB7IGdldENNWUtOdW1iZXIsIG5vcm1hbGl6ZUFscGhhIH0gZnJvbSAnI2hlbHBlcnMnO1xuaW1wb3J0IHsgY215a1RvUmdiIH0gZnJvbSAnI2NvbG9yL3RyYW5zbGF0b3JzJztcbmltcG9ydCB7IEFscGhhQmFzZUNsYXNzIH0gZnJvbSAnLi9iYXNlQ2xhc3Nlcy9fQWxwaGFCYXNlQ2xhc3MnO1xuZXhwb3J0IGNsYXNzIENNWUtTdHJpbmdQYXJzZXIgZXh0ZW5kcyBBbHBoYUJhc2VDbGFzcyB7XG4gICAgY29uc3RydWN0b3IoY29sb3JTdHJpbmcpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgY29uc3QgbWF0Y2ggPSBjb2xvclN0cmluZy5tYXRjaChDT0xPUlJFR1MuQ01ZSyk7XG4gICAgICAgIGNvbnN0IGdyb3VwcyA9IG1hdGNoLmdyb3VwcztcbiAgICAgICAgdGhpcy5fYyA9IGdyb3Vwcy5jX2xlZ2FjeSA/PyBncm91cHMuYztcbiAgICAgICAgdGhpcy5fbSA9IGdyb3Vwcy5tX2xlZ2FjeSA/PyBncm91cHMubTtcbiAgICAgICAgdGhpcy5feSA9IGdyb3Vwcy55X2xlZ2FjeSA/PyBncm91cHMueTtcbiAgICAgICAgdGhpcy5fayA9IGdyb3Vwcy5rX2xlZ2FjeSA/PyBncm91cHMuaztcbiAgICAgICAgdGhpcy5fYSA9IGdyb3Vwcy5hX2xlZ2FjeSA/PyBncm91cHMuYTtcbiAgICAgICAgY29uc3QgcmdiID0gY215a1RvUmdiKGdldENNWUtOdW1iZXIodGhpcy5fYyksIGdldENNWUtOdW1iZXIodGhpcy5fbSksIGdldENNWUtOdW1iZXIodGhpcy5feSksIGdldENNWUtOdW1iZXIodGhpcy5faykpO1xuICAgICAgICBpZiAodGhpcy5fYSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZ2IuQSA9IG5vcm1hbGl6ZUFscGhhKHRoaXMuX2EpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3JnYiA9IHJnYjtcbiAgICB9XG4gICAgZ2V0IGhhc1BlcmNlbnRhZ2VWYWx1ZXMoKSB7XG4gICAgICAgIHJldHVybiAoUENFTlQudGVzdCh0aGlzLl9jKSAmJlxuICAgICAgICAgICAgUENFTlQudGVzdCh0aGlzLl9tKSAmJlxuICAgICAgICAgICAgUENFTlQudGVzdCh0aGlzLl95KSAmJlxuICAgICAgICAgICAgUENFTlQudGVzdCh0aGlzLl9rKSk7XG4gICAgfVxuICAgIHN0YXRpYyB0ZXN0KGNvbG9yU3RyaW5nKSB7XG4gICAgICAgIHJldHVybiBDT0xPUlJFR1MuQ01ZSy50ZXN0KGNvbG9yU3RyaW5nKTtcbiAgICB9XG59XG4iLCJleHBvcnQgeyBIRVhTdHJpbmdQYXJzZXIgfSBmcm9tICcuL19IRVhTdHJpbmdQYXJzZXInO1xuZXhwb3J0IHsgUkdCU3RyaW5nUGFyc2VyIH0gZnJvbSAnLi9fUkdCU3RyaW5nUGFyc2VyJztcbmV4cG9ydCB7IEhTTFN0cmluZ1BhcnNlciB9IGZyb20gJy4vX0hTTFN0cmluZ1BhcnNlcic7XG5leHBvcnQgeyBIV0JTdHJpbmdQYXJzZXIgfSBmcm9tICcuL19IV0JTdHJpbmdQYXJzZXInO1xuZXhwb3J0IHsgQ0lFTGFiU3RyaW5nUGFyc2VyIH0gZnJvbSAnLi9fQ0lFTGFiU3RyaW5nUGFyc2VyJztcbmV4cG9ydCB7IExDSFN0cmluZ1BhcnNlciB9IGZyb20gJy4vX0xDSFN0cmluZ1BhcnNlcic7XG5leHBvcnQgeyBDTVlLU3RyaW5nUGFyc2VyIH0gZnJvbSAnLi9fQ01ZS1N0cmluZ1BhcnNlcic7XG4iLCJpbXBvcnQgeyBBbmdsZXNVbml0RW51bSwgQ01ZS0Z1bmN0aW9uRW51bSwgQ29sb3JVbml0RW51bSB9IGZyb20gJ0B0eXBlcyc7XG5pbXBvcnQgeyBCQVNFXzI1NSwgQ09MT1JfS0VZUywgQ29sb3JLZXl3b3JkcywgQ29sb3JNb2RlbCwgQ09MT1JSRUdTLCBDT01NQVNfQU5EX05FWFRfQ0hBUlMsIERFRkFVTFRfT1BUSU9OUywgRVJST1JTLCBIRVgsIFBDRU5ULCBTUEFDRVMsIFR5cGVPZiwgVkFMSURfQ09MT1JfT0JKRUNUUyB9IGZyb20gJyNjb25zdGFudHMnO1xuaW1wb3J0IHsgZ2V0QmFzZTEyNU51bWJlciwgZ2V0QmFzZTE1ME51bWJlciwgZ2V0QmFzZTI1NU51bWJlciwgZ2V0Q01ZS051bWJlciwgZ2V0T3JkZXJlZEFycmF5U3RyaW5nLCBoYXNQcm9wLCBub3JtYWxpemVBbHBoYSwgbm9ybWFsaXplSHVlLCBwZXJjZW50IH0gZnJvbSAnI2hlbHBlcnMnO1xuaW1wb3J0IHsgQ0lFTGFiU3RyaW5nUGFyc2VyLCBDTVlLU3RyaW5nUGFyc2VyLCBIRVhTdHJpbmdQYXJzZXIsIEhTTFN0cmluZ1BhcnNlciwgSFdCU3RyaW5nUGFyc2VyLCBMQ0hTdHJpbmdQYXJzZXIsIFJHQlN0cmluZ1BhcnNlciB9IGZyb20gJyNwYXJzZXJzJztcbmltcG9ydCB7IGNteWtUb1JnYiwgaHNsVG9SZ2IsIGh3YlRvUmdiLCBsYWJUb1JnYiwgbGNoVG9SZ2IgfSBmcm9tICcjY29sb3IvdHJhbnNsYXRvcnMnO1xuY29uc3QgZ2V0Q29sb3JNb2RlbEZyb21TdHJpbmcgPSAoY29sb3IpID0+IHtcbiAgICBsZXQgbW9kZWw7XG4gICAgT2JqZWN0LmtleXMoQ29sb3JNb2RlbCkuc29tZSgocCkgPT4ge1xuICAgICAgICBjb25zdCByZWcgPSBDT0xPUlJFR1NbcF07XG4gICAgICAgIGlmIChyZWcudGVzdChjb2xvcikpIHtcbiAgICAgICAgICAgIG1vZGVsID0gcDtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgaWYgKCFtb2RlbCAmJlxuICAgICAgICAhIX5DT0xPUl9LRVlTLmluZGV4T2YoY29sb3IpKSB7XG4gICAgICAgIG1vZGVsID0gQ29sb3JNb2RlbC5IRVg7XG4gICAgfVxuICAgIGlmICghbW9kZWwpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKEVSUk9SUy5OT1RfQUNDRVBURURfU1RSSU5HX0lOUFVUKTtcbiAgICB9XG4gICAgcmV0dXJuIG1vZGVsO1xufTtcbmNvbnN0IGdldENvbG9yTW9kZWxGcm9tT2JqZWN0ID0gKGNvbG9yKSA9PiB7XG4gICAgbGV0IG1vZGVsO1xuICAgIGxldCBpbnZhbGlkID0gZmFsc2U7XG4gICAgY29uc3QgcHJvcHMgPSBnZXRPcmRlcmVkQXJyYXlTdHJpbmcoT2JqZWN0LmtleXMoY29sb3IpKTtcbiAgICBpZiAoVkFMSURfQ09MT1JfT0JKRUNUU1twcm9wc10pIHtcbiAgICAgICAgbW9kZWwgPSBWQUxJRF9DT0xPUl9PQkpFQ1RTW3Byb3BzXTtcbiAgICB9XG4gICAgaWYgKG1vZGVsICYmIG1vZGVsID09PSBDb2xvck1vZGVsLlJHQikge1xuICAgICAgICBjb25zdCBoYXNJbnZhbGlkSGV4ID0gT2JqZWN0LmVudHJpZXMoY29sb3IpLnNvbWUoKGl0ZW0pID0+IHtcbiAgICAgICAgICAgIHJldHVybiAhSEVYLnRlc3QoYCR7aXRlbVsxXX1gKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IGhhc0ludmFsaWRSZWdiID0gT2JqZWN0LmVudHJpZXMoY29sb3IpLnNvbWUoKGl0ZW0pID0+IHtcbiAgICAgICAgICAgIHJldHVybiAhKFBDRU5ULnRlc3QoYCR7aXRlbVsxXX1gKSB8fFxuICAgICAgICAgICAgICAgICghSEVYLnRlc3QoYCR7aXRlbVsxXX1gKSAmJlxuICAgICAgICAgICAgICAgICAgICAhaXNOYU4oK2l0ZW1bMV0pICYmXG4gICAgICAgICAgICAgICAgICAgICtpdGVtWzFdIDw9IEJBU0VfMjU1KSk7XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoaGFzSW52YWxpZEhleCAmJiBoYXNJbnZhbGlkUmVnYikge1xuICAgICAgICAgICAgaW52YWxpZCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFoYXNJbnZhbGlkSGV4KSB7XG4gICAgICAgICAgICBtb2RlbCA9IENvbG9yTW9kZWwuSEVYO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmICghbW9kZWwgfHwgaW52YWxpZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoRVJST1JTLk5PVF9BQ0NFUFRFRF9PQkpFQ1RfSU5QVVQpO1xuICAgIH1cbiAgICByZXR1cm4gbW9kZWw7XG59O1xuZXhwb3J0IGNvbnN0IGdldENvbG9yTW9kZWwgPSAoY29sb3IpID0+IHR5cGVvZiBjb2xvciA9PT0gJ3N0cmluZydcbiAgICA/IGdldENvbG9yTW9kZWxGcm9tU3RyaW5nKGNvbG9yKVxuICAgIDogZ2V0Q29sb3JNb2RlbEZyb21PYmplY3QoY29sb3IpO1xuZXhwb3J0IGNvbnN0IGdldFJHQk9iamVjdEZyb21TdHJpbmcgPSB7XG4gICAgW0NvbG9yTW9kZWwuSEVYXShjb2xvcikge1xuICAgICAgICBjb25zdCBjb2xvclN0ciA9ICF+Q09MT1JfS0VZUy5pbmRleE9mKGNvbG9yKVxuICAgICAgICAgICAgPyBjb2xvclxuICAgICAgICAgICAgOiBDb2xvcktleXdvcmRzW2NvbG9yXTtcbiAgICAgICAgcmV0dXJuIG5ldyBIRVhTdHJpbmdQYXJzZXIoY29sb3JTdHIpLnJnYjtcbiAgICB9LFxuICAgIFtDb2xvck1vZGVsLlJHQl0oY29sb3IpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBSR0JTdHJpbmdQYXJzZXIoY29sb3IsIGdldFJHQk9iamVjdCkucmdiO1xuICAgIH0sXG4gICAgW0NvbG9yTW9kZWwuSFNMXShjb2xvcikge1xuICAgICAgICByZXR1cm4gbmV3IEhTTFN0cmluZ1BhcnNlcihjb2xvciwgZ2V0UkdCT2JqZWN0KS5yZ2I7XG4gICAgfSxcbiAgICBbQ29sb3JNb2RlbC5IV0JdKGNvbG9yKSB7XG4gICAgICAgIHJldHVybiBuZXcgSFdCU3RyaW5nUGFyc2VyKGNvbG9yLCBnZXRSR0JPYmplY3QpLnJnYjtcbiAgICB9LFxuICAgIFtDb2xvck1vZGVsLkNJRUxhYl0oY29sb3IpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBDSUVMYWJTdHJpbmdQYXJzZXIoY29sb3IsIGdldFJHQk9iamVjdCkucmdiO1xuICAgIH0sXG4gICAgW0NvbG9yTW9kZWwuTENIXShjb2xvcikge1xuICAgICAgICByZXR1cm4gbmV3IExDSFN0cmluZ1BhcnNlcihjb2xvciwgZ2V0UkdCT2JqZWN0KS5yZ2I7XG4gICAgfSxcbiAgICBbQ29sb3JNb2RlbC5DTVlLXShjb2xvcikge1xuICAgICAgICByZXR1cm4gbmV3IENNWUtTdHJpbmdQYXJzZXIoY29sb3IpLnJnYjtcbiAgICB9XG59O1xuZXhwb3J0IGNvbnN0IGdldFJHQk9iamVjdEZyb21PYmplY3QgPSB7XG4gICAgW0NvbG9yTW9kZWwuSEVYXShjb2xvcikge1xuICAgICAgICBjb25zdCBvYmplY3QgPSB7XG4gICAgICAgICAgICBSOiBnZXRCYXNlMjU1TnVtYmVyKGAke2NvbG9yLlJ9YCksXG4gICAgICAgICAgICBHOiBnZXRCYXNlMjU1TnVtYmVyKGAke2NvbG9yLkd9YCksXG4gICAgICAgICAgICBCOiBnZXRCYXNlMjU1TnVtYmVyKGAke2NvbG9yLkJ9YClcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKGhhc1Byb3AoY29sb3IsICdBJykpIHtcbiAgICAgICAgICAgIG9iamVjdC5BID0gTWF0aC5taW4oZ2V0QmFzZTI1NU51bWJlcihgJHtjb2xvci5BfWAsIHRydWUpLCAxKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb2JqZWN0O1xuICAgIH0sXG4gICAgW0NvbG9yTW9kZWwuUkdCXShjb2xvcikge1xuICAgICAgICByZXR1cm4gdGhpcy5IRVgoY29sb3IpO1xuICAgIH0sXG4gICAgW0NvbG9yTW9kZWwuSFNMXShjb2xvcikge1xuICAgICAgICBjb25zdCBTID0gcGVyY2VudChgJHtjb2xvci5TfWApO1xuICAgICAgICBjb25zdCBMID0gcGVyY2VudChgJHtjb2xvci5MfWApO1xuICAgICAgICBjb25zdCBSR0IgPSBoc2xUb1JnYihub3JtYWxpemVIdWUoY29sb3IuSCksIFMsIEwpO1xuICAgICAgICBpZiAoaGFzUHJvcChjb2xvciwgJ0EnKSkge1xuICAgICAgICAgICAgUkdCLkEgPSBub3JtYWxpemVBbHBoYShjb2xvci5BKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gUkdCO1xuICAgIH0sXG4gICAgW0NvbG9yTW9kZWwuSFdCXShjb2xvcikge1xuICAgICAgICBjb25zdCBXID0gcGVyY2VudChgJHtjb2xvci5XfWApO1xuICAgICAgICBjb25zdCBCID0gcGVyY2VudChgJHtjb2xvci5CfWApO1xuICAgICAgICBjb25zdCBSR0IgPSBod2JUb1JnYihub3JtYWxpemVIdWUoY29sb3IuSCksIFcsIEIpO1xuICAgICAgICBpZiAoaGFzUHJvcChjb2xvciwgJ0EnKSkge1xuICAgICAgICAgICAgUkdCLkEgPSBub3JtYWxpemVBbHBoYShjb2xvci5BKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gUkdCO1xuICAgIH0sXG4gICAgW0NvbG9yTW9kZWwuQ0lFTGFiXShjb2xvcikge1xuICAgICAgICBjb25zdCBMID0gcGVyY2VudChgJHtjb2xvci5MfWApO1xuICAgICAgICBjb25zdCBhID0gZ2V0QmFzZTEyNU51bWJlcihgJHtjb2xvci5hfWApO1xuICAgICAgICBjb25zdCBiID0gZ2V0QmFzZTEyNU51bWJlcihgJHtjb2xvci5ifWApO1xuICAgICAgICBjb25zdCBSR0IgPSBsYWJUb1JnYihMLCBhLCBiKTtcbiAgICAgICAgaWYgKGhhc1Byb3AoY29sb3IsICdBJykpIHtcbiAgICAgICAgICAgIFJHQi5BID0gbm9ybWFsaXplQWxwaGEoY29sb3IuQSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFJHQjtcbiAgICB9LFxuICAgIFtDb2xvck1vZGVsLkxDSF0oY29sb3IpIHtcbiAgICAgICAgY29uc3QgTCA9IHBlcmNlbnQoYCR7Y29sb3IuTH1gKTtcbiAgICAgICAgY29uc3QgQyA9IGdldEJhc2UxNTBOdW1iZXIoYCR7Y29sb3IuQ31gKTtcbiAgICAgICAgY29uc3QgSCA9IG5vcm1hbGl6ZUh1ZShgJHtjb2xvci5IfWApO1xuICAgICAgICBjb25zdCBSR0IgPSBsY2hUb1JnYihMLCBDLCBIKTtcbiAgICAgICAgaWYgKGhhc1Byb3AoY29sb3IsICdBJykpIHtcbiAgICAgICAgICAgIFJHQi5BID0gbm9ybWFsaXplQWxwaGEoY29sb3IuQSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFJHQjtcbiAgICB9LFxuICAgIFtDb2xvck1vZGVsLkNNWUtdKGNvbG9yKSB7XG4gICAgICAgIGNvbnN0IEMgPSBnZXRDTVlLTnVtYmVyKGAke2NvbG9yLkN9YCk7XG4gICAgICAgIGNvbnN0IE0gPSBnZXRDTVlLTnVtYmVyKGAke2NvbG9yLk19YCk7XG4gICAgICAgIGNvbnN0IFkgPSBnZXRDTVlLTnVtYmVyKGAke2NvbG9yLll9YCk7XG4gICAgICAgIGNvbnN0IEsgPSBnZXRDTVlLTnVtYmVyKGAke2NvbG9yLkt9YCk7XG4gICAgICAgIGNvbnN0IFJHQiA9IGNteWtUb1JnYihDLCBNLCBZLCBLKTtcbiAgICAgICAgaWYgKGhhc1Byb3AoY29sb3IsICdBJykpIHtcbiAgICAgICAgICAgIFJHQi5BID0gbm9ybWFsaXplQWxwaGEoY29sb3IuQSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFJHQjtcbiAgICB9XG59O1xuZXhwb3J0IGNvbnN0IGdldFJHQk9iamVjdCA9IChjb2xvciwgbW9kZWwgPSBnZXRDb2xvck1vZGVsKGNvbG9yKSkgPT4ge1xuICAgIHJldHVybiB0eXBlb2YgY29sb3IgPT09ICdzdHJpbmcnXG4gICAgICAgID8gZ2V0UkdCT2JqZWN0RnJvbVN0cmluZ1ttb2RlbF0oY29sb3IpXG4gICAgICAgIDogZ2V0UkdCT2JqZWN0RnJvbU9iamVjdFttb2RlbF0oY29sb3IpO1xufTtcbmV4cG9ydCBjb25zdCBnZXRPcHRpb25zRnJvbUNvbG9ySW5wdXQgPSAob3B0aW9ucywgLi4uY29sb3JzKSA9PiB7XG4gICAgY29uc3QgY3NzQ29sb3JzID0gW107XG4gICAgY29uc3QgYW5nbGVzVW5pdHMgPSBbXTtcbiAgICBjb25zdCByZ2JDb2xvcnMgPSBbXTtcbiAgICBjb25zdCBsYWJDb2xvcnMgPSBbXTtcbiAgICBjb25zdCBsY2hDb2xvcnMgPSBbXTtcbiAgICBjb25zdCBjbXlrQ29sb3JzID0gW107XG4gICAgY29uc3QgYWxwaGFWYWx1ZXMgPSBbXTtcbiAgICBjb25zdCBhbmdsZXNVbml0VmFsdWVzID0gT2JqZWN0LnZhbHVlcyhBbmdsZXNVbml0RW51bSk7XG4gICAgY29uc3QgY29sb3JVbml0VmFsdWVzID0gT2JqZWN0LnZhbHVlcyhDb2xvclVuaXRFbnVtKTtcbiAgICBjb25zdCBjbXlrRnVuY3Rpb25WYWx1ZXMgPSBPYmplY3QudmFsdWVzKENNWUtGdW5jdGlvbkVudW0pO1xuICAgIGNvbnN0IG1hdGNoT3B0aW9ucyA9IHtcbiAgICAgICAgbGVnYWN5Q1NTOiAwLFxuICAgICAgICBzcGFjZXNBZnRlckNvbW1hczogMCxcbiAgICAgICAgY215a0Z1bmN0aW9uOiAwXG4gICAgfTtcbiAgICBmb3IgKGNvbnN0IGNvbG9yIG9mIGNvbG9ycykge1xuICAgICAgICBpZiAodHlwZW9mIGNvbG9yID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgY3NzQ29sb3JzLnB1c2goY29sb3IpO1xuICAgICAgICAgICAgaWYgKGNvbG9yLmluY2x1ZGVzKCcsJykpIHtcbiAgICAgICAgICAgICAgICBtYXRjaE9wdGlvbnMubGVnYWN5Q1NTKys7XG4gICAgICAgICAgICAgICAgY29uc3QgY29tbWFzV2l0aE5leHRDaGFyYWN0ZXIgPSBjb2xvci5tYXRjaChDT01NQVNfQU5EX05FWFRfQ0hBUlMpO1xuICAgICAgICAgICAgICAgIGlmIChuZXcgU2V0KGNvbW1hc1dpdGhOZXh0Q2hhcmFjdGVyKS5zaXplID09PSAxICYmXG4gICAgICAgICAgICAgICAgICAgIFNQQUNFUy50ZXN0KGNvbW1hc1dpdGhOZXh0Q2hhcmFjdGVyWzBdLnNsaWNlKDEpKSkge1xuICAgICAgICAgICAgICAgICAgICBtYXRjaE9wdGlvbnMuc3BhY2VzQWZ0ZXJDb21tYXMrKztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoSFNMU3RyaW5nUGFyc2VyLnRlc3QoY29sb3IpKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcGFyc2VyID0gbmV3IEhTTFN0cmluZ1BhcnNlcihjb2xvciwgZ2V0UkdCT2JqZWN0KTtcbiAgICAgICAgICAgICAgICBhbmdsZXNVbml0cy5wdXNoKHBhcnNlci5hbmdsZVVuaXQpO1xuICAgICAgICAgICAgICAgIGFscGhhVmFsdWVzLnB1c2gocGFyc2VyLmhhc1BlcmNlbnRhZ2VBbHBoYSk7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoSFdCU3RyaW5nUGFyc2VyLnRlc3QoY29sb3IpKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcGFyc2VyID0gbmV3IEhXQlN0cmluZ1BhcnNlcihjb2xvciwgZ2V0UkdCT2JqZWN0KTtcbiAgICAgICAgICAgICAgICBhbmdsZXNVbml0cy5wdXNoKHBhcnNlci5hbmdsZVVuaXQpO1xuICAgICAgICAgICAgICAgIGFscGhhVmFsdWVzLnB1c2gocGFyc2VyLmhhc1BlcmNlbnRhZ2VBbHBoYSk7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoUkdCU3RyaW5nUGFyc2VyLnRlc3QoY29sb3IpKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcGFyc2VyID0gbmV3IFJHQlN0cmluZ1BhcnNlcihjb2xvciwgZ2V0UkdCT2JqZWN0KTtcbiAgICAgICAgICAgICAgICByZ2JDb2xvcnMucHVzaChwYXJzZXIuaGFzUGVyY2VudGFnZVZhbHVlcyk7XG4gICAgICAgICAgICAgICAgYWxwaGFWYWx1ZXMucHVzaChwYXJzZXIuaGFzUGVyY2VudGFnZUFscGhhKTtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChDSUVMYWJTdHJpbmdQYXJzZXIudGVzdChjb2xvcikpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBwYXJzZXIgPSBuZXcgQ0lFTGFiU3RyaW5nUGFyc2VyKGNvbG9yLCBnZXRSR0JPYmplY3QpO1xuICAgICAgICAgICAgICAgIGxhYkNvbG9ycy5wdXNoKHBhcnNlci5oYXNQZXJjZW50YWdlVmFsdWVzKTtcbiAgICAgICAgICAgICAgICBhbHBoYVZhbHVlcy5wdXNoKHBhcnNlci5oYXNQZXJjZW50YWdlQWxwaGEpO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKExDSFN0cmluZ1BhcnNlci50ZXN0KGNvbG9yKSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHBhcnNlciA9IG5ldyBMQ0hTdHJpbmdQYXJzZXIoY29sb3IsIGdldFJHQk9iamVjdCk7XG4gICAgICAgICAgICAgICAgYW5nbGVzVW5pdHMucHVzaChwYXJzZXIuYW5nbGVVbml0KTtcbiAgICAgICAgICAgICAgICBsY2hDb2xvcnMucHVzaChwYXJzZXIuaGFzUGVyY2VudGFnZVZhbHVlcyk7XG4gICAgICAgICAgICAgICAgYWxwaGFWYWx1ZXMucHVzaChwYXJzZXIuaGFzUGVyY2VudGFnZUFscGhhKTtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChDTVlLU3RyaW5nUGFyc2VyLnRlc3QoY29sb3IpKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcGFyc2VyID0gbmV3IENNWUtTdHJpbmdQYXJzZXIoY29sb3IpO1xuICAgICAgICAgICAgICAgIGNteWtDb2xvcnMucHVzaChwYXJzZXIuaGFzUGVyY2VudGFnZVZhbHVlcyk7XG4gICAgICAgICAgICAgICAgaWYgKGNvbG9yLnN0YXJ0c1dpdGgoJ2NteWsnKSkge1xuICAgICAgICAgICAgICAgICAgICBtYXRjaE9wdGlvbnMuY215a0Z1bmN0aW9uKys7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGFscGhhVmFsdWVzLnB1c2gocGFyc2VyLmhhc1BlcmNlbnRhZ2VBbHBoYSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgZGVjaW1hbHM6IHR5cGVvZiBvcHRpb25zLmRlY2ltYWxzID09PSBUeXBlT2YuTlVNQkVSXG4gICAgICAgICAgICA/IG9wdGlvbnMuZGVjaW1hbHNcbiAgICAgICAgICAgIDogREVGQVVMVF9PUFRJT05TLmRlY2ltYWxzLFxuICAgICAgICBsZWdhY3lDU1M6IHR5cGVvZiBvcHRpb25zLmxlZ2FjeUNTUyA9PT0gVHlwZU9mLkJPT0xFQU5cbiAgICAgICAgICAgID8gb3B0aW9ucy5sZWdhY3lDU1NcbiAgICAgICAgICAgIDogQm9vbGVhbihjc3NDb2xvcnMubGVuZ3RoICYmXG4gICAgICAgICAgICAgICAgbWF0Y2hPcHRpb25zLmxlZ2FjeUNTUyA9PT0gY3NzQ29sb3JzLmxlbmd0aCkgfHwgREVGQVVMVF9PUFRJT05TLmxlZ2FjeUNTUyxcbiAgICAgICAgc3BhY2VzQWZ0ZXJDb21tYXM6IHR5cGVvZiBvcHRpb25zLnNwYWNlc0FmdGVyQ29tbWFzID09PSBUeXBlT2YuQk9PTEVBTlxuICAgICAgICAgICAgPyBvcHRpb25zLnNwYWNlc0FmdGVyQ29tbWFzXG4gICAgICAgICAgICA6IEJvb2xlYW4oY3NzQ29sb3JzLmxlbmd0aCAmJlxuICAgICAgICAgICAgICAgIG1hdGNoT3B0aW9ucy5zcGFjZXNBZnRlckNvbW1hcyA9PT0gY3NzQ29sb3JzLmxlbmd0aCkgfHwgREVGQVVMVF9PUFRJT05TLnNwYWNlc0FmdGVyQ29tbWFzLFxuICAgICAgICBhbmdsZXNVbml0OiBvcHRpb25zLmFuZ2xlc1VuaXQgJiYgYW5nbGVzVW5pdFZhbHVlcy5pbmNsdWRlcyhvcHRpb25zLmFuZ2xlc1VuaXQpXG4gICAgICAgICAgICA/IG9wdGlvbnMuYW5nbGVzVW5pdFxuICAgICAgICAgICAgOiAobmV3IFNldChhbmdsZXNVbml0cykuc2l6ZSA9PT0gMVxuICAgICAgICAgICAgICAgID8gYW5nbGVzVW5pdHNbMF1cbiAgICAgICAgICAgICAgICA6IERFRkFVTFRfT1BUSU9OUy5hbmdsZXNVbml0KSxcbiAgICAgICAgcmdiVW5pdDogb3B0aW9ucy5yZ2JVbml0ICYmIGNvbG9yVW5pdFZhbHVlcy5pbmNsdWRlcyhvcHRpb25zLnJnYlVuaXQpXG4gICAgICAgICAgICA/IG9wdGlvbnMucmdiVW5pdFxuICAgICAgICAgICAgOiAobmV3IFNldChyZ2JDb2xvcnMpLnNpemUgPT09IDEgJiYgcmdiQ29sb3JzWzBdXG4gICAgICAgICAgICAgICAgPyBDb2xvclVuaXRFbnVtLlBFUkNFTlRcbiAgICAgICAgICAgICAgICA6IERFRkFVTFRfT1BUSU9OUy5yZ2JVbml0KSxcbiAgICAgICAgbGFiVW5pdDogb3B0aW9ucy5sYWJVbml0ICYmIGNvbG9yVW5pdFZhbHVlcy5pbmNsdWRlcyhvcHRpb25zLmxhYlVuaXQpXG4gICAgICAgICAgICA/IG9wdGlvbnMubGFiVW5pdFxuICAgICAgICAgICAgOiAobmV3IFNldChsYWJDb2xvcnMpLnNpemUgPT09IDEgJiYgbGFiQ29sb3JzWzBdXG4gICAgICAgICAgICAgICAgPyBDb2xvclVuaXRFbnVtLlBFUkNFTlRcbiAgICAgICAgICAgICAgICA6IERFRkFVTFRfT1BUSU9OUy5sYWJVbml0KSxcbiAgICAgICAgbGNoVW5pdDogb3B0aW9ucy5sY2hVbml0ICYmIGNvbG9yVW5pdFZhbHVlcy5pbmNsdWRlcyhvcHRpb25zLmxjaFVuaXQpXG4gICAgICAgICAgICA/IG9wdGlvbnMubGNoVW5pdFxuICAgICAgICAgICAgOiAobmV3IFNldChsY2hDb2xvcnMpLnNpemUgPT09IDEgJiYgbGNoQ29sb3JzWzBdXG4gICAgICAgICAgICAgICAgPyBDb2xvclVuaXRFbnVtLlBFUkNFTlRcbiAgICAgICAgICAgICAgICA6IERFRkFVTFRfT1BUSU9OUy5sY2hVbml0KSxcbiAgICAgICAgY215a1VuaXQ6IG9wdGlvbnMuY215a1VuaXQgJiYgY29sb3JVbml0VmFsdWVzLmluY2x1ZGVzKG9wdGlvbnMuY215a1VuaXQpXG4gICAgICAgICAgICA/IG9wdGlvbnMuY215a1VuaXRcbiAgICAgICAgICAgIDogKG5ldyBTZXQoY215a0NvbG9ycykuc2l6ZSA9PT0gMSAmJiAhY215a0NvbG9yc1swXVxuICAgICAgICAgICAgICAgID8gQ29sb3JVbml0RW51bS5OT05FXG4gICAgICAgICAgICAgICAgOiBERUZBVUxUX09QVElPTlMuY215a1VuaXQpLFxuICAgICAgICBhbHBoYVVuaXQ6IG9wdGlvbnMuYWxwaGFVbml0ICYmIGNvbG9yVW5pdFZhbHVlcy5pbmNsdWRlcyhvcHRpb25zLmFscGhhVW5pdClcbiAgICAgICAgICAgID8gb3B0aW9ucy5hbHBoYVVuaXRcbiAgICAgICAgICAgIDogKG5ldyBTZXQoYWxwaGFWYWx1ZXMpLnNpemUgPT09IDEgJiYgYWxwaGFWYWx1ZXNbMF1cbiAgICAgICAgICAgICAgICA/IENvbG9yVW5pdEVudW0uUEVSQ0VOVFxuICAgICAgICAgICAgICAgIDogREVGQVVMVF9PUFRJT05TLmFscGhhVW5pdCksXG4gICAgICAgIGNteWtGdW5jdGlvbjogb3B0aW9ucy5jbXlrRnVuY3Rpb24gJiYgY215a0Z1bmN0aW9uVmFsdWVzLmluY2x1ZGVzKG9wdGlvbnMuY215a0Z1bmN0aW9uKVxuICAgICAgICAgICAgPyBvcHRpb25zLmNteWtGdW5jdGlvblxuICAgICAgICAgICAgOiAoY215a0NvbG9ycy5sZW5ndGggJiYgY215a0NvbG9ycy5sZW5ndGggPT09IG1hdGNoT3B0aW9ucy5jbXlrRnVuY3Rpb25cbiAgICAgICAgICAgICAgICA/IENNWUtGdW5jdGlvbkVudW0uQ01ZS1xuICAgICAgICAgICAgICAgIDogREVGQVVMVF9PUFRJT05TLmNteWtGdW5jdGlvbilcbiAgICB9O1xufTtcbiIsImltcG9ydCB7IHJvdW5kIH0gZnJvbSAnI2hlbHBlcnMnO1xuZXhwb3J0IGNvbnN0IHJvdW5kSFNMT2JqZWN0ID0gKGNvbG9yLCBkZWNpbWFscykgPT4ge1xuICAgIHJldHVybiB7XG4gICAgICAgIEg6IHJvdW5kKGNvbG9yLkgsIGRlY2ltYWxzKSxcbiAgICAgICAgUzogcm91bmQoY29sb3IuUywgZGVjaW1hbHMpLFxuICAgICAgICBMOiByb3VuZChjb2xvci5MLCBkZWNpbWFscylcbiAgICB9O1xufTtcbmV4cG9ydCBjb25zdCByb3VuZEhXQk9iamVjdCA9IChjb2xvciwgZGVjaW1hbHMpID0+IHtcbiAgICByZXR1cm4ge1xuICAgICAgICBIOiByb3VuZChjb2xvci5ILCBkZWNpbWFscyksXG4gICAgICAgIFc6IHJvdW5kKGNvbG9yLlcsIGRlY2ltYWxzKSxcbiAgICAgICAgQjogcm91bmQoY29sb3IuQiwgZGVjaW1hbHMpXG4gICAgfTtcbn07XG5leHBvcnQgY29uc3Qgcm91bmRDSUVMYWJPYmplY3QgPSAoY29sb3IsIGRlY2ltYWxzKSA9PiB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgTDogcm91bmQoY29sb3IuTCwgZGVjaW1hbHMpLFxuICAgICAgICBhOiByb3VuZChjb2xvci5hLCBkZWNpbWFscyksXG4gICAgICAgIGI6IHJvdW5kKGNvbG9yLmIsIGRlY2ltYWxzKVxuICAgIH07XG59O1xuZXhwb3J0IGNvbnN0IHJvdW5kTENIT2JqZWN0ID0gKGNvbG9yLCBkZWNpbWFscykgPT4ge1xuICAgIHJldHVybiB7XG4gICAgICAgIEw6IHJvdW5kKGNvbG9yLkwsIGRlY2ltYWxzKSxcbiAgICAgICAgQzogcm91bmQoY29sb3IuQywgZGVjaW1hbHMpLFxuICAgICAgICBIOiByb3VuZChjb2xvci5ILCBkZWNpbWFscylcbiAgICB9O1xufTtcbmV4cG9ydCBjb25zdCByb3VuZENNWUtPYmplY3QgPSAoY29sb3IsIGRlY2ltYWxzKSA9PiB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgQzogcm91bmQoY29sb3IuQywgZGVjaW1hbHMpLFxuICAgICAgICBNOiByb3VuZChjb2xvci5NLCBkZWNpbWFscyksXG4gICAgICAgIFk6IHJvdW5kKGNvbG9yLlksIGRlY2ltYWxzKSxcbiAgICAgICAgSzogcm91bmQoY29sb3IuSywgZGVjaW1hbHMpXG4gICAgfTtcbn07XG4iLCJpbXBvcnQgeyBBbmdsZXNVbml0RW51bSwgQ29sb3JVbml0RW51bSB9IGZyb20gJ0B0eXBlcyc7XG5pbXBvcnQgeyBDT0xPUl9QUk9QUywgQ29sb3JNb2RlbCwgVEVNUExBVEVfVkFSLCBWQUxJRF9DT0xPUl9PQkpFQ1RTIH0gZnJvbSAnI2NvbnN0YW50cyc7XG5pbXBvcnQgeyBmcm9tMTI1TnVtYmVyVG9QZXJjZW50LCBmcm9tMTUwTnVtYmVyVG9QZXJjZW50LCBmcm9tMjU1TnVtYmVyVG9QZXJjZW50LCBnZXRPcmRlcmVkQXJyYXlTdHJpbmcsIHBlcmNlbnQsIHJvdW5kLCB0b0hFWCwgdHJhbnNsYXRlRGVncmVlcyB9IGZyb20gJyNoZWxwZXJzJztcbmNvbnN0IGdldENvbW1hID0gKHdpdGhTcGFjZSkgPT4gd2l0aFNwYWNlXG4gICAgPyAnLCAnXG4gICAgOiAnLCc7XG5jb25zdCBwcmVwYXJlQ29sb3JGb3JDc3MgPSAoY29sb3IsIHRyYW5zZm9ybWVyKSA9PiB7XG4gICAgY29uc3QgcHJvcHMgPSBnZXRPcmRlcmVkQXJyYXlTdHJpbmcoT2JqZWN0LmtleXMoY29sb3IpKTtcbiAgICBjb25zdCBtb2RlbCA9IFZBTElEX0NPTE9SX09CSkVDVFNbcHJvcHNdO1xuICAgIGNvbnN0IGtleXMgPSBDT0xPUl9QUk9QU1ttb2RlbF07XG4gICAgcmV0dXJuIGtleXMucmVkdWNlKChyZXN1bHQsIGtleSwgaW5kZXgpID0+IHtcbiAgICAgICAgY29uc3QgdmFsdWUgPSBjb2xvcltrZXldO1xuICAgICAgICBpZiAodHlwZW9mIHZhbHVlICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcmVzdWx0LnB1c2godHJhbnNmb3JtZXIodmFsdWUsIGluZGV4KSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9LCBbXSk7XG59O1xuY29uc3QgZ2V0UmVzdWx0RnJvbVRlbXBsYXRlID0gKHRlbXBsYXRlLCB2YXJzKSA9PiB7XG4gICAgcmV0dXJuIHRlbXBsYXRlLnJlcGxhY2UoVEVNUExBVEVfVkFSLCAoX19tYXRjaCwgaW5kZXhTdHIpID0+IHtcbiAgICAgICAgY29uc3QgaW5kZXggPSAraW5kZXhTdHIgLSAxO1xuICAgICAgICByZXR1cm4gYCR7dmFyc1tpbmRleF19YDtcbiAgICB9KTtcbn07XG5jb25zdCBnZXRBbHBoYSA9ICh2YWx1ZSwgb3B0aW9ucywgaWdub3JlTGVnYWN5ID0gZmFsc2UpID0+IHtcbiAgICBjb25zdCB7IGFscGhhVW5pdCwgbGVnYWN5Q1NTLCBkZWNpbWFscyB9ID0gb3B0aW9ucztcbiAgICBpZiAoYWxwaGFVbml0ID09PSBDb2xvclVuaXRFbnVtLlBFUkNFTlQgJiZcbiAgICAgICAgKCFsZWdhY3lDU1MgfHxcbiAgICAgICAgICAgIGlnbm9yZUxlZ2FjeSkpIHtcbiAgICAgICAgcmV0dXJuIGAke3JvdW5kKHZhbHVlICogMTAwLCBkZWNpbWFscyl9JWA7XG4gICAgfVxuICAgIHJldHVybiByb3VuZCh2YWx1ZSwgZGVjaW1hbHMpO1xufTtcbmNvbnN0IGJ1aWxkSHVlVHJhbnNmb3JtZXIgPSAob3B0aW9ucykgPT4ge1xuICAgIGNvbnN0IHsgYW5nbGVzVW5pdCwgZGVjaW1hbHMgfSA9IG9wdGlvbnM7XG4gICAgcmV0dXJuICh2YWx1ZSwgaW5kZXgpID0+IHtcbiAgICAgICAgaWYgKGluZGV4ID09PSAwICYmXG4gICAgICAgICAgICBhbmdsZXNVbml0ICE9PSBBbmdsZXNVbml0RW51bS5OT05FKSB7XG4gICAgICAgICAgICBjb25zdCB0cmFuc2xhdGVkID0gcm91bmQodHJhbnNsYXRlRGVncmVlcyh2YWx1ZSwgYW5nbGVzVW5pdCksIGRlY2ltYWxzKTtcbiAgICAgICAgICAgIHJldHVybiBgJHt0cmFuc2xhdGVkfSR7YW5nbGVzVW5pdH1gO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpbmRleCA9PT0gM1xuICAgICAgICAgICAgPyBnZXRBbHBoYSh2YWx1ZSwgb3B0aW9ucylcbiAgICAgICAgICAgIDogcm91bmQodmFsdWUsIGRlY2ltYWxzKTtcbiAgICB9O1xufTtcbmV4cG9ydCBjb25zdCBDU1MgPSB7XG4gICAgW0NvbG9yTW9kZWwuSEVYXTogKGNvbG9yKSA9PiB7XG4gICAgICAgIGNvbnN0IHRyYW5zZm9ybWVyID0gKHZhbHVlKSA9PiB0b0hFWChyb3VuZCh2YWx1ZSkpO1xuICAgICAgICBjb25zdCB2YWx1ZXMgPSBwcmVwYXJlQ29sb3JGb3JDc3MoY29sb3IsIHRyYW5zZm9ybWVyKTtcbiAgICAgICAgY29uc3QgdGVtcGxhdGUgPSB2YWx1ZXMubGVuZ3RoID09PSA0XG4gICAgICAgICAgICA/ICcjezF9ezJ9ezN9ezR9J1xuICAgICAgICAgICAgOiAnI3sxfXsyfXszfSc7XG4gICAgICAgIHJldHVybiBnZXRSZXN1bHRGcm9tVGVtcGxhdGUodGVtcGxhdGUsIHZhbHVlcyk7XG4gICAgfSxcbiAgICBbQ29sb3JNb2RlbC5SR0JdOiAoY29sb3IsIG9wdGlvbnMpID0+IHtcbiAgICAgICAgY29uc3QgeyBkZWNpbWFscywgbGVnYWN5Q1NTLCBzcGFjZXNBZnRlckNvbW1hcywgcmdiVW5pdCB9ID0gb3B0aW9ucztcbiAgICAgICAgY29uc3QgY29tbWEgPSBnZXRDb21tYShzcGFjZXNBZnRlckNvbW1hcyk7XG4gICAgICAgIGNvbnN0IHRyYW5zZm9ybWVyID0gKHZhbHVlLCBpbmRleCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHJnYlVuaXQgPT09IENvbG9yVW5pdEVudW0uUEVSQ0VOVCAmJiBpbmRleCA8IDNcbiAgICAgICAgICAgICAgICA/IGAke2Zyb20yNTVOdW1iZXJUb1BlcmNlbnQodmFsdWUsIGRlY2ltYWxzKX0lYFxuICAgICAgICAgICAgICAgIDogKGluZGV4ID09PSAzXG4gICAgICAgICAgICAgICAgICAgID8gZ2V0QWxwaGEodmFsdWUsIG9wdGlvbnMpXG4gICAgICAgICAgICAgICAgICAgIDogcm91bmQodmFsdWUsIGRlY2ltYWxzKSk7XG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IHZhbHVlcyA9IHByZXBhcmVDb2xvckZvckNzcyhjb2xvciwgdHJhbnNmb3JtZXIpO1xuICAgICAgICBjb25zdCB0ZW1wbGF0ZSA9IGxlZ2FjeUNTU1xuICAgICAgICAgICAgPyAodmFsdWVzLmxlbmd0aCA9PT0gNFxuICAgICAgICAgICAgICAgID8gYHJnYmEoezF9JHtjb21tYX17Mn0ke2NvbW1hfXszfSR7Y29tbWF9ezR9KWBcbiAgICAgICAgICAgICAgICA6IGByZ2IoezF9JHtjb21tYX17Mn0ke2NvbW1hfXszfSlgKVxuICAgICAgICAgICAgOiAodmFsdWVzLmxlbmd0aCA9PT0gNFxuICAgICAgICAgICAgICAgID8gYHJnYih7MX0gezJ9IHszfSAvIHs0fSlgXG4gICAgICAgICAgICAgICAgOiBgcmdiKHsxfSB7Mn0gezN9KWApO1xuICAgICAgICByZXR1cm4gZ2V0UmVzdWx0RnJvbVRlbXBsYXRlKHRlbXBsYXRlLCB2YWx1ZXMpO1xuICAgIH0sXG4gICAgW0NvbG9yTW9kZWwuSFNMXTogKGNvbG9yLCBvcHRpb25zKSA9PiB7XG4gICAgICAgIGNvbnN0IHsgbGVnYWN5Q1NTLCBzcGFjZXNBZnRlckNvbW1hcyB9ID0gb3B0aW9ucztcbiAgICAgICAgY29uc3QgY29tbWEgPSBnZXRDb21tYShzcGFjZXNBZnRlckNvbW1hcyk7XG4gICAgICAgIGNvbnN0IHRyYW5zZm9ybWVyID0gYnVpbGRIdWVUcmFuc2Zvcm1lcihvcHRpb25zKTtcbiAgICAgICAgY29uc3QgdmFsdWVzID0gcHJlcGFyZUNvbG9yRm9yQ3NzKGNvbG9yLCB0cmFuc2Zvcm1lcik7XG4gICAgICAgIGNvbnN0IHRlbXBsYXRlID0gbGVnYWN5Q1NTXG4gICAgICAgICAgICA/ICh2YWx1ZXMubGVuZ3RoID09PSA0XG4gICAgICAgICAgICAgICAgPyBgaHNsYSh7MX0ke2NvbW1hfXsyfSUke2NvbW1hfXszfSUke2NvbW1hfXs0fSlgXG4gICAgICAgICAgICAgICAgOiBgaHNsKHsxfSR7Y29tbWF9ezJ9JSR7Y29tbWF9ezN9JSlgKVxuICAgICAgICAgICAgOiAodmFsdWVzLmxlbmd0aCA9PT0gNFxuICAgICAgICAgICAgICAgID8gYGhzbCh7MX0gezJ9JSB7M30lIC8gezR9KWBcbiAgICAgICAgICAgICAgICA6IGBoc2woezF9IHsyfSUgezN9JSlgKTtcbiAgICAgICAgcmV0dXJuIGdldFJlc3VsdEZyb21UZW1wbGF0ZSh0ZW1wbGF0ZSwgdmFsdWVzKTtcbiAgICB9LFxuICAgIFtDb2xvck1vZGVsLkhXQl06IChjb2xvciwgb3B0aW9ucykgPT4ge1xuICAgICAgICBjb25zdCB0cmFuc2Zvcm1lciA9IGJ1aWxkSHVlVHJhbnNmb3JtZXIob3B0aW9ucyk7XG4gICAgICAgIGNvbnN0IHZhbHVlcyA9IHByZXBhcmVDb2xvckZvckNzcyhjb2xvciwgdHJhbnNmb3JtZXIpO1xuICAgICAgICBjb25zdCB0ZW1wbGF0ZSA9IHZhbHVlcy5sZW5ndGggPT09IDRcbiAgICAgICAgICAgID8gYGh3Yih7MX0gezJ9JSB7M30lIC8gezR9KWBcbiAgICAgICAgICAgIDogYGh3Yih7MX0gezJ9JSB7M30lKWA7XG4gICAgICAgIHJldHVybiBnZXRSZXN1bHRGcm9tVGVtcGxhdGUodGVtcGxhdGUsIHZhbHVlcyk7XG4gICAgfSxcbiAgICBbQ29sb3JNb2RlbC5DSUVMYWJdOiAoY29sb3IsIG9wdGlvbnMpID0+IHtcbiAgICAgICAgY29uc3QgeyBkZWNpbWFscywgbGFiVW5pdCB9ID0gb3B0aW9ucztcbiAgICAgICAgY29uc3QgdHJhbnNmb3JtZXIgPSAodmFsdWUsIGluZGV4KSA9PiB7XG4gICAgICAgICAgICBpZiAoaW5kZXggPT09IDApIHtcbiAgICAgICAgICAgICAgICBjb25zdCBMID0gcm91bmQocGVyY2VudCh2YWx1ZSksIGRlY2ltYWxzKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gbGFiVW5pdCA9PT0gQ29sb3JVbml0RW51bS5QRVJDRU5UXG4gICAgICAgICAgICAgICAgICAgID8gYCR7TH0lYFxuICAgICAgICAgICAgICAgICAgICA6IGAke0x9YDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpbmRleCA8IDMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbGFiVW5pdCA9PT0gQ29sb3JVbml0RW51bS5QRVJDRU5UXG4gICAgICAgICAgICAgICAgICAgID8gYCR7ZnJvbTEyNU51bWJlclRvUGVyY2VudCh2YWx1ZSwgZGVjaW1hbHMpfSVgXG4gICAgICAgICAgICAgICAgICAgIDogcm91bmQodmFsdWUsIGRlY2ltYWxzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBnZXRBbHBoYSh2YWx1ZSwgb3B0aW9ucywgdHJ1ZSk7XG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IHZhbHVlcyA9IHByZXBhcmVDb2xvckZvckNzcyhjb2xvciwgdHJhbnNmb3JtZXIpO1xuICAgICAgICBjb25zdCB0ZW1wbGF0ZSA9IHZhbHVlcy5sZW5ndGggPT09IDRcbiAgICAgICAgICAgID8gYGxhYih7MX0gezJ9IHszfSAvIHs0fSlgXG4gICAgICAgICAgICA6IGBsYWIoezF9IHsyfSB7M30pYDtcbiAgICAgICAgcmV0dXJuIGdldFJlc3VsdEZyb21UZW1wbGF0ZSh0ZW1wbGF0ZSwgdmFsdWVzKTtcbiAgICB9LFxuICAgIFtDb2xvck1vZGVsLkxDSF06IChjb2xvciwgb3B0aW9ucykgPT4ge1xuICAgICAgICBjb25zdCB7IGRlY2ltYWxzLCBsY2hVbml0LCBhbmdsZXNVbml0IH0gPSBvcHRpb25zO1xuICAgICAgICBjb25zdCB0cmFuc2Zvcm1lciA9ICh2YWx1ZSwgaW5kZXgpID0+IHtcbiAgICAgICAgICAgIGlmIChpbmRleCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IEwgPSByb3VuZChwZXJjZW50KHZhbHVlKSwgZGVjaW1hbHMpO1xuICAgICAgICAgICAgICAgIHJldHVybiBsY2hVbml0ID09PSBDb2xvclVuaXRFbnVtLlBFUkNFTlRcbiAgICAgICAgICAgICAgICAgICAgPyBgJHtMfSVgXG4gICAgICAgICAgICAgICAgICAgIDogYCR7TH1gO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGluZGV4ID09PSAxKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGxjaFVuaXQgPT09IENvbG9yVW5pdEVudW0uUEVSQ0VOVFxuICAgICAgICAgICAgICAgICAgICA/IGAke2Zyb20xNTBOdW1iZXJUb1BlcmNlbnQodmFsdWUsIGRlY2ltYWxzKX0lYFxuICAgICAgICAgICAgICAgICAgICA6IHJvdW5kKHZhbHVlLCBkZWNpbWFscyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaW5kZXggPT09IDIpIHtcbiAgICAgICAgICAgICAgICBpZiAoYW5nbGVzVW5pdCAhPT0gQW5nbGVzVW5pdEVudW0uTk9ORSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB0cmFuc2xhdGVkID0gcm91bmQodHJhbnNsYXRlRGVncmVlcyh2YWx1ZSwgYW5nbGVzVW5pdCksIGRlY2ltYWxzKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGAke3RyYW5zbGF0ZWR9JHthbmdsZXNVbml0fWA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiByb3VuZCh2YWx1ZSwgZGVjaW1hbHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGdldEFscGhhKHZhbHVlLCBvcHRpb25zLCB0cnVlKTtcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgdmFsdWVzID0gcHJlcGFyZUNvbG9yRm9yQ3NzKGNvbG9yLCB0cmFuc2Zvcm1lcik7XG4gICAgICAgIGNvbnN0IHRlbXBsYXRlID0gdmFsdWVzLmxlbmd0aCA9PT0gNFxuICAgICAgICAgICAgPyBgbGNoKHsxfSB7Mn0gezN9IC8gezR9KWBcbiAgICAgICAgICAgIDogYGxjaCh7MX0gezJ9IHszfSlgO1xuICAgICAgICByZXR1cm4gZ2V0UmVzdWx0RnJvbVRlbXBsYXRlKHRlbXBsYXRlLCB2YWx1ZXMpO1xuICAgIH0sXG4gICAgW0NvbG9yTW9kZWwuQ01ZS106IChjb2xvciwgb3B0aW9ucykgPT4ge1xuICAgICAgICBjb25zdCB7IGRlY2ltYWxzLCBsZWdhY3lDU1MsIHNwYWNlc0FmdGVyQ29tbWFzLCBjbXlrVW5pdCwgY215a0Z1bmN0aW9uIH0gPSBvcHRpb25zO1xuICAgICAgICBjb25zdCBjb21tYSA9IGdldENvbW1hKHNwYWNlc0FmdGVyQ29tbWFzKTtcbiAgICAgICAgY29uc3QgdHJhbnNmb3JtZXIgPSAodmFsdWUsIGluZGV4KSA9PiB7XG4gICAgICAgICAgICBpZiAoY215a1VuaXQgPT09IENvbG9yVW5pdEVudW0uUEVSQ0VOVCAmJlxuICAgICAgICAgICAgICAgIGluZGV4IDwgNCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBgJHtyb3VuZCh2YWx1ZSwgZGVjaW1hbHMpfSVgO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGluZGV4ID09PSA0XG4gICAgICAgICAgICAgICAgPyBnZXRBbHBoYSh2YWx1ZSwgb3B0aW9ucylcbiAgICAgICAgICAgICAgICA6IHJvdW5kKHZhbHVlIC8gMTAwLCBkZWNpbWFscyk7XG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IHZhbHVlcyA9IHByZXBhcmVDb2xvckZvckNzcyhjb2xvciwgdHJhbnNmb3JtZXIpO1xuICAgICAgICBjb25zdCB0ZW1wbGF0ZSA9IGxlZ2FjeUNTU1xuICAgICAgICAgICAgPyAodmFsdWVzLmxlbmd0aCA9PT0gNVxuICAgICAgICAgICAgICAgID8gYCR7Y215a0Z1bmN0aW9ufSh7MX0ke2NvbW1hfXsyfSR7Y29tbWF9ezN9JHtjb21tYX17NH0ke2NvbW1hfXs1fSlgXG4gICAgICAgICAgICAgICAgOiBgJHtjbXlrRnVuY3Rpb259KHsxfSR7Y29tbWF9ezJ9JHtjb21tYX17M30ke2NvbW1hfXs0fSlgKVxuICAgICAgICAgICAgOiAodmFsdWVzLmxlbmd0aCA9PT0gNVxuICAgICAgICAgICAgICAgID8gYCR7Y215a0Z1bmN0aW9ufSh7MX0gezJ9IHszfSB7NH0gLyB7NX0pYFxuICAgICAgICAgICAgICAgIDogYCR7Y215a0Z1bmN0aW9ufSh7MX0gezJ9IHszfSB7NH0pYCk7XG4gICAgICAgIHJldHVybiBnZXRSZXN1bHRGcm9tVGVtcGxhdGUodGVtcGxhdGUsIHZhbHVlcyk7XG4gICAgfVxufTtcbiIsImltcG9ydCB7IEJBU0VfMjU1LCBDb2xvck1vZGVsLCBNaXggfSBmcm9tICcjY29uc3RhbnRzJztcbmltcG9ydCB7IGdldEhFWCwgaGFzUHJvcCwgbWlubWF4LCBub3JtYWxpemVBbHBoYSwgbm9ybWFsaXplSHVlLCByb3VuZCB9IGZyb20gJyNoZWxwZXJzJztcbmltcG9ydCB7IGhzbFRvUmdiLCBodWVSeWIsIHJnYlRvQ215aywgcmdiVG9Ic2wsIHJnYlRvSHdiLCByZ2JUb0xhYiwgcmdiVG9MY2gsIHJnYlRvUnliLCByeWJUb1JnYiB9IGZyb20gJyNjb2xvci90cmFuc2xhdG9ycyc7XG5pbXBvcnQgeyBnZXRDb2xvck1vZGVsLCBnZXRSR0JPYmplY3QgfSBmcm9tICcuL2V4dHJhY3RvcnMnO1xuaW1wb3J0IHsgcm91bmRDSUVMYWJPYmplY3QsIHJvdW5kQ01ZS09iamVjdCwgcm91bmRIU0xPYmplY3QsIHJvdW5kSFdCT2JqZWN0LCByb3VuZExDSE9iamVjdCB9IGZyb20gJy4vcm91bmRlcnMnO1xuaW1wb3J0IHsgQ1NTIH0gZnJvbSAnI2NvbG9yL2Nzcyc7XG5jb25zdCBoYXJtb255ID0gKGNvbG9yLCBhbmdsZXMsIG1vZGUpID0+IGFuZ2xlcy5yZWR1Y2UoKGFyciwgbnVtKSA9PiAoW1xuICAgIC4uLmFycixcbiAgICB7XG4gICAgICAgIC4uLmNvbG9yLFxuICAgICAgICBIOiBtb2RlID09PSBNaXguQURESVRJVkVcbiAgICAgICAgICAgID8gbm9ybWFsaXplSHVlKGNvbG9yLkggKyBudW0pXG4gICAgICAgICAgICA6IG5vcm1hbGl6ZUh1ZShodWVSeWIoaHVlUnliKGNvbG9yLkgsIGZhbHNlKSArIG51bSwgdHJ1ZSkpXG4gICAgfVxuXSksIFt7IC4uLmNvbG9yIH1dKTtcbmV4cG9ydCBjb25zdCBhbmFsb2dvdXMgPSAoY29sb3IsIG1vZGUpID0+IGhhcm1vbnkoY29sb3IsIFszMCwgLTMwXSwgbW9kZSk7XG5leHBvcnQgY29uc3QgY29tcGxlbWVudGFyeSA9IChjb2xvciwgbW9kZSkgPT4gaGFybW9ueShjb2xvciwgWzE4MF0sIG1vZGUpO1xuZXhwb3J0IGNvbnN0IHNwbGl0Q29tcGxlbWVudGFyeSA9IChjb2xvciwgbW9kZSkgPT4gaGFybW9ueShjb2xvciwgWzE1MCwgLTE1MF0sIG1vZGUpO1xuZXhwb3J0IGNvbnN0IHRyaWFkaWMgPSAoY29sb3IsIG1vZGUpID0+IGhhcm1vbnkoY29sb3IsIFsxMjAsIC0xMjBdLCBtb2RlKTtcbmV4cG9ydCBjb25zdCB0ZXRyYWRpYyA9IChjb2xvciwgbW9kZSkgPT4gaGFybW9ueShjb2xvciwgWzYwLCAtMTIwLCAxODBdLCBtb2RlKTtcbmV4cG9ydCBjb25zdCBzcXVhcmUgPSAoY29sb3IsIG1vZGUpID0+IGhhcm1vbnkoY29sb3IsIFs5MCwgLTkwLCAxODBdLCBtb2RlKTtcbmV4cG9ydCBjb25zdCB0cmFuc2xhdGVDb2xvciA9IHtcbiAgICBbQ29sb3JNb2RlbC5IRVhdKGNvbG9yKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBSOiBnZXRIRVgoY29sb3IuUiksXG4gICAgICAgICAgICBHOiBnZXRIRVgoY29sb3IuRyksXG4gICAgICAgICAgICBCOiBnZXRIRVgoY29sb3IuQilcbiAgICAgICAgfTtcbiAgICB9LFxuICAgIEhFWEEoY29sb3IpIHtcbiAgICAgICAgY29uc3QgUkdCID0gdHJhbnNsYXRlQ29sb3IuSEVYKGNvbG9yKTtcbiAgICAgICAgUkdCLkEgPSBoYXNQcm9wKGNvbG9yLCAnQScpXG4gICAgICAgICAgICA/IGdldEhFWChjb2xvci5BICogQkFTRV8yNTUpXG4gICAgICAgICAgICA6ICcweEZGJztcbiAgICAgICAgcmV0dXJuIFJHQjtcbiAgICB9LFxuICAgIFtDb2xvck1vZGVsLlJHQl0oY29sb3IsIGRlY2ltYWxzKSB7XG4gICAgICAgIGNvbnN0IFJHQiA9IHJvdW5kUkdCT2JqZWN0KGNvbG9yLCBkZWNpbWFscyk7XG4gICAgICAgIGlmIChoYXNQcm9wKFJHQiwgJ0EnKSkge1xuICAgICAgICAgICAgZGVsZXRlIFJHQi5BO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBSR0I7XG4gICAgfSxcbiAgICBSR0JBKGNvbG9yLCBkZWNpbWFscykge1xuICAgICAgICBjb25zdCBSR0IgPSB0cmFuc2xhdGVDb2xvci5SR0IoY29sb3IsIGRlY2ltYWxzKTtcbiAgICAgICAgUkdCLkEgPSBoYXNQcm9wKGNvbG9yLCAnQScpXG4gICAgICAgICAgICA/IHJvdW5kKGNvbG9yLkEpXG4gICAgICAgICAgICA6IDE7XG4gICAgICAgIHJldHVybiBSR0I7XG4gICAgfSxcbiAgICBbQ29sb3JNb2RlbC5IU0xdKGNvbG9yLCBkZWNpbWFscykge1xuICAgICAgICBjb25zdCBIU0wgPSByZ2JUb0hzbChjb2xvci5SLCBjb2xvci5HLCBjb2xvci5CKTtcbiAgICAgICAgZGVsZXRlIEhTTC5BO1xuICAgICAgICByZXR1cm4gcm91bmRIU0xPYmplY3QoSFNMLCBkZWNpbWFscyk7XG4gICAgfSxcbiAgICBIU0xBKGNvbG9yLCBkZWNpbWFscykge1xuICAgICAgICBjb25zdCBIU0wgPSB0cmFuc2xhdGVDb2xvci5IU0woY29sb3IsIGRlY2ltYWxzKTtcbiAgICAgICAgSFNMLkEgPSBoYXNQcm9wKGNvbG9yLCAnQScpXG4gICAgICAgICAgICA/IHJvdW5kKGNvbG9yLkEsIGRlY2ltYWxzKVxuICAgICAgICAgICAgOiAxO1xuICAgICAgICByZXR1cm4gSFNMO1xuICAgIH0sXG4gICAgW0NvbG9yTW9kZWwuSFdCXShjb2xvciwgZGVjaW1hbHMpIHtcbiAgICAgICAgY29uc3QgSFdCID0gcmdiVG9Id2IoY29sb3IuUiwgY29sb3IuRywgY29sb3IuQik7XG4gICAgICAgIGRlbGV0ZSBIV0IuQTtcbiAgICAgICAgcmV0dXJuIHJvdW5kSFdCT2JqZWN0KEhXQiwgZGVjaW1hbHMpO1xuICAgIH0sXG4gICAgSFdCQShjb2xvciwgZGVjaW1hbHMpIHtcbiAgICAgICAgY29uc3QgSFdCID0gdHJhbnNsYXRlQ29sb3IuSFdCKGNvbG9yLCBkZWNpbWFscyk7XG4gICAgICAgIEhXQi5BID0gaGFzUHJvcChjb2xvciwgJ0EnKVxuICAgICAgICAgICAgPyByb3VuZChjb2xvci5BLCBkZWNpbWFscylcbiAgICAgICAgICAgIDogMTtcbiAgICAgICAgcmV0dXJuIEhXQjtcbiAgICB9LFxuICAgIFtDb2xvck1vZGVsLkNJRUxhYl0oY29sb3IsIGRlY2ltYWxzKSB7XG4gICAgICAgIGNvbnN0IExhYiA9IHJnYlRvTGFiKGNvbG9yLlIsIGNvbG9yLkcsIGNvbG9yLkIpO1xuICAgICAgICByZXR1cm4gcm91bmRDSUVMYWJPYmplY3QoTGFiLCBkZWNpbWFscyk7XG4gICAgfSxcbiAgICBDSUVMYWJBKGNvbG9yLCBkZWNpbWFscykge1xuICAgICAgICBjb25zdCBMYWIgPSB0cmFuc2xhdGVDb2xvci5DSUVMYWIoY29sb3IsIGRlY2ltYWxzKTtcbiAgICAgICAgTGFiLkEgPSBoYXNQcm9wKGNvbG9yLCAnQScpXG4gICAgICAgICAgICA/IHJvdW5kKGNvbG9yLkEsIGRlY2ltYWxzKVxuICAgICAgICAgICAgOiAxO1xuICAgICAgICByZXR1cm4gTGFiO1xuICAgIH0sXG4gICAgW0NvbG9yTW9kZWwuTENIXShjb2xvciwgZGVjaW1hbHMpIHtcbiAgICAgICAgY29uc3QgbGNoID0gcmdiVG9MY2goY29sb3IuUiwgY29sb3IuRywgY29sb3IuQik7XG4gICAgICAgIHJldHVybiByb3VuZExDSE9iamVjdChsY2gsIGRlY2ltYWxzKTtcbiAgICB9LFxuICAgIExDSEEoY29sb3IsIGRlY2ltYWxzKSB7XG4gICAgICAgIGNvbnN0IGxjaCA9IHRyYW5zbGF0ZUNvbG9yLkxDSChjb2xvciwgZGVjaW1hbHMpO1xuICAgICAgICBsY2guQSA9IGhhc1Byb3AoY29sb3IsICdBJylcbiAgICAgICAgICAgID8gcm91bmQoY29sb3IuQSwgZGVjaW1hbHMpXG4gICAgICAgICAgICA6IDE7XG4gICAgICAgIHJldHVybiBsY2g7XG4gICAgfSxcbiAgICBbQ29sb3JNb2RlbC5DTVlLXShjb2xvciwgZGVjaW1hbHMpIHtcbiAgICAgICAgcmV0dXJuIHJvdW5kQ01ZS09iamVjdChyZ2JUb0NteWsoY29sb3IuUiwgY29sb3IuRywgY29sb3IuQiksIGRlY2ltYWxzKTtcbiAgICB9LFxuICAgIENNWUtBKGNvbG9yLCBkZWNpbWFscykge1xuICAgICAgICBjb25zdCBDTVlLID0gdHJhbnNsYXRlQ29sb3IuQ01ZSyhjb2xvciwgZGVjaW1hbHMpO1xuICAgICAgICBDTVlLLkEgPSBoYXNQcm9wKGNvbG9yLCAnQScpXG4gICAgICAgICAgICA/IHJvdW5kKGNvbG9yLkEsIGRlY2ltYWxzKVxuICAgICAgICAgICAgOiAxO1xuICAgICAgICByZXR1cm4gQ01ZSztcbiAgICB9XG59O1xuZXhwb3J0IGNvbnN0IGJsZW5kID0gKGZyb20sIHRvLCBzdGVwcykgPT4ge1xuICAgIGNvbnN0IGRpdiA9IHN0ZXBzIC0gMTtcbiAgICBjb25zdCBkaWZmUiA9ICh0by5SIC0gZnJvbS5SKSAvIGRpdjtcbiAgICBjb25zdCBkaWZmRyA9ICh0by5HIC0gZnJvbS5HKSAvIGRpdjtcbiAgICBjb25zdCBkaWZmQiA9ICh0by5CIC0gZnJvbS5CKSAvIGRpdjtcbiAgICBjb25zdCBmcm9tQSA9IG5vcm1hbGl6ZUFscGhhKGZyb20uQSk7XG4gICAgY29uc3QgdG9BID0gbm9ybWFsaXplQWxwaGEodG8uQSk7XG4gICAgY29uc3QgZGlmZkEgPSAodG9BIC0gZnJvbUEpIC8gZGl2O1xuICAgIHJldHVybiBBcnJheShzdGVwcykuZmlsbChudWxsKS5tYXAoKF9fbiwgaSkgPT4ge1xuICAgICAgICBpZiAoaSA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIGZyb207XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGkgPT09IGRpdikge1xuICAgICAgICAgICAgcmV0dXJuIHRvO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBSOiByb3VuZChmcm9tLlIgKyBkaWZmUiAqIGkpLFxuICAgICAgICAgICAgRzogcm91bmQoZnJvbS5HICsgZGlmZkcgKiBpKSxcbiAgICAgICAgICAgIEI6IHJvdW5kKGZyb20uQiArIGRpZmZCICogaSksXG4gICAgICAgICAgICBBOiByb3VuZChmcm9tQSArIGRpZmZBICogaSlcbiAgICAgICAgfTtcbiAgICB9KTtcbn07XG5leHBvcnQgY29uc3QgZ2V0Q29sb3JNaXh0dXJlID0gKGNvbG9yLCBzdGVwcywgc2hhZGVzLCBvcHRpb25zKSA9PiB7XG4gICAgY29uc3QgbW9kZWwgPSBnZXRDb2xvck1vZGVsKGNvbG9yKTtcbiAgICBjb25zdCBpc0NTUyA9IHR5cGVvZiBjb2xvciA9PT0gJ3N0cmluZyc7XG4gICAgY29uc3QgUkdCID0gZ2V0UkdCT2JqZWN0KGNvbG9yLCBtb2RlbCk7XG4gICAgY29uc3QgaGFzQWxwaGEgPSAoKHR5cGVvZiBjb2xvciA9PT0gJ3N0cmluZycgJiYgaGFzUHJvcChSR0IsICdBJykpIHx8XG4gICAgICAgICh0eXBlb2YgY29sb3IgIT09ICdzdHJpbmcnICYmXG4gICAgICAgICAgICBoYXNQcm9wKGNvbG9yLCAnQScpKSk7XG4gICAgY29uc3QgSFNMID0gcmdiVG9Ic2woUkdCLlIsIFJHQi5HLCBSR0IuQiwgUkdCLkEpO1xuICAgIGlmICghaGFzQWxwaGEpXG4gICAgICAgIGRlbGV0ZSBIU0wuQTtcbiAgICBjb25zdCBpbmNyZW1lbnQgPSBzaGFkZXNcbiAgICAgICAgPyBIU0wuTCAvIChzdGVwcyArIDEpXG4gICAgICAgIDogKDEwMCAtIEhTTC5MKSAvIChzdGVwcyArIDEpO1xuICAgIGNvbnN0IGhzbE1hcCA9IEFycmF5KHN0ZXBzKS5maWxsKG51bGwpLm1hcCgoX19uLCBpKSA9PiAoe1xuICAgICAgICAuLi5IU0wsXG4gICAgICAgIEw6IEhTTC5MICsgaW5jcmVtZW50ICogKGkgKyAxKSAqICgxIC0gK3NoYWRlcyAqIDIpXG4gICAgfSkpO1xuICAgIHN3aXRjaCAobW9kZWwpIHtcbiAgICAgICAgY2FzZSBDb2xvck1vZGVsLkhFWDpcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiBoc2xNYXAubWFwKChIU0xDb2xvcikgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IFJHQkNvbG9yID0gaHNsVG9SZ2IoSFNMQ29sb3IuSCwgSFNMQ29sb3IuUywgSFNMQ29sb3IuTCk7XG4gICAgICAgICAgICAgICAgaWYgKGhhc0FscGhhKVxuICAgICAgICAgICAgICAgICAgICBSR0JDb2xvci5BID0gSFNMQ29sb3IuQTtcbiAgICAgICAgICAgICAgICByZXR1cm4gaXNDU1NcbiAgICAgICAgICAgICAgICAgICAgPyBoYXNBbHBoYVxuICAgICAgICAgICAgICAgICAgICAgICAgPyBDU1MuSEVYKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAuLi5SR0JDb2xvcixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBBOiByb3VuZChSR0JDb2xvci5BICogQkFTRV8yNTUpXG4gICAgICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICAgICAgOiBDU1MuSEVYKFJHQkNvbG9yKVxuICAgICAgICAgICAgICAgICAgICA6IGhhc0FscGhhXG4gICAgICAgICAgICAgICAgICAgICAgICA/IHRyYW5zbGF0ZUNvbG9yLkhFWEEoUkdCQ29sb3IpXG4gICAgICAgICAgICAgICAgICAgICAgICA6IHRyYW5zbGF0ZUNvbG9yLkhFWChSR0JDb2xvcik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgY2FzZSBDb2xvck1vZGVsLlJHQjpcbiAgICAgICAgICAgIHJldHVybiBoc2xNYXAubWFwKChIU0xDb2xvcikgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IFJHQkNvbG9yID0gaHNsVG9SZ2IoSFNMQ29sb3IuSCwgSFNMQ29sb3IuUywgSFNMQ29sb3IuTCk7XG4gICAgICAgICAgICAgICAgaWYgKGhhc0FscGhhKVxuICAgICAgICAgICAgICAgICAgICBSR0JDb2xvci5BID0gSFNMQ29sb3IuQTtcbiAgICAgICAgICAgICAgICByZXR1cm4gaXNDU1NcbiAgICAgICAgICAgICAgICAgICAgPyBDU1MuUkdCKFJHQkNvbG9yLCBvcHRpb25zKVxuICAgICAgICAgICAgICAgICAgICA6IGhhc0FscGhhXG4gICAgICAgICAgICAgICAgICAgICAgICA/IHRyYW5zbGF0ZUNvbG9yLlJHQkEoUkdCQ29sb3IsIG9wdGlvbnMuZGVjaW1hbHMpXG4gICAgICAgICAgICAgICAgICAgICAgICA6IHRyYW5zbGF0ZUNvbG9yLlJHQihSR0JDb2xvciwgb3B0aW9ucy5kZWNpbWFscyk7XG4gICAgICAgICAgICAgICAgO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIGNhc2UgQ29sb3JNb2RlbC5IU0w6XG4gICAgICAgICAgICByZXR1cm4gaHNsTWFwLm1hcCgoSFNMQ29sb3IpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaXNDU1NcbiAgICAgICAgICAgICAgICAgICAgPyBDU1MuSFNMKEhTTENvbG9yLCBvcHRpb25zKVxuICAgICAgICAgICAgICAgICAgICA6IGhhc0FscGhhXG4gICAgICAgICAgICAgICAgICAgICAgICA/IHRyYW5zbGF0ZUNvbG9yLkhTTEEoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC4uLmhzbFRvUmdiKEhTTENvbG9yLkgsIEhTTENvbG9yLlMsIEhTTENvbG9yLkwpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIEE6IEhTTENvbG9yLkFcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sIG9wdGlvbnMuZGVjaW1hbHMpXG4gICAgICAgICAgICAgICAgICAgICAgICA6IHRyYW5zbGF0ZUNvbG9yLkhTTChoc2xUb1JnYihIU0xDb2xvci5ILCBIU0xDb2xvci5TLCBIU0xDb2xvci5MKSwgb3B0aW9ucy5kZWNpbWFscyk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgY2FzZSBDb2xvck1vZGVsLkhXQjpcbiAgICAgICAgICAgIHJldHVybiBoc2xNYXAubWFwKChIU0xDb2xvcikgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IFJHQkNvbG9yID0gaHNsVG9SZ2IoSFNMQ29sb3IuSCwgSFNMQ29sb3IuUywgSFNMQ29sb3IuTCk7XG4gICAgICAgICAgICAgICAgaWYgKGhhc0FscGhhKVxuICAgICAgICAgICAgICAgICAgICBSR0JDb2xvci5BID0gSFNMQ29sb3IuQTtcbiAgICAgICAgICAgICAgICBjb25zdCBod2IgPSBoYXNBbHBoYVxuICAgICAgICAgICAgICAgICAgICA/IHRyYW5zbGF0ZUNvbG9yLkhXQkEoUkdCQ29sb3IsIG9wdGlvbnMuZGVjaW1hbHMpXG4gICAgICAgICAgICAgICAgICAgIDogdHJhbnNsYXRlQ29sb3IuSFdCKFJHQkNvbG9yLCBvcHRpb25zLmRlY2ltYWxzKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gaXNDU1NcbiAgICAgICAgICAgICAgICAgICAgPyBDU1MuSFdCKGh3Yiwgb3B0aW9ucylcbiAgICAgICAgICAgICAgICAgICAgOiBod2I7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgY2FzZSBDb2xvck1vZGVsLkNJRUxhYjpcbiAgICAgICAgICAgIHJldHVybiBoc2xNYXAubWFwKChIU0xDb2xvcikgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IFJHQkNvbG9yID0gaHNsVG9SZ2IoSFNMQ29sb3IuSCwgSFNMQ29sb3IuUywgSFNMQ29sb3IuTCk7XG4gICAgICAgICAgICAgICAgaWYgKGhhc0FscGhhKVxuICAgICAgICAgICAgICAgICAgICBSR0JDb2xvci5BID0gSFNMQ29sb3IuQTtcbiAgICAgICAgICAgICAgICBjb25zdCBsYWIgPSBoYXNBbHBoYVxuICAgICAgICAgICAgICAgICAgICA/IHRyYW5zbGF0ZUNvbG9yLkNJRUxhYkEoUkdCQ29sb3IsIG9wdGlvbnMuZGVjaW1hbHMpXG4gICAgICAgICAgICAgICAgICAgIDogdHJhbnNsYXRlQ29sb3IuQ0lFTGFiKFJHQkNvbG9yLCBvcHRpb25zLmRlY2ltYWxzKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gaXNDU1NcbiAgICAgICAgICAgICAgICAgICAgPyBDU1MuQ0lFTGFiKGxhYiwgb3B0aW9ucylcbiAgICAgICAgICAgICAgICAgICAgOiBsYWI7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgY2FzZSBDb2xvck1vZGVsLkxDSDpcbiAgICAgICAgICAgIHJldHVybiBoc2xNYXAubWFwKChIU0xDb2xvcikgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IFJHQkNvbG9yID0gaHNsVG9SZ2IoSFNMQ29sb3IuSCwgSFNMQ29sb3IuUywgSFNMQ29sb3IuTCk7XG4gICAgICAgICAgICAgICAgY29uc3QgTENIQ29sb3IgPSByZ2JUb0xjaChSR0JDb2xvci5SLCBSR0JDb2xvci5HLCBSR0JDb2xvci5CKTtcbiAgICAgICAgICAgICAgICBpZiAoaGFzQWxwaGEpXG4gICAgICAgICAgICAgICAgICAgIExDSENvbG9yLkEgPSBIU0xDb2xvci5BO1xuICAgICAgICAgICAgICAgIHJldHVybiBpc0NTU1xuICAgICAgICAgICAgICAgICAgICA/IENTUy5MQ0goTENIQ29sb3IsIG9wdGlvbnMpXG4gICAgICAgICAgICAgICAgICAgIDogaGFzQWxwaGFcbiAgICAgICAgICAgICAgICAgICAgICAgID8gdHJhbnNsYXRlQ29sb3IuTENIQSh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLi4uUkdCQ29sb3IsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgQTogSFNMQ29sb3IuQVxuICAgICAgICAgICAgICAgICAgICAgICAgfSwgb3B0aW9ucy5kZWNpbWFscylcbiAgICAgICAgICAgICAgICAgICAgICAgIDogdHJhbnNsYXRlQ29sb3IuTENIKFJHQkNvbG9yLCBvcHRpb25zLmRlY2ltYWxzKTtcbiAgICAgICAgICAgIH0pO1xuICAgIH1cbn07XG5leHBvcnQgY29uc3QgY29sb3JIYXJtb255ID0ge1xuICAgIGJ1aWxkSGFybW9ueShjb2xvciwgaGFybW9ueUZ1bmN0aW9uLCBtb2RlLCBvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IG1vZGVsID0gZ2V0Q29sb3JNb2RlbChjb2xvcik7XG4gICAgICAgIGNvbnN0IFJHQiA9IGdldFJHQk9iamVjdChjb2xvciwgbW9kZWwpO1xuICAgICAgICBjb25zdCBIU0wgPSByZ2JUb0hzbChSR0IuUiwgUkdCLkcsIFJHQi5CLCBSR0IuQSk7XG4gICAgICAgIGNvbnN0IGhhc0FscGhhID0gKCh0eXBlb2YgY29sb3IgPT09ICdzdHJpbmcnICYmIGhhc1Byb3AoUkdCLCAnQScpKSB8fFxuICAgICAgICAgICAgKHR5cGVvZiBjb2xvciAhPT0gJ3N0cmluZycgJiZcbiAgICAgICAgICAgICAgICBoYXNQcm9wKGNvbG9yLCAnQScpKSk7XG4gICAgICAgIGNvbnN0IGlzQ1NTID0gdHlwZW9mIGNvbG9yID09PSAnc3RyaW5nJztcbiAgICAgICAgc3dpdGNoIChtb2RlbCkge1xuICAgICAgICAgICAgY2FzZSBDb2xvck1vZGVsLkhFWDpcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgcmV0dXJuIGhhc0FscGhhXG4gICAgICAgICAgICAgICAgICAgID8gdGhpcy5IRVhBKHJvdW5kSFNMT2JqZWN0KEhTTCwgMCksIGhhcm1vbnlGdW5jdGlvbiwgbW9kZSwgaXNDU1MpXG4gICAgICAgICAgICAgICAgICAgIDogdGhpcy5IRVgocm91bmRIU0xPYmplY3QoSFNMLCAwKSwgaGFybW9ueUZ1bmN0aW9uLCBtb2RlLCBpc0NTUyk7XG4gICAgICAgICAgICBjYXNlIENvbG9yTW9kZWwuSFNMOlxuICAgICAgICAgICAgICAgIHJldHVybiBoYXNBbHBoYVxuICAgICAgICAgICAgICAgICAgICA/IHRoaXMuSFNMQShIU0wsIGhhcm1vbnlGdW5jdGlvbiwgbW9kZSwgaXNDU1MsIG9wdGlvbnMpXG4gICAgICAgICAgICAgICAgICAgIDogdGhpcy5IU0woSFNMLCBoYXJtb255RnVuY3Rpb24sIG1vZGUsIGlzQ1NTLCBvcHRpb25zKTtcbiAgICAgICAgICAgIGNhc2UgQ29sb3JNb2RlbC5IV0I6XG4gICAgICAgICAgICAgICAgcmV0dXJuIGhhc0FscGhhXG4gICAgICAgICAgICAgICAgICAgID8gdGhpcy5IV0JBKEhTTCwgaGFybW9ueUZ1bmN0aW9uLCBtb2RlLCBpc0NTUywgb3B0aW9ucylcbiAgICAgICAgICAgICAgICAgICAgOiB0aGlzLkhXQihIU0wsIGhhcm1vbnlGdW5jdGlvbiwgbW9kZSwgaXNDU1MsIG9wdGlvbnMpO1xuICAgICAgICAgICAgY2FzZSBDb2xvck1vZGVsLlJHQjpcbiAgICAgICAgICAgICAgICByZXR1cm4gaGFzQWxwaGFcbiAgICAgICAgICAgICAgICAgICAgPyB0aGlzLlJHQkEoSFNMLCBoYXJtb255RnVuY3Rpb24sIG1vZGUsIGlzQ1NTLCBvcHRpb25zKVxuICAgICAgICAgICAgICAgICAgICA6IHRoaXMuUkdCKEhTTCwgaGFybW9ueUZ1bmN0aW9uLCBtb2RlLCBpc0NTUywgb3B0aW9ucyk7XG4gICAgICAgICAgICBjYXNlIENvbG9yTW9kZWwuQ0lFTGFiOlxuICAgICAgICAgICAgICAgIHJldHVybiBoYXNBbHBoYVxuICAgICAgICAgICAgICAgICAgICA/IHRoaXMuQ0lFTGFiQShIU0wsIGhhcm1vbnlGdW5jdGlvbiwgbW9kZSwgaXNDU1MsIG9wdGlvbnMpXG4gICAgICAgICAgICAgICAgICAgIDogdGhpcy5DSUVMYWIoSFNMLCBoYXJtb255RnVuY3Rpb24sIG1vZGUsIGlzQ1NTLCBvcHRpb25zKTtcbiAgICAgICAgICAgIGNhc2UgQ29sb3JNb2RlbC5MQ0g6XG4gICAgICAgICAgICAgICAgcmV0dXJuIGhhc0FscGhhXG4gICAgICAgICAgICAgICAgICAgID8gdGhpcy5MQ0hBKEhTTCwgaGFybW9ueUZ1bmN0aW9uLCBtb2RlLCBpc0NTUywgb3B0aW9ucylcbiAgICAgICAgICAgICAgICAgICAgOiB0aGlzLkxDSChIU0wsIGhhcm1vbnlGdW5jdGlvbiwgbW9kZSwgaXNDU1MsIG9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgfSxcbiAgICBbQ29sb3JNb2RlbC5IRVhdKGNvbG9yLCBoYXJtb255RnVuY3Rpb24sIG1vZGUsIGNzcykge1xuICAgICAgICBjb25zdCBhcnJheSA9IGhhcm1vbnlGdW5jdGlvbihjb2xvciwgbW9kZSk7XG4gICAgICAgIHJldHVybiBhcnJheS5tYXAoKGMpID0+IChjc3NcbiAgICAgICAgICAgID8gQ1NTLkhFWChoc2xUb1JnYihjLkgsIGMuUywgYy5MKSlcbiAgICAgICAgICAgIDogdHJhbnNsYXRlQ29sb3IuSEVYKGhzbFRvUmdiKGMuSCwgYy5TLCBjLkwpKSkpO1xuICAgIH0sXG4gICAgSEVYQShjb2xvciwgaGFybW9ueUZ1bmN0aW9uLCBtb2RlLCBjc3MpIHtcbiAgICAgICAgY29uc3QgYXJyYXkgPSBoYXJtb255RnVuY3Rpb24oY29sb3IsIG1vZGUpO1xuICAgICAgICByZXR1cm4gYXJyYXkubWFwKChjKSA9PiAoY3NzXG4gICAgICAgICAgICA/IENTUy5IRVgoe1xuICAgICAgICAgICAgICAgIC4uLmhzbFRvUmdiKGMuSCwgYy5TLCBjLkwpLFxuICAgICAgICAgICAgICAgIEE6IG5vcm1hbGl6ZUFscGhhKGMuQSkgKiBCQVNFXzI1NVxuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIDogdHJhbnNsYXRlQ29sb3IuSEVYQSh7XG4gICAgICAgICAgICAgICAgLi4uaHNsVG9SZ2IoYy5ILCBjLlMsIGMuTCksXG4gICAgICAgICAgICAgICAgQTogbm9ybWFsaXplQWxwaGEoYy5BKVxuICAgICAgICAgICAgfSkpKTtcbiAgICB9LFxuICAgIFtDb2xvck1vZGVsLlJHQl0oY29sb3IsIGhhcm1vbnlGdW5jdGlvbiwgbW9kZSwgY3NzLCBvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IGFycmF5ID0gaGFybW9ueUZ1bmN0aW9uKGNvbG9yLCBtb2RlKTtcbiAgICAgICAgcmV0dXJuIGFycmF5Lm1hcCgoYykgPT4gKGNzc1xuICAgICAgICAgICAgPyBDU1MuUkdCKGhzbFRvUmdiKGMuSCwgYy5TLCBjLkwpLCBvcHRpb25zKVxuICAgICAgICAgICAgOiB0cmFuc2xhdGVDb2xvci5SR0IoaHNsVG9SZ2IoYy5ILCBjLlMsIGMuTCksIG9wdGlvbnMuZGVjaW1hbHMpKSk7XG4gICAgfSxcbiAgICBSR0JBKGNvbG9yLCBoYXJtb255RnVuY3Rpb24sIG1vZGUsIGNzcywgb3B0aW9ucykge1xuICAgICAgICBjb25zdCBhcnJheSA9IGhhcm1vbnlGdW5jdGlvbihjb2xvciwgbW9kZSk7XG4gICAgICAgIHJldHVybiBhcnJheS5tYXAoKGMpID0+IChjc3NcbiAgICAgICAgICAgID8gQ1NTLlJHQih7XG4gICAgICAgICAgICAgICAgLi4uaHNsVG9SZ2IoYy5ILCBjLlMsIGMuTCksXG4gICAgICAgICAgICAgICAgQTogbm9ybWFsaXplQWxwaGEoYy5BKVxuICAgICAgICAgICAgfSwgb3B0aW9ucylcbiAgICAgICAgICAgIDogdHJhbnNsYXRlQ29sb3IuUkdCQSh7XG4gICAgICAgICAgICAgICAgLi4uaHNsVG9SZ2IoYy5ILCBjLlMsIGMuTCksXG4gICAgICAgICAgICAgICAgQTogbm9ybWFsaXplQWxwaGEoYy5BKVxuICAgICAgICAgICAgfSwgb3B0aW9ucy5kZWNpbWFscykpKTtcbiAgICB9LFxuICAgIFtDb2xvck1vZGVsLkhTTF0oY29sb3IsIGhhcm1vbnlGdW5jdGlvbiwgbW9kZSwgY3NzLCBvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IGFycmF5ID0gaGFybW9ueUZ1bmN0aW9uKGNvbG9yLCBtb2RlKTtcbiAgICAgICAgcmV0dXJuIGFycmF5Lm1hcCgoYykgPT4gKGNzc1xuICAgICAgICAgICAgPyBDU1MuSFNMKHtcbiAgICAgICAgICAgICAgICBIOiBjLkgsXG4gICAgICAgICAgICAgICAgUzogYy5TLFxuICAgICAgICAgICAgICAgIEw6IGMuTFxuICAgICAgICAgICAgfSwgb3B0aW9ucylcbiAgICAgICAgICAgIDogdHJhbnNsYXRlQ29sb3IuSFNMKGhzbFRvUmdiKGMuSCwgYy5TLCBjLkwpLCBvcHRpb25zLmRlY2ltYWxzKSkpO1xuICAgIH0sXG4gICAgSFNMQShjb2xvciwgaGFybW9ueUZ1bmN0aW9uLCBtb2RlLCBjc3MsIG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgYXJyYXkgPSBoYXJtb255RnVuY3Rpb24oY29sb3IsIG1vZGUpO1xuICAgICAgICByZXR1cm4gYXJyYXkubWFwKChjKSA9PiAoY3NzXG4gICAgICAgICAgICA/IENTUy5IU0woe1xuICAgICAgICAgICAgICAgIC4uLmMsXG4gICAgICAgICAgICAgICAgQTogbm9ybWFsaXplQWxwaGEoYy5BKVxuICAgICAgICAgICAgfSwgb3B0aW9ucylcbiAgICAgICAgICAgIDogdHJhbnNsYXRlQ29sb3IuSFNMQSh7XG4gICAgICAgICAgICAgICAgLi4uaHNsVG9SZ2IoYy5ILCBjLlMsIGMuTCksXG4gICAgICAgICAgICAgICAgQTogbm9ybWFsaXplQWxwaGEoYy5BKVxuICAgICAgICAgICAgfSwgb3B0aW9ucy5kZWNpbWFscykpKTtcbiAgICB9LFxuICAgIFtDb2xvck1vZGVsLkhXQl0oY29sb3IsIGhhcm1vbnlGdW5jdGlvbiwgbW9kZSwgY3NzLCBvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IGFycmF5ID0gaGFybW9ueUZ1bmN0aW9uKGNvbG9yLCBtb2RlKTtcbiAgICAgICAgcmV0dXJuIGFycmF5Lm1hcCgoYykgPT4ge1xuICAgICAgICAgICAgY29uc3QgcmdiID0gaHNsVG9SZ2IoYy5ILCBjLlMsIGMuTCk7XG4gICAgICAgICAgICBjb25zdCBod2IgPSByZ2JUb0h3YihyZ2IuUiwgcmdiLkcsIHJnYi5CKTtcbiAgICAgICAgICAgIHJldHVybiBjc3NcbiAgICAgICAgICAgICAgICA/IENTUy5IV0Ioe1xuICAgICAgICAgICAgICAgICAgICBIOiBod2IuSCxcbiAgICAgICAgICAgICAgICAgICAgVzogaHdiLlcsXG4gICAgICAgICAgICAgICAgICAgIEI6IGh3Yi5CXG4gICAgICAgICAgICAgICAgfSwgb3B0aW9ucylcbiAgICAgICAgICAgICAgICA6IHRyYW5zbGF0ZUNvbG9yLkhXQihyZ2IsIG9wdGlvbnMuZGVjaW1hbHMpO1xuICAgICAgICB9KTtcbiAgICB9LFxuICAgIEhXQkEoY29sb3IsIGhhcm1vbnlGdW5jdGlvbiwgbW9kZSwgY3NzLCBvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IGFycmF5ID0gaGFybW9ueUZ1bmN0aW9uKGNvbG9yLCBtb2RlKTtcbiAgICAgICAgcmV0dXJuIGFycmF5Lm1hcCgoYykgPT4ge1xuICAgICAgICAgICAgY29uc3QgcmdiID0gaHNsVG9SZ2IoYy5ILCBjLlMsIGMuTCk7XG4gICAgICAgICAgICBjb25zdCBod2IgPSByZ2JUb0h3YihyZ2IuUiwgcmdiLkcsIHJnYi5CKTtcbiAgICAgICAgICAgIHJldHVybiBjc3NcbiAgICAgICAgICAgICAgICA/IENTUy5IV0Ioe1xuICAgICAgICAgICAgICAgICAgICAuLi5od2IsXG4gICAgICAgICAgICAgICAgICAgIEE6IG5vcm1hbGl6ZUFscGhhKGMuQSlcbiAgICAgICAgICAgICAgICB9LCBvcHRpb25zKVxuICAgICAgICAgICAgICAgIDogdHJhbnNsYXRlQ29sb3IuSFdCQSh7XG4gICAgICAgICAgICAgICAgICAgIC4uLnJnYixcbiAgICAgICAgICAgICAgICAgICAgQTogbm9ybWFsaXplQWxwaGEoYy5BKVxuICAgICAgICAgICAgICAgIH0sIG9wdGlvbnMuZGVjaW1hbHMpO1xuICAgICAgICB9KTtcbiAgICB9LFxuICAgIFtDb2xvck1vZGVsLkNJRUxhYl0oY29sb3IsIGhhcm1vbnlGdW5jdGlvbiwgbW9kZSwgY3NzLCBvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IGFycmF5ID0gaGFybW9ueUZ1bmN0aW9uKGNvbG9yLCBtb2RlKTtcbiAgICAgICAgcmV0dXJuIGFycmF5Lm1hcCgoYykgPT4ge1xuICAgICAgICAgICAgY29uc3QgUkdCID0gaHNsVG9SZ2IoYy5ILCBjLlMsIGMuTCk7XG4gICAgICAgICAgICByZXR1cm4gKGNzc1xuICAgICAgICAgICAgICAgID8gQ1NTLkNJRUxhYihyZ2JUb0xhYihSR0IuUiwgUkdCLkcsIFJHQi5CKSwgb3B0aW9ucylcbiAgICAgICAgICAgICAgICA6IHRyYW5zbGF0ZUNvbG9yLkNJRUxhYihSR0IsIG9wdGlvbnMuZGVjaW1hbHMpKTtcbiAgICAgICAgfSk7XG4gICAgfSxcbiAgICBDSUVMYWJBKGNvbG9yLCBoYXJtb255RnVuY3Rpb24sIG1vZGUsIGNzcywgb3B0aW9ucykge1xuICAgICAgICBjb25zdCBhcnJheSA9IGhhcm1vbnlGdW5jdGlvbihjb2xvciwgbW9kZSk7XG4gICAgICAgIHJldHVybiBhcnJheS5tYXAoKGMpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IFJHQiA9IGhzbFRvUmdiKGMuSCwgYy5TLCBjLkwpO1xuICAgICAgICAgICAgcmV0dXJuIChjc3NcbiAgICAgICAgICAgICAgICA/IENTUy5DSUVMYWIoe1xuICAgICAgICAgICAgICAgICAgICAuLi5yZ2JUb0xhYihSR0IuUiwgUkdCLkcsIFJHQi5CKSxcbiAgICAgICAgICAgICAgICAgICAgQTogbm9ybWFsaXplQWxwaGEoYy5BKVxuICAgICAgICAgICAgICAgIH0sIG9wdGlvbnMpXG4gICAgICAgICAgICAgICAgOiB0cmFuc2xhdGVDb2xvci5DSUVMYWJBKHtcbiAgICAgICAgICAgICAgICAgICAgLi4uUkdCLFxuICAgICAgICAgICAgICAgICAgICBBOiBub3JtYWxpemVBbHBoYShjLkEpXG4gICAgICAgICAgICAgICAgfSwgb3B0aW9ucy5kZWNpbWFscykpO1xuICAgICAgICB9KTtcbiAgICB9LFxuICAgIFtDb2xvck1vZGVsLkxDSF0oY29sb3IsIGhhcm1vbnlGdW5jdGlvbiwgbW9kZSwgY3NzLCBvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IGFycmF5ID0gaGFybW9ueUZ1bmN0aW9uKGNvbG9yLCBtb2RlKTtcbiAgICAgICAgcmV0dXJuIGFycmF5Lm1hcCgoYykgPT4ge1xuICAgICAgICAgICAgY29uc3QgUkdCID0gaHNsVG9SZ2IoYy5ILCBjLlMsIGMuTCk7XG4gICAgICAgICAgICByZXR1cm4gKGNzc1xuICAgICAgICAgICAgICAgID8gQ1NTLkxDSChyZ2JUb0xjaChSR0IuUiwgUkdCLkcsIFJHQi5CKSwgb3B0aW9ucylcbiAgICAgICAgICAgICAgICA6IHRyYW5zbGF0ZUNvbG9yLkxDSChSR0IsIG9wdGlvbnMuZGVjaW1hbHMpKTtcbiAgICAgICAgfSk7XG4gICAgfSxcbiAgICBMQ0hBKGNvbG9yLCBoYXJtb255RnVuY3Rpb24sIG1vZGUsIGNzcywgb3B0aW9ucykge1xuICAgICAgICBjb25zdCBhcnJheSA9IGhhcm1vbnlGdW5jdGlvbihjb2xvciwgbW9kZSk7XG4gICAgICAgIHJldHVybiBhcnJheS5tYXAoKGMpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IFJHQiA9IGhzbFRvUmdiKGMuSCwgYy5TLCBjLkwpO1xuICAgICAgICAgICAgcmV0dXJuIChjc3NcbiAgICAgICAgICAgICAgICA/IENTUy5MQ0goe1xuICAgICAgICAgICAgICAgICAgICAuLi5yZ2JUb0xjaChSR0IuUiwgUkdCLkcsIFJHQi5CKSxcbiAgICAgICAgICAgICAgICAgICAgQTogbm9ybWFsaXplQWxwaGEoYy5BKVxuICAgICAgICAgICAgICAgIH0sIG9wdGlvbnMpXG4gICAgICAgICAgICAgICAgOiB0cmFuc2xhdGVDb2xvci5MQ0hBKHtcbiAgICAgICAgICAgICAgICAgICAgLi4uUkdCLFxuICAgICAgICAgICAgICAgICAgICBBOiBub3JtYWxpemVBbHBoYShjLkEpXG4gICAgICAgICAgICAgICAgfSwgb3B0aW9ucy5kZWNpbWFscykpO1xuICAgICAgICB9KTtcbiAgICB9XG59O1xuZXhwb3J0IGNvbnN0IGNvbG9yTWl4ZXIgPSB7XG4gICAgbWl4KGNvbG9ycywgbW9kZSkge1xuICAgICAgICBjb25zdCByZ2JNYXAgPSBjb2xvcnMubWFwKChjb2xvcikgPT4ge1xuICAgICAgICAgICAgY29uc3QgbW9kZWwgPSBnZXRDb2xvck1vZGVsKGNvbG9yKTtcbiAgICAgICAgICAgIHJldHVybiBnZXRSR0JPYmplY3QoY29sb3IsIG1vZGVsKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IHJ5Yk1hcCA9IG1vZGUgPT09IE1peC5TVUJUUkFDVElWRVxuICAgICAgICAgICAgPyByZ2JNYXAubWFwKChjb2xvcikgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IFJZQiA9IHJnYlRvUnliKGNvbG9yLlIsIGNvbG9yLkcsIGNvbG9yLkIpO1xuICAgICAgICAgICAgICAgIGlmIChoYXNQcm9wKGNvbG9yLCAnQScpKSB7XG4gICAgICAgICAgICAgICAgICAgIFJZQi5BID0gY29sb3IuQTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIFJZQjtcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICA6IG51bGw7XG4gICAgICAgIGZ1bmN0aW9uIGNyZWF0ZU1peChpdGVtcykge1xuICAgICAgICAgICAgY29uc3QgaW5pdGlhbCA9IG1vZGUgPT09IE1peC5BRERJVElWRVxuICAgICAgICAgICAgICAgID8geyBSOiAwLCBHOiAwLCBCOiAwLCBBOiAwIH1cbiAgICAgICAgICAgICAgICA6IHsgUjogMCwgWTogMCwgQjogMCwgQTogMCB9O1xuICAgICAgICAgICAgcmV0dXJuIGl0ZW1zLnJlZHVjZSgobWl4LCBjb2xvcikgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IGNvbG9yQSA9IGhhc1Byb3AoY29sb3IsICdBJykgPyBjb2xvci5BIDogMTtcbiAgICAgICAgICAgICAgICBjb25zdCBjb21tb24gPSB7XG4gICAgICAgICAgICAgICAgICAgIFI6IE1hdGgubWluKG1peC5SICsgY29sb3IuUiAqIGNvbG9yQSwgQkFTRV8yNTUpLFxuICAgICAgICAgICAgICAgICAgICBCOiBNYXRoLm1pbihtaXguQiArIGNvbG9yLkIgKiBjb2xvckEsIEJBU0VfMjU1KSxcbiAgICAgICAgICAgICAgICAgICAgQTogMSAtICgxIC0gY29sb3JBKSAqICgxIC0gbWl4LkEpXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBjb25zdCBtaXhHWSA9ICdHJyBpbiBtaXhcbiAgICAgICAgICAgICAgICAgICAgPyBtaXguR1xuICAgICAgICAgICAgICAgICAgICA6IG1peC5ZO1xuICAgICAgICAgICAgICAgIGNvbnN0IGNvbG9yR1kgPSAnRycgaW4gY29sb3JcbiAgICAgICAgICAgICAgICAgICAgPyBjb2xvci5HXG4gICAgICAgICAgICAgICAgICAgIDogY29sb3IuWTtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAuLi5jb21tb24sXG4gICAgICAgICAgICAgICAgICAgIC4uLihtb2RlID09PSBNaXguQURESVRJVkVcbiAgICAgICAgICAgICAgICAgICAgICAgID8geyBHOiBNYXRoLm1pbihtaXhHWSArIGNvbG9yR1kgKiBjb2xvckEsIEJBU0VfMjU1KSB9XG4gICAgICAgICAgICAgICAgICAgICAgICA6IHsgWTogTWF0aC5taW4obWl4R1kgKyBjb2xvckdZICogY29sb3JBLCBCQVNFXzI1NSkgfSlcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSwgaW5pdGlhbCk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IG1peDtcbiAgICAgICAgaWYgKG1vZGUgPT09IE1peC5BRERJVElWRSkge1xuICAgICAgICAgICAgbWl4ID0gY3JlYXRlTWl4KHJnYk1hcCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBSWUIgPSBjcmVhdGVNaXgocnliTWFwKTtcbiAgICAgICAgICAgIG1peCA9IHJ5YlRvUmdiKFJZQi5SLCBSWUIuWSwgUllCLkIpO1xuICAgICAgICAgICAgbWl4LkEgPSBSWUIuQTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgUjogcm91bmQobWl4LlIpLFxuICAgICAgICAgICAgRzogcm91bmQobWl4LkcpLFxuICAgICAgICAgICAgQjogcm91bmQobWl4LkIpLFxuICAgICAgICAgICAgQTogbWlubWF4KG1peC5BLCAwLCAxKVxuICAgICAgICB9O1xuICAgIH0sXG4gICAgW0NvbG9yTW9kZWwuSEVYXShjb2xvcnMsIG1vZGUsIGNzcykge1xuICAgICAgICBjb25zdCBtaXggPSB0aGlzLm1peChjb2xvcnMsIG1vZGUpO1xuICAgICAgICBkZWxldGUgbWl4LkE7XG4gICAgICAgIHJldHVybiAoY3NzXG4gICAgICAgICAgICA/IENTUy5IRVgobWl4KVxuICAgICAgICAgICAgOiB0cmFuc2xhdGVDb2xvci5IRVgobWl4KSk7XG4gICAgfSxcbiAgICBIRVhBKGNvbG9ycywgbW9kZSwgY3NzKSB7XG4gICAgICAgIGNvbnN0IG1peCA9IHRoaXMubWl4KGNvbG9ycywgbW9kZSk7XG4gICAgICAgIG1peC5BID0gY3NzXG4gICAgICAgICAgICA/IG5vcm1hbGl6ZUFscGhhKG1peC5BKSAqIEJBU0VfMjU1XG4gICAgICAgICAgICA6IG5vcm1hbGl6ZUFscGhhKG1peC5BKTtcbiAgICAgICAgcmV0dXJuIChjc3NcbiAgICAgICAgICAgID8gQ1NTLkhFWChtaXgpXG4gICAgICAgICAgICA6IHRyYW5zbGF0ZUNvbG9yLkhFWEEobWl4KSk7XG4gICAgfSxcbiAgICBbQ29sb3JNb2RlbC5SR0JdKGNvbG9ycywgbW9kZSwgY3NzLCBvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IG1peCA9IHRoaXMubWl4KGNvbG9ycywgbW9kZSk7XG4gICAgICAgIGRlbGV0ZSBtaXguQTtcbiAgICAgICAgcmV0dXJuIChjc3NcbiAgICAgICAgICAgID8gQ1NTLlJHQihtaXgsIG9wdGlvbnMpXG4gICAgICAgICAgICA6IHRyYW5zbGF0ZUNvbG9yLlJHQihtaXgsIG9wdGlvbnMuZGVjaW1hbHMpKTtcbiAgICB9LFxuICAgIFJHQkEoY29sb3JzLCBtb2RlLCBjc3MsIG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgbWl4ID0gdGhpcy5taXgoY29sb3JzLCBtb2RlKTtcbiAgICAgICAgcmV0dXJuIChjc3NcbiAgICAgICAgICAgID8gQ1NTLlJHQihtaXgsIG9wdGlvbnMpXG4gICAgICAgICAgICA6IHRyYW5zbGF0ZUNvbG9yLlJHQkEobWl4LCBvcHRpb25zLmRlY2ltYWxzKSk7XG4gICAgfSxcbiAgICBbQ29sb3JNb2RlbC5IU0xdKGNvbG9ycywgbW9kZSwgY3NzLCBvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IG1peCA9IHRoaXMubWl4KGNvbG9ycywgbW9kZSk7XG4gICAgICAgIGNvbnN0IEhTTCA9IHJnYlRvSHNsKG1peC5SLCBtaXguRywgbWl4LkIpO1xuICAgICAgICBkZWxldGUgbWl4LkE7XG4gICAgICAgIGRlbGV0ZSBIU0wuQTtcbiAgICAgICAgcmV0dXJuIChjc3NcbiAgICAgICAgICAgID8gQ1NTLkhTTChIU0wsIG9wdGlvbnMpXG4gICAgICAgICAgICA6IHRyYW5zbGF0ZUNvbG9yLkhTTChtaXgsIG9wdGlvbnMuZGVjaW1hbHMpKTtcbiAgICB9LFxuICAgIEhTTEEoY29sb3JzLCBtb2RlLCBjc3MsIG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgbWl4ID0gdGhpcy5taXgoY29sb3JzLCBtb2RlKTtcbiAgICAgICAgY29uc3QgSFNMID0gcmdiVG9Ic2wobWl4LlIsIG1peC5HLCBtaXguQiwgbWl4LkEpO1xuICAgICAgICByZXR1cm4gKGNzc1xuICAgICAgICAgICAgPyBDU1MuSFNMKEhTTCwgb3B0aW9ucylcbiAgICAgICAgICAgIDogdHJhbnNsYXRlQ29sb3IuSFNMQShtaXgsIG9wdGlvbnMuZGVjaW1hbHMpKTtcbiAgICB9LFxuICAgIFtDb2xvck1vZGVsLkhXQl0oY29sb3JzLCBtb2RlLCBjc3MsIG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgbWl4ID0gdGhpcy5taXgoY29sb3JzLCBtb2RlKTtcbiAgICAgICAgY29uc3QgSFdCID0gcmdiVG9Id2IobWl4LlIsIG1peC5HLCBtaXguQik7XG4gICAgICAgIGRlbGV0ZSBtaXguQTtcbiAgICAgICAgZGVsZXRlIEhXQi5BO1xuICAgICAgICByZXR1cm4gKGNzc1xuICAgICAgICAgICAgPyBDU1MuSFdCKEhXQiwgb3B0aW9ucylcbiAgICAgICAgICAgIDogdHJhbnNsYXRlQ29sb3IuSFdCKG1peCwgb3B0aW9ucy5kZWNpbWFscykpO1xuICAgIH0sXG4gICAgSFdCQShjb2xvcnMsIG1vZGUsIGNzcywgb3B0aW9ucykge1xuICAgICAgICBjb25zdCBtaXggPSB0aGlzLm1peChjb2xvcnMsIG1vZGUpO1xuICAgICAgICBjb25zdCBIV0IgPSByZ2JUb0h3YihtaXguUiwgbWl4LkcsIG1peC5CLCBtaXguQSk7XG4gICAgICAgIHJldHVybiAoY3NzXG4gICAgICAgICAgICA/IENTUy5IV0IoSFdCLCBvcHRpb25zKVxuICAgICAgICAgICAgOiB0cmFuc2xhdGVDb2xvci5IV0JBKG1peCwgb3B0aW9ucy5kZWNpbWFscykpO1xuICAgIH0sXG4gICAgW0NvbG9yTW9kZWwuQ0lFTGFiXShjb2xvcnMsIG1vZGUsIGNzcywgb3B0aW9ucykge1xuICAgICAgICBjb25zdCBtaXggPSB0aGlzLm1peChjb2xvcnMsIG1vZGUpO1xuICAgICAgICBjb25zdCBMYWIgPSByZ2JUb0xhYihtaXguUiwgbWl4LkcsIG1peC5CKTtcbiAgICAgICAgZGVsZXRlIG1peC5BO1xuICAgICAgICByZXR1cm4gKGNzc1xuICAgICAgICAgICAgPyBDU1MuQ0lFTGFiKExhYiwgb3B0aW9ucylcbiAgICAgICAgICAgIDogdHJhbnNsYXRlQ29sb3IuQ0lFTGFiKG1peCwgb3B0aW9ucy5kZWNpbWFscykpO1xuICAgIH0sXG4gICAgQ0lFTGFiQShjb2xvcnMsIG1vZGUsIGNzcywgb3B0aW9ucykge1xuICAgICAgICBjb25zdCBtaXggPSB0aGlzLm1peChjb2xvcnMsIG1vZGUpO1xuICAgICAgICBjb25zdCBMYWIgPSByZ2JUb0xhYihtaXguUiwgbWl4LkcsIG1peC5CKTtcbiAgICAgICAgaWYgKGhhc1Byb3AobWl4LCAnQScpKSB7XG4gICAgICAgICAgICBMYWIuQSA9IG1peC5BO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAoY3NzXG4gICAgICAgICAgICA/IENTUy5DSUVMYWIoTGFiLCBvcHRpb25zKVxuICAgICAgICAgICAgOiB0cmFuc2xhdGVDb2xvci5DSUVMYWJBKG1peCwgb3B0aW9ucy5kZWNpbWFscykpO1xuICAgIH0sXG4gICAgW0NvbG9yTW9kZWwuTENIXShjb2xvcnMsIG1vZGUsIGNzcywgb3B0aW9ucykge1xuICAgICAgICBjb25zdCBtaXggPSB0aGlzLm1peChjb2xvcnMsIG1vZGUpO1xuICAgICAgICBjb25zdCBsY2ggPSByZ2JUb0xjaChtaXguUiwgbWl4LkcsIG1peC5CKTtcbiAgICAgICAgZGVsZXRlIG1peC5BO1xuICAgICAgICByZXR1cm4gKGNzc1xuICAgICAgICAgICAgPyBDU1MuTENIKGxjaCwgb3B0aW9ucylcbiAgICAgICAgICAgIDogdHJhbnNsYXRlQ29sb3IuTENIKG1peCwgb3B0aW9ucy5kZWNpbWFscykpO1xuICAgIH0sXG4gICAgTENIQShjb2xvcnMsIG1vZGUsIGNzcywgb3B0aW9ucykge1xuICAgICAgICBjb25zdCBtaXggPSB0aGlzLm1peChjb2xvcnMsIG1vZGUpO1xuICAgICAgICBjb25zdCBsY2ggPSByZ2JUb0xjaChtaXguUiwgbWl4LkcsIG1peC5CKTtcbiAgICAgICAgaWYgKGhhc1Byb3AobWl4LCAnQScpKSB7XG4gICAgICAgICAgICBsY2guQSA9IG1peC5BO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAoY3NzXG4gICAgICAgICAgICA/IENTUy5MQ0gobGNoLCBvcHRpb25zKVxuICAgICAgICAgICAgOiB0cmFuc2xhdGVDb2xvci5MQ0hBKG1peCwgb3B0aW9ucy5kZWNpbWFscykpO1xuICAgIH1cbn07XG5leHBvcnQgY29uc3Qgcm91bmRSR0JPYmplY3QgPSAoY29sb3IsIGRlY2ltYWxzKSA9PiB7XG4gICAgY29uc3QgUiA9IHJvdW5kKGNvbG9yLlIsIGRlY2ltYWxzKTtcbiAgICBjb25zdCBHID0gcm91bmQoY29sb3IuRywgZGVjaW1hbHMpO1xuICAgIGNvbnN0IEIgPSByb3VuZChjb2xvci5CLCBkZWNpbWFscyk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgUixcbiAgICAgICAgRyxcbiAgICAgICAgQixcbiAgICAgICAgLi4uKGhhc1Byb3AoY29sb3IsICdBJylcbiAgICAgICAgICAgID8ge1xuICAgICAgICAgICAgICAgIEE6IHJvdW5kKGNvbG9yLkEsIGRlY2ltYWxzKVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgOiB7fSlcbiAgICB9O1xufTtcbiIsImltcG9ydCB7IERFRkFVTFRfQkxFTkRfU1RFUFMsIEhhcm1vbnksIE1peCB9IGZyb20gJyNjb25zdGFudHMnO1xuaW1wb3J0ICogYXMgdXRpbHMgZnJvbSAnI2NvbG9yL3V0aWxzJztcbmltcG9ydCB7IGdldE9wdGlvbnNGcm9tQ29sb3JJbnB1dCwgZ2V0UkdCT2JqZWN0IH0gZnJvbSAnI2NvbG9yL2V4dHJhY3RvcnMnO1xuZXhwb3J0IGNvbnN0IGdldENvbG9yUmV0dXJuID0gKGNvbG9yLCBtb2RlbCwgZGVjaW1hbHMsIHRyYW5zbGF0ZUZ1bmN0aW9uKSA9PiB7XG4gICAgY29uc3QgcmdiT2JqZWN0ID0gZ2V0UkdCT2JqZWN0KGNvbG9yLCBtb2RlbCk7XG4gICAgcmV0dXJuIHRyYW5zbGF0ZUZ1bmN0aW9uKHJnYk9iamVjdCwgZGVjaW1hbHMpO1xufTtcbmV4cG9ydCBjb25zdCBnZXRCbGVuZFJldHVybiA9IChmcm9tLCB0bywgc3RlcHMsIGRlY2ltYWxzLCB0cmFuc2xhdGVGdW5jdGlvbikgPT4ge1xuICAgIGlmIChzdGVwcyA8IDEpXG4gICAgICAgIHN0ZXBzID0gREVGQVVMVF9CTEVORF9TVEVQUztcbiAgICBjb25zdCBmcm9tUkdCT2JqZWN0ID0gZ2V0UkdCT2JqZWN0KGZyb20pO1xuICAgIGNvbnN0IHRvUkdCT2JqZWN0ID0gZ2V0UkdCT2JqZWN0KHRvKTtcbiAgICBjb25zdCBibGVuZEFycmF5ID0gdXRpbHMuYmxlbmQoZnJvbVJHQk9iamVjdCwgdG9SR0JPYmplY3QsIHN0ZXBzKTtcbiAgICByZXR1cm4gYmxlbmRBcnJheS5tYXAoKGNvbG9yKSA9PiB7XG4gICAgICAgIHJldHVybiB0cmFuc2xhdGVGdW5jdGlvbihjb2xvciwgZGVjaW1hbHMpO1xuICAgIH0pO1xufTtcbmV4cG9ydCBmdW5jdGlvbiBnZXRCbGVuZFJldHVybldpdGhQYXJhbWV0ZXJzKHBhcmFtcykge1xuICAgIGNvbnN0IHsgZnJvbSwgdG8sIHRoaXJkUGFyYW1ldGVyLCBmb3VydGhQYXJhbWV0ZXIsIHRyYW5zbGF0ZUZ1bmN0aW9uLCBjc3NGdW5jdGlvbiB9ID0gcGFyYW1zO1xuICAgIGNvbnN0IHJlc3VsdCA9IHR5cGVvZiB0aGlyZFBhcmFtZXRlciA9PT0gJ251bWJlcidcbiAgICAgICAgPyBnZXRCbGVuZFJldHVybihmcm9tLCB0bywgdGhpcmRQYXJhbWV0ZXIsIGZvdXJ0aFBhcmFtZXRlcj8uZGVjaW1hbHMsIHRyYW5zbGF0ZUZ1bmN0aW9uKVxuICAgICAgICA6IGdldEJsZW5kUmV0dXJuKGZyb20sIHRvLCBERUZBVUxUX0JMRU5EX1NURVBTLCB0aGlyZFBhcmFtZXRlcj8uZGVjaW1hbHMsIHRyYW5zbGF0ZUZ1bmN0aW9uKTtcbiAgICBpZiAoY3NzRnVuY3Rpb24pIHtcbiAgICAgICAgcmV0dXJuIHJlc3VsdC5tYXAoKGNvbG9yKSA9PiBjc3NGdW5jdGlvbihjb2xvciwgZ2V0T3B0aW9uc0Zyb21Db2xvcklucHV0KCh0eXBlb2YgdGhpcmRQYXJhbWV0ZXIgPT09ICdudW1iZXInXG4gICAgICAgICAgICA/IGZvdXJ0aFBhcmFtZXRlclxuICAgICAgICAgICAgOiB0aGlyZFBhcmFtZXRlcikgPz8ge30sIGZyb20sIHRvKSkpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuZXhwb3J0IGZ1bmN0aW9uIGdldE1peFJldHVybihwYXJhbXMpIHtcbiAgICBjb25zdCB7IGNvbG9ycywgc2Vjb25kUGFyYW1ldGVyLCB0aGlyZFBhcmFtZXRlciwgY29sb3JNaXhlckZ1bmN0aW9uLCBjc3MgfSA9IHBhcmFtcztcbiAgICBjb25zdCBvcHRpb25zID0gZ2V0T3B0aW9uc0Zyb21Db2xvcklucHV0KCh0eXBlb2Ygc2Vjb25kUGFyYW1ldGVyID09PSAnc3RyaW5nJ1xuICAgICAgICA/IHRoaXJkUGFyYW1ldGVyXG4gICAgICAgIDogc2Vjb25kUGFyYW1ldGVyKSA/PyB7fSwgLi4uY29sb3JzKTtcbiAgICBpZiAodHlwZW9mIHNlY29uZFBhcmFtZXRlciA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgcmV0dXJuIGNvbG9yTWl4ZXJGdW5jdGlvbihjb2xvcnMsIHNlY29uZFBhcmFtZXRlciwgY3NzLCBvcHRpb25zKTtcbiAgICB9XG4gICAgcmV0dXJuIGNvbG9yTWl4ZXJGdW5jdGlvbihjb2xvcnMsIE1peC5BRERJVElWRSwgY3NzLCBvcHRpb25zKTtcbn1cbmV4cG9ydCBjb25zdCBnZXRIYXJtb255UmV0dXJuID0gKGhhcm1vbnksIGNvbG9yLCBtb2RlLCBvcHRpb25zKSA9PiB7XG4gICAgcmV0dXJuICh7XG4gICAgICAgIFtIYXJtb255LkFOQUxPR09VU106IHV0aWxzLmNvbG9ySGFybW9ueS5idWlsZEhhcm1vbnkoY29sb3IsIHV0aWxzLmFuYWxvZ291cywgbW9kZSwgb3B0aW9ucyksXG4gICAgICAgIFtIYXJtb255LkNPTVBMRU1FTlRBUlldOiB1dGlscy5jb2xvckhhcm1vbnkuYnVpbGRIYXJtb255KGNvbG9yLCB1dGlscy5jb21wbGVtZW50YXJ5LCBtb2RlLCBvcHRpb25zKSxcbiAgICAgICAgW0hhcm1vbnkuU1BMSVRfQ09NUExFTUVOVEFSWV06IHV0aWxzLmNvbG9ySGFybW9ueS5idWlsZEhhcm1vbnkoY29sb3IsIHV0aWxzLnNwbGl0Q29tcGxlbWVudGFyeSwgbW9kZSwgb3B0aW9ucyksXG4gICAgICAgIFtIYXJtb255LlRSSUFESUNdOiB1dGlscy5jb2xvckhhcm1vbnkuYnVpbGRIYXJtb255KGNvbG9yLCB1dGlscy50cmlhZGljLCBtb2RlLCBvcHRpb25zKSxcbiAgICAgICAgW0hhcm1vbnkuVEVUUkFESUNdOiB1dGlscy5jb2xvckhhcm1vbnkuYnVpbGRIYXJtb255KGNvbG9yLCB1dGlscy50ZXRyYWRpYywgbW9kZSwgb3B0aW9ucyksXG4gICAgICAgIFtIYXJtb255LlNRVUFSRV06IHV0aWxzLmNvbG9ySGFybW9ueS5idWlsZEhhcm1vbnkoY29sb3IsIHV0aWxzLnNxdWFyZSwgbW9kZSwgb3B0aW9ucylcbiAgICB9KVtoYXJtb255XTtcbn07XG4iLCJpbXBvcnQgeyBCQVNFXzI1NSwgREVGQVVMVF9CTEVORF9TVEVQUywgREVGQVVMVF9TSEFERVNfVElOVFNfU1RFUFMsIEhhcm1vbnksIE1BWF9BTFBIQSwgTUFYX0xBQiwgTUFYX0xDSF9DLCBNQVhfUENFTlQsIE1peCB9IGZyb20gJyNjb25zdGFudHMnO1xuaW1wb3J0IHsgY215a1RvUmdiLCBoc2xUb1JnYiwgaHdiVG9SZ2IsIGxhYlRvTGNoLCBsYWJUb1JnYiwgbGNoVG9MYWIsIGxjaFRvUmdiLCByZ2JUb0NteWssIHJnYlRvSHNsLCByZ2JUb0h3YiwgcmdiVG9MYWIsIHJnYlRvTGNoIH0gZnJvbSAnI2NvbG9yL3RyYW5zbGF0b3JzJztcbmltcG9ydCAqIGFzIHV0aWxzIGZyb20gJyNjb2xvci91dGlscyc7XG5pbXBvcnQgeyBnZXRDb2xvck1vZGVsLCBnZXRPcHRpb25zRnJvbUNvbG9ySW5wdXQsIGdldFJHQk9iamVjdCB9IGZyb20gJyNjb2xvci9leHRyYWN0b3JzJztcbmltcG9ydCB7IENTUyB9IGZyb20gJyNjb2xvci9jc3MnO1xuaW1wb3J0IHsgaXNIYXJtb255LCBpc01peCwgbWlubWF4LCBub3JtYWxpemVIdWUsIHJvdW5kIH0gZnJvbSAnI2hlbHBlcnMnO1xuaW1wb3J0IHsgZ2V0QmxlbmRSZXR1cm4sIGdldEJsZW5kUmV0dXJuV2l0aFBhcmFtZXRlcnMsIGdldENvbG9yUmV0dXJuLCBnZXRIYXJtb255UmV0dXJuLCBnZXRNaXhSZXR1cm4gfSBmcm9tICcjcmV0dXJucyc7XG5jb25zdCBiaW5kZWRNaXhlcnMgPSBPYmplY3QuZnJvbUVudHJpZXMoT2JqZWN0LmVudHJpZXModXRpbHMuY29sb3JNaXhlcikubWFwKChlbnRyeSkgPT4ge1xuICAgIGNvbnN0IFtrZXksIGZuXSA9IGVudHJ5O1xuICAgIHJldHVybiBba2V5LCBmbi5iaW5kKHV0aWxzLmNvbG9yTWl4ZXIpXTtcbn0pKTtcbmV4cG9ydCBjbGFzcyBDb2xvclRyYW5zbGF0b3Ige1xuICAgIGNvbnN0cnVjdG9yKGNvbG9yLCBvcHRpb25zID0ge30pIHtcbiAgICAgICAgdGhpcy5fb3B0aW9ucyA9IGdldE9wdGlvbnNGcm9tQ29sb3JJbnB1dChvcHRpb25zLCBjb2xvcik7XG4gICAgICAgIHRoaXMucmdiID0gZ2V0UkdCT2JqZWN0KGNvbG9yKTtcbiAgICAgICAgdGhpcy51cGRhdGUoJ3JnYicpO1xuICAgIH1cbiAgICB1cGRhdGUoLi4uZXhjbHVkZSkge1xuICAgICAgICBpZiAoIWV4Y2x1ZGUuaW5jbHVkZXMoJ3JnYicpKSB7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZVJHQigpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghZXhjbHVkZS5pbmNsdWRlcygnaHNsJykpIHtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlSFNMKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFleGNsdWRlLmluY2x1ZGVzKCdod2InKSkge1xuICAgICAgICAgICAgdGhpcy51cGRhdGVIV0IoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWV4Y2x1ZGUuaW5jbHVkZXMoJ2xhYicpKSB7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZUxBQigpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghZXhjbHVkZS5pbmNsdWRlcygnbGNoJykpIHtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlTENIKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFleGNsdWRlLmluY2x1ZGVzKCdjbXlrJykpIHtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlQ01ZSygpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHVwZGF0ZVJHQigpIHtcbiAgICAgICAgdGhpcy5yZ2IgPSB7XG4gICAgICAgICAgICAuLi5oc2xUb1JnYih0aGlzLmhzbC5ILCB0aGlzLmhzbC5TLCB0aGlzLmhzbC5MKSxcbiAgICAgICAgICAgIEE6IHRoaXMuaHNsLkFcbiAgICAgICAgfTtcbiAgICB9XG4gICAgdXBkYXRlSFNMKCkge1xuICAgICAgICB0aGlzLmhzbCA9IHJnYlRvSHNsKHRoaXMucmdiLlIsIHRoaXMucmdiLkcsIHRoaXMucmdiLkIsIHRoaXMucmdiLkEpO1xuICAgIH1cbiAgICB1cGRhdGVIV0IoKSB7XG4gICAgICAgIHRoaXMuaHdiID0gcmdiVG9Id2IodGhpcy5yZ2IuUiwgdGhpcy5yZ2IuRywgdGhpcy5yZ2IuQiwgdGhpcy5yZ2IuQSk7XG4gICAgfVxuICAgIHVwZGF0ZUxBQigpIHtcbiAgICAgICAgdGhpcy5sYWIgPSB7XG4gICAgICAgICAgICAuLi5yZ2JUb0xhYih0aGlzLnJnYi5SLCB0aGlzLnJnYi5HLCB0aGlzLnJnYi5CKSxcbiAgICAgICAgICAgIEE6IHRoaXMucmdiLkFcbiAgICAgICAgfTtcbiAgICB9XG4gICAgdXBkYXRlTENIKCkge1xuICAgICAgICB0aGlzLmxjaCA9IHtcbiAgICAgICAgICAgIC4uLnJnYlRvTGNoKHRoaXMucmdiLlIsIHRoaXMucmdiLkcsIHRoaXMucmdiLkIpLFxuICAgICAgICAgICAgQTogdGhpcy5yZ2IuQVxuICAgICAgICB9O1xuICAgIH1cbiAgICB1cGRhdGVDTVlLKCkge1xuICAgICAgICB0aGlzLmNteWsgPSByZ2JUb0NteWsodGhpcy5yZ2IuUiwgdGhpcy5yZ2IuRywgdGhpcy5yZ2IuQik7XG4gICAgfVxuICAgIHVwZGF0ZVJHQkZyb21IV0IoKSB7XG4gICAgICAgIHRoaXMucmdiID0ge1xuICAgICAgICAgICAgLi4uaHdiVG9SZ2IodGhpcy5od2IuSCwgdGhpcy5od2IuVywgdGhpcy5od2IuQiksXG4gICAgICAgICAgICBBOiB0aGlzLnJnYi5BXG4gICAgICAgIH07XG4gICAgfVxuICAgIHVwZGF0ZVJHQkZyb21MQ0goKSB7XG4gICAgICAgIHRoaXMucmdiID0ge1xuICAgICAgICAgICAgLi4ubGNoVG9SZ2IodGhpcy5sY2guTCwgdGhpcy5sY2guQywgdGhpcy5sY2guSCksXG4gICAgICAgICAgICBBOiB0aGlzLnJnYi5BXG4gICAgICAgIH07XG4gICAgfVxuICAgIHVwZGF0ZVJHQkZyb21DTVlLKCkge1xuICAgICAgICB0aGlzLnJnYiA9IHtcbiAgICAgICAgICAgIC4uLmNteWtUb1JnYih0aGlzLmNteWsuQywgdGhpcy5jbXlrLk0sIHRoaXMuY215ay5ZLCB0aGlzLmNteWsuSyksXG4gICAgICAgICAgICBBOiB0aGlzLnJnYi5BXG4gICAgICAgIH07XG4gICAgfVxuICAgIHVwZGF0ZVJHQkZyb21MQUIoKSB7XG4gICAgICAgIHRoaXMucmdiID0ge1xuICAgICAgICAgICAgLi4ubGFiVG9SZ2IodGhpcy5sYWIuTCwgdGhpcy5sYWIuYSwgdGhpcy5sYWIuYiksXG4gICAgICAgICAgICBBOiB0aGlzLnJnYi5BXG4gICAgICAgIH07XG4gICAgfVxuICAgIHVwZGF0ZUxDSEZyb21MQUIoKSB7XG4gICAgICAgIHRoaXMubGNoID0ge1xuICAgICAgICAgICAgLi4ubGFiVG9MY2godGhpcy5sYWIuTCwgdGhpcy5sYWIuYSwgdGhpcy5sYWIuYiksXG4gICAgICAgICAgICBBOiB0aGlzLmxhYi5BXG4gICAgICAgIH07XG4gICAgfVxuICAgIHVwZGF0ZUxBQnJvbUxDSCgpIHtcbiAgICAgICAgdGhpcy5sYWIgPSB7XG4gICAgICAgICAgICAuLi5sY2hUb0xhYih0aGlzLmxjaC5MLCB0aGlzLmxjaC5DLCB0aGlzLmxjaC5IKSxcbiAgICAgICAgICAgIEE6IHRoaXMubGNoLkFcbiAgICAgICAgfTtcbiAgICB9XG4gICAgc2V0T3B0aW9ucyhvcHRpb25zID0ge30pIHtcbiAgICAgICAgdGhpcy5fb3B0aW9ucyA9IHtcbiAgICAgICAgICAgIC4uLnRoaXMuX29wdGlvbnMsXG4gICAgICAgICAgICAuLi5vcHRpb25zXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBzZXRSKFIpIHtcbiAgICAgICAgdGhpcy5yZ2IuUiA9IG1pbm1heChSLCAwLCBCQVNFXzI1NSk7XG4gICAgICAgIHRoaXMudXBkYXRlKCdyZ2InKTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBzZXRHKEcpIHtcbiAgICAgICAgdGhpcy5yZ2IuRyA9IG1pbm1heChHLCAwLCBCQVNFXzI1NSk7XG4gICAgICAgIHRoaXMudXBkYXRlKCdyZ2InKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIHNldEIoQikge1xuICAgICAgICB0aGlzLnJnYi5CID0gbWlubWF4KEIsIDAsIEJBU0VfMjU1KTtcbiAgICAgICAgdGhpcy51cGRhdGUoJ3JnYicpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgc2V0SChIKSB7XG4gICAgICAgIHRoaXMuaHNsLkggPSBub3JtYWxpemVIdWUoSCk7XG4gICAgICAgIHRoaXMudXBkYXRlKCdoc2wnKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIHNldFMoUykge1xuICAgICAgICB0aGlzLmhzbC5TID0gbWlubWF4KFMsIDAsIE1BWF9QQ0VOVCk7XG4gICAgICAgIHRoaXMudXBkYXRlKCdoc2wnKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIHNldEwoTCkge1xuICAgICAgICB0aGlzLmhzbC5MID0gbWlubWF4KEwsIDAsIE1BWF9QQ0VOVCk7XG4gICAgICAgIHRoaXMudXBkYXRlKCdoc2wnKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIHNldFdoaXRlbmVzcyhXKSB7XG4gICAgICAgIHRoaXMuaHdiLlcgPSBtaW5tYXgoVywgMCwgTUFYX1BDRU5UKTtcbiAgICAgICAgdGhpcy51cGRhdGVSR0JGcm9tSFdCKCk7XG4gICAgICAgIHRoaXMudXBkYXRlKCdyZ2InLCAnaHdiJyk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBzZXRCbGFja25lc3MoQikge1xuICAgICAgICB0aGlzLmh3Yi5CID0gbWlubWF4KEIsIDAsIE1BWF9QQ0VOVCk7XG4gICAgICAgIHRoaXMudXBkYXRlUkdCRnJvbUhXQigpO1xuICAgICAgICB0aGlzLnVwZGF0ZSgncmdiJywgJ2h3YicpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgc2V0Q0lFTChMKSB7XG4gICAgICAgIHRoaXMubGFiLkwgPSBtaW5tYXgoTCwgMCwgTUFYX1BDRU5UKTtcbiAgICAgICAgdGhpcy51cGRhdGVSR0JGcm9tTEFCKCk7XG4gICAgICAgIHRoaXMudXBkYXRlTENIRnJvbUxBQigpO1xuICAgICAgICB0aGlzLnVwZGF0ZSgncmdiJywgJ2xhYicsICdsY2gnKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIHNldENJRWEoYSkge1xuICAgICAgICB0aGlzLmxhYi5hID0gbWlubWF4KGEsIC1NQVhfTEFCLCBNQVhfTEFCKTtcbiAgICAgICAgdGhpcy51cGRhdGVSR0JGcm9tTEFCKCk7XG4gICAgICAgIHRoaXMudXBkYXRlTENIRnJvbUxBQigpO1xuICAgICAgICB0aGlzLnVwZGF0ZSgncmdiJywgJ2xhYicsICdsY2gnKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIHNldENJRWIoYikge1xuICAgICAgICB0aGlzLmxhYi5iID0gbWlubWF4KGIsIC1NQVhfTEFCLCBNQVhfTEFCKTtcbiAgICAgICAgdGhpcy51cGRhdGVSR0JGcm9tTEFCKCk7XG4gICAgICAgIHRoaXMudXBkYXRlTENIRnJvbUxBQigpO1xuICAgICAgICB0aGlzLnVwZGF0ZSgncmdiJywgJ2xhYicsICdsY2gnKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIHNldExDSEwobCkge1xuICAgICAgICB0aGlzLmxjaC5MID0gbWlubWF4KGwsIDAsIE1BWF9QQ0VOVCk7XG4gICAgICAgIHRoaXMudXBkYXRlUkdCRnJvbUxDSCgpO1xuICAgICAgICB0aGlzLnVwZGF0ZUxBQnJvbUxDSCgpO1xuICAgICAgICB0aGlzLnVwZGF0ZSgncmdiJywgJ2xhYicsICdsY2gnKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIHNldExDSEMoYykge1xuICAgICAgICB0aGlzLmxjaC5DID0gbWlubWF4KGMsIDAsIE1BWF9MQ0hfQyk7XG4gICAgICAgIHRoaXMudXBkYXRlUkdCRnJvbUxDSCgpO1xuICAgICAgICB0aGlzLnVwZGF0ZUxBQnJvbUxDSCgpO1xuICAgICAgICB0aGlzLnVwZGF0ZSgncmdiJywgJ2xhYicsICdsY2gnKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIHNldExDSEgoaCkge1xuICAgICAgICB0aGlzLmxjaC5IID0gbm9ybWFsaXplSHVlKGgpO1xuICAgICAgICB0aGlzLnVwZGF0ZVJHQkZyb21MQ0goKTtcbiAgICAgICAgdGhpcy51cGRhdGVMQUJyb21MQ0goKTtcbiAgICAgICAgdGhpcy51cGRhdGUoJ3JnYicsICdsYWInLCAnbGNoJyk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBzZXRBKEEpIHtcbiAgICAgICAgY29uc3QgYWxwaGEgPSBtaW5tYXgoQSwgMCwgTUFYX0FMUEhBKTtcbiAgICAgICAgdGhpcy5yZ2IuQSA9IGFscGhhO1xuICAgICAgICB0aGlzLmhzbC5BID0gYWxwaGE7XG4gICAgICAgIHRoaXMuaHdiLkEgPSBhbHBoYTtcbiAgICAgICAgdGhpcy5sYWIuQSA9IGFscGhhO1xuICAgICAgICB0aGlzLmxjaC5BID0gYWxwaGE7XG4gICAgICAgIHRoaXMuY215ay5BID0gYWxwaGE7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBzZXRDKEMpIHtcbiAgICAgICAgdGhpcy5jbXlrLkMgPSBtaW5tYXgoQywgMCwgMTAwKTtcbiAgICAgICAgdGhpcy51cGRhdGVSR0JGcm9tQ01ZSygpO1xuICAgICAgICB0aGlzLnVwZGF0ZSgnY215aycpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgc2V0TShNKSB7XG4gICAgICAgIHRoaXMuY215ay5NID0gbWlubWF4KE0sIDAsIDEwMCk7XG4gICAgICAgIHRoaXMudXBkYXRlUkdCRnJvbUNNWUsoKTtcbiAgICAgICAgdGhpcy51cGRhdGUoJ2NteWsnKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIHNldFkoWSkge1xuICAgICAgICB0aGlzLmNteWsuWSA9IG1pbm1heChZLCAwLCAxMDApO1xuICAgICAgICB0aGlzLnVwZGF0ZVJHQkZyb21DTVlLKCk7XG4gICAgICAgIHRoaXMudXBkYXRlKCdjbXlrJyk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBzZXRLKEspIHtcbiAgICAgICAgdGhpcy5jbXlrLksgPSBtaW5tYXgoSywgMCwgMTAwKTtcbiAgICAgICAgdGhpcy51cGRhdGVSR0JGcm9tQ01ZSygpO1xuICAgICAgICB0aGlzLnVwZGF0ZSgnY215aycpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgZ2V0IG9wdGlvbnMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9vcHRpb25zO1xuICAgIH1cbiAgICBnZXQgUigpIHtcbiAgICAgICAgcmV0dXJuIHJvdW5kKHRoaXMucmdiLlIsIHRoaXMub3B0aW9ucy5kZWNpbWFscyk7XG4gICAgfVxuICAgIGdldCBHKCkge1xuICAgICAgICByZXR1cm4gcm91bmQodGhpcy5yZ2IuRywgdGhpcy5vcHRpb25zLmRlY2ltYWxzKTtcbiAgICB9XG4gICAgZ2V0IEIoKSB7XG4gICAgICAgIHJldHVybiByb3VuZCh0aGlzLnJnYi5CLCB0aGlzLm9wdGlvbnMuZGVjaW1hbHMpO1xuICAgIH1cbiAgICBnZXQgSCgpIHtcbiAgICAgICAgcmV0dXJuIHJvdW5kKHRoaXMuaHNsLkgsIHRoaXMub3B0aW9ucy5kZWNpbWFscyk7XG4gICAgfVxuICAgIGdldCBTKCkge1xuICAgICAgICByZXR1cm4gcm91bmQodGhpcy5oc2wuUywgdGhpcy5vcHRpb25zLmRlY2ltYWxzKTtcbiAgICB9XG4gICAgZ2V0IEwoKSB7XG4gICAgICAgIHJldHVybiByb3VuZCh0aGlzLmhzbC5MLCB0aGlzLm9wdGlvbnMuZGVjaW1hbHMpO1xuICAgIH1cbiAgICBnZXQgV2hpdGVuZXNzKCkge1xuICAgICAgICByZXR1cm4gcm91bmQodGhpcy5od2IuVywgdGhpcy5vcHRpb25zLmRlY2ltYWxzKTtcbiAgICB9XG4gICAgZ2V0IEJsYWNrbmVzcygpIHtcbiAgICAgICAgcmV0dXJuIHJvdW5kKHRoaXMuaHdiLkIsIHRoaXMub3B0aW9ucy5kZWNpbWFscyk7XG4gICAgfVxuICAgIGdldCBDSUVMKCkge1xuICAgICAgICByZXR1cm4gcm91bmQodGhpcy5sYWIuTCwgdGhpcy5vcHRpb25zLmRlY2ltYWxzKTtcbiAgICB9XG4gICAgZ2V0IENJRWEoKSB7XG4gICAgICAgIHJldHVybiByb3VuZCh0aGlzLmxhYi5hLCB0aGlzLm9wdGlvbnMuZGVjaW1hbHMpO1xuICAgIH1cbiAgICBnZXQgQ0lFYigpIHtcbiAgICAgICAgcmV0dXJuIHJvdW5kKHRoaXMubGFiLmIsIHRoaXMub3B0aW9ucy5kZWNpbWFscyk7XG4gICAgfVxuICAgIGdldCBMQ0hMKCkge1xuICAgICAgICByZXR1cm4gcm91bmQodGhpcy5sY2guTCwgdGhpcy5vcHRpb25zLmRlY2ltYWxzKTtcbiAgICB9XG4gICAgZ2V0IExDSEMoKSB7XG4gICAgICAgIHJldHVybiByb3VuZCh0aGlzLmxjaC5DLCB0aGlzLm9wdGlvbnMuZGVjaW1hbHMpO1xuICAgIH1cbiAgICBnZXQgTENISCgpIHtcbiAgICAgICAgcmV0dXJuIHJvdW5kKHRoaXMubGNoLkgsIHRoaXMub3B0aW9ucy5kZWNpbWFscyk7XG4gICAgfVxuICAgIGdldCBBKCkge1xuICAgICAgICByZXR1cm4gcm91bmQodGhpcy5oc2wuQSwgdGhpcy5vcHRpb25zLmRlY2ltYWxzKTtcbiAgICB9XG4gICAgZ2V0IEMoKSB7XG4gICAgICAgIHJldHVybiByb3VuZCh0aGlzLmNteWsuQywgdGhpcy5vcHRpb25zLmRlY2ltYWxzKTtcbiAgICB9XG4gICAgZ2V0IE0oKSB7XG4gICAgICAgIHJldHVybiByb3VuZCh0aGlzLmNteWsuTSwgdGhpcy5vcHRpb25zLmRlY2ltYWxzKTtcbiAgICB9XG4gICAgZ2V0IFkoKSB7XG4gICAgICAgIHJldHVybiByb3VuZCh0aGlzLmNteWsuWSwgdGhpcy5vcHRpb25zLmRlY2ltYWxzKTtcbiAgICB9XG4gICAgZ2V0IEsoKSB7XG4gICAgICAgIHJldHVybiByb3VuZCh0aGlzLmNteWsuSywgdGhpcy5vcHRpb25zLmRlY2ltYWxzKTtcbiAgICB9XG4gICAgZ2V0IEhFWE9iamVjdCgpIHtcbiAgICAgICAgcmV0dXJuIHV0aWxzLnRyYW5zbGF0ZUNvbG9yLkhFWCh0aGlzLnJnYik7XG4gICAgfVxuICAgIGdldCBIRVhBT2JqZWN0KCkge1xuICAgICAgICByZXR1cm4gdXRpbHMudHJhbnNsYXRlQ29sb3IuSEVYQSh0aGlzLnJnYik7XG4gICAgfVxuICAgIGdldCBSR0JPYmplY3QoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBSOiB0aGlzLlIsXG4gICAgICAgICAgICBHOiB0aGlzLkcsXG4gICAgICAgICAgICBCOiB0aGlzLkJcbiAgICAgICAgfTtcbiAgICB9XG4gICAgZ2V0IFJHQkFPYmplY3QoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAuLi50aGlzLlJHQk9iamVjdCxcbiAgICAgICAgICAgIEE6IHRoaXMuQVxuICAgICAgICB9O1xuICAgIH1cbiAgICBnZXQgSFNMT2JqZWN0KCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgSDogdGhpcy5ILFxuICAgICAgICAgICAgUzogdGhpcy5TLFxuICAgICAgICAgICAgTDogdGhpcy5MXG4gICAgICAgIH07XG4gICAgfVxuICAgIGdldCBIU0xBT2JqZWN0KCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgLi4udGhpcy5IU0xPYmplY3QsXG4gICAgICAgICAgICBBOiB0aGlzLkFcbiAgICAgICAgfTtcbiAgICB9XG4gICAgZ2V0IEhXQk9iamVjdCgpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIEg6IHRoaXMuSCxcbiAgICAgICAgICAgIFc6IHRoaXMuV2hpdGVuZXNzLFxuICAgICAgICAgICAgQjogdGhpcy5CbGFja25lc3NcbiAgICAgICAgfTtcbiAgICB9XG4gICAgZ2V0IEhXQkFPYmplY3QoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAuLi50aGlzLkhXQk9iamVjdCxcbiAgICAgICAgICAgIEE6IHRoaXMuQVxuICAgICAgICB9O1xuICAgIH1cbiAgICBnZXQgQ0lFTGFiT2JqZWN0KCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgTDogdGhpcy5DSUVMLFxuICAgICAgICAgICAgYTogdGhpcy5DSUVhLFxuICAgICAgICAgICAgYjogdGhpcy5DSUViXG4gICAgICAgIH07XG4gICAgfVxuICAgIGdldCBDSUVMYWJBT2JqZWN0KCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgLi4udGhpcy5DSUVMYWJPYmplY3QsXG4gICAgICAgICAgICBBOiB0aGlzLkFcbiAgICAgICAgfTtcbiAgICB9XG4gICAgZ2V0IExDSE9iamVjdCgpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIEw6IHRoaXMuTENITCxcbiAgICAgICAgICAgIEM6IHRoaXMuTENIQyxcbiAgICAgICAgICAgIEg6IHRoaXMuTENISFxuICAgICAgICB9O1xuICAgIH1cbiAgICBnZXQgTENIQU9iamVjdCgpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIC4uLnRoaXMuTENIT2JqZWN0LFxuICAgICAgICAgICAgQTogdGhpcy5BXG4gICAgICAgIH07XG4gICAgfVxuICAgIGdldCBDTVlLT2JqZWN0KCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgQzogdGhpcy5DLFxuICAgICAgICAgICAgTTogdGhpcy5NLFxuICAgICAgICAgICAgWTogdGhpcy5ZLFxuICAgICAgICAgICAgSzogdGhpcy5LXG4gICAgICAgIH07XG4gICAgfVxuICAgIGdldCBDTVlLQU9iamVjdCgpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIC4uLnRoaXMuQ01ZS09iamVjdCxcbiAgICAgICAgICAgIEE6IHRoaXMuQVxuICAgICAgICB9O1xuICAgIH1cbiAgICBnZXQgSEVYKCkge1xuICAgICAgICByZXR1cm4gQ1NTLkhFWCh7XG4gICAgICAgICAgICBSOiB0aGlzLlIsXG4gICAgICAgICAgICBHOiB0aGlzLkcsXG4gICAgICAgICAgICBCOiB0aGlzLkJcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGdldCBIRVhBKCkge1xuICAgICAgICByZXR1cm4gQ1NTLkhFWCh7XG4gICAgICAgICAgICBSOiB0aGlzLlIsXG4gICAgICAgICAgICBHOiB0aGlzLkcsXG4gICAgICAgICAgICBCOiB0aGlzLkIsXG4gICAgICAgICAgICBBOiB0aGlzLkEgKiBCQVNFXzI1NVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgZ2V0IFJHQigpIHtcbiAgICAgICAgcmV0dXJuIENTUy5SR0Ioe1xuICAgICAgICAgICAgUjogdGhpcy5SLFxuICAgICAgICAgICAgRzogdGhpcy5HLFxuICAgICAgICAgICAgQjogdGhpcy5CXG4gICAgICAgIH0sIHRoaXMub3B0aW9ucyk7XG4gICAgfVxuICAgIGdldCBSR0JBKCkge1xuICAgICAgICByZXR1cm4gQ1NTLlJHQih7XG4gICAgICAgICAgICBSOiB0aGlzLlIsXG4gICAgICAgICAgICBHOiB0aGlzLkcsXG4gICAgICAgICAgICBCOiB0aGlzLkIsXG4gICAgICAgICAgICBBOiB0aGlzLkFcbiAgICAgICAgfSwgdGhpcy5vcHRpb25zKTtcbiAgICB9XG4gICAgZ2V0IEhTTCgpIHtcbiAgICAgICAgcmV0dXJuIENTUy5IU0woe1xuICAgICAgICAgICAgSDogdGhpcy5ILFxuICAgICAgICAgICAgUzogdGhpcy5TLFxuICAgICAgICAgICAgTDogdGhpcy5MXG4gICAgICAgIH0sIHRoaXMub3B0aW9ucyk7XG4gICAgfVxuICAgIGdldCBIU0xBKCkge1xuICAgICAgICByZXR1cm4gQ1NTLkhTTCh7XG4gICAgICAgICAgICBIOiB0aGlzLkgsXG4gICAgICAgICAgICBTOiB0aGlzLlMsXG4gICAgICAgICAgICBMOiB0aGlzLkwsXG4gICAgICAgICAgICBBOiB0aGlzLkFcbiAgICAgICAgfSwgdGhpcy5vcHRpb25zKTtcbiAgICB9XG4gICAgZ2V0IEhXQigpIHtcbiAgICAgICAgcmV0dXJuIENTUy5IV0Ioe1xuICAgICAgICAgICAgSDogdGhpcy5ILFxuICAgICAgICAgICAgVzogdGhpcy5XaGl0ZW5lc3MsXG4gICAgICAgICAgICBCOiB0aGlzLkJsYWNrbmVzc1xuICAgICAgICB9LCB0aGlzLm9wdGlvbnMpO1xuICAgIH1cbiAgICBnZXQgSFdCQSgpIHtcbiAgICAgICAgcmV0dXJuIENTUy5IV0Ioe1xuICAgICAgICAgICAgSDogdGhpcy5ILFxuICAgICAgICAgICAgVzogdGhpcy5XaGl0ZW5lc3MsXG4gICAgICAgICAgICBCOiB0aGlzLkJsYWNrbmVzcyxcbiAgICAgICAgICAgIEE6IHRoaXMuQVxuICAgICAgICB9LCB0aGlzLm9wdGlvbnMpO1xuICAgIH1cbiAgICBnZXQgQ0lFTGFiKCkge1xuICAgICAgICByZXR1cm4gQ1NTLkNJRUxhYih7XG4gICAgICAgICAgICBMOiB0aGlzLkNJRUwsXG4gICAgICAgICAgICBhOiB0aGlzLkNJRWEsXG4gICAgICAgICAgICBiOiB0aGlzLkNJRWJcbiAgICAgICAgfSwgdGhpcy5vcHRpb25zKTtcbiAgICB9XG4gICAgZ2V0IENJRUxhYkEoKSB7XG4gICAgICAgIHJldHVybiBDU1MuQ0lFTGFiKHtcbiAgICAgICAgICAgIEw6IHRoaXMuQ0lFTCxcbiAgICAgICAgICAgIGE6IHRoaXMuQ0lFYSxcbiAgICAgICAgICAgIGI6IHRoaXMuQ0lFYixcbiAgICAgICAgICAgIEE6IHRoaXMuQVxuICAgICAgICB9LCB0aGlzLm9wdGlvbnMpO1xuICAgIH1cbiAgICBnZXQgTENIKCkge1xuICAgICAgICByZXR1cm4gQ1NTLkxDSCh7XG4gICAgICAgICAgICBMOiB0aGlzLkxDSEwsXG4gICAgICAgICAgICBDOiB0aGlzLkxDSEMsXG4gICAgICAgICAgICBIOiB0aGlzLkxDSEhcbiAgICAgICAgfSwgdGhpcy5vcHRpb25zKTtcbiAgICB9XG4gICAgZ2V0IExDSEEoKSB7XG4gICAgICAgIHJldHVybiBDU1MuTENIKHtcbiAgICAgICAgICAgIEw6IHRoaXMuTENITCxcbiAgICAgICAgICAgIEM6IHRoaXMuTENIQyxcbiAgICAgICAgICAgIEg6IHRoaXMuTENISCxcbiAgICAgICAgICAgIEE6IHRoaXMuQVxuICAgICAgICB9LCB0aGlzLm9wdGlvbnMpO1xuICAgIH1cbiAgICBnZXQgQ01ZSygpIHtcbiAgICAgICAgcmV0dXJuIENTUy5DTVlLKHtcbiAgICAgICAgICAgIEM6IHRoaXMuQyxcbiAgICAgICAgICAgIE06IHRoaXMuTSxcbiAgICAgICAgICAgIFk6IHRoaXMuWSxcbiAgICAgICAgICAgIEs6IHRoaXMuS1xuICAgICAgICB9LCB0aGlzLm9wdGlvbnMpO1xuICAgIH1cbiAgICBnZXQgQ01ZS0EoKSB7XG4gICAgICAgIHJldHVybiBDU1MuQ01ZSyh7XG4gICAgICAgICAgICBDOiB0aGlzLkMsXG4gICAgICAgICAgICBNOiB0aGlzLk0sXG4gICAgICAgICAgICBZOiB0aGlzLlksXG4gICAgICAgICAgICBLOiB0aGlzLkssXG4gICAgICAgICAgICBBOiB0aGlzLkFcbiAgICAgICAgfSwgdGhpcy5vcHRpb25zKTtcbiAgICB9XG4gICAgc3RhdGljIHRvSEVYT2JqZWN0KGNvbG9yKSB7XG4gICAgICAgIGNvbnN0IG1vZGVsID0gZ2V0Q29sb3JNb2RlbChjb2xvcik7XG4gICAgICAgIHJldHVybiBnZXRDb2xvclJldHVybihjb2xvciwgbW9kZWwsIDAsIHV0aWxzLnRyYW5zbGF0ZUNvbG9yLkhFWCk7XG4gICAgfVxuICAgIHN0YXRpYyB0b0hFWChjb2xvcikge1xuICAgICAgICByZXR1cm4gQ1NTLkhFWChDb2xvclRyYW5zbGF0b3IudG9IRVhPYmplY3QoY29sb3IpKTtcbiAgICB9XG4gICAgc3RhdGljIHRvSEVYQU9iamVjdChjb2xvcikge1xuICAgICAgICBjb25zdCBtb2RlbCA9IGdldENvbG9yTW9kZWwoY29sb3IpO1xuICAgICAgICByZXR1cm4gZ2V0Q29sb3JSZXR1cm4oY29sb3IsIG1vZGVsLCAwLCB1dGlscy50cmFuc2xhdGVDb2xvci5IRVhBKTtcbiAgICB9XG4gICAgc3RhdGljIHRvSEVYQShjb2xvcikge1xuICAgICAgICByZXR1cm4gQ1NTLkhFWChDb2xvclRyYW5zbGF0b3IudG9IRVhBT2JqZWN0KGNvbG9yKSk7XG4gICAgfVxuICAgIHN0YXRpYyB0b1JHQk9iamVjdChjb2xvciwgb3B0aW9ucyA9IHt9KSB7XG4gICAgICAgIGNvbnN0IG1vZGVsID0gZ2V0Q29sb3JNb2RlbChjb2xvcik7XG4gICAgICAgIHJldHVybiBnZXRDb2xvclJldHVybihjb2xvciwgbW9kZWwsIG9wdGlvbnMuZGVjaW1hbHMsIHV0aWxzLnRyYW5zbGF0ZUNvbG9yLlJHQik7XG4gICAgfVxuICAgIHN0YXRpYyB0b1JHQihjb2xvciwgb3B0aW9ucyA9IHt9KSB7XG4gICAgICAgIGNvbnN0IHJnYiA9IENvbG9yVHJhbnNsYXRvci50b1JHQk9iamVjdChjb2xvciwgb3B0aW9ucyk7XG4gICAgICAgIGNvbnN0IGRldGVjdGVkT3B0aW9ucyA9IGdldE9wdGlvbnNGcm9tQ29sb3JJbnB1dChvcHRpb25zLCBjb2xvcik7XG4gICAgICAgIHJldHVybiBDU1MuUkdCKHJnYiwgZGV0ZWN0ZWRPcHRpb25zKTtcbiAgICB9XG4gICAgc3RhdGljIHRvUkdCQU9iamVjdChjb2xvciwgb3B0aW9ucyA9IHt9KSB7XG4gICAgICAgIGNvbnN0IG1vZGVsID0gZ2V0Q29sb3JNb2RlbChjb2xvcik7XG4gICAgICAgIHJldHVybiBnZXRDb2xvclJldHVybihjb2xvciwgbW9kZWwsIG9wdGlvbnMuZGVjaW1hbHMsIHV0aWxzLnRyYW5zbGF0ZUNvbG9yLlJHQkEpO1xuICAgIH1cbiAgICBzdGF0aWMgdG9SR0JBKGNvbG9yLCBvcHRpb25zID0ge30pIHtcbiAgICAgICAgY29uc3QgcmdiYSA9IENvbG9yVHJhbnNsYXRvci50b1JHQkFPYmplY3QoY29sb3IsIG9wdGlvbnMpO1xuICAgICAgICBjb25zdCBkZXRlY3RlZE9wdGlvbnMgPSBnZXRPcHRpb25zRnJvbUNvbG9ySW5wdXQob3B0aW9ucywgY29sb3IpO1xuICAgICAgICByZXR1cm4gQ1NTLlJHQihyZ2JhLCBkZXRlY3RlZE9wdGlvbnMpO1xuICAgIH1cbiAgICBzdGF0aWMgdG9IU0xPYmplY3QoY29sb3IsIG9wdGlvbnMgPSB7fSkge1xuICAgICAgICBjb25zdCBtb2RlbCA9IGdldENvbG9yTW9kZWwoY29sb3IpO1xuICAgICAgICByZXR1cm4gZ2V0Q29sb3JSZXR1cm4oY29sb3IsIG1vZGVsLCBvcHRpb25zLmRlY2ltYWxzLCB1dGlscy50cmFuc2xhdGVDb2xvci5IU0wpO1xuICAgIH1cbiAgICBzdGF0aWMgdG9IU0woY29sb3IsIG9wdGlvbnMgPSB7fSkge1xuICAgICAgICBjb25zdCBoc2wgPSBDb2xvclRyYW5zbGF0b3IudG9IU0xPYmplY3QoY29sb3IsIG9wdGlvbnMpO1xuICAgICAgICBjb25zdCBkZXRlY3RlZE9wdGlvbnMgPSBnZXRPcHRpb25zRnJvbUNvbG9ySW5wdXQob3B0aW9ucywgY29sb3IpO1xuICAgICAgICByZXR1cm4gQ1NTLkhTTChoc2wsIGRldGVjdGVkT3B0aW9ucyk7XG4gICAgfVxuICAgIHN0YXRpYyB0b0hTTEFPYmplY3QoY29sb3IsIG9wdGlvbnMgPSB7fSkge1xuICAgICAgICBjb25zdCBtb2RlbCA9IGdldENvbG9yTW9kZWwoY29sb3IpO1xuICAgICAgICByZXR1cm4gZ2V0Q29sb3JSZXR1cm4oY29sb3IsIG1vZGVsLCBvcHRpb25zLmRlY2ltYWxzLCB1dGlscy50cmFuc2xhdGVDb2xvci5IU0xBKTtcbiAgICB9XG4gICAgc3RhdGljIHRvSFNMQShjb2xvciwgb3B0aW9ucyA9IHt9KSB7XG4gICAgICAgIGNvbnN0IGhzbGEgPSBDb2xvclRyYW5zbGF0b3IudG9IU0xBT2JqZWN0KGNvbG9yLCBvcHRpb25zKTtcbiAgICAgICAgY29uc3QgZGV0ZWN0ZWRPcHRpb25zID0gZ2V0T3B0aW9uc0Zyb21Db2xvcklucHV0KG9wdGlvbnMsIGNvbG9yKTtcbiAgICAgICAgcmV0dXJuIENTUy5IU0woaHNsYSwgZGV0ZWN0ZWRPcHRpb25zKTtcbiAgICB9XG4gICAgc3RhdGljIHRvSFdCT2JqZWN0KGNvbG9yLCBvcHRpb25zID0ge30pIHtcbiAgICAgICAgY29uc3QgbW9kZWwgPSBnZXRDb2xvck1vZGVsKGNvbG9yKTtcbiAgICAgICAgcmV0dXJuIGdldENvbG9yUmV0dXJuKGNvbG9yLCBtb2RlbCwgb3B0aW9ucy5kZWNpbWFscywgdXRpbHMudHJhbnNsYXRlQ29sb3IuSFdCKTtcbiAgICB9XG4gICAgc3RhdGljIHRvSFdCKGNvbG9yLCBvcHRpb25zID0ge30pIHtcbiAgICAgICAgY29uc3QgaHdiID0gQ29sb3JUcmFuc2xhdG9yLnRvSFdCT2JqZWN0KGNvbG9yLCBvcHRpb25zKTtcbiAgICAgICAgY29uc3QgZGV0ZWN0ZWRPcHRpb25zID0gZ2V0T3B0aW9uc0Zyb21Db2xvcklucHV0KG9wdGlvbnMsIGNvbG9yKTtcbiAgICAgICAgcmV0dXJuIENTUy5IV0IoaHdiLCBkZXRlY3RlZE9wdGlvbnMpO1xuICAgIH1cbiAgICBzdGF0aWMgdG9IV0JBT2JqZWN0KGNvbG9yLCBvcHRpb25zID0ge30pIHtcbiAgICAgICAgY29uc3QgbW9kZWwgPSBnZXRDb2xvck1vZGVsKGNvbG9yKTtcbiAgICAgICAgcmV0dXJuIGdldENvbG9yUmV0dXJuKGNvbG9yLCBtb2RlbCwgb3B0aW9ucy5kZWNpbWFscywgdXRpbHMudHJhbnNsYXRlQ29sb3IuSFdCQSk7XG4gICAgfVxuICAgIHN0YXRpYyB0b0hXQkEoY29sb3IsIG9wdGlvbnMgPSB7fSkge1xuICAgICAgICBjb25zdCBod2IgPSBDb2xvclRyYW5zbGF0b3IudG9IV0JBT2JqZWN0KGNvbG9yLCBvcHRpb25zKTtcbiAgICAgICAgY29uc3QgZGV0ZWN0ZWRPcHRpb25zID0gZ2V0T3B0aW9uc0Zyb21Db2xvcklucHV0KG9wdGlvbnMsIGNvbG9yKTtcbiAgICAgICAgcmV0dXJuIENTUy5IV0IoaHdiLCBkZXRlY3RlZE9wdGlvbnMpO1xuICAgIH1cbiAgICBzdGF0aWMgdG9DSUVMYWJPYmplY3QoY29sb3IsIG9wdGlvbnMgPSB7fSkge1xuICAgICAgICBjb25zdCBtb2RlbCA9IGdldENvbG9yTW9kZWwoY29sb3IpO1xuICAgICAgICByZXR1cm4gZ2V0Q29sb3JSZXR1cm4oY29sb3IsIG1vZGVsLCBvcHRpb25zLmRlY2ltYWxzLCB1dGlscy50cmFuc2xhdGVDb2xvci5DSUVMYWIpO1xuICAgIH1cbiAgICBzdGF0aWMgdG9DSUVMYWIoY29sb3IsIG9wdGlvbnMgPSB7fSkge1xuICAgICAgICBjb25zdCBsYWIgPSBDb2xvclRyYW5zbGF0b3IudG9DSUVMYWJPYmplY3QoY29sb3IsIG9wdGlvbnMpO1xuICAgICAgICBjb25zdCBkZXRlY3RlZE9wdGlvbnMgPSBnZXRPcHRpb25zRnJvbUNvbG9ySW5wdXQob3B0aW9ucywgY29sb3IpO1xuICAgICAgICByZXR1cm4gQ1NTLkNJRUxhYihsYWIsIGRldGVjdGVkT3B0aW9ucyk7XG4gICAgfVxuICAgIHN0YXRpYyB0b0NJRUxhYkFPYmplY3QoY29sb3IsIG9wdGlvbnMgPSB7fSkge1xuICAgICAgICBjb25zdCBtb2RlbCA9IGdldENvbG9yTW9kZWwoY29sb3IpO1xuICAgICAgICByZXR1cm4gZ2V0Q29sb3JSZXR1cm4oY29sb3IsIG1vZGVsLCBvcHRpb25zLmRlY2ltYWxzLCB1dGlscy50cmFuc2xhdGVDb2xvci5DSUVMYWJBKTtcbiAgICB9XG4gICAgc3RhdGljIHRvQ0lFTGFiQShjb2xvciwgb3B0aW9ucyA9IHt9KSB7XG4gICAgICAgIGNvbnN0IGxhYiA9IENvbG9yVHJhbnNsYXRvci50b0NJRUxhYkFPYmplY3QoY29sb3IsIG9wdGlvbnMpO1xuICAgICAgICBjb25zdCBkZXRlY3RlZE9wdGlvbnMgPSBnZXRPcHRpb25zRnJvbUNvbG9ySW5wdXQob3B0aW9ucywgY29sb3IpO1xuICAgICAgICByZXR1cm4gQ1NTLkNJRUxhYihsYWIsIGRldGVjdGVkT3B0aW9ucyk7XG4gICAgfVxuICAgIHN0YXRpYyB0b0xDSE9iamVjdChjb2xvciwgb3B0aW9ucyA9IHt9KSB7XG4gICAgICAgIGNvbnN0IG1vZGVsID0gZ2V0Q29sb3JNb2RlbChjb2xvcik7XG4gICAgICAgIHJldHVybiBnZXRDb2xvclJldHVybihjb2xvciwgbW9kZWwsIG9wdGlvbnMuZGVjaW1hbHMsIHV0aWxzLnRyYW5zbGF0ZUNvbG9yLkxDSCk7XG4gICAgfVxuICAgIHN0YXRpYyB0b0xDSChjb2xvciwgb3B0aW9ucyA9IHt9KSB7XG4gICAgICAgIGNvbnN0IGxjaCA9IENvbG9yVHJhbnNsYXRvci50b0xDSE9iamVjdChjb2xvciwgb3B0aW9ucyk7XG4gICAgICAgIGNvbnN0IGRldGVjdGVkT3B0aW9ucyA9IGdldE9wdGlvbnNGcm9tQ29sb3JJbnB1dChvcHRpb25zLCBjb2xvcik7XG4gICAgICAgIHJldHVybiBDU1MuTENIKGxjaCwgZGV0ZWN0ZWRPcHRpb25zKTtcbiAgICB9XG4gICAgc3RhdGljIHRvTENIQU9iamVjdChjb2xvciwgb3B0aW9ucyA9IHt9KSB7XG4gICAgICAgIGNvbnN0IG1vZGVsID0gZ2V0Q29sb3JNb2RlbChjb2xvcik7XG4gICAgICAgIHJldHVybiBnZXRDb2xvclJldHVybihjb2xvciwgbW9kZWwsIG9wdGlvbnMuZGVjaW1hbHMsIHV0aWxzLnRyYW5zbGF0ZUNvbG9yLkxDSEEpO1xuICAgIH1cbiAgICBzdGF0aWMgdG9MQ0hBKGNvbG9yLCBvcHRpb25zID0ge30pIHtcbiAgICAgICAgY29uc3QgbGNoID0gQ29sb3JUcmFuc2xhdG9yLnRvTENIQU9iamVjdChjb2xvciwgb3B0aW9ucyk7XG4gICAgICAgIGNvbnN0IGRldGVjdGVkT3B0aW9ucyA9IGdldE9wdGlvbnNGcm9tQ29sb3JJbnB1dChvcHRpb25zLCBjb2xvcik7XG4gICAgICAgIHJldHVybiBDU1MuTENIKGxjaCwgZGV0ZWN0ZWRPcHRpb25zKTtcbiAgICB9XG4gICAgc3RhdGljIHRvQ01ZS09iamVjdChjb2xvciwgb3B0aW9ucyA9IHt9KSB7XG4gICAgICAgIGNvbnN0IG1vZGVsID0gZ2V0Q29sb3JNb2RlbChjb2xvcik7XG4gICAgICAgIHJldHVybiBnZXRDb2xvclJldHVybihjb2xvciwgbW9kZWwsIG9wdGlvbnMuZGVjaW1hbHMsIHV0aWxzLnRyYW5zbGF0ZUNvbG9yLkNNWUspO1xuICAgIH1cbiAgICBzdGF0aWMgdG9DTVlLKGNvbG9yLCBvcHRpb25zID0ge30pIHtcbiAgICAgICAgY29uc3QgY215ayA9IENvbG9yVHJhbnNsYXRvci50b0NNWUtPYmplY3QoY29sb3IsIG9wdGlvbnMpO1xuICAgICAgICBjb25zdCBkZXRlY3RlZE9wdGlvbnMgPSBnZXRPcHRpb25zRnJvbUNvbG9ySW5wdXQob3B0aW9ucywgY29sb3IpO1xuICAgICAgICByZXR1cm4gQ1NTLkNNWUsoY215aywgZGV0ZWN0ZWRPcHRpb25zKTtcbiAgICB9XG4gICAgc3RhdGljIHRvQ01ZS0FPYmplY3QoY29sb3IsIG9wdGlvbnMgPSB7fSkge1xuICAgICAgICBjb25zdCBtb2RlbCA9IGdldENvbG9yTW9kZWwoY29sb3IpO1xuICAgICAgICByZXR1cm4gZ2V0Q29sb3JSZXR1cm4oY29sb3IsIG1vZGVsLCBvcHRpb25zLmRlY2ltYWxzLCB1dGlscy50cmFuc2xhdGVDb2xvci5DTVlLQSk7XG4gICAgfVxuICAgIHN0YXRpYyB0b0NNWUtBKGNvbG9yLCBvcHRpb25zID0ge30pIHtcbiAgICAgICAgY29uc3QgY215a2EgPSBDb2xvclRyYW5zbGF0b3IudG9DTVlLQU9iamVjdChjb2xvciwgb3B0aW9ucyk7XG4gICAgICAgIGNvbnN0IGRldGVjdGVkT3B0aW9ucyA9IGdldE9wdGlvbnNGcm9tQ29sb3JJbnB1dChvcHRpb25zLCBjb2xvcik7XG4gICAgICAgIHJldHVybiBDU1MuQ01ZSyhjbXlrYSwgZGV0ZWN0ZWRPcHRpb25zKTtcbiAgICB9XG4gICAgc3RhdGljIGdldEJsZW5kSEVYT2JqZWN0KGZyb20sIHRvLCBzdGVwcyA9IERFRkFVTFRfQkxFTkRfU1RFUFMpIHtcbiAgICAgICAgcmV0dXJuIGdldEJsZW5kUmV0dXJuKGZyb20sIHRvLCBzdGVwcywgMCwgdXRpbHMudHJhbnNsYXRlQ29sb3IuSEVYKTtcbiAgICB9XG4gICAgc3RhdGljIGdldEJsZW5kSEVYKGZyb20sIHRvLCBzdGVwcyA9IERFRkFVTFRfQkxFTkRfU1RFUFMpIHtcbiAgICAgICAgcmV0dXJuIENvbG9yVHJhbnNsYXRvci5nZXRCbGVuZEhFWE9iamVjdChmcm9tLCB0bywgc3RlcHMpXG4gICAgICAgICAgICAubWFwKChjb2xvcikgPT4gQ1NTLkhFWChjb2xvcikpO1xuICAgIH1cbiAgICBzdGF0aWMgZ2V0QmxlbmRIRVhBT2JqZWN0KGZyb20sIHRvLCBzdGVwcyA9IERFRkFVTFRfQkxFTkRfU1RFUFMpIHtcbiAgICAgICAgcmV0dXJuIGdldEJsZW5kUmV0dXJuKGZyb20sIHRvLCBzdGVwcywgMCwgdXRpbHMudHJhbnNsYXRlQ29sb3IuSEVYQSk7XG4gICAgfVxuICAgIHN0YXRpYyBnZXRCbGVuZEhFWEEoZnJvbSwgdG8sIHN0ZXBzID0gREVGQVVMVF9CTEVORF9TVEVQUykge1xuICAgICAgICByZXR1cm4gQ29sb3JUcmFuc2xhdG9yLmdldEJsZW5kSEVYQU9iamVjdChmcm9tLCB0bywgc3RlcHMpXG4gICAgICAgICAgICAubWFwKChjb2xvcikgPT4gQ1NTLkhFWChjb2xvcikpO1xuICAgIH1cbiAgICBzdGF0aWMgZ2V0QmxlbmRSR0JPYmplY3QoZnJvbSwgdG8sIHRoaXJkUGFyYW1ldGVyLCBmb3VydGhQYXJhbWV0ZXIpIHtcbiAgICAgICAgcmV0dXJuIGdldEJsZW5kUmV0dXJuV2l0aFBhcmFtZXRlcnMoe1xuICAgICAgICAgICAgZnJvbSxcbiAgICAgICAgICAgIHRvLFxuICAgICAgICAgICAgdGhpcmRQYXJhbWV0ZXIsXG4gICAgICAgICAgICBmb3VydGhQYXJhbWV0ZXIsXG4gICAgICAgICAgICB0cmFuc2xhdGVGdW5jdGlvbjogdXRpbHMudHJhbnNsYXRlQ29sb3IuUkdCXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBzdGF0aWMgZ2V0QmxlbmRSR0IoZnJvbSwgdG8sIHRoaXJkUGFyYW1ldGVyLCBmb3VydGhQYXJhbWV0ZXIpIHtcbiAgICAgICAgcmV0dXJuIGdldEJsZW5kUmV0dXJuV2l0aFBhcmFtZXRlcnMoe1xuICAgICAgICAgICAgZnJvbSxcbiAgICAgICAgICAgIHRvLFxuICAgICAgICAgICAgdGhpcmRQYXJhbWV0ZXIsXG4gICAgICAgICAgICBmb3VydGhQYXJhbWV0ZXIsXG4gICAgICAgICAgICB0cmFuc2xhdGVGdW5jdGlvbjogdXRpbHMudHJhbnNsYXRlQ29sb3IuUkdCLFxuICAgICAgICAgICAgY3NzRnVuY3Rpb246IENTUy5SR0JcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHN0YXRpYyBnZXRCbGVuZFJHQkFPYmplY3QoZnJvbSwgdG8sIHRoaXJkUGFyYW1ldGVyLCBmb3VydGhQYXJhbWV0ZXIpIHtcbiAgICAgICAgcmV0dXJuIGdldEJsZW5kUmV0dXJuV2l0aFBhcmFtZXRlcnMoe1xuICAgICAgICAgICAgZnJvbSxcbiAgICAgICAgICAgIHRvLFxuICAgICAgICAgICAgdGhpcmRQYXJhbWV0ZXIsXG4gICAgICAgICAgICBmb3VydGhQYXJhbWV0ZXIsXG4gICAgICAgICAgICB0cmFuc2xhdGVGdW5jdGlvbjogdXRpbHMudHJhbnNsYXRlQ29sb3IuUkdCQVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgc3RhdGljIGdldEJsZW5kUkdCQShmcm9tLCB0bywgdGhpcmRQYXJhbWV0ZXIsIGZvdXJ0aFBhcmFtZXRlcikge1xuICAgICAgICByZXR1cm4gZ2V0QmxlbmRSZXR1cm5XaXRoUGFyYW1ldGVycyh7XG4gICAgICAgICAgICBmcm9tLFxuICAgICAgICAgICAgdG8sXG4gICAgICAgICAgICB0aGlyZFBhcmFtZXRlcixcbiAgICAgICAgICAgIGZvdXJ0aFBhcmFtZXRlcixcbiAgICAgICAgICAgIHRyYW5zbGF0ZUZ1bmN0aW9uOiB1dGlscy50cmFuc2xhdGVDb2xvci5SR0JBLFxuICAgICAgICAgICAgY3NzRnVuY3Rpb246IENTUy5SR0JcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHN0YXRpYyBnZXRCbGVuZEhTTE9iamVjdChmcm9tLCB0bywgdGhpcmRQYXJhbWV0ZXIsIGZvdXJ0aFBhcmFtZXRlcikge1xuICAgICAgICByZXR1cm4gZ2V0QmxlbmRSZXR1cm5XaXRoUGFyYW1ldGVycyh7XG4gICAgICAgICAgICBmcm9tLFxuICAgICAgICAgICAgdG8sXG4gICAgICAgICAgICB0aGlyZFBhcmFtZXRlcixcbiAgICAgICAgICAgIGZvdXJ0aFBhcmFtZXRlcixcbiAgICAgICAgICAgIHRyYW5zbGF0ZUZ1bmN0aW9uOiB1dGlscy50cmFuc2xhdGVDb2xvci5IU0xcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHN0YXRpYyBnZXRCbGVuZEhTTChmcm9tLCB0bywgdGhpcmRQYXJhbWV0ZXIsIGZvdXJ0aFBhcmFtZXRlcikge1xuICAgICAgICByZXR1cm4gZ2V0QmxlbmRSZXR1cm5XaXRoUGFyYW1ldGVycyh7XG4gICAgICAgICAgICBmcm9tLFxuICAgICAgICAgICAgdG8sXG4gICAgICAgICAgICB0aGlyZFBhcmFtZXRlcixcbiAgICAgICAgICAgIGZvdXJ0aFBhcmFtZXRlcixcbiAgICAgICAgICAgIHRyYW5zbGF0ZUZ1bmN0aW9uOiB1dGlscy50cmFuc2xhdGVDb2xvci5IU0wsXG4gICAgICAgICAgICBjc3NGdW5jdGlvbjogQ1NTLkhTTFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgc3RhdGljIGdldEJsZW5kSFNMQU9iamVjdChmcm9tLCB0bywgdGhpcmRQYXJhbWV0ZXIsIGZvdXJ0aFBhcmFtZXRlcikge1xuICAgICAgICByZXR1cm4gZ2V0QmxlbmRSZXR1cm5XaXRoUGFyYW1ldGVycyh7XG4gICAgICAgICAgICBmcm9tLFxuICAgICAgICAgICAgdG8sXG4gICAgICAgICAgICB0aGlyZFBhcmFtZXRlcixcbiAgICAgICAgICAgIGZvdXJ0aFBhcmFtZXRlcixcbiAgICAgICAgICAgIHRyYW5zbGF0ZUZ1bmN0aW9uOiB1dGlscy50cmFuc2xhdGVDb2xvci5IU0xBXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBzdGF0aWMgZ2V0QmxlbmRIU0xBKGZyb20sIHRvLCB0aGlyZFBhcmFtZXRlciwgZm91cnRoUGFyYW1ldGVyKSB7XG4gICAgICAgIHJldHVybiBnZXRCbGVuZFJldHVybldpdGhQYXJhbWV0ZXJzKHtcbiAgICAgICAgICAgIGZyb20sXG4gICAgICAgICAgICB0byxcbiAgICAgICAgICAgIHRoaXJkUGFyYW1ldGVyLFxuICAgICAgICAgICAgZm91cnRoUGFyYW1ldGVyLFxuICAgICAgICAgICAgdHJhbnNsYXRlRnVuY3Rpb246IHV0aWxzLnRyYW5zbGF0ZUNvbG9yLkhTTEEsXG4gICAgICAgICAgICBjc3NGdW5jdGlvbjogQ1NTLkhTTFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgc3RhdGljIGdldEJsZW5kSFdCT2JqZWN0KGZyb20sIHRvLCB0aGlyZFBhcmFtZXRlciwgZm91cnRoUGFyYW1ldGVyKSB7XG4gICAgICAgIHJldHVybiBnZXRCbGVuZFJldHVybldpdGhQYXJhbWV0ZXJzKHtcbiAgICAgICAgICAgIGZyb20sXG4gICAgICAgICAgICB0byxcbiAgICAgICAgICAgIHRoaXJkUGFyYW1ldGVyLFxuICAgICAgICAgICAgZm91cnRoUGFyYW1ldGVyLFxuICAgICAgICAgICAgdHJhbnNsYXRlRnVuY3Rpb246IHV0aWxzLnRyYW5zbGF0ZUNvbG9yLkhXQlxuICAgICAgICB9KTtcbiAgICB9XG4gICAgc3RhdGljIGdldEJsZW5kSFdCKGZyb20sIHRvLCB0aGlyZFBhcmFtZXRlciwgZm91cnRoUGFyYW1ldGVyKSB7XG4gICAgICAgIHJldHVybiBnZXRCbGVuZFJldHVybldpdGhQYXJhbWV0ZXJzKHtcbiAgICAgICAgICAgIGZyb20sXG4gICAgICAgICAgICB0byxcbiAgICAgICAgICAgIHRoaXJkUGFyYW1ldGVyLFxuICAgICAgICAgICAgZm91cnRoUGFyYW1ldGVyLFxuICAgICAgICAgICAgdHJhbnNsYXRlRnVuY3Rpb246IHV0aWxzLnRyYW5zbGF0ZUNvbG9yLkhXQixcbiAgICAgICAgICAgIGNzc0Z1bmN0aW9uOiBDU1MuSFdCXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBzdGF0aWMgZ2V0QmxlbmRIV0JBT2JqZWN0KGZyb20sIHRvLCB0aGlyZFBhcmFtZXRlciwgZm91cnRoUGFyYW1ldGVyKSB7XG4gICAgICAgIHJldHVybiBnZXRCbGVuZFJldHVybldpdGhQYXJhbWV0ZXJzKHtcbiAgICAgICAgICAgIGZyb20sXG4gICAgICAgICAgICB0byxcbiAgICAgICAgICAgIHRoaXJkUGFyYW1ldGVyLFxuICAgICAgICAgICAgZm91cnRoUGFyYW1ldGVyLFxuICAgICAgICAgICAgdHJhbnNsYXRlRnVuY3Rpb246IHV0aWxzLnRyYW5zbGF0ZUNvbG9yLkhXQkFcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHN0YXRpYyBnZXRCbGVuZEhXQkEoZnJvbSwgdG8sIHRoaXJkUGFyYW1ldGVyLCBmb3VydGhQYXJhbWV0ZXIpIHtcbiAgICAgICAgcmV0dXJuIGdldEJsZW5kUmV0dXJuV2l0aFBhcmFtZXRlcnMoe1xuICAgICAgICAgICAgZnJvbSxcbiAgICAgICAgICAgIHRvLFxuICAgICAgICAgICAgdGhpcmRQYXJhbWV0ZXIsXG4gICAgICAgICAgICBmb3VydGhQYXJhbWV0ZXIsXG4gICAgICAgICAgICB0cmFuc2xhdGVGdW5jdGlvbjogdXRpbHMudHJhbnNsYXRlQ29sb3IuSFdCQSxcbiAgICAgICAgICAgIGNzc0Z1bmN0aW9uOiBDU1MuSFdCXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBzdGF0aWMgZ2V0QmxlbmRDSUVMYWJPYmplY3QoZnJvbSwgdG8sIHRoaXJkUGFyYW1ldGVyLCBmb3VydGhQYXJhbWV0ZXIpIHtcbiAgICAgICAgcmV0dXJuIGdldEJsZW5kUmV0dXJuV2l0aFBhcmFtZXRlcnMoe1xuICAgICAgICAgICAgZnJvbSxcbiAgICAgICAgICAgIHRvLFxuICAgICAgICAgICAgdGhpcmRQYXJhbWV0ZXIsXG4gICAgICAgICAgICBmb3VydGhQYXJhbWV0ZXIsXG4gICAgICAgICAgICB0cmFuc2xhdGVGdW5jdGlvbjogdXRpbHMudHJhbnNsYXRlQ29sb3IuQ0lFTGFiXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBzdGF0aWMgZ2V0QmxlbmRDSUVMYWIoZnJvbSwgdG8sIHRoaXJkUGFyYW1ldGVyLCBmb3VydGhQYXJhbWV0ZXIpIHtcbiAgICAgICAgcmV0dXJuIGdldEJsZW5kUmV0dXJuV2l0aFBhcmFtZXRlcnMoe1xuICAgICAgICAgICAgZnJvbSxcbiAgICAgICAgICAgIHRvLFxuICAgICAgICAgICAgdGhpcmRQYXJhbWV0ZXIsXG4gICAgICAgICAgICBmb3VydGhQYXJhbWV0ZXIsXG4gICAgICAgICAgICB0cmFuc2xhdGVGdW5jdGlvbjogdXRpbHMudHJhbnNsYXRlQ29sb3IuQ0lFTGFiLFxuICAgICAgICAgICAgY3NzRnVuY3Rpb246IENTUy5DSUVMYWJcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHN0YXRpYyBnZXRCbGVuZENJRUxhYkFPYmplY3QoZnJvbSwgdG8sIHRoaXJkUGFyYW1ldGVyLCBmb3VydGhQYXJhbWV0ZXIpIHtcbiAgICAgICAgcmV0dXJuIGdldEJsZW5kUmV0dXJuV2l0aFBhcmFtZXRlcnMoe1xuICAgICAgICAgICAgZnJvbSxcbiAgICAgICAgICAgIHRvLFxuICAgICAgICAgICAgdGhpcmRQYXJhbWV0ZXIsXG4gICAgICAgICAgICBmb3VydGhQYXJhbWV0ZXIsXG4gICAgICAgICAgICB0cmFuc2xhdGVGdW5jdGlvbjogdXRpbHMudHJhbnNsYXRlQ29sb3IuQ0lFTGFiQVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgc3RhdGljIGdldEJsZW5kQ0lFTGFiQShmcm9tLCB0bywgdGhpcmRQYXJhbWV0ZXIsIGZvdXJ0aFBhcmFtZXRlcikge1xuICAgICAgICByZXR1cm4gZ2V0QmxlbmRSZXR1cm5XaXRoUGFyYW1ldGVycyh7XG4gICAgICAgICAgICBmcm9tLFxuICAgICAgICAgICAgdG8sXG4gICAgICAgICAgICB0aGlyZFBhcmFtZXRlcixcbiAgICAgICAgICAgIGZvdXJ0aFBhcmFtZXRlcixcbiAgICAgICAgICAgIHRyYW5zbGF0ZUZ1bmN0aW9uOiB1dGlscy50cmFuc2xhdGVDb2xvci5DSUVMYWJBLFxuICAgICAgICAgICAgY3NzRnVuY3Rpb246IENTUy5DSUVMYWJcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHN0YXRpYyBnZXRCbGVuZExDSE9iamVjdChmcm9tLCB0bywgdGhpcmRQYXJhbWV0ZXIsIGZvdXJ0aFBhcmFtZXRlcikge1xuICAgICAgICByZXR1cm4gZ2V0QmxlbmRSZXR1cm5XaXRoUGFyYW1ldGVycyh7XG4gICAgICAgICAgICBmcm9tLFxuICAgICAgICAgICAgdG8sXG4gICAgICAgICAgICB0aGlyZFBhcmFtZXRlcixcbiAgICAgICAgICAgIGZvdXJ0aFBhcmFtZXRlcixcbiAgICAgICAgICAgIHRyYW5zbGF0ZUZ1bmN0aW9uOiB1dGlscy50cmFuc2xhdGVDb2xvci5MQ0hcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHN0YXRpYyBnZXRCbGVuZExDSChmcm9tLCB0bywgdGhpcmRQYXJhbWV0ZXIsIGZvdXJ0aFBhcmFtZXRlcikge1xuICAgICAgICByZXR1cm4gZ2V0QmxlbmRSZXR1cm5XaXRoUGFyYW1ldGVycyh7XG4gICAgICAgICAgICBmcm9tLFxuICAgICAgICAgICAgdG8sXG4gICAgICAgICAgICB0aGlyZFBhcmFtZXRlcixcbiAgICAgICAgICAgIGZvdXJ0aFBhcmFtZXRlcixcbiAgICAgICAgICAgIHRyYW5zbGF0ZUZ1bmN0aW9uOiB1dGlscy50cmFuc2xhdGVDb2xvci5MQ0gsXG4gICAgICAgICAgICBjc3NGdW5jdGlvbjogQ1NTLkxDSFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgc3RhdGljIGdldEJsZW5kTENIQU9iamVjdChmcm9tLCB0bywgdGhpcmRQYXJhbWV0ZXIsIGZvdXJ0aFBhcmFtZXRlcikge1xuICAgICAgICByZXR1cm4gZ2V0QmxlbmRSZXR1cm5XaXRoUGFyYW1ldGVycyh7XG4gICAgICAgICAgICBmcm9tLFxuICAgICAgICAgICAgdG8sXG4gICAgICAgICAgICB0aGlyZFBhcmFtZXRlcixcbiAgICAgICAgICAgIGZvdXJ0aFBhcmFtZXRlcixcbiAgICAgICAgICAgIHRyYW5zbGF0ZUZ1bmN0aW9uOiB1dGlscy50cmFuc2xhdGVDb2xvci5MQ0hBXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBzdGF0aWMgZ2V0QmxlbmRMQ0hBKGZyb20sIHRvLCB0aGlyZFBhcmFtZXRlciwgZm91cnRoUGFyYW1ldGVyKSB7XG4gICAgICAgIHJldHVybiBnZXRCbGVuZFJldHVybldpdGhQYXJhbWV0ZXJzKHtcbiAgICAgICAgICAgIGZyb20sXG4gICAgICAgICAgICB0byxcbiAgICAgICAgICAgIHRoaXJkUGFyYW1ldGVyLFxuICAgICAgICAgICAgZm91cnRoUGFyYW1ldGVyLFxuICAgICAgICAgICAgdHJhbnNsYXRlRnVuY3Rpb246IHV0aWxzLnRyYW5zbGF0ZUNvbG9yLkxDSEEsXG4gICAgICAgICAgICBjc3NGdW5jdGlvbjogQ1NTLkxDSFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgc3RhdGljIGdldE1peEhFWE9iamVjdChjb2xvcnMsIG1vZGUgPSBNaXguQURESVRJVkUpIHtcbiAgICAgICAgcmV0dXJuIHV0aWxzLmNvbG9yTWl4ZXIuSEVYKGNvbG9ycywgbW9kZSwgZmFsc2UpO1xuICAgIH1cbiAgICBzdGF0aWMgZ2V0TWl4SEVYKGNvbG9ycywgbW9kZSA9IE1peC5BRERJVElWRSkge1xuICAgICAgICByZXR1cm4gdXRpbHMuY29sb3JNaXhlci5IRVgoY29sb3JzLCBtb2RlLCB0cnVlKTtcbiAgICB9XG4gICAgc3RhdGljIGdldE1peEhFWEFPYmplY3QoY29sb3JzLCBtb2RlID0gTWl4LkFERElUSVZFKSB7XG4gICAgICAgIHJldHVybiB1dGlscy5jb2xvck1peGVyLkhFWEEoY29sb3JzLCBtb2RlLCBmYWxzZSk7XG4gICAgfVxuICAgIHN0YXRpYyBnZXRNaXhIRVhBKGNvbG9ycywgbW9kZSA9IE1peC5BRERJVElWRSkge1xuICAgICAgICByZXR1cm4gdXRpbHMuY29sb3JNaXhlci5IRVhBKGNvbG9ycywgbW9kZSwgdHJ1ZSk7XG4gICAgfVxuICAgIHN0YXRpYyBnZXRNaXhSR0JPYmplY3QoY29sb3JzLCBzZWNvbmRQYXJhbWV0ZXIsIHRoaXJkUGFyYW1ldGVyKSB7XG4gICAgICAgIHJldHVybiBnZXRNaXhSZXR1cm4oe1xuICAgICAgICAgICAgY29sb3JzLFxuICAgICAgICAgICAgc2Vjb25kUGFyYW1ldGVyLFxuICAgICAgICAgICAgdGhpcmRQYXJhbWV0ZXIsXG4gICAgICAgICAgICBjb2xvck1peGVyRnVuY3Rpb246IGJpbmRlZE1peGVycy5SR0IsXG4gICAgICAgICAgICBjc3M6IGZhbHNlXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBzdGF0aWMgZ2V0TWl4UkdCKGNvbG9ycywgc2Vjb25kUGFyYW1ldGVyLCB0aGlyZFBhcmFtZXRlcikge1xuICAgICAgICByZXR1cm4gZ2V0TWl4UmV0dXJuKHtcbiAgICAgICAgICAgIGNvbG9ycyxcbiAgICAgICAgICAgIHNlY29uZFBhcmFtZXRlcixcbiAgICAgICAgICAgIHRoaXJkUGFyYW1ldGVyLFxuICAgICAgICAgICAgY29sb3JNaXhlckZ1bmN0aW9uOiBiaW5kZWRNaXhlcnMuUkdCLFxuICAgICAgICAgICAgY3NzOiB0cnVlXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBzdGF0aWMgZ2V0TWl4UkdCQU9iamVjdChjb2xvcnMsIHNlY29uZFBhcmFtZXRlciwgdGhpcmRQYXJhbWV0ZXIpIHtcbiAgICAgICAgcmV0dXJuIGdldE1peFJldHVybih7XG4gICAgICAgICAgICBjb2xvcnMsXG4gICAgICAgICAgICBzZWNvbmRQYXJhbWV0ZXIsXG4gICAgICAgICAgICB0aGlyZFBhcmFtZXRlcixcbiAgICAgICAgICAgIGNvbG9yTWl4ZXJGdW5jdGlvbjogYmluZGVkTWl4ZXJzLlJHQkEsXG4gICAgICAgICAgICBjc3M6IGZhbHNlXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBzdGF0aWMgZ2V0TWl4UkdCQShjb2xvcnMsIHNlY29uZFBhcmFtZXRlciwgdGhpcmRQYXJhbWV0ZXIpIHtcbiAgICAgICAgcmV0dXJuIGdldE1peFJldHVybih7XG4gICAgICAgICAgICBjb2xvcnMsXG4gICAgICAgICAgICBzZWNvbmRQYXJhbWV0ZXIsXG4gICAgICAgICAgICB0aGlyZFBhcmFtZXRlcixcbiAgICAgICAgICAgIGNvbG9yTWl4ZXJGdW5jdGlvbjogYmluZGVkTWl4ZXJzLlJHQkEsXG4gICAgICAgICAgICBjc3M6IHRydWVcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHN0YXRpYyBnZXRNaXhIU0xPYmplY3QoY29sb3JzLCBzZWNvbmRQYXJhbWV0ZXIsIHRoaXJkUGFyYW1ldGVyKSB7XG4gICAgICAgIHJldHVybiBnZXRNaXhSZXR1cm4oe1xuICAgICAgICAgICAgY29sb3JzLFxuICAgICAgICAgICAgc2Vjb25kUGFyYW1ldGVyLFxuICAgICAgICAgICAgdGhpcmRQYXJhbWV0ZXIsXG4gICAgICAgICAgICBjb2xvck1peGVyRnVuY3Rpb246IGJpbmRlZE1peGVycy5IU0wsXG4gICAgICAgICAgICBjc3M6IGZhbHNlXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBzdGF0aWMgZ2V0TWl4SFNMKGNvbG9ycywgc2Vjb25kUGFyYW1ldGVyLCB0aGlyZFBhcmFtZXRlcikge1xuICAgICAgICByZXR1cm4gZ2V0TWl4UmV0dXJuKHtcbiAgICAgICAgICAgIGNvbG9ycyxcbiAgICAgICAgICAgIHNlY29uZFBhcmFtZXRlcixcbiAgICAgICAgICAgIHRoaXJkUGFyYW1ldGVyLFxuICAgICAgICAgICAgY29sb3JNaXhlckZ1bmN0aW9uOiBiaW5kZWRNaXhlcnMuSFNMLFxuICAgICAgICAgICAgY3NzOiB0cnVlXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBzdGF0aWMgZ2V0TWl4SFNMQU9iamVjdChjb2xvcnMsIHNlY29uZFBhcmFtZXRlciwgdGhpcmRQYXJhbWV0ZXIpIHtcbiAgICAgICAgcmV0dXJuIGdldE1peFJldHVybih7XG4gICAgICAgICAgICBjb2xvcnMsXG4gICAgICAgICAgICBzZWNvbmRQYXJhbWV0ZXIsXG4gICAgICAgICAgICB0aGlyZFBhcmFtZXRlcixcbiAgICAgICAgICAgIGNvbG9yTWl4ZXJGdW5jdGlvbjogYmluZGVkTWl4ZXJzLkhTTEEsXG4gICAgICAgICAgICBjc3M6IGZhbHNlXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBzdGF0aWMgZ2V0TWl4SFNMQShjb2xvcnMsIHNlY29uZFBhcmFtZXRlciwgdGhpcmRQYXJhbWV0ZXIpIHtcbiAgICAgICAgcmV0dXJuIGdldE1peFJldHVybih7XG4gICAgICAgICAgICBjb2xvcnMsXG4gICAgICAgICAgICBzZWNvbmRQYXJhbWV0ZXIsXG4gICAgICAgICAgICB0aGlyZFBhcmFtZXRlcixcbiAgICAgICAgICAgIGNvbG9yTWl4ZXJGdW5jdGlvbjogYmluZGVkTWl4ZXJzLkhTTEEsXG4gICAgICAgICAgICBjc3M6IHRydWVcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHN0YXRpYyBnZXRNaXhIV0JPYmplY3QoY29sb3JzLCBzZWNvbmRQYXJhbWV0ZXIsIHRoaXJkUGFyYW1ldGVyKSB7XG4gICAgICAgIHJldHVybiBnZXRNaXhSZXR1cm4oe1xuICAgICAgICAgICAgY29sb3JzLFxuICAgICAgICAgICAgc2Vjb25kUGFyYW1ldGVyLFxuICAgICAgICAgICAgdGhpcmRQYXJhbWV0ZXIsXG4gICAgICAgICAgICBjb2xvck1peGVyRnVuY3Rpb246IGJpbmRlZE1peGVycy5IV0IsXG4gICAgICAgICAgICBjc3M6IGZhbHNlXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBzdGF0aWMgZ2V0TWl4SFdCKGNvbG9ycywgc2Vjb25kUGFyYW1ldGVyLCB0aGlyZFBhcmFtZXRlcikge1xuICAgICAgICByZXR1cm4gZ2V0TWl4UmV0dXJuKHtcbiAgICAgICAgICAgIGNvbG9ycyxcbiAgICAgICAgICAgIHNlY29uZFBhcmFtZXRlcixcbiAgICAgICAgICAgIHRoaXJkUGFyYW1ldGVyLFxuICAgICAgICAgICAgY29sb3JNaXhlckZ1bmN0aW9uOiBiaW5kZWRNaXhlcnMuSFdCLFxuICAgICAgICAgICAgY3NzOiB0cnVlXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBzdGF0aWMgZ2V0TWl4SFdCQU9iamVjdChjb2xvcnMsIHNlY29uZFBhcmFtZXRlciwgdGhpcmRQYXJhbWV0ZXIpIHtcbiAgICAgICAgcmV0dXJuIGdldE1peFJldHVybih7XG4gICAgICAgICAgICBjb2xvcnMsXG4gICAgICAgICAgICBzZWNvbmRQYXJhbWV0ZXIsXG4gICAgICAgICAgICB0aGlyZFBhcmFtZXRlcixcbiAgICAgICAgICAgIGNvbG9yTWl4ZXJGdW5jdGlvbjogYmluZGVkTWl4ZXJzLkhXQkEsXG4gICAgICAgICAgICBjc3M6IGZhbHNlXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBzdGF0aWMgZ2V0TWl4SFdCQShjb2xvcnMsIHNlY29uZFBhcmFtZXRlciwgdGhpcmRQYXJhbWV0ZXIpIHtcbiAgICAgICAgcmV0dXJuIGdldE1peFJldHVybih7XG4gICAgICAgICAgICBjb2xvcnMsXG4gICAgICAgICAgICBzZWNvbmRQYXJhbWV0ZXIsXG4gICAgICAgICAgICB0aGlyZFBhcmFtZXRlcixcbiAgICAgICAgICAgIGNvbG9yTWl4ZXJGdW5jdGlvbjogYmluZGVkTWl4ZXJzLkhXQkEsXG4gICAgICAgICAgICBjc3M6IHRydWVcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHN0YXRpYyBnZXRNaXhDSUVMYWJPYmplY3QoY29sb3JzLCBzZWNvbmRQYXJhbWV0ZXIsIHRoaXJkUGFyYW1ldGVyKSB7XG4gICAgICAgIHJldHVybiBnZXRNaXhSZXR1cm4oe1xuICAgICAgICAgICAgY29sb3JzLFxuICAgICAgICAgICAgc2Vjb25kUGFyYW1ldGVyLFxuICAgICAgICAgICAgdGhpcmRQYXJhbWV0ZXIsXG4gICAgICAgICAgICBjb2xvck1peGVyRnVuY3Rpb246IGJpbmRlZE1peGVycy5DSUVMYWIsXG4gICAgICAgICAgICBjc3M6IGZhbHNlXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBzdGF0aWMgZ2V0TWl4Q0lFTGFiKGNvbG9ycywgc2Vjb25kUGFyYW1ldGVyLCB0aGlyZFBhcmFtZXRlcikge1xuICAgICAgICByZXR1cm4gZ2V0TWl4UmV0dXJuKHtcbiAgICAgICAgICAgIGNvbG9ycyxcbiAgICAgICAgICAgIHNlY29uZFBhcmFtZXRlcixcbiAgICAgICAgICAgIHRoaXJkUGFyYW1ldGVyLFxuICAgICAgICAgICAgY29sb3JNaXhlckZ1bmN0aW9uOiBiaW5kZWRNaXhlcnMuQ0lFTGFiLFxuICAgICAgICAgICAgY3NzOiB0cnVlXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBzdGF0aWMgZ2V0TWl4Q0lFTGFiQU9iamVjdChjb2xvcnMsIHNlY29uZFBhcmFtZXRlciwgdGhpcmRQYXJhbWV0ZXIpIHtcbiAgICAgICAgcmV0dXJuIGdldE1peFJldHVybih7XG4gICAgICAgICAgICBjb2xvcnMsXG4gICAgICAgICAgICBzZWNvbmRQYXJhbWV0ZXIsXG4gICAgICAgICAgICB0aGlyZFBhcmFtZXRlcixcbiAgICAgICAgICAgIGNvbG9yTWl4ZXJGdW5jdGlvbjogYmluZGVkTWl4ZXJzLkNJRUxhYkEsXG4gICAgICAgICAgICBjc3M6IGZhbHNlXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBzdGF0aWMgZ2V0TWl4Q0lFTGFiQShjb2xvcnMsIHNlY29uZFBhcmFtZXRlciwgdGhpcmRQYXJhbWV0ZXIpIHtcbiAgICAgICAgcmV0dXJuIGdldE1peFJldHVybih7XG4gICAgICAgICAgICBjb2xvcnMsXG4gICAgICAgICAgICBzZWNvbmRQYXJhbWV0ZXIsXG4gICAgICAgICAgICB0aGlyZFBhcmFtZXRlcixcbiAgICAgICAgICAgIGNvbG9yTWl4ZXJGdW5jdGlvbjogYmluZGVkTWl4ZXJzLkNJRUxhYkEsXG4gICAgICAgICAgICBjc3M6IHRydWVcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHN0YXRpYyBnZXRNaXhMQ0hPYmplY3QoY29sb3JzLCBzZWNvbmRQYXJhbWV0ZXIsIHRoaXJkUGFyYW1ldGVyKSB7XG4gICAgICAgIHJldHVybiBnZXRNaXhSZXR1cm4oe1xuICAgICAgICAgICAgY29sb3JzLFxuICAgICAgICAgICAgc2Vjb25kUGFyYW1ldGVyLFxuICAgICAgICAgICAgdGhpcmRQYXJhbWV0ZXIsXG4gICAgICAgICAgICBjb2xvck1peGVyRnVuY3Rpb246IGJpbmRlZE1peGVycy5MQ0gsXG4gICAgICAgICAgICBjc3M6IGZhbHNlXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBzdGF0aWMgZ2V0TWl4TENIKGNvbG9ycywgc2Vjb25kUGFyYW1ldGVyLCB0aGlyZFBhcmFtZXRlcikge1xuICAgICAgICByZXR1cm4gZ2V0TWl4UmV0dXJuKHtcbiAgICAgICAgICAgIGNvbG9ycyxcbiAgICAgICAgICAgIHNlY29uZFBhcmFtZXRlcixcbiAgICAgICAgICAgIHRoaXJkUGFyYW1ldGVyLFxuICAgICAgICAgICAgY29sb3JNaXhlckZ1bmN0aW9uOiBiaW5kZWRNaXhlcnMuTENILFxuICAgICAgICAgICAgY3NzOiB0cnVlXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBzdGF0aWMgZ2V0TWl4TENIQU9iamVjdChjb2xvcnMsIHNlY29uZFBhcmFtZXRlciwgdGhpcmRQYXJhbWV0ZXIpIHtcbiAgICAgICAgcmV0dXJuIGdldE1peFJldHVybih7XG4gICAgICAgICAgICBjb2xvcnMsXG4gICAgICAgICAgICBzZWNvbmRQYXJhbWV0ZXIsXG4gICAgICAgICAgICB0aGlyZFBhcmFtZXRlcixcbiAgICAgICAgICAgIGNvbG9yTWl4ZXJGdW5jdGlvbjogYmluZGVkTWl4ZXJzLkxDSEEsXG4gICAgICAgICAgICBjc3M6IGZhbHNlXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBzdGF0aWMgZ2V0TWl4TENIQShjb2xvcnMsIHNlY29uZFBhcmFtZXRlciwgdGhpcmRQYXJhbWV0ZXIpIHtcbiAgICAgICAgcmV0dXJuIGdldE1peFJldHVybih7XG4gICAgICAgICAgICBjb2xvcnMsXG4gICAgICAgICAgICBzZWNvbmRQYXJhbWV0ZXIsXG4gICAgICAgICAgICB0aGlyZFBhcmFtZXRlcixcbiAgICAgICAgICAgIGNvbG9yTWl4ZXJGdW5jdGlvbjogYmluZGVkTWl4ZXJzLkxDSEEsXG4gICAgICAgICAgICBjc3M6IHRydWVcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHN0YXRpYyBnZXRTaGFkZXMoY29sb3IsIHNlY29uZFBhcmFtZXRlciwgdGhpcmRQYXJhbWV0ZXIpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBzZWNvbmRQYXJhbWV0ZXIgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICByZXR1cm4gdXRpbHMuZ2V0Q29sb3JNaXh0dXJlKGNvbG9yLCBzZWNvbmRQYXJhbWV0ZXIsIHRydWUsIGdldE9wdGlvbnNGcm9tQ29sb3JJbnB1dCh0aGlyZFBhcmFtZXRlciB8fCB7fSwgY29sb3IpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdXRpbHMuZ2V0Q29sb3JNaXh0dXJlKGNvbG9yLCBERUZBVUxUX1NIQURFU19USU5UU19TVEVQUywgdHJ1ZSwgZ2V0T3B0aW9uc0Zyb21Db2xvcklucHV0KHNlY29uZFBhcmFtZXRlciB8fCB7fSwgY29sb3IpKTtcbiAgICB9XG4gICAgc3RhdGljIGdldFRpbnRzKGNvbG9yLCBzZWNvbmRQYXJhbWV0ZXIsIHRoaXJkUGFyYW1ldGVyKSB7XG4gICAgICAgIGlmICh0eXBlb2Ygc2Vjb25kUGFyYW1ldGVyID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgcmV0dXJuIHV0aWxzLmdldENvbG9yTWl4dHVyZShjb2xvciwgc2Vjb25kUGFyYW1ldGVyLCBmYWxzZSwgZ2V0T3B0aW9uc0Zyb21Db2xvcklucHV0KHRoaXJkUGFyYW1ldGVyIHx8IHt9LCBjb2xvcikpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB1dGlscy5nZXRDb2xvck1peHR1cmUoY29sb3IsIERFRkFVTFRfU0hBREVTX1RJTlRTX1NURVBTLCBmYWxzZSwgZ2V0T3B0aW9uc0Zyb21Db2xvcklucHV0KHNlY29uZFBhcmFtZXRlciB8fCB7fSwgY29sb3IpKTtcbiAgICB9XG4gICAgc3RhdGljIGdldEhhcm1vbnkoY29sb3IsIHNlY29uZFBhcmFtLCB0aGlyZFBhcmFtLCBmb3VydGhQYXJhbSkge1xuICAgICAgICBpZiAoaXNIYXJtb255KHNlY29uZFBhcmFtKSkge1xuICAgICAgICAgICAgcmV0dXJuIGdldEhhcm1vbnlSZXR1cm4oc2Vjb25kUGFyYW0sIGNvbG9yLCBpc01peCh0aGlyZFBhcmFtKVxuICAgICAgICAgICAgICAgID8gdGhpcmRQYXJhbVxuICAgICAgICAgICAgICAgIDogTWl4LkFERElUSVZFLCBnZXRPcHRpb25zRnJvbUNvbG9ySW5wdXQoaXNNaXgodGhpcmRQYXJhbSlcbiAgICAgICAgICAgICAgICA/IChmb3VydGhQYXJhbSB8fCB7fSlcbiAgICAgICAgICAgICAgICA6IHRoaXJkUGFyYW0gfHwge30sIGNvbG9yKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaXNNaXgoc2Vjb25kUGFyYW0pKSB7XG4gICAgICAgICAgICByZXR1cm4gZ2V0SGFybW9ueVJldHVybihIYXJtb255LkNPTVBMRU1FTlRBUlksIGNvbG9yLCBzZWNvbmRQYXJhbSwgZ2V0T3B0aW9uc0Zyb21Db2xvcklucHV0KHRoaXJkUGFyYW0gfHwge30sIGNvbG9yKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGdldEhhcm1vbnlSZXR1cm4oSGFybW9ueS5DT01QTEVNRU5UQVJZLCBjb2xvciwgTWl4LkFERElUSVZFLCBnZXRPcHRpb25zRnJvbUNvbG9ySW5wdXQoc2Vjb25kUGFyYW0gfHwge30sIGNvbG9yKSk7XG4gICAgfVxufVxuZXhwb3J0IHsgSGFybW9ueSwgTWl4IH07XG4iLCJpbXBvcnQgJy4vc3R5bGVzLnNjc3MnO1xuXG5leHBvcnQgZGVmYXVsdCAoQ29sb3JUcmFuc2xhdG9yKSA9PiB7XG5cbiAgICBjb25zdCBjb250YWluZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICBjb25zdCBjb2xvciA9IG5ldyBDb2xvclRyYW5zbGF0b3IoJ2hzbCgxODAgMTAwJSA1MCUpJywgeyBkZWNpbWFsczogMCB9KTtcblxuICAgIGZvciAobGV0IHJvdyA9IDA7IHJvdyA8IDEwOyByb3crKykge1xuXG4gICAgICAgIGZvciAobGV0IGNvbCA9IDA7IGNvbCA8IDEwOyBjb2wrKykge1xuXG4gICAgICAgICAgICBjb2xvclxuICAgICAgICAgICAgICAgIC5zZXRTKHJvdyAqIDEwKVxuICAgICAgICAgICAgICAgIC5zZXRMKGNvbCAqIDUgKyAzMCk7XG5cbiAgICAgICAgICAgIGNvbnN0IGJveCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuXG4gICAgICAgICAgICBib3guY2xhc3NMaXN0LmFkZCgnYm94Jyk7XG4gICAgICAgICAgICBib3guc3R5bGUuYmFja2dyb3VuZCA9IGNvbG9yLkhFWDtcblxuICAgICAgICAgICAgYm94LmlubmVyVGV4dCA9XG4gICAgICAgICAgICAgICAgYFI6JHtjb2xvci5SfVxuICAgICAgICAgICAgICAgICBHOiR7Y29sb3IuR31cbiAgICAgICAgICAgICAgICAgQjoke2NvbG9yLkJ9YDtcbiAgICAgICAgICAgIGNvbnRhaW5lci5hcHBlbmRDaGlsZChib3gpO1xuXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gY29udGFpbmVyO1xuXG59OyIsImltcG9ydCAnLi9zdHlsZXMuc2Nzcyc7XG5cbmV4cG9ydCBkZWZhdWx0IChDb2xvclRyYW5zbGF0b3IpID0+IHtcblxuICAgIGNvbnN0IGNvbnRhaW5lciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIGNvbnN0IGNvbG9yID0gbmV3IENvbG9yVHJhbnNsYXRvcih7IFI6IDI1NSwgRzogMCwgQjogMCB9KTtcbiAgICBjb25zdCBodWUgPSBbMCwgMzAsIDYwLCAxMjAsIDI0MCwgMjgwLCAzMjAsIDBdO1xuICAgIGxldCByYWluYm93O1xuXG4gICAgZm9yIChsZXQgciA9IDA7IHIgPCBodWUubGVuZ3RoOyByKyspIHtcblxuICAgICAgICBjb2xvci5zZXRIKGh1ZVtyXSk7XG5cbiAgICAgICAgY29uc3QgYm93ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG5cbiAgICAgICAgYm93LmNsYXNzTGlzdC5hZGQoJ3JhaW5ib3cnKTtcbiAgICAgICAgYm93LnN0eWxlLmJhY2tncm91bmQgPSBjb2xvci5IRVg7XG5cbiAgICAgICAgaWYgKHJhaW5ib3cpIHtcbiAgICAgICAgICAgIHJhaW5ib3cuYXBwZW5kQ2hpbGQoYm93KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbnRhaW5lci5hcHBlbmRDaGlsZChib3cpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmFpbmJvdyA9IGJvdztcbiAgICB9XG5cbiAgICByYWluYm93LnN0eWxlLmJhY2tncm91bmQgPSAnIzMzMyc7XG5cbiAgICByZXR1cm4gY29udGFpbmVyO1xuXG59OyIsImltcG9ydCAnLi9zdHlsZXMuc2Nzcyc7XG5cbmV4cG9ydCBkZWZhdWx0IChDb2xvclRyYW5zbGF0b3IpID0+IHtcblxuICAgIGNvbnN0IGNvbnRhaW5lciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIGNvbnN0IGhzbCA9IHsgSDogMCwgUzogJzkwJScsIEw6ICc1MCUnIH07XG4gICAgY29uc3QgaHVlID0gW3VuZGVmaW5lZCwgNTUsIDMwLCAwLCAyOTAsIDIyMCwgMTMwXTtcbiAgICBjb25zdCB0b3RhbCA9IGh1ZS5sZW5ndGg7XG5cbiAgICBmb3IgKGxldCByb3cgPSAwOyByb3cgPCB0b3RhbDsgcm93KyspIHtcblxuICAgICAgICBmb3IgKGxldCBjb2wgPSAwOyBjb2wgPCB0b3RhbDsgY29sKyspIHtcblxuICAgICAgICAgICAgbGV0IGluZGV4ID0gdG90YWwgLSByb3cgKyBjb2w7XG4gICAgICAgICAgICBpZiAoaW5kZXggPj0gdG90YWwpIHtcbiAgICAgICAgICAgICAgICBpbmRleCAtPSB0b3RhbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGhzbC5IID0gaHVlW2luZGV4XTtcbiAgICAgICAgICAgIGNvbnN0IHJnYiA9IGh1ZVtpbmRleF0gPT09IHVuZGVmaW5lZFxuICAgICAgICAgICAgICAgID8gJyNGRkYnXG4gICAgICAgICAgICAgICAgOiBDb2xvclRyYW5zbGF0b3IudG9IRVgoaHNsKTtcbiAgICAgICAgICAgIGNvbnN0IGJveCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuXG4gICAgICAgICAgICBib3guY2xhc3NMaXN0LmFkZCgnZmxhZycpO1xuICAgICAgICAgICAgYm94LnN0eWxlLmJhY2tncm91bmQgPSByZ2I7XG5cbiAgICAgICAgICAgIGNvbnRhaW5lci5hcHBlbmRDaGlsZChib3gpO1xuXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gY29udGFpbmVyO1xuXG59OyIsImltcG9ydCAnLi9zdHlsZXMuc2Nzcyc7XG5cbmV4cG9ydCBkZWZhdWx0IChDb2xvclRyYW5zbGF0b3IpID0+IHtcblxuICAgIGNvbnN0IGNvbnRhaW5lciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIGNvbnN0IGhleENvbG9ycyA9IFtcbiAgICAgICAgJyNGRTI3MTInLCAnI0ZFNTQwOScsICcjRkI5OTAyJyxcbiAgICAgICAgJyNGQUJEMDMnLCAnI0ZGRkUzMicsICcjRDFFQTJDJyxcbiAgICAgICAgJyM2NkIxMzInLCAnIzAzOTJDRScsICcjMDI0N0ZFJyxcbiAgICAgICAgJyMzRDAwQTUnLCAnIzg2MDFCMCcsICcjQTcxOTRCJ1xuICAgIF07XG5cbiAgICBoZXhDb2xvcnMuZm9yRWFjaCgoY29sb3IpID0+IHtcblxuICAgICAgICBjb25zdCByZ2IgPSBDb2xvclRyYW5zbGF0b3IudG9SR0IoY29sb3IpO1xuICAgICAgICBjb25zdCBoc2wgPSBDb2xvclRyYW5zbGF0b3IudG9IU0woY29sb3IsIHsgZGVjaW1hbHM6IDAgfSk7XG4gICAgICAgIGNvbnN0IGh3YiA9IENvbG9yVHJhbnNsYXRvci50b0hXQihjb2xvciwgeyBkZWNpbWFsczogMCB9KTtcbiAgICAgICAgY29uc3QgbGFiID0gQ29sb3JUcmFuc2xhdG9yLnRvQ0lFTGFiKGNvbG9yLCB7IGRlY2ltYWxzOiAwIH0pO1xuICAgICAgICBjb25zdCBsY2ggPSBDb2xvclRyYW5zbGF0b3IudG9MQ0goY29sb3IsIHsgZGVjaW1hbHM6IDAgfSk7XG5cbiAgICAgICAgY29uc3QgcmdiRGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgIGNvbnN0IGhzbERpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICBjb25zdCBod2JEaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgY29uc3QgbGFiRGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgIGNvbnN0IGxjaERpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuXG4gICAgICAgIHJnYkRpdi5zdHlsZS5iYWNrZ3JvdW5kQ29sb3IgPSByZ2I7XG4gICAgICAgIHJnYkRpdi50ZXh0Q29udGVudCA9IHJnYjtcblxuICAgICAgICBoc2xEaXYuc3R5bGUuYmFja2dyb3VuZENvbG9yID0gaHNsO1xuICAgICAgICBoc2xEaXYudGV4dENvbnRlbnQgPSBoc2w7XG5cbiAgICAgICAgaHdiRGl2LnN0eWxlLmJhY2tncm91bmRDb2xvciA9IGh3YjtcbiAgICAgICAgaHdiRGl2LnRleHRDb250ZW50ID0gaHdiO1xuXG4gICAgICAgIGxhYkRpdi5zdHlsZS5iYWNrZ3JvdW5kQ29sb3IgPSBsYWI7XG4gICAgICAgIGxhYkRpdi50ZXh0Q29udGVudCA9IGxhYjtcblxuICAgICAgICBsY2hEaXYuc3R5bGUuYmFja2dyb3VuZENvbG9yID0gbGNoO1xuICAgICAgICBsY2hEaXYudGV4dENvbnRlbnQgPSBsY2g7XG5cbiAgICAgICAgY29udGFpbmVyLmFwcGVuZENoaWxkKHJnYkRpdik7XG4gICAgICAgIGNvbnRhaW5lci5hcHBlbmRDaGlsZChoc2xEaXYpO1xuICAgICAgICBjb250YWluZXIuYXBwZW5kQ2hpbGQoaHdiRGl2KTtcbiAgICAgICAgY29udGFpbmVyLmFwcGVuZENoaWxkKGxhYkRpdik7XG4gICAgICAgIGNvbnRhaW5lci5hcHBlbmRDaGlsZChsY2hEaXYpO1xuXG4gICAgfSk7XG5cbiAgICByZXR1cm4gY29udGFpbmVyO1xuXG59OyIsImltcG9ydCAnLi9zdHlsZXMuc2Nzcyc7XG5cbmV4cG9ydCBkZWZhdWx0IChDb2xvclRyYW5zbGF0b3IpID0+IHtcblxuICAgIGNvbnN0IGNvbnRhaW5lciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIGNvbnN0IGNvbG9ycyA9IFtcbiAgICAgICAgJ3JlZCcsXG4gICAgICAgICdsaW1lJyxcbiAgICAgICAgJ2JsdWUnLFxuICAgICAgICAnYXF1YScsXG4gICAgICAgICd5ZWxsb3cnLFxuICAgICAgICAnZnVjaHNpYSdcbiAgICBdO1xuICAgIGNvbnN0IHRvdGFsID0gY29sb3JzLmxlbmd0aDtcblxuICAgIGZvciAobGV0IHJvdyA9IDA7IHJvdyA8IHRvdGFsOyByb3crKykge1xuXG4gICAgICAgIGNvbnN0IGhzbCA9IENvbG9yVHJhbnNsYXRvci50b0hTTE9iamVjdChjb2xvcnNbcm93XSk7XG4gICAgICAgIGNvbnN0IHN0ZXAgPSBoc2wuUyAvICh0b3RhbCAtIDEpO1xuXG4gICAgICAgIGZvciAobGV0IGNvbCA9IDA7IGNvbCA8IHRvdGFsOyBjb2wrKykge1xuXG4gICAgICAgICAgICBjb25zdCByZ2IgPSBDb2xvclRyYW5zbGF0b3IudG9IRVgoaHNsKTtcbiAgICAgICAgICAgIGNvbnN0IGNteWsgPSBDb2xvclRyYW5zbGF0b3IudG9DTVlLT2JqZWN0KGhzbCwgeyBkZWNpbWFsczogMCB9KTtcblxuICAgICAgICAgICAgY29uc3QgYm94ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgICAgICBib3guY2xhc3NMaXN0LmFkZCgnYm94Jyk7XG4gICAgICAgICAgICBib3guc3R5bGUuYmFja2dyb3VuZCA9IHJnYjtcbiAgICAgICAgICAgIGJveC5pbm5lclRleHQgPSBgQzoke2NteWsuQ31cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgTToke2NteWsuTX1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgWToke2NteWsuWX1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgSzoke2NteWsuS31gO1xuXG4gICAgICAgICAgICBjb250YWluZXIuYXBwZW5kQ2hpbGQoYm94KTtcblxuICAgICAgICAgICAgaHNsLlMgLT0gc3RlcDtcblxuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGNvbnRhaW5lcjtcblxufTsiLCJpbXBvcnQgJy4vc3R5bGVzLnNjc3MnO1xuXG5leHBvcnQgZGVmYXVsdCAoQ29sb3JUcmFuc2xhdG9yKSA9PiB7XG5cbiAgICBjb25zdCBjb250YWluZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICBjb25zdCByb3dzID0gMTE7XG4gICAgY29uc3QgbXVsdCA9IDM7XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJvd3M7IGkrKykge1xuXG4gICAgICAgIGNvbnN0IGJsZW5kcyA9IENvbG9yVHJhbnNsYXRvci5nZXRCbGVuZEhFWCgnI0YwMCcsICcjRkYwJywgbXVsdCArIGkgKiBtdWx0KTtcblxuICAgICAgICBibGVuZHMuZm9yRWFjaCgoYmxlbmQsIGluZGV4KSA9PiB7XG4gICAgICAgICAgICBjb25zdCBib3ggPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgICAgIGJveC5jbGFzc0xpc3QuYWRkKCdib3gnLCBgZmlsZSR7aX1gKTtcbiAgICAgICAgICAgIGJveC5zdHlsZS5iYWNrZ3JvdW5kID0gYmxlbmQ7XG4gICAgICAgICAgICBib3guaW5uZXJUZXh0ID0gaW5kZXggKyAxO1xuICAgICAgICAgICAgY29udGFpbmVyLmFwcGVuZENoaWxkKGJveCk7XG4gICAgICAgIH0pO1xuXG4gICAgfVxuXG4gICAgcmV0dXJuIGNvbnRhaW5lcjtcblxufTsiLCJpbXBvcnQgJy4vc3R5bGVzLnNjc3MnO1xuXG5leHBvcnQgZGVmYXVsdCAoQ29sb3JUcmFuc2xhdG9yKSA9PiB7XG5cbiAgICBjb25zdCBjb250YWluZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcblxuICAgIGNvbnN0IGNvbG9ycyA9IFsnI0YwMCcsICcjRkY4MDAwJywgJyNGRjAnLCAnIzBGMCcsICcjMDBGJywgJyNBMEYnLCAnI0YwQSddO1xuXG4gICAgY29uc3QgY3JlYXRlQm94ID0gKGNvbG9yLCB0eXBlKSA9PiB7XG4gICAgICAgIGNvbnN0IGJveCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICBib3guY2xhc3NMaXN0LmFkZCgnYm94Jyk7XG4gICAgICAgIGJveC5zdHlsZS5iYWNrZ3JvdW5kQ29sb3IgPSBjb2xvcjtcbiAgICAgICAgaWYgKHR5cGUpIGJveC5kYXRhc2V0LnR5cGUgPSB0eXBlO1xuICAgICAgICBjb250YWluZXIuYXBwZW5kQ2hpbGQoYm94KTtcbiAgICB9O1xuXG4gICAgY29sb3JzLmZvckVhY2goKGNvbG9yKSA9PiB7XG4gICAgICAgIGNvbnN0IHNoYWRlcyA9IENvbG9yVHJhbnNsYXRvci5nZXRTaGFkZXMoY29sb3IsIDMpLnJldmVyc2UoKTtcbiAgICAgICAgY29uc3QgdGludHMgPSBDb2xvclRyYW5zbGF0b3IuZ2V0VGludHMoY29sb3IsIDMpO1xuICAgICAgICBzaGFkZXMuZm9yRWFjaCgoc2hhZGUpID0+IGNyZWF0ZUJveChzaGFkZSwgJ3NoYWRlJykpO1xuICAgICAgICBjcmVhdGVCb3goY29sb3IpO1xuICAgICAgICB0aW50cy5mb3JFYWNoKCh0aW50KSA9PiBjcmVhdGVCb3godGludCwgJ3RpbnQnKSk7XG4gICAgfSk7XG5cbiAgICByZXR1cm4gY29udGFpbmVyO1xuXG59OyIsImltcG9ydCAnLi9zdHlsZXMuc2Nzcyc7XG5cblxuZXhwb3J0IGRlZmF1bHQgKENvbG9yVHJhbnNsYXRvcikgPT4ge1xuXG4gICAgY29uc3QgY29udGFpbmVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG5cbiAgICBjb25zdCBtaXhlcyA9IFtcbiAgICAgICAgJyNGMDAnLFxuICAgICAgICAnIzBGMCcsXG4gICAgICAgICcjMDBGJyxcbiAgICAgICAgWzEsIDNdLFxuICAgICAgICBbMSwgMl0sXG4gICAgICAgIFsyLCAzXSxcbiAgICAgICAgWzEsIDIsIDNdXG4gICAgXTtcblxuICAgIGNvbnN0IGZpbGxQbGFuZXMgPSAoKSA9PiB7XG4gICAgICAgIGNvbnN0IHBsYW5lcyA9IGNvbnRhaW5lci5xdWVyeVNlbGVjdG9yQWxsKCcjcGxhbmVzIHBhdGgnKTtcbiAgICAgICAgcGxhbmVzLmZvckVhY2goKHBsYW5lLCBpbmRleCkgPT4ge1xuICAgICAgICAgICAgbGV0IGNvbG9yID0gJyNDQ0MnO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBtaXhlc1tpbmRleF0gPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgY29sb3IgPSBtaXhlc1tpbmRleF07XG4gICAgICAgICAgICB9IGVsc2UgaWYobWl4ZXNbaW5kZXhdKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgY29sb3JzID0gbWl4ZXNbaW5kZXhdLm1hcCgoaSkgPT4gbWl4ZXNbaSAtIDFdKTtcbiAgICAgICAgICAgICAgICBjb2xvciA9IG1peGVzW2luZGV4XSA9IENvbG9yVHJhbnNsYXRvci5nZXRNaXhIRVgoY29sb3JzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHBsYW5lLnNldEF0dHJpYnV0ZSgnZmlsbCcsIGNvbG9yKTtcbiAgICAgICAgfSk7XG4gICAgfTtcblxuICAgIGZldGNoKCdpbWFnZXMvY29sb3ItbWl4ZXMuc3ZnJylcbiAgICAgICAgLnRoZW4ocmVzdWx0ID0+IHJlc3VsdC50ZXh0KCkpXG4gICAgICAgIC50aGVuKChzdmdDb2RlKSA9PiB7XG4gICAgICAgICAgICBjb250YWluZXIuaW5uZXJIVE1MID0gc3ZnQ29kZTtcbiAgICAgICAgICAgIGZpbGxQbGFuZXMoKTtcbiAgICAgICAgfSk7XG5cbiAgICByZXR1cm4gY29udGFpbmVyO1xuXG59OyIsImltcG9ydCAnLi9zdHlsZXMuc2Nzcyc7XG5cbmV4cG9ydCBkZWZhdWx0IChDb2xvclRyYW5zbGF0b3IsIHsgTWl4IH0pID0+IHtcblxuICAgIGNvbnN0IGNvbnRhaW5lciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuXG4gICAgY29uc3QgbWl4ZXMgPSBbXG4gICAgICAgICcjRjAwJyxcbiAgICAgICAgJyNGRjAnLFxuICAgICAgICAnIzAwRicsXG4gICAgICAgIFsxLCAzXSxcbiAgICAgICAgWzEsIDJdLFxuICAgICAgICBbMiwgM10sXG4gICAgICAgIFsxLCAyLCAzXVxuICAgIF07XG5cbiAgICBjb25zdCBmaWxsUGxhbmVzID0gKCkgPT4ge1xuICAgICAgICBjb25zdCBwbGFuZXMgPSBjb250YWluZXIucXVlcnlTZWxlY3RvckFsbCgnI3BsYW5lcyBwYXRoJyk7XG4gICAgICAgIHBsYW5lcy5mb3JFYWNoKChwbGFuZSwgaW5kZXgpID0+IHtcbiAgICAgICAgICAgIGxldCBjb2xvciA9ICcjQ0NDJztcbiAgICAgICAgICAgIGlmICh0eXBlb2YgbWl4ZXNbaW5kZXhdID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIGNvbG9yID0gbWl4ZXNbaW5kZXhdO1xuICAgICAgICAgICAgfSBlbHNlIGlmKG1peGVzW2luZGV4XSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGNvbG9ycyA9IG1peGVzW2luZGV4XS5tYXAoKGkpID0+IG1peGVzW2kgLSAxXSk7XG4gICAgICAgICAgICAgICAgY29sb3IgPSBtaXhlc1tpbmRleF0gPSBDb2xvclRyYW5zbGF0b3IuZ2V0TWl4SEVYKGNvbG9ycywgTWl4LlNVQlRSQUNUSVZFKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHBsYW5lLnNldEF0dHJpYnV0ZSgnZmlsbCcsIGNvbG9yKTtcbiAgICAgICAgfSk7XG4gICAgfTtcblxuICAgIGZldGNoKCdpbWFnZXMvY29sb3ItbWl4ZXMuc3ZnJylcbiAgICAgICAgLnRoZW4ocmVzdWx0ID0+IHJlc3VsdC50ZXh0KCkpXG4gICAgICAgIC50aGVuKChzdmdDb2RlKSA9PiB7XG4gICAgICAgICAgICBjb250YWluZXIuaW5uZXJIVE1MID0gc3ZnQ29kZTtcbiAgICAgICAgICAgIGZpbGxQbGFuZXMoKTtcbiAgICAgICAgfSk7XG5cbiAgICByZXR1cm4gY29udGFpbmVyO1xuXG59OyIsImltcG9ydCAnLi9zdHlsZXMuc2Nzcyc7XG5cbmV4cG9ydCBkZWZhdWx0IChDb2xvclRyYW5zbGF0b3IsIHsgSGFybW9ueSB9KSA9PiB7XG5cbiAgICBjb25zdCBjb250YWluZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcblxuICAgIGNvbnN0IGhhcm1vbmllcyA9IFtcbiAgICAgICAgeyBsYWJlbDogJ0NvbXBsZW1lbnRhcnknLCAgICAgICB2YWx1ZTogSGFybW9ueS5DT01QTEVNRU5UQVJZIH0sXG4gICAgICAgIHsgbGFiZWw6ICdTcGxpdCBDb21wbGVtZW50YXJ5JywgdmFsdWU6IEhhcm1vbnkuU1BMSVRfQ09NUExFTUVOVEFSWSB9LFxuICAgICAgICB7IGxhYmVsOiAnQW5hbG9nb3VzJywgICAgICAgICAgIHZhbHVlOiBIYXJtb255LkFOQUxPR09VUyB9LFxuICAgICAgICB7IGxhYmVsOiAnVHJpYWRpYycsICAgICAgICAgICAgIHZhbHVlOiBIYXJtb255LlRSSUFESUMgfSxcbiAgICAgICAgeyBsYWJlbDogJ1RldHJhZGljJywgICAgICAgICAgICB2YWx1ZTogSGFybW9ueS5URVRSQURJQyB9LFxuICAgICAgICB7IGxhYmVsOiAnU3F1YXJlJywgICAgICAgICAgICAgIHZhbHVlOiBIYXJtb255LlNRVUFSRSB9XG4gICAgXTtcblxuICAgIGNvbnN0IGJhc2VDb2xvciA9ICcjRjAwJztcblxuICAgIGNvbnN0IGNyZWF0ZUVsZW1lbnQgPSAoY2xhc3NOYW1lLCBwYXJlbnQpID0+IHtcbiAgICAgICAgY29uc3QgZGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgIGRpdi5jbGFzc0xpc3QuYWRkKGNsYXNzTmFtZSk7XG4gICAgICAgIHBhcmVudC5hcHBlbmRDaGlsZChkaXYpO1xuICAgICAgICByZXR1cm4gZGl2O1xuICAgIH07XG5cbiAgICBjb25zdCBjcmVhdGVIYXJtb255ID0gKGl0ZW0pID0+IHtcblxuICAgICAgICBjb25zdCB3cmFwcGVyID0gY3JlYXRlRWxlbWVudCgnd3JhcHBlcicsIGNvbnRhaW5lcik7XG4gICAgICAgIGNvbnN0IHdoZWVsID0gY3JlYXRlRWxlbWVudCgnd2hlZWwnLCB3cmFwcGVyKTtcbiAgICAgICAgY29uc3QgaGFybW9ueSA9IGNyZWF0ZUVsZW1lbnQoJ2hhcm1vbnknLCB3cmFwcGVyKTtcbiAgICAgICAgY3JlYXRlRWxlbWVudCgnbGFiZWwnLCB3cmFwcGVyKS5pbm5lclRleHQgPSBpdGVtLmxhYmVsO1xuXG4gICAgICAgIGZldGNoKCdpbWFnZXMvd2hlZWwtYWRkaXRpdmUuc3ZnJylcbiAgICAgICAgICAgIC50aGVuKHJlc3VsdCA9PiByZXN1bHQudGV4dCgpKVxuICAgICAgICAgICAgLnRoZW4oKHN2Z0NvZGUpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBoYXJtb255Q29sb3JzID0gQ29sb3JUcmFuc2xhdG9yLmdldEhhcm1vbnkoYmFzZUNvbG9yLCBpdGVtLnZhbHVlKTtcbiAgICAgICAgICAgICAgICBjb25zdCBzZWxlY3RvciA9ICdwYXRoJyArIGhhcm1vbnlDb2xvcnMubWFwKChjb2xvcikgPT4gYDpub3QoW2ZpbGw9XCIke2NvbG9yfVwiXSlgKS5qb2luKCcnKTtcbiAgICAgICAgICAgICAgICB3aGVlbC5pbm5lckhUTUwgPSBzdmdDb2RlO1xuICAgICAgICAgICAgICAgIGhhcm1vbnlDb2xvcnMuZm9yRWFjaCgoaGV4KSA9PiBjcmVhdGVFbGVtZW50KCdib3gnLCBoYXJtb255KS5zdHlsZS5iYWNrZ3JvdW5kID0gaGV4KTtcbiAgICAgICAgICAgICAgICB3aGVlbC5xdWVyeVNlbGVjdG9yQWxsKHNlbGVjdG9yKS5mb3JFYWNoKChwYXRoKSA9PiBwYXRoLnNldEF0dHJpYnV0ZSgnZmlsbC1vcGFjaXR5JywgJzAuMjUnKSk7XG4gICAgICAgICAgICB9KTtcblxuICAgIH07XG5cbiAgICBoYXJtb25pZXMuZm9yRWFjaCgoaXRlbSkgPT4gY3JlYXRlSGFybW9ueShpdGVtKSk7XG5cbiAgICByZXR1cm4gY29udGFpbmVyO1xuXG59OyIsImltcG9ydCAnLi9zdHlsZXMuc2Nzcyc7XG5cbmV4cG9ydCBkZWZhdWx0IChDb2xvclRyYW5zbGF0b3IsIHsgSGFybW9ueSwgTWl4IH0pID0+IHtcblxuICAgIGNvbnN0IGNvbnRhaW5lciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuXG4gICAgY29uc3QgaGFybW9uaWVzID0gW1xuICAgICAgICB7IGxhYmVsOiAnQ29tcGxlbWVudGFyeScsICAgICAgIHZhbHVlOiBIYXJtb255LkNPTVBMRU1FTlRBUlkgfSxcbiAgICAgICAgeyBsYWJlbDogJ1NwbGl0IENvbXBsZW1lbnRhcnknLCB2YWx1ZTogSGFybW9ueS5TUExJVF9DT01QTEVNRU5UQVJZIH0sXG4gICAgICAgIHsgbGFiZWw6ICdBbmFsb2dvdXMnLCAgICAgICAgICAgdmFsdWU6IEhhcm1vbnkuQU5BTE9HT1VTIH0sXG4gICAgICAgIHsgbGFiZWw6ICdUcmlhZGljJywgICAgICAgICAgICAgdmFsdWU6IEhhcm1vbnkuVFJJQURJQyB9LFxuICAgICAgICB7IGxhYmVsOiAnVGV0cmFkaWMnLCAgICAgICAgICAgIHZhbHVlOiBIYXJtb255LlRFVFJBRElDIH0sXG4gICAgICAgIHsgbGFiZWw6ICdTcXVhcmUnLCAgICAgICAgICAgICAgdmFsdWU6IEhhcm1vbnkuU1FVQVJFIH1cbiAgICBdO1xuXG4gICAgY29uc3QgYmFzZUNvbG9yID0gJyNGMDAnO1xuXG4gICAgY29uc3QgY3JlYXRlRWxlbWVudCA9IChjbGFzc05hbWUsIHBhcmVudCkgPT4ge1xuICAgICAgICBjb25zdCBkaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgZGl2LmNsYXNzTGlzdC5hZGQoY2xhc3NOYW1lKTtcbiAgICAgICAgcGFyZW50LmFwcGVuZENoaWxkKGRpdik7XG4gICAgICAgIHJldHVybiBkaXY7XG4gICAgfTtcblxuICAgIGNvbnN0IGNyZWF0ZUhhcm1vbnkgPSAoaXRlbSkgPT4ge1xuXG4gICAgICAgIGNvbnN0IHdyYXBwZXIgPSBjcmVhdGVFbGVtZW50KCd3cmFwcGVyJywgY29udGFpbmVyKTtcbiAgICAgICAgY29uc3Qgd2hlZWwgPSBjcmVhdGVFbGVtZW50KCd3aGVlbCcsIHdyYXBwZXIpO1xuICAgICAgICBjb25zdCBoYXJtb255ID0gY3JlYXRlRWxlbWVudCgnaGFybW9ueScsIHdyYXBwZXIpO1xuICAgICAgICBjcmVhdGVFbGVtZW50KCdsYWJlbCcsIHdyYXBwZXIpLmlubmVyVGV4dCA9IGl0ZW0ubGFiZWw7XG5cbiAgICAgICAgZmV0Y2goJ2ltYWdlcy93aGVlbC1zdWJ0cmFjdGl2ZS5zdmcnKVxuICAgICAgICAgICAgLnRoZW4ocmVzdWx0ID0+IHJlc3VsdC50ZXh0KCkpXG4gICAgICAgICAgICAudGhlbigoc3ZnQ29kZSkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IGhhcm1vbnlDb2xvcnMgPSBDb2xvclRyYW5zbGF0b3IuZ2V0SGFybW9ueShiYXNlQ29sb3IsIGl0ZW0udmFsdWUsIE1peC5TVUJUUkFDVElWRSk7XG4gICAgICAgICAgICAgICAgY29uc3Qgc2VsZWN0b3IgPSAncGF0aCcgKyBoYXJtb255Q29sb3JzLm1hcCgoY29sb3IpID0+IGA6bm90KFtmaWxsPVwiJHtjb2xvcn1cIl0pYCkuam9pbignJyk7XG4gICAgICAgICAgICAgICAgd2hlZWwuaW5uZXJIVE1MID0gc3ZnQ29kZTtcbiAgICAgICAgICAgICAgICBoYXJtb255Q29sb3JzLmZvckVhY2goKGhleCkgPT4gY3JlYXRlRWxlbWVudCgnYm94JywgaGFybW9ueSkuc3R5bGUuYmFja2dyb3VuZCA9IGhleCk7XG4gICAgICAgICAgICAgICAgd2hlZWwucXVlcnlTZWxlY3RvckFsbChzZWxlY3RvcikuZm9yRWFjaCgocGF0aCkgPT4gcGF0aC5zZXRBdHRyaWJ1dGUoJ2ZpbGwtb3BhY2l0eScsICcwLjI1JykpO1xuICAgICAgICAgICAgfSk7XG5cbiAgICB9O1xuXG4gICAgaGFybW9uaWVzLmZvckVhY2goKGl0ZW0pID0+IGNyZWF0ZUhhcm1vbnkoaXRlbSkpO1xuXG4gICAgcmV0dXJuIGNvbnRhaW5lcjtcblxufTsiLCJpbXBvcnQgJy4uLy4uL25vZGVfbW9kdWxlcy9nb29nbGUtY29kZS1wcmV0dGlmeS9iaW4vcnVuX3ByZXR0aWZ5Lm1pbic7XG5pbXBvcnQgJy4uLy4uL25vZGVfbW9kdWxlcy9nb29nbGUtY29kZS1wcmV0dGlmeS9iaW4vcHJldHRpZnkubWluLmNzcyc7XG5pbXBvcnQgJy4uLy4uL25vZGVfbW9kdWxlcy9nb29nbGUtY29kZS1wcmV0dGlmeS9zdHlsZXMvZGVzZXJ0LmNzcyc7XG5pbXBvcnQgJ3doYXR3Zy1mZXRjaCc7XG5pbXBvcnQgJy4vc3R5bGVzLnNjc3MnO1xuaW1wb3J0IHsgQ29sb3JUcmFuc2xhdG9yLCBIYXJtb255LCBNaXggfSBmcm9tICcuLi8nO1xuaW1wb3J0IGRlbW8xIGZyb20gJy4vZGVtbzEnO1xuaW1wb3J0IGRlbW8yIGZyb20gJy4vZGVtbzInO1xuaW1wb3J0IGRlbW8zIGZyb20gJy4vZGVtbzMnO1xuaW1wb3J0IGRlbW80IGZyb20gJy4vZGVtbzQnO1xuaW1wb3J0IGRlbW81IGZyb20gJy4vZGVtbzUnO1xuaW1wb3J0IGRlbW82IGZyb20gJy4vZGVtbzYnO1xuaW1wb3J0IGRlbW83IGZyb20gJy4vZGVtbzcnO1xuaW1wb3J0IGRlbW84IGZyb20gJy4vZGVtbzgnO1xuaW1wb3J0IGRlbW85IGZyb20gJy4vZGVtbzknO1xuaW1wb3J0IGRlbW8xMCBmcm9tICcuL2RlbW8xMCc7XG5pbXBvcnQgZGVtbzExIGZyb20gJy4vZGVtbzExJztcblxuY29uc3QgZnVuY3Rpb1RvU3RyaW5nID0gKGZuKSA9PiB7XG4gICAgY29uc3QgYXJ0aWNsZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2FydGljbGUnKTtcbiAgICBjb25zdCBwcmUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdwcmUnKTtcbiAgICBhcnRpY2xlLmNsYXNzTGlzdC5hZGQoJ2Z1bmN0aW9uLWNvbnRhaW5lcicpO1xuICAgIHByZS5jbGFzc0xpc3QuYWRkKCdwcmV0dHlwcmludCcpO1xuICAgIGFydGljbGUuYXBwZW5kQ2hpbGQocHJlKTtcbiAgICBwcmUuaW5uZXJIVE1MID0gZm4udG9TdHJpbmcoKS5yZXBsYWNlKCcoQ29sb3JUcmFuc2xhdG9yKScsICcoKScpO1xuICAgIHJldHVybiBhcnRpY2xlO1xufTtcblxuY29uc3QgZGVtb3MgPSBuZXcgTWFwKFtcbiAgICBbJ2RlbW8xJywgZGVtbzFdLFxuICAgIFsnZGVtbzInLCBkZW1vMl0sXG4gICAgWydkZW1vMycsIGRlbW8zXSxcbiAgICBbJ2RlbW80JywgZGVtbzRdLFxuICAgIFsnZGVtbzUnLCBkZW1vNV0sXG4gICAgWydkZW1vNicsIGRlbW82XSxcbiAgICBbJ2RlbW83JywgZGVtbzddLFxuICAgIFsnZGVtbzgnLCBkZW1vOF0sXG4gICAgWydkZW1vOScsIGRlbW85XSxcbiAgICBbJ2RlbW8xMCcsIGRlbW8xMF0sXG4gICAgWydkZW1vMTEnLCBkZW1vMTFdXG5dKTtcblxuZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignRE9NQ29udGVudExvYWRlZCcsICgpID0+IHtcbiAgICBkZW1vcy5mb3JFYWNoKChtb2R1bGUsIGRpdikgPT4ge1xuICAgICAgICBjb25zdCBkZW1vID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoZGl2KTtcbiAgICAgICAgY29uc3QgY29udGFpbmVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgIGNvbnN0IHdyYXBwZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcblxuICAgICAgICBjb250YWluZXIuY2xhc3NMaXN0LmFkZCgnZGVtby1jb250YWluZXInKTtcbiAgICAgICAgd3JhcHBlci5jbGFzc0xpc3QuYWRkKCdkZW1vLXdyYXBwZXInKTtcblxuICAgICAgICB3cmFwcGVyLmFwcGVuZENoaWxkKG1vZHVsZShDb2xvclRyYW5zbGF0b3IsIHsgSGFybW9ueSwgTWl4IH0pKTtcbiAgICAgICAgY29udGFpbmVyLmFwcGVuZENoaWxkKHdyYXBwZXIpO1xuICAgICAgICBkZW1vLmFwcGVuZENoaWxkKGNvbnRhaW5lcik7XG4gICAgICAgIGRlbW8uYXBwZW5kQ2hpbGQoZnVuY3Rpb1RvU3RyaW5nKG1vZHVsZSkpO1xuICAgIH0pO1xufSk7Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///699\n")},966:(module,exports)=>{eval('var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!function(){var r=null;\n(function(){function X(e){function j(){try{J.doScroll("left")}catch(e){P(j,50);return}w("poll")}function w(j){if(!(j.type=="readystatechange"&&x.readyState!="complete")&&((j.type=="load"?n:x)[z](i+j.type,w,!1),!m&&(m=!0)))e.call(n,j.type||j)}var Y=x.addEventListener,m=!1,C=!0,t=Y?"addEventListener":"attachEvent",z=Y?"removeEventListener":"detachEvent",i=Y?"":"on";if(x.readyState=="complete")e.call(n,"lazy");else{if(x.createEventObject&&J.doScroll){try{C=!n.frameElement}catch(A){}C&&j()}x[t](i+"DOMContentLoaded",\nw,!1);x[t](i+"readystatechange",w,!1);n[t](i+"load",w,!1)}}function Q(){S&&X(function(){var e=K.length;$(e?function(){for(var j=0;j<e;++j)(function(e){P(function(){n.exports[K[e]].apply(n,arguments)},0)})(j)}:void 0)})}for(var n=window,P=n.setTimeout,x=document,J=x.documentElement,L=x.head||x.getElementsByTagName("head")[0]||J,z="",A=x.scripts,m=A.length;--m>=0;){var M=A[m],T=M.src.match(/^[^#?]*\\/run_prettify\\.js(\\?[^#]*)?(?:#.*)?$/);if(T){z=T[1]||"";M.parentNode.removeChild(M);break}}var S=!0,D=\n[],N=[],K=[];z.replace(/[&?]([^&=]+)=([^&]+)/g,function(e,j,w){w=decodeURIComponent(w);j=decodeURIComponent(j);j=="autorun"?S=!/^[0fn]/i.test(w):j=="lang"?D.push(w):j=="skin"?N.push(w):j=="callback"&&K.push(w)});m=0;for(z=D.length;m<z;++m)(function(){var e=x.createElement("script");e.onload=e.onerror=e.onreadystatechange=function(){if(e&&(!e.readyState||/loaded|complete/.test(e.readyState)))e.onerror=e.onload=e.onreadystatechange=r,--R,R||P(Q,0),e.parentNode&&e.parentNode.removeChild(e),e=r};e.type=\n"text/javascript";e.src="https://google-code-prettify.googlecode.com/svn/loader/lang-"+encodeURIComponent(D[m])+".js";L.insertBefore(e,L.firstChild)})(D[m]);for(var R=D.length,A=[],m=0,z=N.length;m<z;++m)A.push("https://google-code-prettify.googlecode.com/svn/loader/skins/"+encodeURIComponent(N[m])+".css");A.push("https://google-code-prettify.googlecode.com/svn/loader/prettify.css");(function(e){function j(m){if(m!==w){var n=x.createElement("link");n.rel="stylesheet";n.type="text/css";if(m+1<w)n.error=\nn.onerror=function(){j(m+1)};n.href=e[m];L.appendChild(n)}}var w=e.length;j(0)})(A);var $=function(){window.PR_SHOULD_USE_CONTINUATION=!0;var e;(function(){function j(a){function d(f){var b=f.charCodeAt(0);if(b!==92)return b;var a=f.charAt(1);return(b=i[a])?b:"0"<=a&&a<="7"?parseInt(f.substring(1),8):a==="u"||a==="x"?parseInt(f.substring(2),16):f.charCodeAt(1)}function h(f){if(f<32)return(f<16?"\\\\x0":"\\\\x")+f.toString(16);f=String.fromCharCode(f);return f==="\\\\"||f==="-"||f==="]"||f==="^"?"\\\\"+f:\nf}function b(f){var b=f.substring(1,f.length-1).match(/\\\\u[\\dA-Fa-f]{4}|\\\\x[\\dA-Fa-f]{2}|\\\\[0-3][0-7]{0,2}|\\\\[0-7]{1,2}|\\\\[\\S\\s]|[^\\\\]/g),f=[],a=b[0]==="^",c=["["];a&&c.push("^");for(var a=a?1:0,g=b.length;a<g;++a){var k=b[a];if(/\\\\[bdsw]/i.test(k))c.push(k);else{var k=d(k),o;a+2<g&&"-"===b[a+1]?(o=d(b[a+2]),a+=2):o=k;f.push([k,o]);o<65||k>122||(o<65||k>90||f.push([Math.max(65,k)|32,Math.min(o,90)|32]),o<97||k>122||f.push([Math.max(97,k)&-33,Math.min(o,122)&-33]))}}f.sort(function(f,a){return f[0]-\na[0]||a[1]-f[1]});b=[];g=[];for(a=0;a<f.length;++a)k=f[a],k[0]<=g[1]+1?g[1]=Math.max(g[1],k[1]):b.push(g=k);for(a=0;a<b.length;++a)k=b[a],c.push(h(k[0])),k[1]>k[0]&&(k[1]+1>k[0]&&c.push("-"),c.push(h(k[1])));c.push("]");return c.join("")}function e(f){for(var a=f.source.match(/\\[(?:[^\\\\\\]]|\\\\[\\S\\s])*]|\\\\u[\\dA-Fa-f]{4}|\\\\x[\\dA-Fa-f]{2}|\\\\\\d+|\\\\[^\\dux]|\\(\\?[!:=]|[()^]|[^()[\\\\^]+/g),c=a.length,d=[],g=0,k=0;g<c;++g){var o=a[g];o==="("?++k:"\\\\"===o.charAt(0)&&(o=+o.substring(1))&&(o<=k?d[o]=-1:a[g]=h(o))}for(g=\n1;g<d.length;++g)-1===d[g]&&(d[g]=++j);for(k=g=0;g<c;++g)o=a[g],o==="("?(++k,d[k]||(a[g]="(?:")):"\\\\"===o.charAt(0)&&(o=+o.substring(1))&&o<=k&&(a[g]="\\\\"+d[o]);for(g=0;g<c;++g)"^"===a[g]&&"^"!==a[g+1]&&(a[g]="");if(f.ignoreCase&&F)for(g=0;g<c;++g)o=a[g],f=o.charAt(0),o.length>=2&&f==="["?a[g]=b(o):f!=="\\\\"&&(a[g]=o.replace(/[A-Za-z]/g,function(a){a=a.charCodeAt(0);return"["+String.fromCharCode(a&-33,a|32)+"]"}));return a.join("")}for(var j=0,F=!1,l=!1,I=0,c=a.length;I<c;++I){var p=a[I];if(p.ignoreCase)l=\n!0;else if(/[a-z]/i.test(p.source.replace(/\\\\u[\\da-f]{4}|\\\\x[\\da-f]{2}|\\\\[^UXux]/gi,""))){F=!0;l=!1;break}}for(var i={b:8,t:9,n:10,v:11,f:12,r:13},q=[],I=0,c=a.length;I<c;++I){p=a[I];if(p.global||p.multiline)throw Error(""+p);q.push("(?:"+e(p)+")")}return RegExp(q.join("|"),l?"gi":"g")}function m(a,d){function h(a){var c=a.nodeType;if(c==1){if(!b.test(a.className)){for(c=a.firstChild;c;c=c.nextSibling)h(c);c=a.nodeName.toLowerCase();if("br"===c||"li"===c)e[l]="\\n",F[l<<1]=j++,F[l++<<1|1]=a}}else if(c==\n3||c==4)c=a.nodeValue,c.length&&(c=d?c.replace(/\\r\\n?/g,"\\n"):c.replace(/[\\t\\n\\r ]+/g," "),e[l]=c,F[l<<1]=j,j+=c.length,F[l++<<1|1]=a)}var b=/(?:^|\\s)nocode(?:\\s|$)/,e=[],j=0,F=[],l=0;h(a);return{a:e.join("").replace(/\\n$/,""),d:F}}function n(a,d,h,b){d&&(a={a:d,e:a},h(a),b.push.apply(b,a.g))}function x(a){for(var d=void 0,h=a.firstChild;h;h=h.nextSibling)var b=h.nodeType,d=b===1?d?a:h:b===3?S.test(h.nodeValue)?a:d:d;return d===a?void 0:d}function C(a,d){function h(a){for(var l=a.e,j=[l,"pln"],c=\n0,p=a.a.match(e)||[],m={},q=0,f=p.length;q<f;++q){var B=p[q],y=m[B],u=void 0,g;if(typeof y==="string")g=!1;else{var k=b[B.charAt(0)];if(k)u=B.match(k[1]),y=k[0];else{for(g=0;g<i;++g)if(k=d[g],u=B.match(k[1])){y=k[0];break}u||(y="pln")}if((g=y.length>=5&&"lang-"===y.substring(0,5))&&!(u&&typeof u[1]==="string"))g=!1,y="src";g||(m[B]=y)}k=c;c+=B.length;if(g){g=u[1];var o=B.indexOf(g),H=o+g.length;u[2]&&(H=B.length-u[2].length,o=H-g.length);y=y.substring(5);n(l+k,B.substring(0,o),h,j);n(l+k+o,g,A(y,\ng),j);n(l+k+H,B.substring(H),h,j)}else j.push(l+k,y)}a.g=j}var b={},e;(function(){for(var h=a.concat(d),l=[],i={},c=0,p=h.length;c<p;++c){var m=h[c],q=m[3];if(q)for(var f=q.length;--f>=0;)b[q.charAt(f)]=m;m=m[1];q=""+m;i.hasOwnProperty(q)||(l.push(m),i[q]=r)}l.push(/[\\S\\s]/);e=j(l)})();var i=d.length;return h}function t(a){var d=[],h=[];a.tripleQuotedStrings?d.push(["str",/^(?:\'\'\'(?:[^\'\\\\]|\\\\[\\S\\s]|\'\'?(?=[^\']))*(?:\'\'\'|$)|"""(?:[^"\\\\]|\\\\[\\S\\s]|""?(?=[^"]))*(?:"""|$)|\'(?:[^\'\\\\]|\\\\[\\S\\s])*(?:\'|$)|"(?:[^"\\\\]|\\\\[\\S\\s])*(?:"|$))/,\nr,"\'\\""]):a.multiLineStrings?d.push(["str",/^(?:\'(?:[^\'\\\\]|\\\\[\\S\\s])*(?:\'|$)|"(?:[^"\\\\]|\\\\[\\S\\s])*(?:"|$)|`(?:[^\\\\`]|\\\\[\\S\\s])*(?:`|$))/,r,"\'\\"`"]):d.push(["str",/^(?:\'(?:[^\\n\\r\'\\\\]|\\\\.)*(?:\'|$)|"(?:[^\\n\\r"\\\\]|\\\\.)*(?:"|$))/,r,"\\"\'"]);a.verbatimStrings&&h.push(["str",/^@"(?:[^"]|"")*(?:"|$)/,r]);var b=a.hashComments;b&&(a.cStyleComments?(b>1?d.push(["com",/^#(?:##(?:[^#]|#(?!##))*(?:###|$)|.*)/,r,"#"]):d.push(["com",/^#(?:(?:define|e(?:l|nd)if|else|error|ifn?def|include|line|pragma|undef|warning)\\b|[^\\n\\r]*)/,\nr,"#"]),h.push(["str",/^<(?:(?:(?:\\.\\.\\/)*|\\/?)(?:[\\w-]+(?:\\/[\\w-]+)+)?[\\w-]+\\.h(?:h|pp|\\+\\+)?|[a-z]\\w*)>/,r])):d.push(["com",/^#[^\\n\\r]*/,r,"#"]));a.cStyleComments&&(h.push(["com",/^\\/\\/[^\\n\\r]*/,r]),h.push(["com",/^\\/\\*[\\S\\s]*?(?:\\*\\/|$)/,r]));if(b=a.regexLiterals){var e=(b=b>1?"":"\\n\\r")?".":"[\\\\S\\\\s]";h.push(["lang-regex",RegExp("^(?:^^\\\\.?|[+-]|[!=]=?=?|\\\\#|%=?|&&?=?|\\\\(|\\\\*=?|[+\\\\-]=|->|\\\\/=?|::?|<<?=?|>>?>?=?|,|;|\\\\?|@|\\\\[|~|{|\\\\^\\\\^?=?|\\\\|\\\\|?=?|break|case|continue|delete|do|else|finally|instanceof|return|throw|try|typeof)\\\\s*("+\n("/(?=[^/*"+b+"])(?:[^/\\\\x5B\\\\x5C"+b+"]|\\\\x5C"+e+"|\\\\x5B(?:[^\\\\x5C\\\\x5D"+b+"]|\\\\x5C"+e+")*(?:\\\\x5D|$))+/")+")")])}(b=a.types)&&h.push(["typ",b]);b=(""+a.keywords).replace(/^ | $/g,"");b.length&&h.push(["kwd",RegExp("^(?:"+b.replace(/[\\s,]+/g,"|")+")\\\\b"),r]);d.push(["pln",/^\\s+/,r," \\r\\n\\t\\u00a0"]);b="^.[^\\\\s\\\\w.$@\'\\"`/\\\\\\\\]*";a.regexLiterals&&(b+="(?!s*/)");h.push(["lit",/^@[$_a-z][\\w$@]*/i,r],["typ",/^(?:[@_]?[A-Z]+[a-z][\\w$@]*|\\w+_t\\b)/,r],["pln",/^[$_a-z][\\w$@]*/i,r],["lit",/^(?:0x[\\da-f]+|(?:\\d(?:_\\d+)*\\d*(?:\\.\\d*)?|\\.\\d\\+)(?:e[+-]?\\d+)?)[a-z]*/i,\nr,"0123456789"],["pln",/^\\\\[\\S\\s]?/,r],["pun",RegExp(b),r]);return C(d,h)}function z(a,d,h){function b(a){var c=a.nodeType;if(c==1&&!j.test(a.className))if("br"===a.nodeName)e(a),a.parentNode&&a.parentNode.removeChild(a);else for(a=a.firstChild;a;a=a.nextSibling)b(a);else if((c==3||c==4)&&h){var d=a.nodeValue,i=d.match(m);if(i)c=d.substring(0,i.index),a.nodeValue=c,(d=d.substring(i.index+i[0].length))&&a.parentNode.insertBefore(l.createTextNode(d),a.nextSibling),e(a),c||a.parentNode.removeChild(a)}}\nfunction e(a){function b(a,c){var d=c?a.cloneNode(!1):a,f=a.parentNode;if(f){var f=b(f,1),h=a.nextSibling;f.appendChild(d);for(var e=h;e;e=h)h=e.nextSibling,f.appendChild(e)}return d}for(;!a.nextSibling;)if(a=a.parentNode,!a)return;for(var a=b(a.nextSibling,0),d;(d=a.parentNode)&&d.nodeType===1;)a=d;c.push(a)}for(var j=/(?:^|\\s)nocode(?:\\s|$)/,m=/\\r\\n?|\\n/,l=a.ownerDocument,i=l.createElement("li");a.firstChild;)i.appendChild(a.firstChild);for(var c=[i],p=0;p<c.length;++p)b(c[p]);d===(d|0)&&c[0].setAttribute("value",\nd);var n=l.createElement("ol");n.className="linenums";for(var d=Math.max(0,d-1|0)||0,p=0,q=c.length;p<q;++p)i=c[p],i.className="L"+(p+d)%10,i.firstChild||i.appendChild(l.createTextNode("\\u00a0")),n.appendChild(i);a.appendChild(n)}function i(a,d){for(var h=d.length;--h>=0;){var b=d[h];U.hasOwnProperty(b)?V.console&&console.warn("cannot override language handler %s",b):U[b]=a}}function A(a,d){if(!a||!U.hasOwnProperty(a))a=/^\\s*</.test(d)?"default-markup":"default-code";return U[a]}function D(a){var d=\na.h;try{var h=m(a.c,a.i),b=h.a;a.a=b;a.d=h.d;a.e=0;A(d,b)(a);var e=/\\bMSIE\\s(\\d+)/.exec(navigator.userAgent),e=e&&+e[1]<=8,d=/\\n/g,i=a.a,j=i.length,h=0,l=a.d,n=l.length,b=0,c=a.g,p=c.length,t=0;c[p]=j;var q,f;for(f=q=0;f<p;)c[f]!==c[f+2]?(c[q++]=c[f++],c[q++]=c[f++]):f+=2;p=q;for(f=q=0;f<p;){for(var x=c[f],y=c[f+1],u=f+2;u+2<=p&&c[u+1]===y;)u+=2;c[q++]=x;c[q++]=y;f=u}c.length=q;var g=a.c,k;if(g)k=g.style.display,g.style.display="none";try{for(;b<n;){var o=l[b+2]||j,H=c[t+2]||j,u=Math.min(o,H),E=l[b+\n1],W;if(E.nodeType!==1&&(W=i.substring(h,u))){e&&(W=W.replace(d,"\\r"));E.nodeValue=W;var Z=E.ownerDocument,s=Z.createElement("span");s.className=c[t+1];var z=E.parentNode;z.replaceChild(s,E);s.appendChild(E);h<o&&(l[b+1]=E=Z.createTextNode(i.substring(u,o)),z.insertBefore(E,s.nextSibling))}h=u;h>=o&&(b+=2);h>=H&&(t+=2)}}finally{if(g)g.style.display=k}}catch(v){V.console&&console.log(v&&v.stack||v)}}var V=window,G=["break,continue,do,else,for,if,return,while"],O=[[G,"auto,case,char,const,default,double,enum,extern,float,goto,inline,int,long,register,short,signed,sizeof,static,struct,switch,typedef,union,unsigned,void,volatile"],\n"catch,class,delete,false,import,new,operator,private,protected,public,this,throw,true,try,typeof"],J=[O,"alignof,align_union,asm,axiom,bool,concept,concept_map,const_cast,constexpr,decltype,delegate,dynamic_cast,explicit,export,friend,generic,late_check,mutable,namespace,nullptr,property,reinterpret_cast,static_assert,static_cast,template,typeid,typename,using,virtual,where"],K=[O,"abstract,assert,boolean,byte,extends,final,finally,implements,import,instanceof,interface,null,native,package,strictfp,super,synchronized,throws,transient"],\nL=[K,"as,base,by,checked,decimal,delegate,descending,dynamic,event,fixed,foreach,from,group,implicit,in,internal,into,is,let,lock,object,out,override,orderby,params,partial,readonly,ref,sbyte,sealed,stackalloc,string,select,uint,ulong,unchecked,unsafe,ushort,var,virtual,where"],O=[O,"debugger,eval,export,function,get,null,set,undefined,var,with,Infinity,NaN"],M=[G,"and,as,assert,class,def,del,elif,except,exec,finally,from,global,import,in,is,lambda,nonlocal,not,or,pass,print,raise,try,with,yield,False,True,None"],\nN=[G,"alias,and,begin,case,class,def,defined,elsif,end,ensure,false,in,module,next,nil,not,or,redo,rescue,retry,self,super,then,true,undef,unless,until,when,yield,BEGIN,END"],R=[G,"as,assert,const,copy,drop,enum,extern,fail,false,fn,impl,let,log,loop,match,mod,move,mut,priv,pub,pure,ref,self,static,struct,true,trait,type,unsafe,use"],G=[G,"case,done,elif,esac,eval,fi,function,in,local,set,then,until"],Q=/^(DIR|FILE|vector|(de|priority_)?queue|list|stack|(const_)?iterator|(multi)?(set|map)|bitset|u?(int|float)\\d*)\\b/,\nS=/\\S/,T=t({keywords:[J,L,O,"caller,delete,die,do,dump,elsif,eval,exit,foreach,for,goto,if,import,last,local,my,next,no,our,print,package,redo,require,sub,undef,unless,until,use,wantarray,while,BEGIN,END",M,N,G],hashComments:!0,cStyleComments:!0,multiLineStrings:!0,regexLiterals:!0}),U={};i(T,["default-code"]);i(C([],[["pln",/^[^<?]+/],["dec",/^<!\\w[^>]*(?:>|$)/],["com",/^<\\!--[\\S\\s]*?(?:--\\>|$)/],["lang-",/^<\\?([\\S\\s]+?)(?:\\?>|$)/],["lang-",/^<%([\\S\\s]+?)(?:%>|$)/],["pun",/^(?:<[%?]|[%?]>)/],["lang-",\n/^<xmp\\b[^>]*>([\\S\\s]+?)<\\/xmp\\b[^>]*>/i],["lang-js",/^<script\\b[^>]*>([\\S\\s]*?)(<\\/script\\b[^>]*>)/i],["lang-css",/^<style\\b[^>]*>([\\S\\s]*?)(<\\/style\\b[^>]*>)/i],["lang-in.tag",/^(<\\/?[a-z][^<>]*>)/i]]),["default-markup","htm","html","mxml","xhtml","xml","xsl"]);i(C([["pln",/^\\s+/,r," \\t\\r\\n"],["atv",/^(?:"[^"]*"?|\'[^\']*\'?)/,r,"\\"\'"]],[["tag",/^^<\\/?[a-z](?:[\\w-.:]*\\w)?|\\/?>$/i],["atn",/^(?!style[\\s=]|on)[a-z](?:[\\w:-]*\\w)?/i],["lang-uq.val",/^=\\s*([^\\s"\'>]*(?:[^\\s"\'/>]|\\/(?=\\s)))/],["pun",/^[/<->]+/],\n["lang-js",/^on\\w+\\s*=\\s*"([^"]+)"/i],["lang-js",/^on\\w+\\s*=\\s*\'([^\']+)\'/i],["lang-js",/^on\\w+\\s*=\\s*([^\\s"\'>]+)/i],["lang-css",/^style\\s*=\\s*"([^"]+)"/i],["lang-css",/^style\\s*=\\s*\'([^\']+)\'/i],["lang-css",/^style\\s*=\\s*([^\\s"\'>]+)/i]]),["in.tag"]);i(C([],[["atv",/^[\\S\\s]+/]]),["uq.val"]);i(t({keywords:J,hashComments:!0,cStyleComments:!0,types:Q}),["c","cc","cpp","cxx","cyc","m"]);i(t({keywords:"null,true,false"}),["json"]);i(t({keywords:L,hashComments:!0,cStyleComments:!0,verbatimStrings:!0,types:Q}),\n["cs"]);i(t({keywords:K,cStyleComments:!0}),["java"]);i(t({keywords:G,hashComments:!0,multiLineStrings:!0}),["bash","bsh","csh","sh"]);i(t({keywords:M,hashComments:!0,multiLineStrings:!0,tripleQuotedStrings:!0}),["cv","py","python"]);i(t({keywords:"caller,delete,die,do,dump,elsif,eval,exit,foreach,for,goto,if,import,last,local,my,next,no,our,print,package,redo,require,sub,undef,unless,until,use,wantarray,while,BEGIN,END",hashComments:!0,multiLineStrings:!0,regexLiterals:2}),["perl","pl","pm"]);i(t({keywords:N,\nhashComments:!0,multiLineStrings:!0,regexLiterals:!0}),["rb","ruby"]);i(t({keywords:O,cStyleComments:!0,regexLiterals:!0}),["javascript","js"]);i(t({keywords:"all,and,by,catch,class,else,extends,false,finally,for,if,in,is,isnt,loop,new,no,not,null,of,off,on,or,return,super,then,throw,true,try,unless,until,when,while,yes",hashComments:3,cStyleComments:!0,multilineStrings:!0,tripleQuotedStrings:!0,regexLiterals:!0}),["coffee"]);i(t({keywords:R,cStyleComments:!0,multilineStrings:!0}),["rc","rs","rust"]);\ni(C([],[["str",/^[\\S\\s]+/]]),["regex"]);var X=V.PR={createSimpleLexer:C,registerLangHandler:i,sourceDecorator:t,PR_ATTRIB_NAME:"atn",PR_ATTRIB_VALUE:"atv",PR_COMMENT:"com",PR_DECLARATION:"dec",PR_KEYWORD:"kwd",PR_LITERAL:"lit",PR_NOCODE:"nocode",PR_PLAIN:"pln",PR_PUNCTUATION:"pun",PR_SOURCE:"src",PR_STRING:"str",PR_TAG:"tag",PR_TYPE:"typ",prettyPrintOne:function(a,d,e){var b=document.createElement("div");b.innerHTML="<pre>"+a+"</pre>";b=b.firstChild;e&&z(b,e,!0);D({h:d,j:e,c:b,i:1});return b.innerHTML},\nprettyPrint:e=e=function(a,d){function e(){for(var b=V.PR_SHOULD_USE_CONTINUATION?c.now()+250:Infinity;p<j.length&&c.now()<b;p++){for(var d=j[p],m=k,l=d;l=l.previousSibling;){var n=l.nodeType,s=(n===7||n===8)&&l.nodeValue;if(s?!/^\\??prettify\\b/.test(s):n!==3||/\\S/.test(l.nodeValue))break;if(s){m={};s.replace(/\\b(\\w+)=([\\w%+\\-.:]+)/g,function(a,b,c){m[b]=c});break}}l=d.className;if((m!==k||f.test(l))&&!w.test(l)){n=!1;for(s=d.parentNode;s;s=s.parentNode)if(g.test(s.tagName)&&s.className&&f.test(s.className)){n=\n!0;break}if(!n){d.className+=" prettyprinted";n=m.lang;if(!n){var n=l.match(q),A;if(!n&&(A=x(d))&&u.test(A.tagName))n=A.className.match(q);n&&(n=n[1])}if(y.test(d.tagName))s=1;else var s=d.currentStyle,v=i.defaultView,s=(s=s?s.whiteSpace:v&&v.getComputedStyle?v.getComputedStyle(d,r).getPropertyValue("white-space"):0)&&"pre"===s.substring(0,3);v=m.linenums;if(!(v=v==="true"||+v))v=(v=l.match(/\\blinenums\\b(?::(\\d+))?/))?v[1]&&v[1].length?+v[1]:!0:!1;v&&z(d,v,s);t={h:n,c:d,j:v,i:s};D(t)}}}p<j.length?\nP(e,250):"function"===typeof a&&a()}for(var b=d||document.body,i=b.ownerDocument||document,b=[b.getElementsByTagName("pre"),b.getElementsByTagName("code"),b.getElementsByTagName("xmp")],j=[],m=0;m<b.length;++m)for(var l=0,n=b[m].length;l<n;++l)j.push(b[m][l]);var b=r,c=Date;c.now||(c={now:function(){return+new Date}});var p=0,t,q=/\\blang(?:uage)?-([\\w.]+)(?!\\S)/,f=/\\bprettyprint\\b/,w=/\\bprettyprinted\\b/,y=/pre|xmp/i,u=/^code$/i,g=/^(?:pre|code|xmp)$/i,k={};e()}}; true&&\n!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = (function(){return X}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))})();return e}();R||P(Q,0)})();}()\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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YSw0REFBNEQsc0JBQXNCLEtBQUssdUJBQXVCLG9CQUFvQixFQUFFLCtDQUErQyxtRUFBbUUsTUFBTSxLQUFLLG1EQUFtRCxPQUFPLEVBQUUsT0FBTyxjQUFjLG1DQUFtQyxLQUFLLG1CQUFtQixFQUFFLHVFQUF1RTtBQUNqZ0IsR0FBRyxNQUFNLE9BQU8sOEJBQThCLFNBQVMsT0FBTyxtQkFBbUIsMERBQTBELFlBQVkseUJBQXlCLHlLQUF5SyxhQUFhLDhGQUE4RixZQUFZLEdBQUcsaUJBQWlCLE9BQU87QUFDM2Usb0NBQW9DLCtKQUErSixXQUFXLDhCQUE4QixJQUFJLG9CQUFvQixlQUFlLFdBQVcsZUFBZSxpQkFBaUIsRUFBRSw2SUFBNkksTUFBTSxLQUFzQztBQUN6ZixpQ0FBOEIsRUFBRSxtQ0FBQyxXQUFXLFNBQVM7QUFBQSxrR0FBQyxDQUFDLElBQUksU0FBUyxHQUFHLFVBQVUsS0FBSyIsInNvdXJjZXMiOlsid2VicGFjazovL2NvbG9ydHJhbnNsYXRvci8uL25vZGVfbW9kdWxlcy8ucG5wbS9nb29nbGUtY29kZS1wcmV0dGlmeUAxLjAuNS9ub2RlX21vZHVsZXMvZ29vZ2xlLWNvZGUtcHJldHRpZnkvYmluL3J1bl9wcmV0dGlmeS5taW4uanM/ZmM4OSJdLCJzb3VyY2VzQ29udGVudCI6WyIhZnVuY3Rpb24oKXt2YXIgcj1udWxsO1xuKGZ1bmN0aW9uKCl7ZnVuY3Rpb24gWChlKXtmdW5jdGlvbiBqKCl7dHJ5e0ouZG9TY3JvbGwoXCJsZWZ0XCIpfWNhdGNoKGUpe1Aoaiw1MCk7cmV0dXJufXcoXCJwb2xsXCIpfWZ1bmN0aW9uIHcoail7aWYoIShqLnR5cGU9PVwicmVhZHlzdGF0ZWNoYW5nZVwiJiZ4LnJlYWR5U3RhdGUhPVwiY29tcGxldGVcIikmJigoai50eXBlPT1cImxvYWRcIj9uOngpW3pdKGkrai50eXBlLHcsITEpLCFtJiYobT0hMCkpKWUuY2FsbChuLGoudHlwZXx8ail9dmFyIFk9eC5hZGRFdmVudExpc3RlbmVyLG09ITEsQz0hMCx0PVk/XCJhZGRFdmVudExpc3RlbmVyXCI6XCJhdHRhY2hFdmVudFwiLHo9WT9cInJlbW92ZUV2ZW50TGlzdGVuZXJcIjpcImRldGFjaEV2ZW50XCIsaT1ZP1wiXCI6XCJvblwiO2lmKHgucmVhZHlTdGF0ZT09XCJjb21wbGV0ZVwiKWUuY2FsbChuLFwibGF6eVwiKTtlbHNle2lmKHguY3JlYXRlRXZlbnRPYmplY3QmJkouZG9TY3JvbGwpe3RyeXtDPSFuLmZyYW1lRWxlbWVudH1jYXRjaChBKXt9QyYmaigpfXhbdF0oaStcIkRPTUNvbnRlbnRMb2FkZWRcIixcbncsITEpO3hbdF0oaStcInJlYWR5c3RhdGVjaGFuZ2VcIix3LCExKTtuW3RdKGkrXCJsb2FkXCIsdywhMSl9fWZ1bmN0aW9uIFEoKXtTJiZYKGZ1bmN0aW9uKCl7dmFyIGU9Sy5sZW5ndGg7JChlP2Z1bmN0aW9uKCl7Zm9yKHZhciBqPTA7ajxlOysraikoZnVuY3Rpb24oZSl7UChmdW5jdGlvbigpe24uZXhwb3J0c1tLW2VdXS5hcHBseShuLGFyZ3VtZW50cyl9LDApfSkoail9OnZvaWQgMCl9KX1mb3IodmFyIG49d2luZG93LFA9bi5zZXRUaW1lb3V0LHg9ZG9jdW1lbnQsSj14LmRvY3VtZW50RWxlbWVudCxMPXguaGVhZHx8eC5nZXRFbGVtZW50c0J5VGFnTmFtZShcImhlYWRcIilbMF18fEosej1cIlwiLEE9eC5zY3JpcHRzLG09QS5sZW5ndGg7LS1tPj0wOyl7dmFyIE09QVttXSxUPU0uc3JjLm1hdGNoKC9eW14jP10qXFwvcnVuX3ByZXR0aWZ5XFwuanMoXFw/W14jXSopPyg/OiMuKik/JC8pO2lmKFQpe3o9VFsxXXx8XCJcIjtNLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoTSk7YnJlYWt9fXZhciBTPSEwLEQ9XG5bXSxOPVtdLEs9W107ei5yZXBsYWNlKC9bJj9dKFteJj1dKyk9KFteJl0rKS9nLGZ1bmN0aW9uKGUsaix3KXt3PWRlY29kZVVSSUNvbXBvbmVudCh3KTtqPWRlY29kZVVSSUNvbXBvbmVudChqKTtqPT1cImF1dG9ydW5cIj9TPSEvXlswZm5dL2kudGVzdCh3KTpqPT1cImxhbmdcIj9ELnB1c2godyk6aj09XCJza2luXCI/Ti5wdXNoKHcpOmo9PVwiY2FsbGJhY2tcIiYmSy5wdXNoKHcpfSk7bT0wO2Zvcih6PUQubGVuZ3RoO208ejsrK20pKGZ1bmN0aW9uKCl7dmFyIGU9eC5jcmVhdGVFbGVtZW50KFwic2NyaXB0XCIpO2Uub25sb2FkPWUub25lcnJvcj1lLm9ucmVhZHlzdGF0ZWNoYW5nZT1mdW5jdGlvbigpe2lmKGUmJighZS5yZWFkeVN0YXRlfHwvbG9hZGVkfGNvbXBsZXRlLy50ZXN0KGUucmVhZHlTdGF0ZSkpKWUub25lcnJvcj1lLm9ubG9hZD1lLm9ucmVhZHlzdGF0ZWNoYW5nZT1yLC0tUixSfHxQKFEsMCksZS5wYXJlbnROb2RlJiZlLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoZSksZT1yfTtlLnR5cGU9XG5cInRleHQvamF2YXNjcmlwdFwiO2Uuc3JjPVwiaHR0cHM6Ly9nb29nbGUtY29kZS1wcmV0dGlmeS5nb29nbGVjb2RlLmNvbS9zdm4vbG9hZGVyL2xhbmctXCIrZW5jb2RlVVJJQ29tcG9uZW50KERbbV0pK1wiLmpzXCI7TC5pbnNlcnRCZWZvcmUoZSxMLmZpcnN0Q2hpbGQpfSkoRFttXSk7Zm9yKHZhciBSPUQubGVuZ3RoLEE9W10sbT0wLHo9Ti5sZW5ndGg7bTx6OysrbSlBLnB1c2goXCJodHRwczovL2dvb2dsZS1jb2RlLXByZXR0aWZ5Lmdvb2dsZWNvZGUuY29tL3N2bi9sb2FkZXIvc2tpbnMvXCIrZW5jb2RlVVJJQ29tcG9uZW50KE5bbV0pK1wiLmNzc1wiKTtBLnB1c2goXCJodHRwczovL2dvb2dsZS1jb2RlLXByZXR0aWZ5Lmdvb2dsZWNvZGUuY29tL3N2bi9sb2FkZXIvcHJldHRpZnkuY3NzXCIpOyhmdW5jdGlvbihlKXtmdW5jdGlvbiBqKG0pe2lmKG0hPT13KXt2YXIgbj14LmNyZWF0ZUVsZW1lbnQoXCJsaW5rXCIpO24ucmVsPVwic3R5bGVzaGVldFwiO24udHlwZT1cInRleHQvY3NzXCI7aWYobSsxPHcpbi5lcnJvcj1cbm4ub25lcnJvcj1mdW5jdGlvbigpe2oobSsxKX07bi5ocmVmPWVbbV07TC5hcHBlbmRDaGlsZChuKX19dmFyIHc9ZS5sZW5ndGg7aigwKX0pKEEpO3ZhciAkPWZ1bmN0aW9uKCl7d2luZG93LlBSX1NIT1VMRF9VU0VfQ09OVElOVUFUSU9OPSEwO3ZhciBlOyhmdW5jdGlvbigpe2Z1bmN0aW9uIGooYSl7ZnVuY3Rpb24gZChmKXt2YXIgYj1mLmNoYXJDb2RlQXQoMCk7aWYoYiE9PTkyKXJldHVybiBiO3ZhciBhPWYuY2hhckF0KDEpO3JldHVybihiPWlbYV0pP2I6XCIwXCI8PWEmJmE8PVwiN1wiP3BhcnNlSW50KGYuc3Vic3RyaW5nKDEpLDgpOmE9PT1cInVcInx8YT09PVwieFwiP3BhcnNlSW50KGYuc3Vic3RyaW5nKDIpLDE2KTpmLmNoYXJDb2RlQXQoMSl9ZnVuY3Rpb24gaChmKXtpZihmPDMyKXJldHVybihmPDE2P1wiXFxcXHgwXCI6XCJcXFxceFwiKStmLnRvU3RyaW5nKDE2KTtmPVN0cmluZy5mcm9tQ2hhckNvZGUoZik7cmV0dXJuIGY9PT1cIlxcXFxcInx8Zj09PVwiLVwifHxmPT09XCJdXCJ8fGY9PT1cIl5cIj9cIlxcXFxcIitmOlxuZn1mdW5jdGlvbiBiKGYpe3ZhciBiPWYuc3Vic3RyaW5nKDEsZi5sZW5ndGgtMSkubWF0Y2goL1xcXFx1W1xcZEEtRmEtZl17NH18XFxcXHhbXFxkQS1GYS1mXXsyfXxcXFxcWzAtM11bMC03XXswLDJ9fFxcXFxbMC03XXsxLDJ9fFxcXFxbXFxTXFxzXXxbXlxcXFxdL2cpLGY9W10sYT1iWzBdPT09XCJeXCIsYz1bXCJbXCJdO2EmJmMucHVzaChcIl5cIik7Zm9yKHZhciBhPWE/MTowLGc9Yi5sZW5ndGg7YTxnOysrYSl7dmFyIGs9YlthXTtpZigvXFxcXFtiZHN3XS9pLnRlc3QoaykpYy5wdXNoKGspO2Vsc2V7dmFyIGs9ZChrKSxvO2ErMjxnJiZcIi1cIj09PWJbYSsxXT8obz1kKGJbYSsyXSksYSs9Mik6bz1rO2YucHVzaChbayxvXSk7bzw2NXx8az4xMjJ8fChvPDY1fHxrPjkwfHxmLnB1c2goW01hdGgubWF4KDY1LGspfDMyLE1hdGgubWluKG8sOTApfDMyXSksbzw5N3x8az4xMjJ8fGYucHVzaChbTWF0aC5tYXgoOTcsaykmLTMzLE1hdGgubWluKG8sMTIyKSYtMzNdKSl9fWYuc29ydChmdW5jdGlvbihmLGEpe3JldHVybiBmWzBdLVxuYVswXXx8YVsxXS1mWzFdfSk7Yj1bXTtnPVtdO2ZvcihhPTA7YTxmLmxlbmd0aDsrK2Epaz1mW2FdLGtbMF08PWdbMV0rMT9nWzFdPU1hdGgubWF4KGdbMV0sa1sxXSk6Yi5wdXNoKGc9ayk7Zm9yKGE9MDthPGIubGVuZ3RoOysrYSlrPWJbYV0sYy5wdXNoKGgoa1swXSkpLGtbMV0+a1swXSYmKGtbMV0rMT5rWzBdJiZjLnB1c2goXCItXCIpLGMucHVzaChoKGtbMV0pKSk7Yy5wdXNoKFwiXVwiKTtyZXR1cm4gYy5qb2luKFwiXCIpfWZ1bmN0aW9uIGUoZil7Zm9yKHZhciBhPWYuc291cmNlLm1hdGNoKC9cXFsoPzpbXlxcXFxcXF1dfFxcXFxbXFxTXFxzXSkqXXxcXFxcdVtcXGRBLUZhLWZdezR9fFxcXFx4W1xcZEEtRmEtZl17Mn18XFxcXFxcZCt8XFxcXFteXFxkdXhdfFxcKFxcP1shOj1dfFsoKV5dfFteKClbXFxcXF5dKy9nKSxjPWEubGVuZ3RoLGQ9W10sZz0wLGs9MDtnPGM7KytnKXt2YXIgbz1hW2ddO289PT1cIihcIj8rK2s6XCJcXFxcXCI9PT1vLmNoYXJBdCgwKSYmKG89K28uc3Vic3RyaW5nKDEpKSYmKG88PWs/ZFtvXT0tMTphW2ddPWgobykpfWZvcihnPVxuMTtnPGQubGVuZ3RoOysrZyktMT09PWRbZ10mJihkW2ddPSsraik7Zm9yKGs9Zz0wO2c8YzsrK2cpbz1hW2ddLG89PT1cIihcIj8oKytrLGRba118fChhW2ddPVwiKD86XCIpKTpcIlxcXFxcIj09PW8uY2hhckF0KDApJiYobz0rby5zdWJzdHJpbmcoMSkpJiZvPD1rJiYoYVtnXT1cIlxcXFxcIitkW29dKTtmb3IoZz0wO2c8YzsrK2cpXCJeXCI9PT1hW2ddJiZcIl5cIiE9PWFbZysxXSYmKGFbZ109XCJcIik7aWYoZi5pZ25vcmVDYXNlJiZGKWZvcihnPTA7ZzxjOysrZylvPWFbZ10sZj1vLmNoYXJBdCgwKSxvLmxlbmd0aD49MiYmZj09PVwiW1wiP2FbZ109YihvKTpmIT09XCJcXFxcXCImJihhW2ddPW8ucmVwbGFjZSgvW0EtWmEtel0vZyxmdW5jdGlvbihhKXthPWEuY2hhckNvZGVBdCgwKTtyZXR1cm5cIltcIitTdHJpbmcuZnJvbUNoYXJDb2RlKGEmLTMzLGF8MzIpK1wiXVwifSkpO3JldHVybiBhLmpvaW4oXCJcIil9Zm9yKHZhciBqPTAsRj0hMSxsPSExLEk9MCxjPWEubGVuZ3RoO0k8YzsrK0kpe3ZhciBwPWFbSV07aWYocC5pZ25vcmVDYXNlKWw9XG4hMDtlbHNlIGlmKC9bYS16XS9pLnRlc3QocC5zb3VyY2UucmVwbGFjZSgvXFxcXHVbXFxkYS1mXXs0fXxcXFxceFtcXGRhLWZdezJ9fFxcXFxbXlVYdXhdL2dpLFwiXCIpKSl7Rj0hMDtsPSExO2JyZWFrfX1mb3IodmFyIGk9e2I6OCx0OjksbjoxMCx2OjExLGY6MTIscjoxM30scT1bXSxJPTAsYz1hLmxlbmd0aDtJPGM7KytJKXtwPWFbSV07aWYocC5nbG9iYWx8fHAubXVsdGlsaW5lKXRocm93IEVycm9yKFwiXCIrcCk7cS5wdXNoKFwiKD86XCIrZShwKStcIilcIil9cmV0dXJuIFJlZ0V4cChxLmpvaW4oXCJ8XCIpLGw/XCJnaVwiOlwiZ1wiKX1mdW5jdGlvbiBtKGEsZCl7ZnVuY3Rpb24gaChhKXt2YXIgYz1hLm5vZGVUeXBlO2lmKGM9PTEpe2lmKCFiLnRlc3QoYS5jbGFzc05hbWUpKXtmb3IoYz1hLmZpcnN0Q2hpbGQ7YztjPWMubmV4dFNpYmxpbmcpaChjKTtjPWEubm9kZU5hbWUudG9Mb3dlckNhc2UoKTtpZihcImJyXCI9PT1jfHxcImxpXCI9PT1jKWVbbF09XCJcXG5cIixGW2w8PDFdPWorKyxGW2wrKzw8MXwxXT1hfX1lbHNlIGlmKGM9PVxuM3x8Yz09NCljPWEubm9kZVZhbHVlLGMubGVuZ3RoJiYoYz1kP2MucmVwbGFjZSgvXFxyXFxuPy9nLFwiXFxuXCIpOmMucmVwbGFjZSgvW1xcdFxcblxcciBdKy9nLFwiIFwiKSxlW2xdPWMsRltsPDwxXT1qLGorPWMubGVuZ3RoLEZbbCsrPDwxfDFdPWEpfXZhciBiPS8oPzpefFxccylub2NvZGUoPzpcXHN8JCkvLGU9W10saj0wLEY9W10sbD0wO2goYSk7cmV0dXJue2E6ZS5qb2luKFwiXCIpLnJlcGxhY2UoL1xcbiQvLFwiXCIpLGQ6Rn19ZnVuY3Rpb24gbihhLGQsaCxiKXtkJiYoYT17YTpkLGU6YX0saChhKSxiLnB1c2guYXBwbHkoYixhLmcpKX1mdW5jdGlvbiB4KGEpe2Zvcih2YXIgZD12b2lkIDAsaD1hLmZpcnN0Q2hpbGQ7aDtoPWgubmV4dFNpYmxpbmcpdmFyIGI9aC5ub2RlVHlwZSxkPWI9PT0xP2Q/YTpoOmI9PT0zP1MudGVzdChoLm5vZGVWYWx1ZSk/YTpkOmQ7cmV0dXJuIGQ9PT1hP3ZvaWQgMDpkfWZ1bmN0aW9uIEMoYSxkKXtmdW5jdGlvbiBoKGEpe2Zvcih2YXIgbD1hLmUsaj1bbCxcInBsblwiXSxjPVxuMCxwPWEuYS5tYXRjaChlKXx8W10sbT17fSxxPTAsZj1wLmxlbmd0aDtxPGY7KytxKXt2YXIgQj1wW3FdLHk9bVtCXSx1PXZvaWQgMCxnO2lmKHR5cGVvZiB5PT09XCJzdHJpbmdcIilnPSExO2Vsc2V7dmFyIGs9YltCLmNoYXJBdCgwKV07aWYoayl1PUIubWF0Y2goa1sxXSkseT1rWzBdO2Vsc2V7Zm9yKGc9MDtnPGk7KytnKWlmKGs9ZFtnXSx1PUIubWF0Y2goa1sxXSkpe3k9a1swXTticmVha311fHwoeT1cInBsblwiKX1pZigoZz15Lmxlbmd0aD49NSYmXCJsYW5nLVwiPT09eS5zdWJzdHJpbmcoMCw1KSkmJiEodSYmdHlwZW9mIHVbMV09PT1cInN0cmluZ1wiKSlnPSExLHk9XCJzcmNcIjtnfHwobVtCXT15KX1rPWM7Yys9Qi5sZW5ndGg7aWYoZyl7Zz11WzFdO3ZhciBvPUIuaW5kZXhPZihnKSxIPW8rZy5sZW5ndGg7dVsyXSYmKEg9Qi5sZW5ndGgtdVsyXS5sZW5ndGgsbz1ILWcubGVuZ3RoKTt5PXkuc3Vic3RyaW5nKDUpO24obCtrLEIuc3Vic3RyaW5nKDAsbyksaCxqKTtuKGwraytvLGcsQSh5LFxuZyksaik7bihsK2srSCxCLnN1YnN0cmluZyhIKSxoLGopfWVsc2Ugai5wdXNoKGwrayx5KX1hLmc9an12YXIgYj17fSxlOyhmdW5jdGlvbigpe2Zvcih2YXIgaD1hLmNvbmNhdChkKSxsPVtdLGk9e30sYz0wLHA9aC5sZW5ndGg7YzxwOysrYyl7dmFyIG09aFtjXSxxPW1bM107aWYocSlmb3IodmFyIGY9cS5sZW5ndGg7LS1mPj0wOyliW3EuY2hhckF0KGYpXT1tO209bVsxXTtxPVwiXCIrbTtpLmhhc093blByb3BlcnR5KHEpfHwobC5wdXNoKG0pLGlbcV09cil9bC5wdXNoKC9bXFxTXFxzXS8pO2U9aihsKX0pKCk7dmFyIGk9ZC5sZW5ndGg7cmV0dXJuIGh9ZnVuY3Rpb24gdChhKXt2YXIgZD1bXSxoPVtdO2EudHJpcGxlUXVvdGVkU3RyaW5ncz9kLnB1c2goW1wic3RyXCIsL14oPzonJycoPzpbXidcXFxcXXxcXFxcW1xcU1xcc118Jyc/KD89W14nXSkpKig/OicnJ3wkKXxcIlwiXCIoPzpbXlwiXFxcXF18XFxcXFtcXFNcXHNdfFwiXCI/KD89W15cIl0pKSooPzpcIlwiXCJ8JCl8Jyg/OlteJ1xcXFxdfFxcXFxbXFxTXFxzXSkqKD86J3wkKXxcIig/OlteXCJcXFxcXXxcXFxcW1xcU1xcc10pKig/OlwifCQpKS8sXG5yLFwiJ1xcXCJcIl0pOmEubXVsdGlMaW5lU3RyaW5ncz9kLnB1c2goW1wic3RyXCIsL14oPzonKD86W14nXFxcXF18XFxcXFtcXFNcXHNdKSooPzonfCQpfFwiKD86W15cIlxcXFxdfFxcXFxbXFxTXFxzXSkqKD86XCJ8JCl8YCg/OlteXFxcXGBdfFxcXFxbXFxTXFxzXSkqKD86YHwkKSkvLHIsXCInXFxcImBcIl0pOmQucHVzaChbXCJzdHJcIiwvXig/OicoPzpbXlxcblxccidcXFxcXXxcXFxcLikqKD86J3wkKXxcIig/OlteXFxuXFxyXCJcXFxcXXxcXFxcLikqKD86XCJ8JCkpLyxyLFwiXFxcIidcIl0pO2EudmVyYmF0aW1TdHJpbmdzJiZoLnB1c2goW1wic3RyXCIsL15AXCIoPzpbXlwiXXxcIlwiKSooPzpcInwkKS8scl0pO3ZhciBiPWEuaGFzaENvbW1lbnRzO2ImJihhLmNTdHlsZUNvbW1lbnRzPyhiPjE/ZC5wdXNoKFtcImNvbVwiLC9eIyg/OiMjKD86W14jXXwjKD8hIyMpKSooPzojIyN8JCl8LiopLyxyLFwiI1wiXSk6ZC5wdXNoKFtcImNvbVwiLC9eIyg/Oig/OmRlZmluZXxlKD86bHxuZClpZnxlbHNlfGVycm9yfGlmbj9kZWZ8aW5jbHVkZXxsaW5lfHByYWdtYXx1bmRlZnx3YXJuaW5nKVxcYnxbXlxcblxccl0qKS8sXG5yLFwiI1wiXSksaC5wdXNoKFtcInN0clwiLC9ePCg/Oig/Oig/OlxcLlxcLlxcLykqfFxcLz8pKD86W1xcdy1dKyg/OlxcL1tcXHctXSspKyk/W1xcdy1dK1xcLmgoPzpofHBwfFxcK1xcKyk/fFthLXpdXFx3Kik+LyxyXSkpOmQucHVzaChbXCJjb21cIiwvXiNbXlxcblxccl0qLyxyLFwiI1wiXSkpO2EuY1N0eWxlQ29tbWVudHMmJihoLnB1c2goW1wiY29tXCIsL15cXC9cXC9bXlxcblxccl0qLyxyXSksaC5wdXNoKFtcImNvbVwiLC9eXFwvXFwqW1xcU1xcc10qPyg/OlxcKlxcL3wkKS8scl0pKTtpZihiPWEucmVnZXhMaXRlcmFscyl7dmFyIGU9KGI9Yj4xP1wiXCI6XCJcXG5cXHJcIik/XCIuXCI6XCJbXFxcXFNcXFxcc11cIjtoLnB1c2goW1wibGFuZy1yZWdleFwiLFJlZ0V4cChcIl4oPzpeXlxcXFwuP3xbKy1dfFshPV09Pz0/fFxcXFwjfCU9P3wmJj89P3xcXFxcKHxcXFxcKj0/fFsrXFxcXC1dPXwtPnxcXFxcLz0/fDo6P3w8PD89P3w+Pj8+Pz0/fCx8O3xcXFxcP3xAfFxcXFxbfH58e3xcXFxcXlxcXFxePz0/fFxcXFx8XFxcXHw/PT98YnJlYWt8Y2FzZXxjb250aW51ZXxkZWxldGV8ZG98ZWxzZXxmaW5hbGx5fGluc3RhbmNlb2Z8cmV0dXJufHRocm93fHRyeXx0eXBlb2YpXFxcXHMqKFwiK1xuKFwiLyg/PVteLypcIitiK1wiXSkoPzpbXi9cXFxceDVCXFxcXHg1Q1wiK2IrXCJdfFxcXFx4NUNcIitlK1wifFxcXFx4NUIoPzpbXlxcXFx4NUNcXFxceDVEXCIrYitcIl18XFxcXHg1Q1wiK2UrXCIpKig/OlxcXFx4NUR8JCkpKy9cIikrXCIpXCIpXSl9KGI9YS50eXBlcykmJmgucHVzaChbXCJ0eXBcIixiXSk7Yj0oXCJcIithLmtleXdvcmRzKS5yZXBsYWNlKC9eIHwgJC9nLFwiXCIpO2IubGVuZ3RoJiZoLnB1c2goW1wia3dkXCIsUmVnRXhwKFwiXig/OlwiK2IucmVwbGFjZSgvW1xccyxdKy9nLFwifFwiKStcIilcXFxcYlwiKSxyXSk7ZC5wdXNoKFtcInBsblwiLC9eXFxzKy8scixcIiBcXHJcXG5cXHRcXHUwMGEwXCJdKTtiPVwiXi5bXlxcXFxzXFxcXHcuJEAnXFxcImAvXFxcXFxcXFxdKlwiO2EucmVnZXhMaXRlcmFscyYmKGIrPVwiKD8hcyovKVwiKTtoLnB1c2goW1wibGl0XCIsL15AWyRfYS16XVtcXHckQF0qL2kscl0sW1widHlwXCIsL14oPzpbQF9dP1tBLVpdK1thLXpdW1xcdyRAXSp8XFx3K190XFxiKS8scl0sW1wicGxuXCIsL15bJF9hLXpdW1xcdyRAXSovaSxyXSxbXCJsaXRcIiwvXig/OjB4W1xcZGEtZl0rfCg/OlxcZCg/Ol9cXGQrKSpcXGQqKD86XFwuXFxkKik/fFxcLlxcZFxcKykoPzplWystXT9cXGQrKT8pW2Etel0qL2ksXG5yLFwiMDEyMzQ1Njc4OVwiXSxbXCJwbG5cIiwvXlxcXFxbXFxTXFxzXT8vLHJdLFtcInB1blwiLFJlZ0V4cChiKSxyXSk7cmV0dXJuIEMoZCxoKX1mdW5jdGlvbiB6KGEsZCxoKXtmdW5jdGlvbiBiKGEpe3ZhciBjPWEubm9kZVR5cGU7aWYoYz09MSYmIWoudGVzdChhLmNsYXNzTmFtZSkpaWYoXCJiclwiPT09YS5ub2RlTmFtZSllKGEpLGEucGFyZW50Tm9kZSYmYS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGEpO2Vsc2UgZm9yKGE9YS5maXJzdENoaWxkO2E7YT1hLm5leHRTaWJsaW5nKWIoYSk7ZWxzZSBpZigoYz09M3x8Yz09NCkmJmgpe3ZhciBkPWEubm9kZVZhbHVlLGk9ZC5tYXRjaChtKTtpZihpKWM9ZC5zdWJzdHJpbmcoMCxpLmluZGV4KSxhLm5vZGVWYWx1ZT1jLChkPWQuc3Vic3RyaW5nKGkuaW5kZXgraVswXS5sZW5ndGgpKSYmYS5wYXJlbnROb2RlLmluc2VydEJlZm9yZShsLmNyZWF0ZVRleHROb2RlKGQpLGEubmV4dFNpYmxpbmcpLGUoYSksY3x8YS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGEpfX1cbmZ1bmN0aW9uIGUoYSl7ZnVuY3Rpb24gYihhLGMpe3ZhciBkPWM/YS5jbG9uZU5vZGUoITEpOmEsZj1hLnBhcmVudE5vZGU7aWYoZil7dmFyIGY9YihmLDEpLGg9YS5uZXh0U2libGluZztmLmFwcGVuZENoaWxkKGQpO2Zvcih2YXIgZT1oO2U7ZT1oKWg9ZS5uZXh0U2libGluZyxmLmFwcGVuZENoaWxkKGUpfXJldHVybiBkfWZvcig7IWEubmV4dFNpYmxpbmc7KWlmKGE9YS5wYXJlbnROb2RlLCFhKXJldHVybjtmb3IodmFyIGE9YihhLm5leHRTaWJsaW5nLDApLGQ7KGQ9YS5wYXJlbnROb2RlKSYmZC5ub2RlVHlwZT09PTE7KWE9ZDtjLnB1c2goYSl9Zm9yKHZhciBqPS8oPzpefFxccylub2NvZGUoPzpcXHN8JCkvLG09L1xcclxcbj98XFxuLyxsPWEub3duZXJEb2N1bWVudCxpPWwuY3JlYXRlRWxlbWVudChcImxpXCIpO2EuZmlyc3RDaGlsZDspaS5hcHBlbmRDaGlsZChhLmZpcnN0Q2hpbGQpO2Zvcih2YXIgYz1baV0scD0wO3A8Yy5sZW5ndGg7KytwKWIoY1twXSk7ZD09PShkfDApJiZjWzBdLnNldEF0dHJpYnV0ZShcInZhbHVlXCIsXG5kKTt2YXIgbj1sLmNyZWF0ZUVsZW1lbnQoXCJvbFwiKTtuLmNsYXNzTmFtZT1cImxpbmVudW1zXCI7Zm9yKHZhciBkPU1hdGgubWF4KDAsZC0xfDApfHwwLHA9MCxxPWMubGVuZ3RoO3A8cTsrK3ApaT1jW3BdLGkuY2xhc3NOYW1lPVwiTFwiKyhwK2QpJTEwLGkuZmlyc3RDaGlsZHx8aS5hcHBlbmRDaGlsZChsLmNyZWF0ZVRleHROb2RlKFwiXFx1MDBhMFwiKSksbi5hcHBlbmRDaGlsZChpKTthLmFwcGVuZENoaWxkKG4pfWZ1bmN0aW9uIGkoYSxkKXtmb3IodmFyIGg9ZC5sZW5ndGg7LS1oPj0wOyl7dmFyIGI9ZFtoXTtVLmhhc093blByb3BlcnR5KGIpP1YuY29uc29sZSYmY29uc29sZS53YXJuKFwiY2Fubm90IG92ZXJyaWRlIGxhbmd1YWdlIGhhbmRsZXIgJXNcIixiKTpVW2JdPWF9fWZ1bmN0aW9uIEEoYSxkKXtpZighYXx8IVUuaGFzT3duUHJvcGVydHkoYSkpYT0vXlxccyo8Ly50ZXN0KGQpP1wiZGVmYXVsdC1tYXJrdXBcIjpcImRlZmF1bHQtY29kZVwiO3JldHVybiBVW2FdfWZ1bmN0aW9uIEQoYSl7dmFyIGQ9XG5hLmg7dHJ5e3ZhciBoPW0oYS5jLGEuaSksYj1oLmE7YS5hPWI7YS5kPWguZDthLmU9MDtBKGQsYikoYSk7dmFyIGU9L1xcYk1TSUVcXHMoXFxkKykvLmV4ZWMobmF2aWdhdG9yLnVzZXJBZ2VudCksZT1lJiYrZVsxXTw9OCxkPS9cXG4vZyxpPWEuYSxqPWkubGVuZ3RoLGg9MCxsPWEuZCxuPWwubGVuZ3RoLGI9MCxjPWEuZyxwPWMubGVuZ3RoLHQ9MDtjW3BdPWo7dmFyIHEsZjtmb3IoZj1xPTA7ZjxwOyljW2ZdIT09Y1tmKzJdPyhjW3ErK109Y1tmKytdLGNbcSsrXT1jW2YrK10pOmYrPTI7cD1xO2ZvcihmPXE9MDtmPHA7KXtmb3IodmFyIHg9Y1tmXSx5PWNbZisxXSx1PWYrMjt1KzI8PXAmJmNbdSsxXT09PXk7KXUrPTI7Y1txKytdPXg7Y1txKytdPXk7Zj11fWMubGVuZ3RoPXE7dmFyIGc9YS5jLGs7aWYoZylrPWcuc3R5bGUuZGlzcGxheSxnLnN0eWxlLmRpc3BsYXk9XCJub25lXCI7dHJ5e2Zvcig7YjxuOyl7dmFyIG89bFtiKzJdfHxqLEg9Y1t0KzJdfHxqLHU9TWF0aC5taW4obyxIKSxFPWxbYitcbjFdLFc7aWYoRS5ub2RlVHlwZSE9PTEmJihXPWkuc3Vic3RyaW5nKGgsdSkpKXtlJiYoVz1XLnJlcGxhY2UoZCxcIlxcclwiKSk7RS5ub2RlVmFsdWU9Vzt2YXIgWj1FLm93bmVyRG9jdW1lbnQscz1aLmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIpO3MuY2xhc3NOYW1lPWNbdCsxXTt2YXIgej1FLnBhcmVudE5vZGU7ei5yZXBsYWNlQ2hpbGQocyxFKTtzLmFwcGVuZENoaWxkKEUpO2g8byYmKGxbYisxXT1FPVouY3JlYXRlVGV4dE5vZGUoaS5zdWJzdHJpbmcodSxvKSksei5pbnNlcnRCZWZvcmUoRSxzLm5leHRTaWJsaW5nKSl9aD11O2g+PW8mJihiKz0yKTtoPj1IJiYodCs9Mil9fWZpbmFsbHl7aWYoZylnLnN0eWxlLmRpc3BsYXk9a319Y2F0Y2godil7Vi5jb25zb2xlJiZjb25zb2xlLmxvZyh2JiZ2LnN0YWNrfHx2KX19dmFyIFY9d2luZG93LEc9W1wiYnJlYWssY29udGludWUsZG8sZWxzZSxmb3IsaWYscmV0dXJuLHdoaWxlXCJdLE89W1tHLFwiYXV0byxjYXNlLGNoYXIsY29uc3QsZGVmYXVsdCxkb3VibGUsZW51bSxleHRlcm4sZmxvYXQsZ290byxpbmxpbmUsaW50LGxvbmcscmVnaXN0ZXIsc2hvcnQsc2lnbmVkLHNpemVvZixzdGF0aWMsc3RydWN0LHN3aXRjaCx0eXBlZGVmLHVuaW9uLHVuc2lnbmVkLHZvaWQsdm9sYXRpbGVcIl0sXG5cImNhdGNoLGNsYXNzLGRlbGV0ZSxmYWxzZSxpbXBvcnQsbmV3LG9wZXJhdG9yLHByaXZhdGUscHJvdGVjdGVkLHB1YmxpYyx0aGlzLHRocm93LHRydWUsdHJ5LHR5cGVvZlwiXSxKPVtPLFwiYWxpZ25vZixhbGlnbl91bmlvbixhc20sYXhpb20sYm9vbCxjb25jZXB0LGNvbmNlcHRfbWFwLGNvbnN0X2Nhc3QsY29uc3RleHByLGRlY2x0eXBlLGRlbGVnYXRlLGR5bmFtaWNfY2FzdCxleHBsaWNpdCxleHBvcnQsZnJpZW5kLGdlbmVyaWMsbGF0ZV9jaGVjayxtdXRhYmxlLG5hbWVzcGFjZSxudWxscHRyLHByb3BlcnR5LHJlaW50ZXJwcmV0X2Nhc3Qsc3RhdGljX2Fzc2VydCxzdGF0aWNfY2FzdCx0ZW1wbGF0ZSx0eXBlaWQsdHlwZW5hbWUsdXNpbmcsdmlydHVhbCx3aGVyZVwiXSxLPVtPLFwiYWJzdHJhY3QsYXNzZXJ0LGJvb2xlYW4sYnl0ZSxleHRlbmRzLGZpbmFsLGZpbmFsbHksaW1wbGVtZW50cyxpbXBvcnQsaW5zdGFuY2VvZixpbnRlcmZhY2UsbnVsbCxuYXRpdmUscGFja2FnZSxzdHJpY3RmcCxzdXBlcixzeW5jaHJvbml6ZWQsdGhyb3dzLHRyYW5zaWVudFwiXSxcbkw9W0ssXCJhcyxiYXNlLGJ5LGNoZWNrZWQsZGVjaW1hbCxkZWxlZ2F0ZSxkZXNjZW5kaW5nLGR5bmFtaWMsZXZlbnQsZml4ZWQsZm9yZWFjaCxmcm9tLGdyb3VwLGltcGxpY2l0LGluLGludGVybmFsLGludG8saXMsbGV0LGxvY2ssb2JqZWN0LG91dCxvdmVycmlkZSxvcmRlcmJ5LHBhcmFtcyxwYXJ0aWFsLHJlYWRvbmx5LHJlZixzYnl0ZSxzZWFsZWQsc3RhY2thbGxvYyxzdHJpbmcsc2VsZWN0LHVpbnQsdWxvbmcsdW5jaGVja2VkLHVuc2FmZSx1c2hvcnQsdmFyLHZpcnR1YWwsd2hlcmVcIl0sTz1bTyxcImRlYnVnZ2VyLGV2YWwsZXhwb3J0LGZ1bmN0aW9uLGdldCxudWxsLHNldCx1bmRlZmluZWQsdmFyLHdpdGgsSW5maW5pdHksTmFOXCJdLE09W0csXCJhbmQsYXMsYXNzZXJ0LGNsYXNzLGRlZixkZWwsZWxpZixleGNlcHQsZXhlYyxmaW5hbGx5LGZyb20sZ2xvYmFsLGltcG9ydCxpbixpcyxsYW1iZGEsbm9ubG9jYWwsbm90LG9yLHBhc3MscHJpbnQscmFpc2UsdHJ5LHdpdGgseWllbGQsRmFsc2UsVHJ1ZSxOb25lXCJdLFxuTj1bRyxcImFsaWFzLGFuZCxiZWdpbixjYXNlLGNsYXNzLGRlZixkZWZpbmVkLGVsc2lmLGVuZCxlbnN1cmUsZmFsc2UsaW4sbW9kdWxlLG5leHQsbmlsLG5vdCxvcixyZWRvLHJlc2N1ZSxyZXRyeSxzZWxmLHN1cGVyLHRoZW4sdHJ1ZSx1bmRlZix1bmxlc3MsdW50aWwsd2hlbix5aWVsZCxCRUdJTixFTkRcIl0sUj1bRyxcImFzLGFzc2VydCxjb25zdCxjb3B5LGRyb3AsZW51bSxleHRlcm4sZmFpbCxmYWxzZSxmbixpbXBsLGxldCxsb2csbG9vcCxtYXRjaCxtb2QsbW92ZSxtdXQscHJpdixwdWIscHVyZSxyZWYsc2VsZixzdGF0aWMsc3RydWN0LHRydWUsdHJhaXQsdHlwZSx1bnNhZmUsdXNlXCJdLEc9W0csXCJjYXNlLGRvbmUsZWxpZixlc2FjLGV2YWwsZmksZnVuY3Rpb24saW4sbG9jYWwsc2V0LHRoZW4sdW50aWxcIl0sUT0vXihESVJ8RklMRXx2ZWN0b3J8KGRlfHByaW9yaXR5Xyk/cXVldWV8bGlzdHxzdGFja3woY29uc3RfKT9pdGVyYXRvcnwobXVsdGkpPyhzZXR8bWFwKXxiaXRzZXR8dT8oaW50fGZsb2F0KVxcZCopXFxiLyxcblM9L1xcUy8sVD10KHtrZXl3b3JkczpbSixMLE8sXCJjYWxsZXIsZGVsZXRlLGRpZSxkbyxkdW1wLGVsc2lmLGV2YWwsZXhpdCxmb3JlYWNoLGZvcixnb3RvLGlmLGltcG9ydCxsYXN0LGxvY2FsLG15LG5leHQsbm8sb3VyLHByaW50LHBhY2thZ2UscmVkbyxyZXF1aXJlLHN1Yix1bmRlZix1bmxlc3MsdW50aWwsdXNlLHdhbnRhcnJheSx3aGlsZSxCRUdJTixFTkRcIixNLE4sR10saGFzaENvbW1lbnRzOiEwLGNTdHlsZUNvbW1lbnRzOiEwLG11bHRpTGluZVN0cmluZ3M6ITAscmVnZXhMaXRlcmFsczohMH0pLFU9e307aShULFtcImRlZmF1bHQtY29kZVwiXSk7aShDKFtdLFtbXCJwbG5cIiwvXltePD9dKy9dLFtcImRlY1wiLC9ePCFcXHdbXj5dKig/Oj58JCkvXSxbXCJjb21cIiwvXjxcXCEtLVtcXFNcXHNdKj8oPzotLVxcPnwkKS9dLFtcImxhbmctXCIsL148XFw/KFtcXFNcXHNdKz8pKD86XFw/PnwkKS9dLFtcImxhbmctXCIsL148JShbXFxTXFxzXSs/KSg/OiU+fCQpL10sW1wicHVuXCIsL14oPzo8WyU/XXxbJT9dPikvXSxbXCJsYW5nLVwiLFxuL148eG1wXFxiW14+XSo+KFtcXFNcXHNdKz8pPFxcL3htcFxcYltePl0qPi9pXSxbXCJsYW5nLWpzXCIsL148c2NyaXB0XFxiW14+XSo+KFtcXFNcXHNdKj8pKDxcXC9zY3JpcHRcXGJbXj5dKj4pL2ldLFtcImxhbmctY3NzXCIsL148c3R5bGVcXGJbXj5dKj4oW1xcU1xcc10qPykoPFxcL3N0eWxlXFxiW14+XSo+KS9pXSxbXCJsYW5nLWluLnRhZ1wiLC9eKDxcXC8/W2Etel1bXjw+XSo+KS9pXV0pLFtcImRlZmF1bHQtbWFya3VwXCIsXCJodG1cIixcImh0bWxcIixcIm14bWxcIixcInhodG1sXCIsXCJ4bWxcIixcInhzbFwiXSk7aShDKFtbXCJwbG5cIiwvXlxccysvLHIsXCIgXFx0XFxyXFxuXCJdLFtcImF0dlwiLC9eKD86XCJbXlwiXSpcIj98J1teJ10qJz8pLyxyLFwiXFxcIidcIl1dLFtbXCJ0YWdcIiwvXl48XFwvP1thLXpdKD86W1xcdy0uOl0qXFx3KT98XFwvPz4kL2ldLFtcImF0blwiLC9eKD8hc3R5bGVbXFxzPV18b24pW2Etel0oPzpbXFx3Oi1dKlxcdyk/L2ldLFtcImxhbmctdXEudmFsXCIsL149XFxzKihbXlxcc1wiJz5dKig/OlteXFxzXCInLz5dfFxcLyg/PVxccykpKS9dLFtcInB1blwiLC9eWy88LT5dKy9dLFxuW1wibGFuZy1qc1wiLC9eb25cXHcrXFxzKj1cXHMqXCIoW15cIl0rKVwiL2ldLFtcImxhbmctanNcIiwvXm9uXFx3K1xccyo9XFxzKicoW14nXSspJy9pXSxbXCJsYW5nLWpzXCIsL15vblxcdytcXHMqPVxccyooW15cXHNcIic+XSspL2ldLFtcImxhbmctY3NzXCIsL15zdHlsZVxccyo9XFxzKlwiKFteXCJdKylcIi9pXSxbXCJsYW5nLWNzc1wiLC9ec3R5bGVcXHMqPVxccyonKFteJ10rKScvaV0sW1wibGFuZy1jc3NcIiwvXnN0eWxlXFxzKj1cXHMqKFteXFxzXCInPl0rKS9pXV0pLFtcImluLnRhZ1wiXSk7aShDKFtdLFtbXCJhdHZcIiwvXltcXFNcXHNdKy9dXSksW1widXEudmFsXCJdKTtpKHQoe2tleXdvcmRzOkosaGFzaENvbW1lbnRzOiEwLGNTdHlsZUNvbW1lbnRzOiEwLHR5cGVzOlF9KSxbXCJjXCIsXCJjY1wiLFwiY3BwXCIsXCJjeHhcIixcImN5Y1wiLFwibVwiXSk7aSh0KHtrZXl3b3JkczpcIm51bGwsdHJ1ZSxmYWxzZVwifSksW1wianNvblwiXSk7aSh0KHtrZXl3b3JkczpMLGhhc2hDb21tZW50czohMCxjU3R5bGVDb21tZW50czohMCx2ZXJiYXRpbVN0cmluZ3M6ITAsdHlwZXM6UX0pLFxuW1wiY3NcIl0pO2kodCh7a2V5d29yZHM6SyxjU3R5bGVDb21tZW50czohMH0pLFtcImphdmFcIl0pO2kodCh7a2V5d29yZHM6RyxoYXNoQ29tbWVudHM6ITAsbXVsdGlMaW5lU3RyaW5nczohMH0pLFtcImJhc2hcIixcImJzaFwiLFwiY3NoXCIsXCJzaFwiXSk7aSh0KHtrZXl3b3JkczpNLGhhc2hDb21tZW50czohMCxtdWx0aUxpbmVTdHJpbmdzOiEwLHRyaXBsZVF1b3RlZFN0cmluZ3M6ITB9KSxbXCJjdlwiLFwicHlcIixcInB5dGhvblwiXSk7aSh0KHtrZXl3b3JkczpcImNhbGxlcixkZWxldGUsZGllLGRvLGR1bXAsZWxzaWYsZXZhbCxleGl0LGZvcmVhY2gsZm9yLGdvdG8saWYsaW1wb3J0LGxhc3QsbG9jYWwsbXksbmV4dCxubyxvdXIscHJpbnQscGFja2FnZSxyZWRvLHJlcXVpcmUsc3ViLHVuZGVmLHVubGVzcyx1bnRpbCx1c2Usd2FudGFycmF5LHdoaWxlLEJFR0lOLEVORFwiLGhhc2hDb21tZW50czohMCxtdWx0aUxpbmVTdHJpbmdzOiEwLHJlZ2V4TGl0ZXJhbHM6Mn0pLFtcInBlcmxcIixcInBsXCIsXCJwbVwiXSk7aSh0KHtrZXl3b3JkczpOLFxuaGFzaENvbW1lbnRzOiEwLG11bHRpTGluZVN0cmluZ3M6ITAscmVnZXhMaXRlcmFsczohMH0pLFtcInJiXCIsXCJydWJ5XCJdKTtpKHQoe2tleXdvcmRzOk8sY1N0eWxlQ29tbWVudHM6ITAscmVnZXhMaXRlcmFsczohMH0pLFtcImphdmFzY3JpcHRcIixcImpzXCJdKTtpKHQoe2tleXdvcmRzOlwiYWxsLGFuZCxieSxjYXRjaCxjbGFzcyxlbHNlLGV4dGVuZHMsZmFsc2UsZmluYWxseSxmb3IsaWYsaW4saXMsaXNudCxsb29wLG5ldyxubyxub3QsbnVsbCxvZixvZmYsb24sb3IscmV0dXJuLHN1cGVyLHRoZW4sdGhyb3csdHJ1ZSx0cnksdW5sZXNzLHVudGlsLHdoZW4sd2hpbGUseWVzXCIsaGFzaENvbW1lbnRzOjMsY1N0eWxlQ29tbWVudHM6ITAsbXVsdGlsaW5lU3RyaW5nczohMCx0cmlwbGVRdW90ZWRTdHJpbmdzOiEwLHJlZ2V4TGl0ZXJhbHM6ITB9KSxbXCJjb2ZmZWVcIl0pO2kodCh7a2V5d29yZHM6UixjU3R5bGVDb21tZW50czohMCxtdWx0aWxpbmVTdHJpbmdzOiEwfSksW1wicmNcIixcInJzXCIsXCJydXN0XCJdKTtcbmkoQyhbXSxbW1wic3RyXCIsL15bXFxTXFxzXSsvXV0pLFtcInJlZ2V4XCJdKTt2YXIgWD1WLlBSPXtjcmVhdGVTaW1wbGVMZXhlcjpDLHJlZ2lzdGVyTGFuZ0hhbmRsZXI6aSxzb3VyY2VEZWNvcmF0b3I6dCxQUl9BVFRSSUJfTkFNRTpcImF0blwiLFBSX0FUVFJJQl9WQUxVRTpcImF0dlwiLFBSX0NPTU1FTlQ6XCJjb21cIixQUl9ERUNMQVJBVElPTjpcImRlY1wiLFBSX0tFWVdPUkQ6XCJrd2RcIixQUl9MSVRFUkFMOlwibGl0XCIsUFJfTk9DT0RFOlwibm9jb2RlXCIsUFJfUExBSU46XCJwbG5cIixQUl9QVU5DVFVBVElPTjpcInB1blwiLFBSX1NPVVJDRTpcInNyY1wiLFBSX1NUUklORzpcInN0clwiLFBSX1RBRzpcInRhZ1wiLFBSX1RZUEU6XCJ0eXBcIixwcmV0dHlQcmludE9uZTpmdW5jdGlvbihhLGQsZSl7dmFyIGI9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtiLmlubmVySFRNTD1cIjxwcmU+XCIrYStcIjwvcHJlPlwiO2I9Yi5maXJzdENoaWxkO2UmJnooYixlLCEwKTtEKHtoOmQsajplLGM6YixpOjF9KTtyZXR1cm4gYi5pbm5lckhUTUx9LFxucHJldHR5UHJpbnQ6ZT1lPWZ1bmN0aW9uKGEsZCl7ZnVuY3Rpb24gZSgpe2Zvcih2YXIgYj1WLlBSX1NIT1VMRF9VU0VfQ09OVElOVUFUSU9OP2Mubm93KCkrMjUwOkluZmluaXR5O3A8ai5sZW5ndGgmJmMubm93KCk8YjtwKyspe2Zvcih2YXIgZD1qW3BdLG09ayxsPWQ7bD1sLnByZXZpb3VzU2libGluZzspe3ZhciBuPWwubm9kZVR5cGUscz0obj09PTd8fG49PT04KSYmbC5ub2RlVmFsdWU7aWYocz8hL15cXD8/cHJldHRpZnlcXGIvLnRlc3Qocyk6biE9PTN8fC9cXFMvLnRlc3QobC5ub2RlVmFsdWUpKWJyZWFrO2lmKHMpe209e307cy5yZXBsYWNlKC9cXGIoXFx3Kyk9KFtcXHclK1xcLS46XSspL2csZnVuY3Rpb24oYSxiLGMpe21bYl09Y30pO2JyZWFrfX1sPWQuY2xhc3NOYW1lO2lmKChtIT09a3x8Zi50ZXN0KGwpKSYmIXcudGVzdChsKSl7bj0hMTtmb3Iocz1kLnBhcmVudE5vZGU7cztzPXMucGFyZW50Tm9kZSlpZihnLnRlc3Qocy50YWdOYW1lKSYmcy5jbGFzc05hbWUmJmYudGVzdChzLmNsYXNzTmFtZSkpe249XG4hMDticmVha31pZighbil7ZC5jbGFzc05hbWUrPVwiIHByZXR0eXByaW50ZWRcIjtuPW0ubGFuZztpZighbil7dmFyIG49bC5tYXRjaChxKSxBO2lmKCFuJiYoQT14KGQpKSYmdS50ZXN0KEEudGFnTmFtZSkpbj1BLmNsYXNzTmFtZS5tYXRjaChxKTtuJiYobj1uWzFdKX1pZih5LnRlc3QoZC50YWdOYW1lKSlzPTE7ZWxzZSB2YXIgcz1kLmN1cnJlbnRTdHlsZSx2PWkuZGVmYXVsdFZpZXcscz0ocz1zP3Mud2hpdGVTcGFjZTp2JiZ2LmdldENvbXB1dGVkU3R5bGU/di5nZXRDb21wdXRlZFN0eWxlKGQscikuZ2V0UHJvcGVydHlWYWx1ZShcIndoaXRlLXNwYWNlXCIpOjApJiZcInByZVwiPT09cy5zdWJzdHJpbmcoMCwzKTt2PW0ubGluZW51bXM7aWYoISh2PXY9PT1cInRydWVcInx8K3YpKXY9KHY9bC5tYXRjaCgvXFxibGluZW51bXNcXGIoPzo6KFxcZCspKT8vKSk/dlsxXSYmdlsxXS5sZW5ndGg/K3ZbMV06ITA6ITE7diYmeihkLHYscyk7dD17aDpuLGM6ZCxqOnYsaTpzfTtEKHQpfX19cDxqLmxlbmd0aD9cblAoZSwyNTApOlwiZnVuY3Rpb25cIj09PXR5cGVvZiBhJiZhKCl9Zm9yKHZhciBiPWR8fGRvY3VtZW50LmJvZHksaT1iLm93bmVyRG9jdW1lbnR8fGRvY3VtZW50LGI9W2IuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCJwcmVcIiksYi5nZXRFbGVtZW50c0J5VGFnTmFtZShcImNvZGVcIiksYi5nZXRFbGVtZW50c0J5VGFnTmFtZShcInhtcFwiKV0saj1bXSxtPTA7bTxiLmxlbmd0aDsrK20pZm9yKHZhciBsPTAsbj1iW21dLmxlbmd0aDtsPG47KytsKWoucHVzaChiW21dW2xdKTt2YXIgYj1yLGM9RGF0ZTtjLm5vd3x8KGM9e25vdzpmdW5jdGlvbigpe3JldHVybituZXcgRGF0ZX19KTt2YXIgcD0wLHQscT0vXFxibGFuZyg/OnVhZ2UpPy0oW1xcdy5dKykoPyFcXFMpLyxmPS9cXGJwcmV0dHlwcmludFxcYi8sdz0vXFxicHJldHR5cHJpbnRlZFxcYi8seT0vcHJlfHhtcC9pLHU9L15jb2RlJC9pLGc9L14oPzpwcmV8Y29kZXx4bXApJC9pLGs9e307ZSgpfX07dHlwZW9mIGRlZmluZT09PVwiZnVuY3Rpb25cIiYmZGVmaW5lLmFtZCYmXG5kZWZpbmUoXCJnb29nbGUtY29kZS1wcmV0dGlmeVwiLFtdLGZ1bmN0aW9uKCl7cmV0dXJuIFh9KX0pKCk7cmV0dXJuIGV9KCk7Unx8UChRLDApfSkoKTt9KClcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///966\n')}},__webpack_module_cache__={};function __webpack_require__(I){var g=__webpack_module_cache__[I];if(void 0!==g)return g.exports;var C=__webpack_module_cache__[I]={exports:{}};return __webpack_modules__[I](C,C.exports,__webpack_require__),C.exports}__webpack_require__.g=function(){if("object"==typeof globalThis)return globalThis;try{return this||new Function("return this")()}catch(I){if("object"==typeof window)return window}}();var __webpack_exports__=__webpack_require__(699),__webpack_export_target__=window;for(var __webpack_i__ in __webpack_exports__)__webpack_export_target__[__webpack_i__]=__webpack_exports__[__webpack_i__];__webpack_exports__.__esModule&&Object.defineProperty(__webpack_export_target__,"__esModule",{value:!0})})();